_N_E =
(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([["pages/index"],{

/***/ "./components/layout.js":
/*!******************************!*\
  !*** ./components/layout.js ***!
  \******************************/
/*! exports provided: siteTitle, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "siteTitle", function() { return siteTitle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Layout; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ "./node_modules/next/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ "./node_modules/next/image.js");
/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _layout_module_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./layout.module.css */ "./components/layout.module.css");
/* harmony import */ var _layout_module_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_layout_module_css__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _styles_utils_module_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../styles/utils.module.css */ "./styles/utils.module.css");
/* harmony import */ var _styles_utils_module_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_styles_utils_module_css__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_5__);

var _jsxFileName = "C:\\Personal\\Projects\\smile\\components\\layout.js";





var name = 'Smile';
var siteTitle = 'Smile';
function Layout(_ref) {
  var children = _ref.children,
      home = _ref.home;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    className: _layout_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.container,
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_head__WEBPACK_IMPORTED_MODULE_1___default.a, {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("link", {
        rel: "icon",
        href: "/favicon.ico"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 14,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 7
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("header", {
      className: _layout_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.header
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("main", {
      children: children
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 7
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: _layout_module_css__WEBPACK_IMPORTED_MODULE_3___default.a.backToHome,
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_5___default.a, {
        href: "/",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
          children: "\u2190 Back to home"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 21,
          columnNumber: 13
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 20,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 12,
    columnNumber: 5
  }, this);
}
_c = Layout;

var _c;

$RefreshReg$(_c, "Layout");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./components/layout.module.css":
/*!**************************************!*\
  !*** ./components/layout.module.css ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./layout.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/layout.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./layout.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/layout.module.css",
      function () {
        content = __webpack_require__(/*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./layout.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/layout.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _asyncToGenerator; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/extends.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/extends.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");

var iterableToArray = __webpack_require__(/*! ./iterableToArray */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/face-api.js/build/es6/NeuralNetwork.js":
/*!*************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/NeuralNetwork.js ***!
  \*************************************************************/
/*! exports provided: NeuralNetwork */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeuralNetwork", function() { return NeuralNetwork; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common_getModelUris__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common/getModelUris */ "./node_modules/face-api.js/build/es6/common/getModelUris.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./env */ "./node_modules/face-api.js/build/es6/env/index.js");





var NeuralNetwork = /** @class */ (function () {
    function NeuralNetwork(_name) {
        this._name = _name;
        this._params = undefined;
        this._paramMappings = [];
    }
    Object.defineProperty(NeuralNetwork.prototype, "params", {
        get: function () { return this._params; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NeuralNetwork.prototype, "paramMappings", {
        get: function () { return this._paramMappings; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NeuralNetwork.prototype, "isLoaded", {
        get: function () { return !!this.params; },
        enumerable: true,
        configurable: true
    });
    NeuralNetwork.prototype.getParamFromPath = function (paramPath) {
        var _a = this.traversePropertyPath(paramPath), obj = _a.obj, objProp = _a.objProp;
        return obj[objProp];
    };
    NeuralNetwork.prototype.reassignParamFromPath = function (paramPath, tensor) {
        var _a = this.traversePropertyPath(paramPath), obj = _a.obj, objProp = _a.objProp;
        obj[objProp].dispose();
        obj[objProp] = tensor;
    };
    NeuralNetwork.prototype.getParamList = function () {
        var _this = this;
        return this._paramMappings.map(function (_a) {
            var paramPath = _a.paramPath;
            return ({
                path: paramPath,
                tensor: _this.getParamFromPath(paramPath)
            });
        });
    };
    NeuralNetwork.prototype.getTrainableParams = function () {
        return this.getParamList().filter(function (param) { return param.tensor instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Variable"]; });
    };
    NeuralNetwork.prototype.getFrozenParams = function () {
        return this.getParamList().filter(function (param) { return !(param.tensor instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Variable"]); });
    };
    NeuralNetwork.prototype.variable = function () {
        var _this = this;
        this.getFrozenParams().forEach(function (_a) {
            var path = _a.path, tensor = _a.tensor;
            _this.reassignParamFromPath(path, tensor.variable());
        });
    };
    NeuralNetwork.prototype.freeze = function () {
        var _this = this;
        this.getTrainableParams().forEach(function (_a) {
            var path = _a.path, variable = _a.tensor;
            var tensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tensor"](variable.dataSync());
            variable.dispose();
            _this.reassignParamFromPath(path, tensor);
        });
    };
    NeuralNetwork.prototype.dispose = function (throwOnRedispose) {
        if (throwOnRedispose === void 0) { throwOnRedispose = true; }
        this.getParamList().forEach(function (param) {
            if (throwOnRedispose && param.tensor.isDisposed) {
                throw new Error("param tensor has already been disposed for path " + param.path);
            }
            param.tensor.dispose();
        });
        this._params = undefined;
    };
    NeuralNetwork.prototype.serializeParams = function () {
        return new Float32Array(this.getParamList()
            .map(function (_a) {
            var tensor = _a.tensor;
            return Array.from(tensor.dataSync());
        })
            .reduce(function (flat, arr) { return flat.concat(arr); }));
    };
    NeuralNetwork.prototype.load = function (weightsOrUrl) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (weightsOrUrl instanceof Float32Array) {
                            this.extractWeights(weightsOrUrl);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, this.loadFromUri(weightsOrUrl)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    NeuralNetwork.prototype.loadFromUri = function (uri) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var weightMap;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (uri && typeof uri !== 'string') {
                            throw new Error(this._name + ".loadFromUri - expected model uri");
                        }
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_3__["loadWeightMap"])(uri, this.getDefaultModelName())];
                    case 1:
                        weightMap = _a.sent();
                        this.loadFromWeightMap(weightMap);
                        return [2 /*return*/];
                }
            });
        });
    };
    NeuralNetwork.prototype.loadFromDisk = function (filePath) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var readFile, _a, manifestUri, modelBaseUri, fetchWeightsFromDisk, loadWeights, manifest, _b, _c, weightMap;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (filePath && typeof filePath !== 'string') {
                            throw new Error(this._name + ".loadFromDisk - expected model file path");
                        }
                        readFile = _env__WEBPACK_IMPORTED_MODULE_4__["env"].getEnv().readFile;
                        _a = Object(_common_getModelUris__WEBPACK_IMPORTED_MODULE_2__["getModelUris"])(filePath, this.getDefaultModelName()), manifestUri = _a.manifestUri, modelBaseUri = _a.modelBaseUri;
                        fetchWeightsFromDisk = function (filePaths) { return Promise.all(filePaths.map(function (filePath) { return readFile(filePath).then(function (buf) { return buf.buffer; }); })); };
                        loadWeights = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["io"].weightsLoaderFactory(fetchWeightsFromDisk);
                        _c = (_b = JSON).parse;
                        return [4 /*yield*/, readFile(manifestUri)];
                    case 1:
                        manifest = _c.apply(_b, [(_d.sent()).toString()]);
                        return [4 /*yield*/, loadWeights(manifest, modelBaseUri)];
                    case 2:
                        weightMap = _d.sent();
                        this.loadFromWeightMap(weightMap);
                        return [2 /*return*/];
                }
            });
        });
    };
    NeuralNetwork.prototype.loadFromWeightMap = function (weightMap) {
        var _a = this.extractParamsFromWeigthMap(weightMap), paramMappings = _a.paramMappings, params = _a.params;
        this._paramMappings = paramMappings;
        this._params = params;
    };
    NeuralNetwork.prototype.extractWeights = function (weights) {
        var _a = this.extractParams(weights), paramMappings = _a.paramMappings, params = _a.params;
        this._paramMappings = paramMappings;
        this._params = params;
    };
    NeuralNetwork.prototype.traversePropertyPath = function (paramPath) {
        if (!this.params) {
            throw new Error("traversePropertyPath - model has no loaded params");
        }
        var result = paramPath.split('/').reduce(function (res, objProp) {
            if (!res.nextObj.hasOwnProperty(objProp)) {
                throw new Error("traversePropertyPath - object does not have property " + objProp + ", for path " + paramPath);
            }
            return { obj: res.nextObj, objProp: objProp, nextObj: res.nextObj[objProp] };
        }, { nextObj: this.params });
        var obj = result.obj, objProp = result.objProp;
        if (!obj || !objProp || !(obj[objProp] instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Tensor"])) {
            throw new Error("traversePropertyPath - parameter is not a tensor, for path " + paramPath);
        }
        return { obj: obj, objProp: objProp };
    };
    return NeuralNetwork;
}());

//# sourceMappingURL=NeuralNetwork.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ageGenderNet/AgeGenderNet.js":
/*!*************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ageGenderNet/AgeGenderNet.js ***!
  \*************************************************************************/
/*! exports provided: AgeGenderNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgeGenderNet", function() { return AgeGenderNet; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/fullyConnectedLayer */ "./node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js");
/* harmony import */ var _faceProcessor_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../faceProcessor/util */ "./node_modules/face-api.js/build/es6/faceProcessor/util.js");
/* harmony import */ var _xception_TinyXception__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../xception/TinyXception */ "./node_modules/face-api.js/build/es6/xception/TinyXception.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/ageGenderNet/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/ageGenderNet/extractParamsFromWeigthMap.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types */ "./node_modules/face-api.js/build/es6/ageGenderNet/types.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");










var AgeGenderNet = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(AgeGenderNet, _super);
    function AgeGenderNet(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) { faceFeatureExtractor = new _xception_TinyXception__WEBPACK_IMPORTED_MODULE_4__["TinyXception"](2); }
        var _this = _super.call(this, 'AgeGenderNet') || this;
        _this._faceFeatureExtractor = faceFeatureExtractor;
        return _this;
    }
    Object.defineProperty(AgeGenderNet.prototype, "faceFeatureExtractor", {
        get: function () {
            return this._faceFeatureExtractor;
        },
        enumerable: true,
        configurable: true
    });
    AgeGenderNet.prototype.runNet = function (input) {
        var _this = this;
        var params = this.params;
        if (!params) {
            throw new Error(this._name + " - load model before inference");
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var bottleneckFeatures = input instanceof _dom__WEBPACK_IMPORTED_MODULE_9__["NetInput"]
                ? _this.faceFeatureExtractor.forwardInput(input)
                : input;
            var pooled = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["avgPool"](bottleneckFeatures, [7, 7], [2, 2], 'valid').as2D(bottleneckFeatures.shape[0], -1);
            var age = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__["fullyConnectedLayer"])(pooled, params.fc.age).as1D();
            var gender = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__["fullyConnectedLayer"])(pooled, params.fc.gender);
            return { age: age, gender: gender };
        });
    };
    AgeGenderNet.prototype.forwardInput = function (input) {
        var _this = this;
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var _a = _this.runNet(input), age = _a.age, gender = _a.gender;
            return { age: age, gender: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["softmax"](gender) };
        });
    };
    AgeGenderNet.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_9__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    AgeGenderNet.prototype.predictAgeAndGender = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var netInput, out, ages, genders, ageAndGenderTensors, predictionsByBatch;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_9__["toNetInput"])(input)];
                    case 1:
                        netInput = _a.sent();
                        return [4 /*yield*/, this.forwardInput(netInput)];
                    case 2:
                        out = _a.sent();
                        ages = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["unstack"](out.age);
                        genders = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["unstack"](out.gender);
                        ageAndGenderTensors = ages.map(function (ageTensor, i) { return ({
                            ageTensor: ageTensor,
                            genderTensor: genders[i]
                        }); });
                        return [4 /*yield*/, Promise.all(ageAndGenderTensors.map(function (_a) {
                                var ageTensor = _a.ageTensor, genderTensor = _a.genderTensor;
                                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
                                    var age, probMale, isMale, gender, genderProbability;
                                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                                        switch (_b.label) {
                                            case 0: return [4 /*yield*/, ageTensor.data()];
                                            case 1:
                                                age = (_b.sent())[0];
                                                return [4 /*yield*/, genderTensor.data()];
                                            case 2:
                                                probMale = (_b.sent())[0];
                                                isMale = probMale > 0.5;
                                                gender = isMale ? _types__WEBPACK_IMPORTED_MODULE_7__["Gender"].MALE : _types__WEBPACK_IMPORTED_MODULE_7__["Gender"].FEMALE;
                                                genderProbability = isMale ? probMale : (1 - probMale);
                                                ageTensor.dispose();
                                                genderTensor.dispose();
                                                return [2 /*return*/, { age: age, gender: gender, genderProbability: genderProbability }];
                                        }
                                    });
                                });
                            }))];
                    case 3:
                        predictionsByBatch = _a.sent();
                        out.age.dispose();
                        out.gender.dispose();
                        return [2 /*return*/, netInput.isBatchInput
                                ? predictionsByBatch
                                : predictionsByBatch[0]];
                }
            });
        });
    };
    AgeGenderNet.prototype.getDefaultModelName = function () {
        return 'age_gender_model';
    };
    AgeGenderNet.prototype.dispose = function (throwOnRedispose) {
        if (throwOnRedispose === void 0) { throwOnRedispose = true; }
        this.faceFeatureExtractor.dispose(throwOnRedispose);
        _super.prototype.dispose.call(this, throwOnRedispose);
    };
    AgeGenderNet.prototype.loadClassifierParams = function (weights) {
        var _a = this.extractClassifierParams(weights), params = _a.params, paramMappings = _a.paramMappings;
        this._params = params;
        this._paramMappings = paramMappings;
    };
    AgeGenderNet.prototype.extractClassifierParams = function (weights) {
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_5__["extractParams"])(weights);
    };
    AgeGenderNet.prototype.extractParamsFromWeigthMap = function (weightMap) {
        var _a = Object(_faceProcessor_util__WEBPACK_IMPORTED_MODULE_3__["seperateWeightMaps"])(weightMap), featureExtractorMap = _a.featureExtractorMap, classifierMap = _a.classifierMap;
        this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_6__["extractParamsFromWeigthMap"])(classifierMap);
    };
    AgeGenderNet.prototype.extractParams = function (weights) {
        var classifierWeightSize = (512 * 1 + 1) + (512 * 2 + 2);
        var featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);
        var classifierWeights = weights.slice(weights.length - classifierWeightSize);
        this.faceFeatureExtractor.extractWeights(featureExtractorWeights);
        return this.extractClassifierParams(classifierWeights);
    };
    return AgeGenderNet;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_8__["NeuralNetwork"]));

//# sourceMappingURL=AgeGenderNet.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ageGenderNet/extractParams.js":
/*!**************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ageGenderNet/extractParams.js ***!
  \**************************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");

function extractParams(weights) {
    var paramMappings = [];
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var extractFCParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractFCParamsFactory"])(extractWeights, paramMappings);
    var age = extractFCParams(512, 1, 'fc/age');
    var gender = extractFCParams(512, 2, 'fc/gender');
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return {
        paramMappings: paramMappings,
        params: { fc: { age: age, gender: gender } }
    };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ageGenderNet/extractParamsFromWeigthMap.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ageGenderNet/extractParamsFromWeigthMap.js ***!
  \***************************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");

function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var extractWeightEntry = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightEntryFactory"])(weightMap, paramMappings);
    function extractFcParams(prefix) {
        var weights = extractWeightEntry(prefix + "/weights", 2);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return { weights: weights, bias: bias };
    }
    var params = {
        fc: {
            age: extractFcParams('fc/age'),
            gender: extractFcParams('fc/gender')
        }
    };
    Object(_common__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ageGenderNet/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ageGenderNet/index.js ***!
  \******************************************************************/
/*! exports provided: AgeGenderNet, Gender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _AgeGenderNet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AgeGenderNet */ "./node_modules/face-api.js/build/es6/ageGenderNet/AgeGenderNet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AgeGenderNet", function() { return _AgeGenderNet__WEBPACK_IMPORTED_MODULE_0__["AgeGenderNet"]; });

/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/face-api.js/build/es6/ageGenderNet/types.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Gender", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Gender"]; });



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ageGenderNet/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ageGenderNet/types.js ***!
  \******************************************************************/
/*! exports provided: Gender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Gender", function() { return Gender; });
var Gender;
(function (Gender) {
    Gender["FEMALE"] = "female";
    Gender["MALE"] = "male";
})(Gender || (Gender = {}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/BoundingBox.js":
/*!*******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/BoundingBox.js ***!
  \*******************************************************************/
/*! exports provided: BoundingBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBox", function() { return BoundingBox; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Box__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Box */ "./node_modules/face-api.js/build/es6/classes/Box.js");


var BoundingBox = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(BoundingBox, _super);
    function BoundingBox(left, top, right, bottom, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) { allowNegativeDimensions = false; }
        return _super.call(this, { left: left, top: top, right: right, bottom: bottom }, allowNegativeDimensions) || this;
    }
    return BoundingBox;
}(_Box__WEBPACK_IMPORTED_MODULE_1__["Box"]));

//# sourceMappingURL=BoundingBox.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/Box.js":
/*!***********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/Box.js ***!
  \***********************************************************/
/*! exports provided: Box */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box", function() { return Box; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Point */ "./node_modules/face-api.js/build/es6/classes/Point.js");


var Box = /** @class */ (function () {
    function Box(_box, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) { allowNegativeDimensions = true; }
        var box = (_box || {});
        var isBbox = [box.left, box.top, box.right, box.bottom].every(_utils__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"]);
        var isRect = [box.x, box.y, box.width, box.height].every(_utils__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"]);
        if (!isRect && !isBbox) {
            throw new Error("Box.constructor - expected box to be IBoundingBox | IRect, instead have " + JSON.stringify(box));
        }
        var _a = isRect
            ? [box.x, box.y, box.width, box.height]
            : [box.left, box.top, box.right - box.left, box.bottom - box.top], x = _a[0], y = _a[1], width = _a[2], height = _a[3];
        Box.assertIsValidBox({ x: x, y: y, width: width, height: height }, 'Box.constructor', allowNegativeDimensions);
        this._x = x;
        this._y = y;
        this._width = width;
        this._height = height;
    }
    Box.isRect = function (rect) {
        return !!rect && [rect.x, rect.y, rect.width, rect.height].every(_utils__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"]);
    };
    Box.assertIsValidBox = function (box, callee, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) { allowNegativeDimensions = false; }
        if (!Box.isRect(box)) {
            throw new Error(callee + " - invalid box: " + JSON.stringify(box) + ", expected object with properties x, y, width, height");
        }
        if (!allowNegativeDimensions && (box.width < 0 || box.height < 0)) {
            throw new Error(callee + " - width (" + box.width + ") and height (" + box.height + ") must be positive numbers");
        }
    };
    Object.defineProperty(Box.prototype, "x", {
        get: function () { return this._x; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "y", {
        get: function () { return this._y; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "width", {
        get: function () { return this._width; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "height", {
        get: function () { return this._height; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "left", {
        get: function () { return this.x; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "top", {
        get: function () { return this.y; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "right", {
        get: function () { return this.x + this.width; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "bottom", {
        get: function () { return this.y + this.height; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "area", {
        get: function () { return this.width * this.height; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "topLeft", {
        get: function () { return new _Point__WEBPACK_IMPORTED_MODULE_1__["Point"](this.left, this.top); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "topRight", {
        get: function () { return new _Point__WEBPACK_IMPORTED_MODULE_1__["Point"](this.right, this.top); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "bottomLeft", {
        get: function () { return new _Point__WEBPACK_IMPORTED_MODULE_1__["Point"](this.left, this.bottom); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "bottomRight", {
        get: function () { return new _Point__WEBPACK_IMPORTED_MODULE_1__["Point"](this.right, this.bottom); },
        enumerable: true,
        configurable: true
    });
    Box.prototype.round = function () {
        var _a = [this.x, this.y, this.width, this.height]
            .map(function (val) { return Math.round(val); }), x = _a[0], y = _a[1], width = _a[2], height = _a[3];
        return new Box({ x: x, y: y, width: width, height: height });
    };
    Box.prototype.floor = function () {
        var _a = [this.x, this.y, this.width, this.height]
            .map(function (val) { return Math.floor(val); }), x = _a[0], y = _a[1], width = _a[2], height = _a[3];
        return new Box({ x: x, y: y, width: width, height: height });
    };
    Box.prototype.toSquare = function () {
        var _a = this, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        var diff = Math.abs(width - height);
        if (width < height) {
            x -= (diff / 2);
            width += diff;
        }
        if (height < width) {
            y -= (diff / 2);
            height += diff;
        }
        return new Box({ x: x, y: y, width: width, height: height });
    };
    Box.prototype.rescale = function (s) {
        var scaleX = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isDimensions"])(s) ? s.width : s;
        var scaleY = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isDimensions"])(s) ? s.height : s;
        return new Box({
            x: this.x * scaleX,
            y: this.y * scaleY,
            width: this.width * scaleX,
            height: this.height * scaleY
        });
    };
    Box.prototype.pad = function (padX, padY) {
        var _a = [
            this.x - (padX / 2),
            this.y - (padY / 2),
            this.width + padX,
            this.height + padY
        ], x = _a[0], y = _a[1], width = _a[2], height = _a[3];
        return new Box({ x: x, y: y, width: width, height: height });
    };
    Box.prototype.clipAtImageBorders = function (imgWidth, imgHeight) {
        var _a = this, x = _a.x, y = _a.y, right = _a.right, bottom = _a.bottom;
        var clippedX = Math.max(x, 0);
        var clippedY = Math.max(y, 0);
        var newWidth = right - clippedX;
        var newHeight = bottom - clippedY;
        var clippedWidth = Math.min(newWidth, imgWidth - clippedX);
        var clippedHeight = Math.min(newHeight, imgHeight - clippedY);
        return (new Box({ x: clippedX, y: clippedY, width: clippedWidth, height: clippedHeight })).floor();
    };
    Box.prototype.shift = function (sx, sy) {
        var _a = this, width = _a.width, height = _a.height;
        var x = this.x + sx;
        var y = this.y + sy;
        return new Box({ x: x, y: y, width: width, height: height });
    };
    Box.prototype.padAtBorders = function (imageHeight, imageWidth) {
        var w = this.width + 1;
        var h = this.height + 1;
        var dx = 1;
        var dy = 1;
        var edx = w;
        var edy = h;
        var x = this.left;
        var y = this.top;
        var ex = this.right;
        var ey = this.bottom;
        if (ex > imageWidth) {
            edx = -ex + imageWidth + w;
            ex = imageWidth;
        }
        if (ey > imageHeight) {
            edy = -ey + imageHeight + h;
            ey = imageHeight;
        }
        if (x < 1) {
            edy = 2 - x;
            x = 1;
        }
        if (y < 1) {
            edy = 2 - y;
            y = 1;
        }
        return { dy: dy, edy: edy, dx: dx, edx: edx, y: y, ey: ey, x: x, ex: ex, w: w, h: h };
    };
    Box.prototype.calibrate = function (region) {
        return new Box({
            left: this.left + (region.left * this.width),
            top: this.top + (region.top * this.height),
            right: this.right + (region.right * this.width),
            bottom: this.bottom + (region.bottom * this.height)
        }).toSquare().round();
    };
    return Box;
}());

//# sourceMappingURL=Box.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/Dimensions.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/Dimensions.js ***!
  \******************************************************************/
/*! exports provided: Dimensions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dimensions", function() { return Dimensions; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");

var Dimensions = /** @class */ (function () {
    function Dimensions(width, height) {
        if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"])(width) || !Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isValidNumber"])(height)) {
            throw new Error("Dimensions.constructor - expected width and height to be valid numbers, instead have " + JSON.stringify({ width: width, height: height }));
        }
        this._width = width;
        this._height = height;
    }
    Object.defineProperty(Dimensions.prototype, "width", {
        get: function () { return this._width; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dimensions.prototype, "height", {
        get: function () { return this._height; },
        enumerable: true,
        configurable: true
    });
    Dimensions.prototype.reverse = function () {
        return new Dimensions(1 / this.width, 1 / this.height);
    };
    return Dimensions;
}());

//# sourceMappingURL=Dimensions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/FaceDetection.js ***!
  \*********************************************************************/
/*! exports provided: FaceDetection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceDetection", function() { return FaceDetection; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _ObjectDetection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ObjectDetection */ "./node_modules/face-api.js/build/es6/classes/ObjectDetection.js");


var FaceDetection = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceDetection, _super);
    function FaceDetection(score, relativeBox, imageDims) {
        return _super.call(this, score, score, '', relativeBox, imageDims) || this;
    }
    FaceDetection.prototype.forSize = function (width, height) {
        var _a = _super.prototype.forSize.call(this, width, height), score = _a.score, relativeBox = _a.relativeBox, imageDims = _a.imageDims;
        return new FaceDetection(score, relativeBox, imageDims);
    };
    return FaceDetection;
}(_ObjectDetection__WEBPACK_IMPORTED_MODULE_1__["ObjectDetection"]));

//# sourceMappingURL=FaceDetection.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js ***!
  \*********************************************************************/
/*! exports provided: FaceLandmarks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks", function() { return FaceLandmarks; });
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _Box__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Box */ "./node_modules/face-api.js/build/es6/classes/Box.js");
/* harmony import */ var _Dimensions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Dimensions */ "./node_modules/face-api.js/build/es6/classes/Dimensions.js");
/* harmony import */ var _FaceDetection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Point */ "./node_modules/face-api.js/build/es6/classes/Point.js");
/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Rect */ "./node_modules/face-api.js/build/es6/classes/Rect.js");







// face alignment constants
var relX = 0.5;
var relY = 0.43;
var relScale = 0.45;
var FaceLandmarks = /** @class */ (function () {
    function FaceLandmarks(relativeFaceLandmarkPositions, imgDims, shift) {
        if (shift === void 0) { shift = new _Point__WEBPACK_IMPORTED_MODULE_5__["Point"](0, 0); }
        var width = imgDims.width, height = imgDims.height;
        this._imgDims = new _Dimensions__WEBPACK_IMPORTED_MODULE_3__["Dimensions"](width, height);
        this._shift = shift;
        this._positions = relativeFaceLandmarkPositions.map(function (pt) { return pt.mul(new _Point__WEBPACK_IMPORTED_MODULE_5__["Point"](width, height)).add(shift); });
    }
    Object.defineProperty(FaceLandmarks.prototype, "shift", {
        get: function () { return new _Point__WEBPACK_IMPORTED_MODULE_5__["Point"](this._shift.x, this._shift.y); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceLandmarks.prototype, "imageWidth", {
        get: function () { return this._imgDims.width; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceLandmarks.prototype, "imageHeight", {
        get: function () { return this._imgDims.height; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceLandmarks.prototype, "positions", {
        get: function () { return this._positions; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceLandmarks.prototype, "relativePositions", {
        get: function () {
            var _this = this;
            return this._positions.map(function (pt) { return pt.sub(_this._shift).div(new _Point__WEBPACK_IMPORTED_MODULE_5__["Point"](_this.imageWidth, _this.imageHeight)); });
        },
        enumerable: true,
        configurable: true
    });
    FaceLandmarks.prototype.forSize = function (width, height) {
        return new this.constructor(this.relativePositions, { width: width, height: height });
    };
    FaceLandmarks.prototype.shiftBy = function (x, y) {
        return new this.constructor(this.relativePositions, this._imgDims, new _Point__WEBPACK_IMPORTED_MODULE_5__["Point"](x, y));
    };
    FaceLandmarks.prototype.shiftByPoint = function (pt) {
        return this.shiftBy(pt.x, pt.y);
    };
    /**
     * Aligns the face landmarks after face detection from the relative positions of the faces
     * bounding box, or it's current shift. This function should be used to align the face images
     * after face detection has been performed, before they are passed to the face recognition net.
     * This will make the computed face descriptor more accurate.
     *
     * @param detection (optional) The bounding box of the face or the face detection result. If
     * no argument was passed the position of the face landmarks are assumed to be relative to
     * it's current shift.
     * @returns The bounding box of the aligned face.
     */
    FaceLandmarks.prototype.align = function (detection, options) {
        if (options === void 0) { options = {}; }
        if (detection) {
            var box = detection instanceof _FaceDetection__WEBPACK_IMPORTED_MODULE_4__["FaceDetection"]
                ? detection.box.floor()
                : new _Box__WEBPACK_IMPORTED_MODULE_2__["Box"](detection);
            return this.shiftBy(box.x, box.y).align(null, options);
        }
        var _a = Object.assign({}, { useDlibAlignment: false, minBoxPadding: 0.2 }, options), useDlibAlignment = _a.useDlibAlignment, minBoxPadding = _a.minBoxPadding;
        if (useDlibAlignment) {
            return this.alignDlib();
        }
        return this.alignMinBbox(minBoxPadding);
    };
    FaceLandmarks.prototype.alignDlib = function () {
        var centers = this.getRefPointsForAlignment();
        var leftEyeCenter = centers[0], rightEyeCenter = centers[1], mouthCenter = centers[2];
        var distToMouth = function (pt) { return mouthCenter.sub(pt).magnitude(); };
        var eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2;
        var size = Math.floor(eyeToMouthDist / relScale);
        var refPoint = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getCenterPoint"])(centers);
        // TODO: pad in case rectangle is out of image bounds
        var x = Math.floor(Math.max(0, refPoint.x - (relX * size)));
        var y = Math.floor(Math.max(0, refPoint.y - (relY * size)));
        return new _Rect__WEBPACK_IMPORTED_MODULE_6__["Rect"](x, y, Math.min(size, this.imageWidth + x), Math.min(size, this.imageHeight + y));
    };
    FaceLandmarks.prototype.alignMinBbox = function (padding) {
        var box = Object(_ops__WEBPACK_IMPORTED_MODULE_0__["minBbox"])(this.positions);
        return box.pad(box.width * padding, box.height * padding);
    };
    FaceLandmarks.prototype.getRefPointsForAlignment = function () {
        throw new Error('getRefPointsForAlignment not implemented by base class');
    };
    return FaceLandmarks;
}());

//# sourceMappingURL=FaceLandmarks.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks5.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/FaceLandmarks5.js ***!
  \**********************************************************************/
/*! exports provided: FaceLandmarks5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks5", function() { return FaceLandmarks5; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _FaceLandmarks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FaceLandmarks */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js");



var FaceLandmarks5 = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceLandmarks5, _super);
    function FaceLandmarks5() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FaceLandmarks5.prototype.getRefPointsForAlignment = function () {
        var pts = this.positions;
        return [
            pts[0],
            pts[1],
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getCenterPoint"])([pts[3], pts[4]])
        ];
    };
    return FaceLandmarks5;
}(_FaceLandmarks__WEBPACK_IMPORTED_MODULE_2__["FaceLandmarks"]));

//# sourceMappingURL=FaceLandmarks5.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js":
/*!***********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js ***!
  \***********************************************************************/
/*! exports provided: FaceLandmarks68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks68", function() { return FaceLandmarks68; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _FaceLandmarks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FaceLandmarks */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js");



var FaceLandmarks68 = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceLandmarks68, _super);
    function FaceLandmarks68() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FaceLandmarks68.prototype.getJawOutline = function () {
        return this.positions.slice(0, 17);
    };
    FaceLandmarks68.prototype.getLeftEyeBrow = function () {
        return this.positions.slice(17, 22);
    };
    FaceLandmarks68.prototype.getRightEyeBrow = function () {
        return this.positions.slice(22, 27);
    };
    FaceLandmarks68.prototype.getNose = function () {
        return this.positions.slice(27, 36);
    };
    FaceLandmarks68.prototype.getLeftEye = function () {
        return this.positions.slice(36, 42);
    };
    FaceLandmarks68.prototype.getRightEye = function () {
        return this.positions.slice(42, 48);
    };
    FaceLandmarks68.prototype.getMouth = function () {
        return this.positions.slice(48, 68);
    };
    FaceLandmarks68.prototype.getRefPointsForAlignment = function () {
        return [
            this.getLeftEye(),
            this.getRightEye(),
            this.getMouth()
        ].map(_utils__WEBPACK_IMPORTED_MODULE_1__["getCenterPoint"]);
    };
    return FaceLandmarks68;
}(_FaceLandmarks__WEBPACK_IMPORTED_MODULE_2__["FaceLandmarks"]));

//# sourceMappingURL=FaceLandmarks68.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/FaceMatch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/FaceMatch.js ***!
  \*****************************************************************/
/*! exports provided: FaceMatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceMatch", function() { return FaceMatch; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");

var FaceMatch = /** @class */ (function () {
    function FaceMatch(label, distance) {
        this._label = label;
        this._distance = distance;
    }
    Object.defineProperty(FaceMatch.prototype, "label", {
        get: function () { return this._label; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceMatch.prototype, "distance", {
        get: function () { return this._distance; },
        enumerable: true,
        configurable: true
    });
    FaceMatch.prototype.toString = function (withDistance) {
        if (withDistance === void 0) { withDistance = true; }
        return "" + this.label + (withDistance ? " (" + Object(_utils__WEBPACK_IMPORTED_MODULE_0__["round"])(this.distance) + ")" : '');
    };
    return FaceMatch;
}());

//# sourceMappingURL=FaceMatch.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/LabeledBox.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/LabeledBox.js ***!
  \******************************************************************/
/*! exports provided: LabeledBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabeledBox", function() { return LabeledBox; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _Box__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Box */ "./node_modules/face-api.js/build/es6/classes/Box.js");



var LabeledBox = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(LabeledBox, _super);
    function LabeledBox(box, label) {
        var _this = _super.call(this, box) || this;
        _this._label = label;
        return _this;
    }
    LabeledBox.assertIsValidLabeledBox = function (box, callee) {
        _Box__WEBPACK_IMPORTED_MODULE_2__["Box"].assertIsValidBox(box, callee);
        if (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isValidNumber"])(box.label)) {
            throw new Error(callee + " - expected property label (" + box.label + ") to be a number");
        }
    };
    Object.defineProperty(LabeledBox.prototype, "label", {
        get: function () { return this._label; },
        enumerable: true,
        configurable: true
    });
    return LabeledBox;
}(_Box__WEBPACK_IMPORTED_MODULE_2__["Box"]));

//# sourceMappingURL=LabeledBox.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/LabeledFaceDescriptors.js":
/*!******************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/LabeledFaceDescriptors.js ***!
  \******************************************************************************/
/*! exports provided: LabeledFaceDescriptors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabeledFaceDescriptors", function() { return LabeledFaceDescriptors; });
var LabeledFaceDescriptors = /** @class */ (function () {
    function LabeledFaceDescriptors(label, descriptors) {
        if (!(typeof label === 'string')) {
            throw new Error('LabeledFaceDescriptors - constructor expected label to be a string');
        }
        if (!Array.isArray(descriptors) || descriptors.some(function (desc) { return !(desc instanceof Float32Array); })) {
            throw new Error('LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array');
        }
        this._label = label;
        this._descriptors = descriptors;
    }
    Object.defineProperty(LabeledFaceDescriptors.prototype, "label", {
        get: function () { return this._label; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LabeledFaceDescriptors.prototype, "descriptors", {
        get: function () { return this._descriptors; },
        enumerable: true,
        configurable: true
    });
    LabeledFaceDescriptors.prototype.toJSON = function () {
        return {
            label: this.label,
            descriptors: this.descriptors.map(function (d) { return Array.from(d); })
        };
    };
    LabeledFaceDescriptors.fromJSON = function (json) {
        var descriptors = json.descriptors.map(function (d) {
            return new Float32Array(d);
        });
        return new LabeledFaceDescriptors(json.label, descriptors);
    };
    return LabeledFaceDescriptors;
}());

//# sourceMappingURL=LabeledFaceDescriptors.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/ObjectDetection.js":
/*!***********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/ObjectDetection.js ***!
  \***********************************************************************/
/*! exports provided: ObjectDetection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectDetection", function() { return ObjectDetection; });
/* harmony import */ var _Box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Box */ "./node_modules/face-api.js/build/es6/classes/Box.js");
/* harmony import */ var _Dimensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Dimensions */ "./node_modules/face-api.js/build/es6/classes/Dimensions.js");


var ObjectDetection = /** @class */ (function () {
    function ObjectDetection(score, classScore, className, relativeBox, imageDims) {
        this._imageDims = new _Dimensions__WEBPACK_IMPORTED_MODULE_1__["Dimensions"](imageDims.width, imageDims.height);
        this._score = score;
        this._classScore = classScore;
        this._className = className;
        this._box = new _Box__WEBPACK_IMPORTED_MODULE_0__["Box"](relativeBox).rescale(this._imageDims);
    }
    Object.defineProperty(ObjectDetection.prototype, "score", {
        get: function () { return this._score; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection.prototype, "classScore", {
        get: function () { return this._classScore; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection.prototype, "className", {
        get: function () { return this._className; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection.prototype, "box", {
        get: function () { return this._box; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection.prototype, "imageDims", {
        get: function () { return this._imageDims; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection.prototype, "imageWidth", {
        get: function () { return this.imageDims.width; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection.prototype, "imageHeight", {
        get: function () { return this.imageDims.height; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObjectDetection.prototype, "relativeBox", {
        get: function () { return new _Box__WEBPACK_IMPORTED_MODULE_0__["Box"](this._box).rescale(this.imageDims.reverse()); },
        enumerable: true,
        configurable: true
    });
    ObjectDetection.prototype.forSize = function (width, height) {
        return new ObjectDetection(this.score, this.classScore, this.className, this.relativeBox, { width: width, height: height });
    };
    return ObjectDetection;
}());

//# sourceMappingURL=ObjectDetection.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/Point.js":
/*!*************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/Point.js ***!
  \*************************************************************/
/*! exports provided: Point */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return Point; });
var Point = /** @class */ (function () {
    function Point(x, y) {
        this._x = x;
        this._y = y;
    }
    Object.defineProperty(Point.prototype, "x", {
        get: function () { return this._x; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Point.prototype, "y", {
        get: function () { return this._y; },
        enumerable: true,
        configurable: true
    });
    Point.prototype.add = function (pt) {
        return new Point(this.x + pt.x, this.y + pt.y);
    };
    Point.prototype.sub = function (pt) {
        return new Point(this.x - pt.x, this.y - pt.y);
    };
    Point.prototype.mul = function (pt) {
        return new Point(this.x * pt.x, this.y * pt.y);
    };
    Point.prototype.div = function (pt) {
        return new Point(this.x / pt.x, this.y / pt.y);
    };
    Point.prototype.abs = function () {
        return new Point(Math.abs(this.x), Math.abs(this.y));
    };
    Point.prototype.magnitude = function () {
        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
    };
    Point.prototype.floor = function () {
        return new Point(Math.floor(this.x), Math.floor(this.y));
    };
    return Point;
}());

//# sourceMappingURL=Point.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/PredictedBox.js":
/*!********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/PredictedBox.js ***!
  \********************************************************************/
/*! exports provided: PredictedBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictedBox", function() { return PredictedBox; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _LabeledBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LabeledBox */ "./node_modules/face-api.js/build/es6/classes/LabeledBox.js");



var PredictedBox = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictedBox, _super);
    function PredictedBox(box, label, score, classScore) {
        var _this = _super.call(this, box, label) || this;
        _this._score = score;
        _this._classScore = classScore;
        return _this;
    }
    PredictedBox.assertIsValidPredictedBox = function (box, callee) {
        _LabeledBox__WEBPACK_IMPORTED_MODULE_2__["LabeledBox"].assertIsValidLabeledBox(box, callee);
        if (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isValidProbablitiy"])(box.score)
            || !Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isValidProbablitiy"])(box.classScore)) {
            throw new Error(callee + " - expected properties score (" + box.score + ") and (" + box.classScore + ") to be a number between [0, 1]");
        }
    };
    Object.defineProperty(PredictedBox.prototype, "score", {
        get: function () { return this._score; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PredictedBox.prototype, "classScore", {
        get: function () { return this._classScore; },
        enumerable: true,
        configurable: true
    });
    return PredictedBox;
}(_LabeledBox__WEBPACK_IMPORTED_MODULE_2__["LabeledBox"]));

//# sourceMappingURL=PredictedBox.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/Rect.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/Rect.js ***!
  \************************************************************/
/*! exports provided: Rect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rect", function() { return Rect; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Box__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Box */ "./node_modules/face-api.js/build/es6/classes/Box.js");


var Rect = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(Rect, _super);
    function Rect(x, y, width, height, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) { allowNegativeDimensions = false; }
        return _super.call(this, { x: x, y: y, width: width, height: height }, allowNegativeDimensions) || this;
    }
    return Rect;
}(_Box__WEBPACK_IMPORTED_MODULE_1__["Box"]));

//# sourceMappingURL=Rect.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/classes/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/classes/index.js ***!
  \*************************************************************/
/*! exports provided: BoundingBox, Box, Dimensions, FaceDetection, FaceLandmarks, FaceLandmarks5, FaceLandmarks68, FaceMatch, LabeledBox, LabeledFaceDescriptors, ObjectDetection, Point, PredictedBox, Rect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BoundingBox */ "./node_modules/face-api.js/build/es6/classes/BoundingBox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoundingBox", function() { return _BoundingBox__WEBPACK_IMPORTED_MODULE_0__["BoundingBox"]; });

/* harmony import */ var _Box__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Box */ "./node_modules/face-api.js/build/es6/classes/Box.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Box", function() { return _Box__WEBPACK_IMPORTED_MODULE_1__["Box"]; });

/* harmony import */ var _Dimensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Dimensions */ "./node_modules/face-api.js/build/es6/classes/Dimensions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Dimensions", function() { return _Dimensions__WEBPACK_IMPORTED_MODULE_2__["Dimensions"]; });

/* harmony import */ var _FaceDetection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceDetection", function() { return _FaceDetection__WEBPACK_IMPORTED_MODULE_3__["FaceDetection"]; });

/* harmony import */ var _FaceLandmarks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FaceLandmarks */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks", function() { return _FaceLandmarks__WEBPACK_IMPORTED_MODULE_4__["FaceLandmarks"]; });

/* harmony import */ var _FaceLandmarks5__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./FaceLandmarks5 */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks5.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks5", function() { return _FaceLandmarks5__WEBPACK_IMPORTED_MODULE_5__["FaceLandmarks5"]; });

/* harmony import */ var _FaceLandmarks68__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FaceLandmarks68 */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks68", function() { return _FaceLandmarks68__WEBPACK_IMPORTED_MODULE_6__["FaceLandmarks68"]; });

/* harmony import */ var _FaceMatch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./FaceMatch */ "./node_modules/face-api.js/build/es6/classes/FaceMatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceMatch", function() { return _FaceMatch__WEBPACK_IMPORTED_MODULE_7__["FaceMatch"]; });

/* harmony import */ var _LabeledBox__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./LabeledBox */ "./node_modules/face-api.js/build/es6/classes/LabeledBox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LabeledBox", function() { return _LabeledBox__WEBPACK_IMPORTED_MODULE_8__["LabeledBox"]; });

/* harmony import */ var _LabeledFaceDescriptors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./LabeledFaceDescriptors */ "./node_modules/face-api.js/build/es6/classes/LabeledFaceDescriptors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LabeledFaceDescriptors", function() { return _LabeledFaceDescriptors__WEBPACK_IMPORTED_MODULE_9__["LabeledFaceDescriptors"]; });

/* harmony import */ var _ObjectDetection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ObjectDetection */ "./node_modules/face-api.js/build/es6/classes/ObjectDetection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ObjectDetection", function() { return _ObjectDetection__WEBPACK_IMPORTED_MODULE_10__["ObjectDetection"]; });

/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Point */ "./node_modules/face-api.js/build/es6/classes/Point.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return _Point__WEBPACK_IMPORTED_MODULE_11__["Point"]; });

/* harmony import */ var _PredictedBox__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./PredictedBox */ "./node_modules/face-api.js/build/es6/classes/PredictedBox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PredictedBox", function() { return _PredictedBox__WEBPACK_IMPORTED_MODULE_12__["PredictedBox"]; });

/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Rect */ "./node_modules/face-api.js/build/es6/classes/Rect.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Rect", function() { return _Rect__WEBPACK_IMPORTED_MODULE_13__["Rect"]; });















//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/convLayer.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/convLayer.js ***!
  \****************************************************************/
/*! exports provided: convLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convLayer", function() { return convLayer; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function convLayer(x, params, padding, withRelu) {
    if (padding === void 0) { padding = 'same'; }
    if (withRelu === void 0) { withRelu = false; }
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"](x, params.filters, [1, 1], padding), params.bias);
        return withRelu ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](out) : out;
    });
}
//# sourceMappingURL=convLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/depthwiseSeparableConv.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/depthwiseSeparableConv.js ***!
  \*****************************************************************************/
/*! exports provided: depthwiseSeparableConv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthwiseSeparableConv", function() { return depthwiseSeparableConv; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function depthwiseSeparableConv(x, params, stride) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["separableConv2d"](x, params.depthwise_filter, params.pointwise_filter, stride, 'same');
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out, params.bias);
        return out;
    });
}
//# sourceMappingURL=depthwiseSeparableConv.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/disposeUnusedWeightTensors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/disposeUnusedWeightTensors.js ***!
  \*********************************************************************************/
/*! exports provided: disposeUnusedWeightTensors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disposeUnusedWeightTensors", function() { return disposeUnusedWeightTensors; });
function disposeUnusedWeightTensors(weightMap, paramMappings) {
    Object.keys(weightMap).forEach(function (path) {
        if (!paramMappings.some(function (pm) { return pm.originalPath === path; })) {
            weightMap[path].dispose();
        }
    });
}
//# sourceMappingURL=disposeUnusedWeightTensors.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/extractConvParamsFactory.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/extractConvParamsFactory.js ***!
  \*******************************************************************************/
/*! exports provided: extractConvParamsFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractConvParamsFactory", function() { return extractConvParamsFactory; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function extractConvParamsFactory(extractWeights, paramMappings) {
    return function (channelsIn, channelsOut, filterSize, mappedPrefix) {
        var filters = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"](extractWeights(channelsIn * channelsOut * filterSize * filterSize), [filterSize, filterSize, channelsIn, channelsOut]);
        var bias = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(channelsOut));
        paramMappings.push({ paramPath: mappedPrefix + "/filters" }, { paramPath: mappedPrefix + "/bias" });
        return { filters: filters, bias: bias };
    };
}
//# sourceMappingURL=extractConvParamsFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/extractFCParamsFactory.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/extractFCParamsFactory.js ***!
  \*****************************************************************************/
/*! exports provided: extractFCParamsFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractFCParamsFactory", function() { return extractFCParamsFactory; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function extractFCParamsFactory(extractWeights, paramMappings) {
    return function (channelsIn, channelsOut, mappedPrefix) {
        var fc_weights = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor2d"](extractWeights(channelsIn * channelsOut), [channelsIn, channelsOut]);
        var fc_bias = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(channelsOut));
        paramMappings.push({ paramPath: mappedPrefix + "/weights" }, { paramPath: mappedPrefix + "/bias" });
        return {
            weights: fc_weights,
            bias: fc_bias
        };
    };
}
//# sourceMappingURL=extractFCParamsFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js ***!
  \****************************************************************************************/
/*! exports provided: extractSeparableConvParamsFactory, loadSeparableConvParamsFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractSeparableConvParamsFactory", function() { return extractSeparableConvParamsFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadSeparableConvParamsFactory", function() { return loadSeparableConvParamsFactory; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/face-api.js/build/es6/common/types.js");


function extractSeparableConvParamsFactory(extractWeights, paramMappings) {
    return function (channelsIn, channelsOut, mappedPrefix) {
        var depthwise_filter = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"](extractWeights(3 * 3 * channelsIn), [3, 3, channelsIn, 1]);
        var pointwise_filter = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"](extractWeights(channelsIn * channelsOut), [1, 1, channelsIn, channelsOut]);
        var bias = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(channelsOut));
        paramMappings.push({ paramPath: mappedPrefix + "/depthwise_filter" }, { paramPath: mappedPrefix + "/pointwise_filter" }, { paramPath: mappedPrefix + "/bias" });
        return new _types__WEBPACK_IMPORTED_MODULE_1__["SeparableConvParams"](depthwise_filter, pointwise_filter, bias);
    };
}
function loadSeparableConvParamsFactory(extractWeightEntry) {
    return function (prefix) {
        var depthwise_filter = extractWeightEntry(prefix + "/depthwise_filter", 4);
        var pointwise_filter = extractWeightEntry(prefix + "/pointwise_filter", 4);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return new _types__WEBPACK_IMPORTED_MODULE_1__["SeparableConvParams"](depthwise_filter, pointwise_filter, bias);
    };
}
//# sourceMappingURL=extractSeparableConvParamsFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/extractWeightEntryFactory.js":
/*!********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/extractWeightEntryFactory.js ***!
  \********************************************************************************/
/*! exports provided: extractWeightEntryFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractWeightEntryFactory", function() { return extractWeightEntryFactory; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");

function extractWeightEntryFactory(weightMap, paramMappings) {
    return function (originalPath, paramRank, mappedPath) {
        var tensor = weightMap[originalPath];
        if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isTensor"])(tensor, paramRank)) {
            throw new Error("expected weightMap[" + originalPath + "] to be a Tensor" + paramRank + "D, instead have " + tensor);
        }
        paramMappings.push({ originalPath: originalPath, paramPath: mappedPath || originalPath });
        return tensor;
    };
}
//# sourceMappingURL=extractWeightEntryFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/extractWeightsFactory.js":
/*!****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/extractWeightsFactory.js ***!
  \****************************************************************************/
/*! exports provided: extractWeightsFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractWeightsFactory", function() { return extractWeightsFactory; });
function extractWeightsFactory(weights) {
    var remainingWeights = weights;
    function extractWeights(numWeights) {
        var ret = remainingWeights.slice(0, numWeights);
        remainingWeights = remainingWeights.slice(numWeights);
        return ret;
    }
    function getRemainingWeights() {
        return remainingWeights;
    }
    return {
        extractWeights: extractWeights,
        getRemainingWeights: getRemainingWeights
    };
}
//# sourceMappingURL=extractWeightsFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js ***!
  \**************************************************************************/
/*! exports provided: fullyConnectedLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fullyConnectedLayer", function() { return fullyConnectedLayer; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function fullyConnectedLayer(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["matMul"](x, params.weights), params.bias);
    });
}
//# sourceMappingURL=fullyConnectedLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/getModelUris.js":
/*!*******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/getModelUris.js ***!
  \*******************************************************************/
/*! exports provided: getModelUris */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getModelUris", function() { return getModelUris; });
function getModelUris(uri, defaultModelName) {
    var defaultManifestFilename = defaultModelName + "-weights_manifest.json";
    if (!uri) {
        return {
            modelBaseUri: '',
            manifestUri: defaultManifestFilename
        };
    }
    if (uri === '/') {
        return {
            modelBaseUri: '/',
            manifestUri: "/" + defaultManifestFilename
        };
    }
    var protocol = uri.startsWith('http://') ? 'http://' : uri.startsWith('https://') ? 'https://' : '';
    uri = uri.replace(protocol, '');
    var parts = uri.split('/').filter(function (s) { return s; });
    var manifestFile = uri.endsWith('.json')
        ? parts[parts.length - 1]
        : defaultManifestFilename;
    var modelBaseUri = protocol + (uri.endsWith('.json') ? parts.slice(0, parts.length - 1) : parts).join('/');
    modelBaseUri = uri.startsWith('/') ? "/" + modelBaseUri : modelBaseUri;
    return {
        modelBaseUri: modelBaseUri,
        manifestUri: modelBaseUri === '/' ? "/" + manifestFile : modelBaseUri + "/" + manifestFile
    };
}
//# sourceMappingURL=getModelUris.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/index.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/index.js ***!
  \************************************************************/
/*! exports provided: convLayer, depthwiseSeparableConv, disposeUnusedWeightTensors, extractConvParamsFactory, extractFCParamsFactory, extractSeparableConvParamsFactory, loadSeparableConvParamsFactory, extractWeightEntryFactory, extractWeightsFactory, getModelUris, SeparableConvParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _convLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./convLayer */ "./node_modules/face-api.js/build/es6/common/convLayer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "convLayer", function() { return _convLayer__WEBPACK_IMPORTED_MODULE_0__["convLayer"]; });

/* harmony import */ var _depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./depthwiseSeparableConv */ "./node_modules/face-api.js/build/es6/common/depthwiseSeparableConv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "depthwiseSeparableConv", function() { return _depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"]; });

/* harmony import */ var _disposeUnusedWeightTensors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./disposeUnusedWeightTensors */ "./node_modules/face-api.js/build/es6/common/disposeUnusedWeightTensors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "disposeUnusedWeightTensors", function() { return _disposeUnusedWeightTensors__WEBPACK_IMPORTED_MODULE_2__["disposeUnusedWeightTensors"]; });

/* harmony import */ var _extractConvParamsFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extractConvParamsFactory */ "./node_modules/face-api.js/build/es6/common/extractConvParamsFactory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractConvParamsFactory", function() { return _extractConvParamsFactory__WEBPACK_IMPORTED_MODULE_3__["extractConvParamsFactory"]; });

/* harmony import */ var _extractFCParamsFactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./extractFCParamsFactory */ "./node_modules/face-api.js/build/es6/common/extractFCParamsFactory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractFCParamsFactory", function() { return _extractFCParamsFactory__WEBPACK_IMPORTED_MODULE_4__["extractFCParamsFactory"]; });

/* harmony import */ var _extractSeparableConvParamsFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extractSeparableConvParamsFactory */ "./node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractSeparableConvParamsFactory", function() { return _extractSeparableConvParamsFactory__WEBPACK_IMPORTED_MODULE_5__["extractSeparableConvParamsFactory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadSeparableConvParamsFactory", function() { return _extractSeparableConvParamsFactory__WEBPACK_IMPORTED_MODULE_5__["loadSeparableConvParamsFactory"]; });

/* harmony import */ var _extractWeightEntryFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractWeightEntryFactory */ "./node_modules/face-api.js/build/es6/common/extractWeightEntryFactory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractWeightEntryFactory", function() { return _extractWeightEntryFactory__WEBPACK_IMPORTED_MODULE_6__["extractWeightEntryFactory"]; });

/* harmony import */ var _extractWeightsFactory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extractWeightsFactory */ "./node_modules/face-api.js/build/es6/common/extractWeightsFactory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractWeightsFactory", function() { return _extractWeightsFactory__WEBPACK_IMPORTED_MODULE_7__["extractWeightsFactory"]; });

/* harmony import */ var _getModelUris__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getModelUris */ "./node_modules/face-api.js/build/es6/common/getModelUris.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getModelUris", function() { return _getModelUris__WEBPACK_IMPORTED_MODULE_8__["getModelUris"]; });

/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./types */ "./node_modules/face-api.js/build/es6/common/types.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SeparableConvParams", function() { return _types__WEBPACK_IMPORTED_MODULE_9__["SeparableConvParams"]; });











//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/loadConvParamsFactory.js":
/*!****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/loadConvParamsFactory.js ***!
  \****************************************************************************/
/*! exports provided: loadConvParamsFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadConvParamsFactory", function() { return loadConvParamsFactory; });
function loadConvParamsFactory(extractWeightEntry) {
    return function (prefix) {
        var filters = extractWeightEntry(prefix + "/filters", 4);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return { filters: filters, bias: bias };
    };
}
//# sourceMappingURL=loadConvParamsFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/common/types.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/common/types.js ***!
  \************************************************************/
/*! exports provided: SeparableConvParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SeparableConvParams", function() { return SeparableConvParams; });
var SeparableConvParams = /** @class */ (function () {
    function SeparableConvParams(depthwise_filter, pointwise_filter, bias) {
        this.depthwise_filter = depthwise_filter;
        this.pointwise_filter = pointwise_filter;
        this.bias = bias;
    }
    return SeparableConvParams;
}());

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/NetInput.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/NetInput.js ***!
  \************************************************************/
/*! exports provided: NetInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NetInput", function() { return NetInput; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _ops_padToSquare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ops/padToSquare */ "./node_modules/face-api.js/build/es6/ops/padToSquare.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _createCanvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createCanvas */ "./node_modules/face-api.js/build/es6/dom/createCanvas.js");
/* harmony import */ var _imageToSquare__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./imageToSquare */ "./node_modules/face-api.js/build/es6/dom/imageToSquare.js");






var NetInput = /** @class */ (function () {
    function NetInput(inputs, treatAsBatchInput) {
        var _this = this;
        if (treatAsBatchInput === void 0) { treatAsBatchInput = false; }
        this._imageTensors = [];
        this._canvases = [];
        this._treatAsBatchInput = false;
        this._inputDimensions = [];
        if (!Array.isArray(inputs)) {
            throw new Error("NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have " + inputs);
        }
        this._treatAsBatchInput = treatAsBatchInput;
        this._batchSize = inputs.length;
        inputs.forEach(function (input, idx) {
            if (Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor3D"])(input)) {
                _this._imageTensors[idx] = input;
                _this._inputDimensions[idx] = input.shape;
                return;
            }
            if (Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor4D"])(input)) {
                var batchSize = input.shape[0];
                if (batchSize !== 1) {
                    throw new Error("NetInput - tf.Tensor4D with batchSize " + batchSize + " passed, but not supported in input array");
                }
                _this._imageTensors[idx] = input;
                _this._inputDimensions[idx] = input.shape.slice(1);
                return;
            }
            var canvas = input instanceof _env__WEBPACK_IMPORTED_MODULE_1__["env"].getEnv().Canvas ? input : Object(_createCanvas__WEBPACK_IMPORTED_MODULE_4__["createCanvasFromMedia"])(input);
            _this._canvases[idx] = canvas;
            _this._inputDimensions[idx] = [canvas.height, canvas.width, 3];
        });
    }
    Object.defineProperty(NetInput.prototype, "imageTensors", {
        get: function () {
            return this._imageTensors;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput.prototype, "canvases", {
        get: function () {
            return this._canvases;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput.prototype, "isBatchInput", {
        get: function () {
            return this.batchSize > 1 || this._treatAsBatchInput;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput.prototype, "batchSize", {
        get: function () {
            return this._batchSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput.prototype, "inputDimensions", {
        get: function () {
            return this._inputDimensions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput.prototype, "inputSize", {
        get: function () {
            return this._inputSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NetInput.prototype, "reshapedInputDimensions", {
        get: function () {
            var _this = this;
            return Object(_utils__WEBPACK_IMPORTED_MODULE_3__["range"])(this.batchSize, 0, 1).map(function (_, batchIdx) { return _this.getReshapedInputDimensions(batchIdx); });
        },
        enumerable: true,
        configurable: true
    });
    NetInput.prototype.getInput = function (batchIdx) {
        return this.canvases[batchIdx] || this.imageTensors[batchIdx];
    };
    NetInput.prototype.getInputDimensions = function (batchIdx) {
        return this._inputDimensions[batchIdx];
    };
    NetInput.prototype.getInputHeight = function (batchIdx) {
        return this._inputDimensions[batchIdx][0];
    };
    NetInput.prototype.getInputWidth = function (batchIdx) {
        return this._inputDimensions[batchIdx][1];
    };
    NetInput.prototype.getReshapedInputDimensions = function (batchIdx) {
        if (typeof this.inputSize !== 'number') {
            throw new Error('getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet');
        }
        var width = this.getInputWidth(batchIdx);
        var height = this.getInputHeight(batchIdx);
        return Object(_utils__WEBPACK_IMPORTED_MODULE_3__["computeReshapedDimensions"])({ width: width, height: height }, this.inputSize);
    };
    /**
     * Create a batch tensor from all input canvases and tensors
     * with size [batchSize, inputSize, inputSize, 3].
     *
     * @param inputSize Height and width of the tensor.
     * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on
     * both sides of the minor dimension oof the image.
     * @returns The batch tensor.
     */
    NetInput.prototype.toBatchTensor = function (inputSize, isCenterInputs) {
        var _this = this;
        if (isCenterInputs === void 0) { isCenterInputs = true; }
        this._inputSize = inputSize;
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
            var inputTensors = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["range"])(_this.batchSize, 0, 1).map(function (batchIdx) {
                var input = _this.getInput(batchIdx);
                if (input instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]) {
                    var imgTensor = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor4D"])(input) ? input : input.expandDims();
                    imgTensor = Object(_ops_padToSquare__WEBPACK_IMPORTED_MODULE_2__["padToSquare"])(imgTensor, isCenterInputs);
                    if (imgTensor.shape[1] !== inputSize || imgTensor.shape[2] !== inputSize) {
                        imgTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].resizeBilinear(imgTensor, [inputSize, inputSize]);
                    }
                    return imgTensor.as3D(inputSize, inputSize, 3);
                }
                if (input instanceof _env__WEBPACK_IMPORTED_MODULE_1__["env"].getEnv().Canvas) {
                    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["browser"].fromPixels(Object(_imageToSquare__WEBPACK_IMPORTED_MODULE_5__["imageToSquare"])(input, inputSize, isCenterInputs));
                }
                throw new Error("toBatchTensor - at batchIdx " + batchIdx + ", expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have " + input);
            });
            var batchTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"](inputTensors.map(function (t) { return t.toFloat(); })).as4D(_this.batchSize, inputSize, inputSize, 3);
            return batchTensor;
        });
    };
    return NetInput;
}());

//# sourceMappingURL=NetInput.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/awaitMediaLoaded.js":
/*!********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/awaitMediaLoaded.js ***!
  \********************************************************************/
/*! exports provided: awaitMediaLoaded */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "awaitMediaLoaded", function() { return awaitMediaLoaded; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _isMediaLoaded__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isMediaLoaded */ "./node_modules/face-api.js/build/es6/dom/isMediaLoaded.js");


function awaitMediaLoaded(media) {
    return new Promise(function (resolve, reject) {
        if (media instanceof _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv().Canvas || Object(_isMediaLoaded__WEBPACK_IMPORTED_MODULE_1__["isMediaLoaded"])(media)) {
            return resolve();
        }
        function onLoad(e) {
            if (!e.currentTarget)
                return;
            e.currentTarget.removeEventListener('load', onLoad);
            e.currentTarget.removeEventListener('error', onError);
            resolve(e);
        }
        function onError(e) {
            if (!e.currentTarget)
                return;
            e.currentTarget.removeEventListener('load', onLoad);
            e.currentTarget.removeEventListener('error', onError);
            reject(e);
        }
        media.addEventListener('load', onLoad);
        media.addEventListener('error', onError);
    });
}
//# sourceMappingURL=awaitMediaLoaded.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/bufferToImage.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/bufferToImage.js ***!
  \*****************************************************************/
/*! exports provided: bufferToImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferToImage", function() { return bufferToImage; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");

function bufferToImage(buf) {
    return new Promise(function (resolve, reject) {
        if (!(buf instanceof Blob)) {
            return reject('bufferToImage - expected buf to be of type: Blob');
        }
        var reader = new FileReader();
        reader.onload = function () {
            if (typeof reader.result !== 'string') {
                return reject('bufferToImage - expected reader.result to be a string, in onload');
            }
            var img = _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv().createImageElement();
            img.onload = function () { return resolve(img); };
            img.onerror = reject;
            img.src = reader.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(buf);
    });
}
//# sourceMappingURL=bufferToImage.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/createCanvas.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/createCanvas.js ***!
  \****************************************************************/
/*! exports provided: createCanvas, createCanvasFromMedia */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCanvas", function() { return createCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCanvasFromMedia", function() { return createCanvasFromMedia; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getContext2dOrThrow */ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js");
/* harmony import */ var _getMediaDimensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getMediaDimensions */ "./node_modules/face-api.js/build/es6/dom/getMediaDimensions.js");
/* harmony import */ var _isMediaLoaded__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isMediaLoaded */ "./node_modules/face-api.js/build/es6/dom/isMediaLoaded.js");




function createCanvas(_a) {
    var width = _a.width, height = _a.height;
    var createCanvasElement = _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv().createCanvasElement;
    var canvas = createCanvasElement();
    canvas.width = width;
    canvas.height = height;
    return canvas;
}
function createCanvasFromMedia(media, dims) {
    var ImageData = _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv().ImageData;
    if (!(media instanceof ImageData) && !Object(_isMediaLoaded__WEBPACK_IMPORTED_MODULE_3__["isMediaLoaded"])(media)) {
        throw new Error('createCanvasFromMedia - media has not finished loading yet');
    }
    var _a = dims || Object(_getMediaDimensions__WEBPACK_IMPORTED_MODULE_2__["getMediaDimensions"])(media), width = _a.width, height = _a.height;
    var canvas = createCanvas({ width: width, height: height });
    if (media instanceof ImageData) {
        Object(_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_1__["getContext2dOrThrow"])(canvas).putImageData(media, 0, 0);
    }
    else {
        Object(_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_1__["getContext2dOrThrow"])(canvas).drawImage(media, 0, 0, width, height);
    }
    return canvas;
}
//# sourceMappingURL=createCanvas.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/extractFaceTensors.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/extractFaceTensors.js ***!
  \**********************************************************************/
/*! exports provided: extractFaceTensors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractFaceTensors", function() { return extractFaceTensors; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");




/**
 * Extracts the tensors of the image regions containing the detected faces.
 * Useful if you want to compute the face descriptors for the face images.
 * Using this method is faster then extracting a canvas for each face and
 * converting them to tensors individually.
 *
 * @param imageTensor The image tensor that face detection has been performed on.
 * @param detections The face detection results or face bounding boxes for that image.
 * @returns Tensors of the corresponding image region for each detected face.
 */
function extractFaceTensors(imageTensor, detections) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            if (!Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor3D"])(imageTensor) && !Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor4D"])(imageTensor)) {
                throw new Error('extractFaceTensors - expected image tensor to be 3D or 4D');
            }
            if (Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor4D"])(imageTensor) && imageTensor.shape[0] > 1) {
                throw new Error('extractFaceTensors - batchSize > 1 not supported');
            }
            return [2 /*return*/, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
                    var _a = imageTensor.shape.slice(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor4D"])(imageTensor) ? 1 : 0), imgHeight = _a[0], imgWidth = _a[1], numChannels = _a[2];
                    var boxes = detections.map(function (det) { return det instanceof _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_2__["FaceDetection"]
                        ? det.forSize(imgWidth, imgHeight).box
                        : det; })
                        .map(function (box) { return box.clipAtImageBorders(imgWidth, imgHeight); });
                    var faceTensors = boxes.map(function (_a) {
                        var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
                        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["slice3d"](imageTensor.as3D(imgHeight, imgWidth, numChannels), [y, x, 0], [height, width, numChannels]);
                    });
                    return faceTensors;
                })];
        });
    });
}
//# sourceMappingURL=extractFaceTensors.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/extractFaces.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/extractFaces.js ***!
  \****************************************************************/
/*! exports provided: extractFaces */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractFaces", function() { return extractFaces; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _createCanvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createCanvas */ "./node_modules/face-api.js/build/es6/dom/createCanvas.js");
/* harmony import */ var _getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getContext2dOrThrow */ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js");
/* harmony import */ var _imageTensorToCanvas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./imageTensorToCanvas */ "./node_modules/face-api.js/build/es6/dom/imageTensorToCanvas.js");
/* harmony import */ var _toNetInput__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./toNetInput */ "./node_modules/face-api.js/build/es6/dom/toNetInput.js");







/**
 * Extracts the image regions containing the detected faces.
 *
 * @param input The image that face detection has been performed on.
 * @param detections The face detection results or face bounding boxes for that image.
 * @returns The Canvases of the corresponding image region for each detected face.
 */
function extractFaces(input, detections) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var Canvas, canvas, netInput, tensorOrCanvas, _a, ctx, boxes;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
            switch (_b.label) {
                case 0:
                    Canvas = _env__WEBPACK_IMPORTED_MODULE_2__["env"].getEnv().Canvas;
                    canvas = input;
                    if (!!(input instanceof Canvas)) return [3 /*break*/, 5];
                    return [4 /*yield*/, Object(_toNetInput__WEBPACK_IMPORTED_MODULE_6__["toNetInput"])(input)];
                case 1:
                    netInput = _b.sent();
                    if (netInput.batchSize > 1) {
                        throw new Error('extractFaces - batchSize > 1 not supported');
                    }
                    tensorOrCanvas = netInput.getInput(0);
                    if (!(tensorOrCanvas instanceof Canvas)) return [3 /*break*/, 2];
                    _a = tensorOrCanvas;
                    return [3 /*break*/, 4];
                case 2: return [4 /*yield*/, Object(_imageTensorToCanvas__WEBPACK_IMPORTED_MODULE_5__["imageTensorToCanvas"])(tensorOrCanvas)];
                case 3:
                    _a = _b.sent();
                    _b.label = 4;
                case 4:
                    canvas = _a;
                    _b.label = 5;
                case 5:
                    ctx = Object(_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_4__["getContext2dOrThrow"])(canvas);
                    boxes = detections.map(function (det) { return det instanceof _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_1__["FaceDetection"]
                        ? det.forSize(canvas.width, canvas.height).box.floor()
                        : det; })
                        .map(function (box) { return box.clipAtImageBorders(canvas.width, canvas.height); });
                    return [2 /*return*/, boxes.map(function (_a) {
                            var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
                            var faceImg = Object(_createCanvas__WEBPACK_IMPORTED_MODULE_3__["createCanvas"])({ width: width, height: height });
                            Object(_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_4__["getContext2dOrThrow"])(faceImg)
                                .putImageData(ctx.getImageData(x, y, width, height), 0, 0);
                            return faceImg;
                        })];
            }
        });
    });
}
//# sourceMappingURL=extractFaces.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/fetchImage.js":
/*!**************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/fetchImage.js ***!
  \**************************************************************/
/*! exports provided: fetchImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchImage", function() { return fetchImage; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _bufferToImage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bufferToImage */ "./node_modules/face-api.js/build/es6/dom/bufferToImage.js");
/* harmony import */ var _fetchOrThrow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fetchOrThrow */ "./node_modules/face-api.js/build/es6/dom/fetchOrThrow.js");



function fetchImage(uri) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var res, blob;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, Object(_fetchOrThrow__WEBPACK_IMPORTED_MODULE_2__["fetchOrThrow"])(uri)];
                case 1:
                    res = _a.sent();
                    return [4 /*yield*/, (res).blob()];
                case 2:
                    blob = _a.sent();
                    if (!blob.type.startsWith('image/')) {
                        throw new Error("fetchImage - expected blob type to be of type image/*, instead have: " + blob.type + ", for url: " + res.url);
                    }
                    return [2 /*return*/, Object(_bufferToImage__WEBPACK_IMPORTED_MODULE_1__["bufferToImage"])(blob)];
            }
        });
    });
}
//# sourceMappingURL=fetchImage.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/fetchJson.js":
/*!*************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/fetchJson.js ***!
  \*************************************************************/
/*! exports provided: fetchJson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchJson", function() { return fetchJson; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _fetchOrThrow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fetchOrThrow */ "./node_modules/face-api.js/build/es6/dom/fetchOrThrow.js");


function fetchJson(uri) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, Object(_fetchOrThrow__WEBPACK_IMPORTED_MODULE_1__["fetchOrThrow"])(uri)];
                case 1: return [2 /*return*/, (_a.sent()).json()];
            }
        });
    });
}
//# sourceMappingURL=fetchJson.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/fetchNetWeights.js":
/*!*******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/fetchNetWeights.js ***!
  \*******************************************************************/
/*! exports provided: fetchNetWeights */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchNetWeights", function() { return fetchNetWeights; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _fetchOrThrow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fetchOrThrow */ "./node_modules/face-api.js/build/es6/dom/fetchOrThrow.js");


function fetchNetWeights(uri) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var _a;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = Float32Array.bind;
                    return [4 /*yield*/, Object(_fetchOrThrow__WEBPACK_IMPORTED_MODULE_1__["fetchOrThrow"])(uri)];
                case 1: return [4 /*yield*/, (_b.sent()).arrayBuffer()];
                case 2: return [2 /*return*/, new (_a.apply(Float32Array, [void 0, _b.sent()]))()];
            }
        });
    });
}
//# sourceMappingURL=fetchNetWeights.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/fetchOrThrow.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/fetchOrThrow.js ***!
  \****************************************************************/
/*! exports provided: fetchOrThrow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchOrThrow", function() { return fetchOrThrow; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");


function fetchOrThrow(url, init) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var fetch, res;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0:
                    fetch = _env__WEBPACK_IMPORTED_MODULE_1__["env"].getEnv().fetch;
                    return [4 /*yield*/, fetch(url, init)];
                case 1:
                    res = _a.sent();
                    if (!(res.status < 400)) {
                        throw new Error("failed to fetch: (" + res.status + ") " + res.statusText + ", from url: " + res.url);
                    }
                    return [2 /*return*/, res];
            }
        });
    });
}
//# sourceMappingURL=fetchOrThrow.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js":
/*!***********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js ***!
  \***********************************************************************/
/*! exports provided: getContext2dOrThrow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContext2dOrThrow", function() { return getContext2dOrThrow; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _resolveInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolveInput */ "./node_modules/face-api.js/build/es6/dom/resolveInput.js");


function getContext2dOrThrow(canvasArg) {
    var _a = _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv(), Canvas = _a.Canvas, CanvasRenderingContext2D = _a.CanvasRenderingContext2D;
    if (canvasArg instanceof CanvasRenderingContext2D) {
        return canvasArg;
    }
    var canvas = Object(_resolveInput__WEBPACK_IMPORTED_MODULE_1__["resolveInput"])(canvasArg);
    if (!(canvas instanceof Canvas)) {
        throw new Error('resolveContext2d - expected canvas to be of instance of Canvas');
    }
    var ctx = canvas.getContext('2d');
    if (!ctx) {
        throw new Error('resolveContext2d - canvas 2d context is null');
    }
    return ctx;
}
//# sourceMappingURL=getContext2dOrThrow.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/getMediaDimensions.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/getMediaDimensions.js ***!
  \**********************************************************************/
/*! exports provided: getMediaDimensions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMediaDimensions", function() { return getMediaDimensions; });
/* harmony import */ var _classes_Dimensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/Dimensions */ "./node_modules/face-api.js/build/es6/classes/Dimensions.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");


function getMediaDimensions(input) {
    var _a = _env__WEBPACK_IMPORTED_MODULE_1__["env"].getEnv(), Image = _a.Image, Video = _a.Video;
    if (input instanceof Image) {
        return new _classes_Dimensions__WEBPACK_IMPORTED_MODULE_0__["Dimensions"](input.naturalWidth, input.naturalHeight);
    }
    if (input instanceof Video) {
        return new _classes_Dimensions__WEBPACK_IMPORTED_MODULE_0__["Dimensions"](input.videoWidth, input.videoHeight);
    }
    return new _classes_Dimensions__WEBPACK_IMPORTED_MODULE_0__["Dimensions"](input.width, input.height);
}
//# sourceMappingURL=getMediaDimensions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/imageTensorToCanvas.js":
/*!***********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/imageTensorToCanvas.js ***!
  \***********************************************************************/
/*! exports provided: imageTensorToCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "imageTensorToCanvas", function() { return imageTensorToCanvas; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");




function imageTensorToCanvas(imgTensor, canvas) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var targetCanvas, _a, height, width, numChannels, imgTensor3D;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
            switch (_b.label) {
                case 0:
                    targetCanvas = canvas || _env__WEBPACK_IMPORTED_MODULE_2__["env"].getEnv().createCanvasElement();
                    _a = imgTensor.shape.slice(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isTensor4D"])(imgTensor) ? 1 : 0), height = _a[0], width = _a[1], numChannels = _a[2];
                    imgTensor3D = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () { return imgTensor.as3D(height, width, numChannels).toInt(); });
                    return [4 /*yield*/, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["browser"].toPixels(imgTensor3D, targetCanvas)];
                case 1:
                    _b.sent();
                    imgTensor3D.dispose();
                    return [2 /*return*/, targetCanvas];
            }
        });
    });
}
//# sourceMappingURL=imageTensorToCanvas.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/imageToSquare.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/imageToSquare.js ***!
  \*****************************************************************/
/*! exports provided: imageToSquare */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "imageToSquare", function() { return imageToSquare; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _createCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createCanvas */ "./node_modules/face-api.js/build/es6/dom/createCanvas.js");
/* harmony import */ var _getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getContext2dOrThrow */ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js");
/* harmony import */ var _getMediaDimensions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMediaDimensions */ "./node_modules/face-api.js/build/es6/dom/getMediaDimensions.js");




function imageToSquare(input, inputSize, centerImage) {
    if (centerImage === void 0) { centerImage = false; }
    var _a = _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv(), Image = _a.Image, Canvas = _a.Canvas;
    if (!(input instanceof Image || input instanceof Canvas)) {
        throw new Error('imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement');
    }
    var dims = Object(_getMediaDimensions__WEBPACK_IMPORTED_MODULE_3__["getMediaDimensions"])(input);
    var scale = inputSize / Math.max(dims.height, dims.width);
    var width = scale * dims.width;
    var height = scale * dims.height;
    var targetCanvas = Object(_createCanvas__WEBPACK_IMPORTED_MODULE_1__["createCanvas"])({ width: inputSize, height: inputSize });
    var inputCanvas = input instanceof Canvas ? input : Object(_createCanvas__WEBPACK_IMPORTED_MODULE_1__["createCanvasFromMedia"])(input);
    var offset = Math.abs(width - height) / 2;
    var dx = centerImage && width < height ? offset : 0;
    var dy = centerImage && height < width ? offset : 0;
    Object(_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_2__["getContext2dOrThrow"])(targetCanvas).drawImage(inputCanvas, dx, dy, width, height);
    return targetCanvas;
}
//# sourceMappingURL=imageToSquare.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/index.js ***!
  \*********************************************************/
/*! exports provided: awaitMediaLoaded, bufferToImage, createCanvas, createCanvasFromMedia, extractFaces, extractFaceTensors, fetchImage, fetchJson, fetchNetWeights, fetchOrThrow, getContext2dOrThrow, getMediaDimensions, imageTensorToCanvas, imageToSquare, isMediaElement, isMediaLoaded, loadWeightMap, matchDimensions, NetInput, resolveInput, toNetInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _awaitMediaLoaded__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./awaitMediaLoaded */ "./node_modules/face-api.js/build/es6/dom/awaitMediaLoaded.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "awaitMediaLoaded", function() { return _awaitMediaLoaded__WEBPACK_IMPORTED_MODULE_0__["awaitMediaLoaded"]; });

/* harmony import */ var _bufferToImage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bufferToImage */ "./node_modules/face-api.js/build/es6/dom/bufferToImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferToImage", function() { return _bufferToImage__WEBPACK_IMPORTED_MODULE_1__["bufferToImage"]; });

/* harmony import */ var _createCanvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createCanvas */ "./node_modules/face-api.js/build/es6/dom/createCanvas.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createCanvas", function() { return _createCanvas__WEBPACK_IMPORTED_MODULE_2__["createCanvas"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createCanvasFromMedia", function() { return _createCanvas__WEBPACK_IMPORTED_MODULE_2__["createCanvasFromMedia"]; });

/* harmony import */ var _extractFaces__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extractFaces */ "./node_modules/face-api.js/build/es6/dom/extractFaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractFaces", function() { return _extractFaces__WEBPACK_IMPORTED_MODULE_3__["extractFaces"]; });

/* harmony import */ var _extractFaceTensors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./extractFaceTensors */ "./node_modules/face-api.js/build/es6/dom/extractFaceTensors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractFaceTensors", function() { return _extractFaceTensors__WEBPACK_IMPORTED_MODULE_4__["extractFaceTensors"]; });

/* harmony import */ var _fetchImage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fetchImage */ "./node_modules/face-api.js/build/es6/dom/fetchImage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchImage", function() { return _fetchImage__WEBPACK_IMPORTED_MODULE_5__["fetchImage"]; });

/* harmony import */ var _fetchJson__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fetchJson */ "./node_modules/face-api.js/build/es6/dom/fetchJson.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchJson", function() { return _fetchJson__WEBPACK_IMPORTED_MODULE_6__["fetchJson"]; });

/* harmony import */ var _fetchNetWeights__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fetchNetWeights */ "./node_modules/face-api.js/build/es6/dom/fetchNetWeights.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchNetWeights", function() { return _fetchNetWeights__WEBPACK_IMPORTED_MODULE_7__["fetchNetWeights"]; });

/* harmony import */ var _fetchOrThrow__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fetchOrThrow */ "./node_modules/face-api.js/build/es6/dom/fetchOrThrow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchOrThrow", function() { return _fetchOrThrow__WEBPACK_IMPORTED_MODULE_8__["fetchOrThrow"]; });

/* harmony import */ var _getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getContext2dOrThrow */ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContext2dOrThrow", function() { return _getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_9__["getContext2dOrThrow"]; });

/* harmony import */ var _getMediaDimensions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./getMediaDimensions */ "./node_modules/face-api.js/build/es6/dom/getMediaDimensions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMediaDimensions", function() { return _getMediaDimensions__WEBPACK_IMPORTED_MODULE_10__["getMediaDimensions"]; });

/* harmony import */ var _imageTensorToCanvas__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./imageTensorToCanvas */ "./node_modules/face-api.js/build/es6/dom/imageTensorToCanvas.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "imageTensorToCanvas", function() { return _imageTensorToCanvas__WEBPACK_IMPORTED_MODULE_11__["imageTensorToCanvas"]; });

/* harmony import */ var _imageToSquare__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./imageToSquare */ "./node_modules/face-api.js/build/es6/dom/imageToSquare.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "imageToSquare", function() { return _imageToSquare__WEBPACK_IMPORTED_MODULE_12__["imageToSquare"]; });

/* harmony import */ var _isMediaElement__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./isMediaElement */ "./node_modules/face-api.js/build/es6/dom/isMediaElement.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMediaElement", function() { return _isMediaElement__WEBPACK_IMPORTED_MODULE_13__["isMediaElement"]; });

/* harmony import */ var _isMediaLoaded__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./isMediaLoaded */ "./node_modules/face-api.js/build/es6/dom/isMediaLoaded.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMediaLoaded", function() { return _isMediaLoaded__WEBPACK_IMPORTED_MODULE_14__["isMediaLoaded"]; });

/* harmony import */ var _loadWeightMap__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./loadWeightMap */ "./node_modules/face-api.js/build/es6/dom/loadWeightMap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadWeightMap", function() { return _loadWeightMap__WEBPACK_IMPORTED_MODULE_15__["loadWeightMap"]; });

/* harmony import */ var _matchDimensions__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./matchDimensions */ "./node_modules/face-api.js/build/es6/dom/matchDimensions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matchDimensions", function() { return _matchDimensions__WEBPACK_IMPORTED_MODULE_16__["matchDimensions"]; });

/* harmony import */ var _NetInput__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./NetInput */ "./node_modules/face-api.js/build/es6/dom/NetInput.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NetInput", function() { return _NetInput__WEBPACK_IMPORTED_MODULE_17__["NetInput"]; });

/* harmony import */ var _resolveInput__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./resolveInput */ "./node_modules/face-api.js/build/es6/dom/resolveInput.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveInput", function() { return _resolveInput__WEBPACK_IMPORTED_MODULE_18__["resolveInput"]; });

/* harmony import */ var _toNetInput__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./toNetInput */ "./node_modules/face-api.js/build/es6/dom/toNetInput.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toNetInput", function() { return _toNetInput__WEBPACK_IMPORTED_MODULE_19__["toNetInput"]; });





















//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/isMediaElement.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/isMediaElement.js ***!
  \******************************************************************/
/*! exports provided: isMediaElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMediaElement", function() { return isMediaElement; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");

function isMediaElement(input) {
    var _a = _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv(), Image = _a.Image, Canvas = _a.Canvas, Video = _a.Video;
    return input instanceof Image
        || input instanceof Canvas
        || input instanceof Video;
}
//# sourceMappingURL=isMediaElement.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/isMediaLoaded.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/isMediaLoaded.js ***!
  \*****************************************************************/
/*! exports provided: isMediaLoaded */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMediaLoaded", function() { return isMediaLoaded; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");

function isMediaLoaded(media) {
    var _a = _env__WEBPACK_IMPORTED_MODULE_0__["env"].getEnv(), Image = _a.Image, Video = _a.Video;
    return (media instanceof Image && media.complete)
        || (media instanceof Video && media.readyState >= 3);
}
//# sourceMappingURL=isMediaLoaded.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/loadWeightMap.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/loadWeightMap.js ***!
  \*****************************************************************/
/*! exports provided: loadWeightMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadWeightMap", function() { return loadWeightMap; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common_getModelUris__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/getModelUris */ "./node_modules/face-api.js/build/es6/common/getModelUris.js");
/* harmony import */ var _fetchJson__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fetchJson */ "./node_modules/face-api.js/build/es6/dom/fetchJson.js");




function loadWeightMap(uri, defaultModelName) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var _a, manifestUri, modelBaseUri, manifest;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = Object(_common_getModelUris__WEBPACK_IMPORTED_MODULE_2__["getModelUris"])(uri, defaultModelName), manifestUri = _a.manifestUri, modelBaseUri = _a.modelBaseUri;
                    return [4 /*yield*/, Object(_fetchJson__WEBPACK_IMPORTED_MODULE_3__["fetchJson"])(manifestUri)];
                case 1:
                    manifest = _b.sent();
                    return [2 /*return*/, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["io"].loadWeights(manifest, modelBaseUri)];
            }
        });
    });
}
//# sourceMappingURL=loadWeightMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/matchDimensions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/matchDimensions.js ***!
  \*******************************************************************/
/*! exports provided: matchDimensions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matchDimensions", function() { return matchDimensions; });
/* harmony import */ var _getMediaDimensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getMediaDimensions */ "./node_modules/face-api.js/build/es6/dom/getMediaDimensions.js");

function matchDimensions(input, reference, useMediaDimensions) {
    if (useMediaDimensions === void 0) { useMediaDimensions = false; }
    var _a = useMediaDimensions
        ? Object(_getMediaDimensions__WEBPACK_IMPORTED_MODULE_0__["getMediaDimensions"])(reference)
        : reference, width = _a.width, height = _a.height;
    input.width = width;
    input.height = height;
    return { width: width, height: height };
}
//# sourceMappingURL=matchDimensions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/resolveInput.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/resolveInput.js ***!
  \****************************************************************/
/*! exports provided: resolveInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveInput", function() { return resolveInput; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");

function resolveInput(arg) {
    if (!_env__WEBPACK_IMPORTED_MODULE_0__["env"].isNodejs() && typeof arg === 'string') {
        return document.getElementById(arg);
    }
    return arg;
}
//# sourceMappingURL=resolveInput.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/dom/toNetInput.js":
/*!**************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/dom/toNetInput.js ***!
  \**************************************************************/
/*! exports provided: toNetInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toNetInput", function() { return toNetInput; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _awaitMediaLoaded__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./awaitMediaLoaded */ "./node_modules/face-api.js/build/es6/dom/awaitMediaLoaded.js");
/* harmony import */ var _isMediaElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isMediaElement */ "./node_modules/face-api.js/build/es6/dom/isMediaElement.js");
/* harmony import */ var _NetInput__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NetInput */ "./node_modules/face-api.js/build/es6/dom/NetInput.js");
/* harmony import */ var _resolveInput__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resolveInput */ "./node_modules/face-api.js/build/es6/dom/resolveInput.js");






/**
 * Validates the input to make sure, they are valid net inputs and awaits all media elements
 * to be finished loading.
 *
 * @param input The input, which can be a media element or an array of different media elements.
 * @returns A NetInput instance, which can be passed into one of the neural networks.
 */
function toNetInput(inputs) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var inputArgArray, getIdxHint, inputArray;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (inputs instanceof _NetInput__WEBPACK_IMPORTED_MODULE_4__["NetInput"]) {
                        return [2 /*return*/, inputs];
                    }
                    inputArgArray = Array.isArray(inputs)
                        ? inputs
                        : [inputs];
                    if (!inputArgArray.length) {
                        throw new Error('toNetInput - empty array passed as input');
                    }
                    getIdxHint = function (idx) { return Array.isArray(inputs) ? " at input index " + idx + ":" : ''; };
                    inputArray = inputArgArray.map(_resolveInput__WEBPACK_IMPORTED_MODULE_5__["resolveInput"]);
                    inputArray.forEach(function (input, i) {
                        if (!Object(_isMediaElement__WEBPACK_IMPORTED_MODULE_3__["isMediaElement"])(input) && !Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isTensor3D"])(input) && !Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isTensor4D"])(input)) {
                            if (typeof inputArgArray[i] === 'string') {
                                throw new Error("toNetInput -" + getIdxHint(i) + " string passed, but could not resolve HTMLElement for element id " + inputArgArray[i]);
                            }
                            throw new Error("toNetInput -" + getIdxHint(i) + " expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id");
                        }
                        if (Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isTensor4D"])(input)) {
                            // if tf.Tensor4D is passed in the input array, the batch size has to be 1
                            var batchSize = input.shape[0];
                            if (batchSize !== 1) {
                                throw new Error("toNetInput -" + getIdxHint(i) + " tf.Tensor4D with batchSize " + batchSize + " passed, but not supported in input array");
                            }
                        }
                    });
                    // wait for all media elements being loaded
                    return [4 /*yield*/, Promise.all(inputArray.map(function (input) { return Object(_isMediaElement__WEBPACK_IMPORTED_MODULE_3__["isMediaElement"])(input) && Object(_awaitMediaLoaded__WEBPACK_IMPORTED_MODULE_2__["awaitMediaLoaded"])(input); }))];
                case 1:
                    // wait for all media elements being loaded
                    _a.sent();
                    return [2 /*return*/, new _NetInput__WEBPACK_IMPORTED_MODULE_4__["NetInput"](inputArray, Array.isArray(inputs))];
            }
        });
    });
}
//# sourceMappingURL=toNetInput.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/draw/DrawBox.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/draw/DrawBox.js ***!
  \************************************************************/
/*! exports provided: DrawBoxOptions, DrawBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawBoxOptions", function() { return DrawBoxOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawBox", function() { return DrawBox; });
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _dom_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom/getContext2dOrThrow */ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js");
/* harmony import */ var _DrawTextField__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DrawTextField */ "./node_modules/face-api.js/build/es6/draw/DrawTextField.js");



var DrawBoxOptions = /** @class */ (function () {
    function DrawBoxOptions(options) {
        if (options === void 0) { options = {}; }
        var boxColor = options.boxColor, lineWidth = options.lineWidth, label = options.label, drawLabelOptions = options.drawLabelOptions;
        this.boxColor = boxColor || 'rgba(0, 0, 255, 1)';
        this.lineWidth = lineWidth || 2;
        this.label = label;
        var defaultDrawLabelOptions = {
            anchorPosition: _DrawTextField__WEBPACK_IMPORTED_MODULE_2__["AnchorPosition"].BOTTOM_LEFT,
            backgroundColor: this.boxColor
        };
        this.drawLabelOptions = new _DrawTextField__WEBPACK_IMPORTED_MODULE_2__["DrawTextFieldOptions"](Object.assign({}, defaultDrawLabelOptions, drawLabelOptions));
    }
    return DrawBoxOptions;
}());

var DrawBox = /** @class */ (function () {
    function DrawBox(box, options) {
        if (options === void 0) { options = {}; }
        this.box = new _classes__WEBPACK_IMPORTED_MODULE_0__["Box"](box);
        this.options = new DrawBoxOptions(options);
    }
    DrawBox.prototype.draw = function (canvasArg) {
        var ctx = Object(_dom_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_1__["getContext2dOrThrow"])(canvasArg);
        var _a = this.options, boxColor = _a.boxColor, lineWidth = _a.lineWidth;
        var _b = this.box, x = _b.x, y = _b.y, width = _b.width, height = _b.height;
        ctx.strokeStyle = boxColor;
        ctx.lineWidth = lineWidth;
        ctx.strokeRect(x, y, width, height);
        var label = this.options.label;
        if (label) {
            new _DrawTextField__WEBPACK_IMPORTED_MODULE_2__["DrawTextField"]([label], { x: x - (lineWidth / 2), y: y }, this.options.drawLabelOptions).draw(canvasArg);
        }
    };
    return DrawBox;
}());

//# sourceMappingURL=DrawBox.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/draw/DrawFaceLandmarks.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/draw/DrawFaceLandmarks.js ***!
  \**********************************************************************/
/*! exports provided: DrawFaceLandmarksOptions, DrawFaceLandmarks, drawFaceLandmarks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawFaceLandmarksOptions", function() { return DrawFaceLandmarksOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawFaceLandmarks", function() { return DrawFaceLandmarks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawFaceLandmarks", function() { return drawFaceLandmarks; });
/* harmony import */ var _classes_FaceLandmarks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/FaceLandmarks */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js");
/* harmony import */ var _classes_FaceLandmarks68__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/FaceLandmarks68 */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js");
/* harmony import */ var _dom_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom/getContext2dOrThrow */ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js");
/* harmony import */ var _factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factories/WithFaceLandmarks */ "./node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js");
/* harmony import */ var _drawContour__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drawContour */ "./node_modules/face-api.js/build/es6/draw/drawContour.js");





var DrawFaceLandmarksOptions = /** @class */ (function () {
    function DrawFaceLandmarksOptions(options) {
        if (options === void 0) { options = {}; }
        var _a = options.drawLines, drawLines = _a === void 0 ? true : _a, _b = options.drawPoints, drawPoints = _b === void 0 ? true : _b, lineWidth = options.lineWidth, lineColor = options.lineColor, pointSize = options.pointSize, pointColor = options.pointColor;
        this.drawLines = drawLines;
        this.drawPoints = drawPoints;
        this.lineWidth = lineWidth || 1;
        this.pointSize = pointSize || 2;
        this.lineColor = lineColor || 'rgba(0, 255, 255, 1)';
        this.pointColor = pointColor || 'rgba(255, 0, 255, 1)';
    }
    return DrawFaceLandmarksOptions;
}());

var DrawFaceLandmarks = /** @class */ (function () {
    function DrawFaceLandmarks(faceLandmarks, options) {
        if (options === void 0) { options = {}; }
        this.faceLandmarks = faceLandmarks;
        this.options = new DrawFaceLandmarksOptions(options);
    }
    DrawFaceLandmarks.prototype.draw = function (canvasArg) {
        var ctx = Object(_dom_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_2__["getContext2dOrThrow"])(canvasArg);
        var _a = this.options, drawLines = _a.drawLines, drawPoints = _a.drawPoints, lineWidth = _a.lineWidth, lineColor = _a.lineColor, pointSize = _a.pointSize, pointColor = _a.pointColor;
        if (drawLines && this.faceLandmarks instanceof _classes_FaceLandmarks68__WEBPACK_IMPORTED_MODULE_1__["FaceLandmarks68"]) {
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = lineWidth;
            Object(_drawContour__WEBPACK_IMPORTED_MODULE_4__["drawContour"])(ctx, this.faceLandmarks.getJawOutline());
            Object(_drawContour__WEBPACK_IMPORTED_MODULE_4__["drawContour"])(ctx, this.faceLandmarks.getLeftEyeBrow());
            Object(_drawContour__WEBPACK_IMPORTED_MODULE_4__["drawContour"])(ctx, this.faceLandmarks.getRightEyeBrow());
            Object(_drawContour__WEBPACK_IMPORTED_MODULE_4__["drawContour"])(ctx, this.faceLandmarks.getNose());
            Object(_drawContour__WEBPACK_IMPORTED_MODULE_4__["drawContour"])(ctx, this.faceLandmarks.getLeftEye(), true);
            Object(_drawContour__WEBPACK_IMPORTED_MODULE_4__["drawContour"])(ctx, this.faceLandmarks.getRightEye(), true);
            Object(_drawContour__WEBPACK_IMPORTED_MODULE_4__["drawContour"])(ctx, this.faceLandmarks.getMouth(), true);
        }
        if (drawPoints) {
            ctx.strokeStyle = pointColor;
            ctx.fillStyle = pointColor;
            var drawPoint = function (pt) {
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, pointSize, 0, 2 * Math.PI);
                ctx.fill();
            };
            this.faceLandmarks.positions.forEach(drawPoint);
        }
    };
    return DrawFaceLandmarks;
}());

function drawFaceLandmarks(canvasArg, faceLandmarks) {
    var faceLandmarksArray = Array.isArray(faceLandmarks) ? faceLandmarks : [faceLandmarks];
    faceLandmarksArray.forEach(function (f) {
        var landmarks = f instanceof _classes_FaceLandmarks__WEBPACK_IMPORTED_MODULE_0__["FaceLandmarks"]
            ? f
            : (Object(_factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__["isWithFaceLandmarks"])(f) ? f.landmarks : undefined);
        if (!landmarks) {
            throw new Error('drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof');
        }
        new DrawFaceLandmarks(landmarks).draw(canvasArg);
    });
}
//# sourceMappingURL=DrawFaceLandmarks.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/draw/DrawTextField.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/draw/DrawTextField.js ***!
  \******************************************************************/
/*! exports provided: AnchorPosition, DrawTextFieldOptions, DrawTextField */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnchorPosition", function() { return AnchorPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawTextFieldOptions", function() { return DrawTextFieldOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawTextField", function() { return DrawTextField; });
/* harmony import */ var _dom_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom/getContext2dOrThrow */ "./node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js");
/* harmony import */ var _dom_resolveInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom/resolveInput */ "./node_modules/face-api.js/build/es6/dom/resolveInput.js");


var AnchorPosition;
(function (AnchorPosition) {
    AnchorPosition["TOP_LEFT"] = "TOP_LEFT";
    AnchorPosition["TOP_RIGHT"] = "TOP_RIGHT";
    AnchorPosition["BOTTOM_LEFT"] = "BOTTOM_LEFT";
    AnchorPosition["BOTTOM_RIGHT"] = "BOTTOM_RIGHT";
})(AnchorPosition || (AnchorPosition = {}));
var DrawTextFieldOptions = /** @class */ (function () {
    function DrawTextFieldOptions(options) {
        if (options === void 0) { options = {}; }
        var anchorPosition = options.anchorPosition, backgroundColor = options.backgroundColor, fontColor = options.fontColor, fontSize = options.fontSize, fontStyle = options.fontStyle, padding = options.padding;
        this.anchorPosition = anchorPosition || AnchorPosition.TOP_LEFT;
        this.backgroundColor = backgroundColor || 'rgba(0, 0, 0, 0.5)';
        this.fontColor = fontColor || 'rgba(255, 255, 255, 1)';
        this.fontSize = fontSize || 14;
        this.fontStyle = fontStyle || 'Georgia';
        this.padding = padding || 4;
    }
    return DrawTextFieldOptions;
}());

var DrawTextField = /** @class */ (function () {
    function DrawTextField(text, anchor, options) {
        if (options === void 0) { options = {}; }
        this.text = typeof text === 'string'
            ? [text]
            : (text instanceof DrawTextField ? text.text : text);
        this.anchor = anchor;
        this.options = new DrawTextFieldOptions(options);
    }
    DrawTextField.prototype.measureWidth = function (ctx) {
        var padding = this.options.padding;
        return this.text.map(function (l) { return ctx.measureText(l).width; }).reduce(function (w0, w1) { return w0 < w1 ? w1 : w0; }, 0) + (2 * padding);
    };
    DrawTextField.prototype.measureHeight = function () {
        var _a = this.options, fontSize = _a.fontSize, padding = _a.padding;
        return this.text.length * fontSize + (2 * padding);
    };
    DrawTextField.prototype.getUpperLeft = function (ctx, canvasDims) {
        var anchorPosition = this.options.anchorPosition;
        var isShiftLeft = anchorPosition === AnchorPosition.BOTTOM_RIGHT || anchorPosition === AnchorPosition.TOP_RIGHT;
        var isShiftTop = anchorPosition === AnchorPosition.BOTTOM_LEFT || anchorPosition === AnchorPosition.BOTTOM_RIGHT;
        var textFieldWidth = this.measureWidth(ctx);
        var textFieldHeight = this.measureHeight();
        var x = (isShiftLeft ? this.anchor.x - textFieldWidth : this.anchor.x);
        var y = isShiftTop ? this.anchor.y - textFieldHeight : this.anchor.y;
        // adjust anchor if text box exceeds canvas borders
        if (canvasDims) {
            var width = canvasDims.width, height = canvasDims.height;
            var newX = Math.max(Math.min(x, width - textFieldWidth), 0);
            var newY = Math.max(Math.min(y, height - textFieldHeight), 0);
            return { x: newX, y: newY };
        }
        return { x: x, y: y };
    };
    DrawTextField.prototype.draw = function (canvasArg) {
        var canvas = Object(_dom_resolveInput__WEBPACK_IMPORTED_MODULE_1__["resolveInput"])(canvasArg);
        var ctx = Object(_dom_getContext2dOrThrow__WEBPACK_IMPORTED_MODULE_0__["getContext2dOrThrow"])(canvas);
        var _a = this.options, backgroundColor = _a.backgroundColor, fontColor = _a.fontColor, fontSize = _a.fontSize, fontStyle = _a.fontStyle, padding = _a.padding;
        ctx.font = fontSize + "px " + fontStyle;
        var maxTextWidth = this.measureWidth(ctx);
        var textHeight = this.measureHeight();
        ctx.fillStyle = backgroundColor;
        var upperLeft = this.getUpperLeft(ctx, canvas);
        ctx.fillRect(upperLeft.x, upperLeft.y, maxTextWidth, textHeight);
        ctx.fillStyle = fontColor;
        this.text.forEach(function (textLine, i) {
            var x = padding + upperLeft.x;
            var y = padding + upperLeft.y + ((i + 1) * fontSize);
            ctx.fillText(textLine, x, y);
        });
    };
    return DrawTextField;
}());

//# sourceMappingURL=DrawTextField.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/draw/drawContour.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/draw/drawContour.js ***!
  \****************************************************************/
/*! exports provided: drawContour */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawContour", function() { return drawContour; });
function drawContour(ctx, points, isClosed) {
    if (isClosed === void 0) { isClosed = false; }
    ctx.beginPath();
    points.slice(1).forEach(function (_a, prevIdx) {
        var x = _a.x, y = _a.y;
        var from = points[prevIdx];
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(x, y);
    });
    if (isClosed) {
        var from = points[points.length - 1];
        var to = points[0];
        if (!from || !to) {
            return;
        }
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
    }
    ctx.stroke();
}
//# sourceMappingURL=drawContour.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/draw/drawDetections.js":
/*!*******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/draw/drawDetections.js ***!
  \*******************************************************************/
/*! exports provided: drawDetections */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawDetections", function() { return drawDetections; });
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factories/WithFaceDetection */ "./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _DrawBox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DrawBox */ "./node_modules/face-api.js/build/es6/draw/DrawBox.js");





function drawDetections(canvasArg, detections) {
    var detectionsArray = Array.isArray(detections) ? detections : [detections];
    detectionsArray.forEach(function (det) {
        var score = det instanceof _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_1__["FaceDetection"]
            ? det.score
            : (Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_2__["isWithFaceDetection"])(det) ? det.detection.score : undefined);
        var box = det instanceof _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_1__["FaceDetection"]
            ? det.box
            : (Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_2__["isWithFaceDetection"])(det) ? det.detection.box : new _classes__WEBPACK_IMPORTED_MODULE_0__["Box"](det));
        var label = score ? "" + Object(_utils__WEBPACK_IMPORTED_MODULE_3__["round"])(score) : undefined;
        new _DrawBox__WEBPACK_IMPORTED_MODULE_4__["DrawBox"](box, { label: label }).draw(canvasArg);
    });
}
//# sourceMappingURL=drawDetections.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/draw/drawFaceExpressions.js":
/*!************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/draw/drawFaceExpressions.js ***!
  \************************************************************************/
/*! exports provided: drawFaceExpressions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawFaceExpressions", function() { return drawFaceExpressions; });
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _faceExpressionNet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../faceExpressionNet */ "./node_modules/face-api.js/build/es6/faceExpressionNet/index.js");
/* harmony import */ var _factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factories/WithFaceDetection */ "./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js");
/* harmony import */ var _factories_WithFaceExpressions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factories/WithFaceExpressions */ "./node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _DrawTextField__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DrawTextField */ "./node_modules/face-api.js/build/es6/draw/DrawTextField.js");






function drawFaceExpressions(canvasArg, faceExpressions, minConfidence, textFieldAnchor) {
    if (minConfidence === void 0) { minConfidence = 0.1; }
    var faceExpressionsArray = Array.isArray(faceExpressions) ? faceExpressions : [faceExpressions];
    faceExpressionsArray.forEach(function (e) {
        var expr = e instanceof _faceExpressionNet__WEBPACK_IMPORTED_MODULE_1__["FaceExpressions"]
            ? e
            : (Object(_factories_WithFaceExpressions__WEBPACK_IMPORTED_MODULE_3__["isWithFaceExpressions"])(e) ? e.expressions : undefined);
        if (!expr) {
            throw new Error('drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof');
        }
        var sorted = expr.asSortedArray();
        var resultsToDisplay = sorted.filter(function (expr) { return expr.probability > minConfidence; });
        var anchor = Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_2__["isWithFaceDetection"])(e)
            ? e.detection.box.bottomLeft
            : (textFieldAnchor || new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
        var drawTextField = new _DrawTextField__WEBPACK_IMPORTED_MODULE_5__["DrawTextField"](resultsToDisplay.map(function (expr) { return expr.expression + " (" + Object(_utils__WEBPACK_IMPORTED_MODULE_4__["round"])(expr.probability) + ")"; }), anchor);
        drawTextField.draw(canvasArg);
    });
}
//# sourceMappingURL=drawFaceExpressions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/draw/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/draw/index.js ***!
  \**********************************************************/
/*! exports provided: drawContour, drawDetections, drawFaceExpressions, DrawBoxOptions, DrawBox, DrawFaceLandmarksOptions, DrawFaceLandmarks, drawFaceLandmarks, AnchorPosition, DrawTextFieldOptions, DrawTextField */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drawContour__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawContour */ "./node_modules/face-api.js/build/es6/draw/drawContour.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drawContour", function() { return _drawContour__WEBPACK_IMPORTED_MODULE_0__["drawContour"]; });

/* harmony import */ var _drawDetections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawDetections */ "./node_modules/face-api.js/build/es6/draw/drawDetections.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drawDetections", function() { return _drawDetections__WEBPACK_IMPORTED_MODULE_1__["drawDetections"]; });

/* harmony import */ var _drawFaceExpressions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawFaceExpressions */ "./node_modules/face-api.js/build/es6/draw/drawFaceExpressions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drawFaceExpressions", function() { return _drawFaceExpressions__WEBPACK_IMPORTED_MODULE_2__["drawFaceExpressions"]; });

/* harmony import */ var _DrawBox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DrawBox */ "./node_modules/face-api.js/build/es6/draw/DrawBox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawBoxOptions", function() { return _DrawBox__WEBPACK_IMPORTED_MODULE_3__["DrawBoxOptions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawBox", function() { return _DrawBox__WEBPACK_IMPORTED_MODULE_3__["DrawBox"]; });

/* harmony import */ var _DrawFaceLandmarks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DrawFaceLandmarks */ "./node_modules/face-api.js/build/es6/draw/DrawFaceLandmarks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawFaceLandmarksOptions", function() { return _DrawFaceLandmarks__WEBPACK_IMPORTED_MODULE_4__["DrawFaceLandmarksOptions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawFaceLandmarks", function() { return _DrawFaceLandmarks__WEBPACK_IMPORTED_MODULE_4__["DrawFaceLandmarks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drawFaceLandmarks", function() { return _DrawFaceLandmarks__WEBPACK_IMPORTED_MODULE_4__["drawFaceLandmarks"]; });

/* harmony import */ var _DrawTextField__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DrawTextField */ "./node_modules/face-api.js/build/es6/draw/DrawTextField.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnchorPosition", function() { return _DrawTextField__WEBPACK_IMPORTED_MODULE_5__["AnchorPosition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawTextFieldOptions", function() { return _DrawTextField__WEBPACK_IMPORTED_MODULE_5__["DrawTextFieldOptions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawTextField", function() { return _DrawTextField__WEBPACK_IMPORTED_MODULE_5__["DrawTextField"]; });







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/env/createBrowserEnv.js":
/*!********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/env/createBrowserEnv.js ***!
  \********************************************************************/
/*! exports provided: createBrowserEnv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBrowserEnv", function() { return createBrowserEnv; });
function createBrowserEnv() {
    var fetch = window['fetch'] || function () {
        throw new Error('fetch - missing fetch implementation for browser environment');
    };
    var readFile = function () {
        throw new Error('readFile - filesystem not available for browser environment');
    };
    return {
        Canvas: HTMLCanvasElement,
        CanvasRenderingContext2D: CanvasRenderingContext2D,
        Image: HTMLImageElement,
        ImageData: ImageData,
        Video: HTMLVideoElement,
        createCanvasElement: function () { return document.createElement('canvas'); },
        createImageElement: function () { return document.createElement('img'); },
        fetch: fetch,
        readFile: readFile
    };
}
//# sourceMappingURL=createBrowserEnv.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/env/createFileSystem.js":
/*!********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/env/createFileSystem.js ***!
  \********************************************************************/
/*! exports provided: createFileSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFileSystem", function() { return createFileSystem; });
function createFileSystem(fs) {
    var requireFsError = '';
    if (!fs) {
        try {
            fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
        }
        catch (err) {
            requireFsError = err.toString();
        }
    }
    var readFile = fs
        ? function (filePath) {
            return new Promise(function (res, rej) {
                fs.readFile(filePath, function (err, buffer) {
                    return err ? rej(err) : res(buffer);
                });
            });
        }
        : function () {
            throw new Error("readFile - failed to require fs in nodejs environment with error: " + requireFsError);
        };
    return {
        readFile: readFile
    };
}
//# sourceMappingURL=createFileSystem.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/env/createNodejsEnv.js":
/*!*******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/env/createNodejsEnv.js ***!
  \*******************************************************************/
/*! exports provided: createNodejsEnv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNodejsEnv", function() { return createNodejsEnv; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _createFileSystem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createFileSystem */ "./node_modules/face-api.js/build/es6/env/createFileSystem.js");


function createNodejsEnv() {
    var Canvas = global['Canvas'] || global['HTMLCanvasElement'];
    var Image = global['Image'] || global['HTMLImageElement'];
    var createCanvasElement = function () {
        if (Canvas) {
            return new Canvas();
        }
        throw new Error('createCanvasElement - missing Canvas implementation for nodejs environment');
    };
    var createImageElement = function () {
        if (Image) {
            return new Image();
        }
        throw new Error('createImageElement - missing Image implementation for nodejs environment');
    };
    var fetch = global['fetch'] || function () {
        throw new Error('fetch - missing fetch implementation for nodejs environment');
    };
    var fileSystem = Object(_createFileSystem__WEBPACK_IMPORTED_MODULE_1__["createFileSystem"])();
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({ Canvas: Canvas || /** @class */ (function () {
            function Canvas() {
            }
            return Canvas;
        }()), CanvasRenderingContext2D: global['CanvasRenderingContext2D'] || /** @class */ (function () {
            function class_1() {
            }
            return class_1;
        }()), Image: Image || /** @class */ (function () {
            function Image() {
            }
            return Image;
        }()), ImageData: global['ImageData'] || /** @class */ (function () {
            function class_2() {
            }
            return class_2;
        }()), Video: global['HTMLVideoElement'] || /** @class */ (function () {
            function class_3() {
            }
            return class_3;
        }()), createCanvasElement: createCanvasElement,
        createImageElement: createImageElement,
        fetch: fetch }, fileSystem);
}
//# sourceMappingURL=createNodejsEnv.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../next/dist/compiled/webpack/global.js */ "./node_modules/next/dist/compiled/webpack/global.js")))

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/env/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/env/index.js ***!
  \*********************************************************/
/*! exports provided: env */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "env", function() { return env; });
/* harmony import */ var _createBrowserEnv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createBrowserEnv */ "./node_modules/face-api.js/build/es6/env/createBrowserEnv.js");
/* harmony import */ var _createFileSystem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createFileSystem */ "./node_modules/face-api.js/build/es6/env/createFileSystem.js");
/* harmony import */ var _createNodejsEnv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createNodejsEnv */ "./node_modules/face-api.js/build/es6/env/createNodejsEnv.js");
/* harmony import */ var _isBrowser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isBrowser */ "./node_modules/face-api.js/build/es6/env/isBrowser.js");
/* harmony import */ var _isNodejs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isNodejs */ "./node_modules/face-api.js/build/es6/env/isNodejs.js");





var environment;
function getEnv() {
    if (!environment) {
        throw new Error('getEnv - environment is not defined, check isNodejs() and isBrowser()');
    }
    return environment;
}
function setEnv(env) {
    environment = env;
}
function initialize() {
    // check for isBrowser() first to prevent electron renderer process
    // to be initialized with wrong environment due to isNodejs() returning true
    if (Object(_isBrowser__WEBPACK_IMPORTED_MODULE_3__["isBrowser"])()) {
        setEnv(Object(_createBrowserEnv__WEBPACK_IMPORTED_MODULE_0__["createBrowserEnv"])());
    }
    if (Object(_isNodejs__WEBPACK_IMPORTED_MODULE_4__["isNodejs"])()) {
        setEnv(Object(_createNodejsEnv__WEBPACK_IMPORTED_MODULE_2__["createNodejsEnv"])());
    }
}
function monkeyPatch(env) {
    if (!environment) {
        initialize();
    }
    if (!environment) {
        throw new Error('monkeyPatch - environment is not defined, check isNodejs() and isBrowser()');
    }
    var _a = env.Canvas, Canvas = _a === void 0 ? environment.Canvas : _a, _b = env.Image, Image = _b === void 0 ? environment.Image : _b;
    environment.Canvas = Canvas;
    environment.Image = Image;
    environment.createCanvasElement = env.createCanvasElement || (function () { return new Canvas(); });
    environment.createImageElement = env.createImageElement || (function () { return new Image(); });
    environment.ImageData = env.ImageData || environment.ImageData;
    environment.Video = env.Video || environment.Video;
    environment.fetch = env.fetch || environment.fetch;
    environment.readFile = env.readFile || environment.readFile;
}
var env = {
    getEnv: getEnv,
    setEnv: setEnv,
    initialize: initialize,
    createBrowserEnv: _createBrowserEnv__WEBPACK_IMPORTED_MODULE_0__["createBrowserEnv"],
    createFileSystem: _createFileSystem__WEBPACK_IMPORTED_MODULE_1__["createFileSystem"],
    createNodejsEnv: _createNodejsEnv__WEBPACK_IMPORTED_MODULE_2__["createNodejsEnv"],
    monkeyPatch: monkeyPatch,
    isBrowser: _isBrowser__WEBPACK_IMPORTED_MODULE_3__["isBrowser"],
    isNodejs: _isNodejs__WEBPACK_IMPORTED_MODULE_4__["isNodejs"]
};
initialize();
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/env/isBrowser.js":
/*!*************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/env/isBrowser.js ***!
  \*************************************************************/
/*! exports provided: isBrowser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
function isBrowser() {
    return typeof window === 'object'
        && typeof document !== 'undefined'
        && typeof HTMLImageElement !== 'undefined'
        && typeof HTMLCanvasElement !== 'undefined'
        && typeof HTMLVideoElement !== 'undefined'
        && typeof ImageData !== 'undefined'
        && typeof CanvasRenderingContext2D !== 'undefined';
}
//# sourceMappingURL=isBrowser.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/env/isNodejs.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/env/isNodejs.js ***!
  \************************************************************/
/*! exports provided: isNodejs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNodejs", function() { return isNodejs; });
function isNodejs() {
    return typeof global === 'object'
        && "function" === 'function'
        && typeof module !== 'undefined'
        // issues with gatsby.js: module.exports is undefined
        // && !!module.exports
        && typeof process !== 'undefined' && !!process.version;
}
//# sourceMappingURL=isNodejs.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../next/dist/compiled/webpack/global.js */ "./node_modules/next/dist/compiled/webpack/global.js"), __webpack_require__(/*! ./../../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/euclideanDistance.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/euclideanDistance.js ***!
  \*****************************************************************/
/*! exports provided: euclideanDistance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "euclideanDistance", function() { return euclideanDistance; });
function euclideanDistance(arr1, arr2) {
    if (arr1.length !== arr2.length)
        throw new Error('euclideanDistance: arr1.length !== arr2.length');
    var desc1 = Array.from(arr1);
    var desc2 = Array.from(arr2);
    return Math.sqrt(desc1
        .map(function (val, i) { return val - desc2[i]; })
        .reduce(function (res, diff) { return res + Math.pow(diff, 2); }, 0));
}
//# sourceMappingURL=euclideanDistance.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressionNet.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressionNet.js ***!
  \***********************************************************************************/
/*! exports provided: FaceExpressionNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceExpressionNet", function() { return FaceExpressionNet; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _faceFeatureExtractor_FaceFeatureExtractor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../faceFeatureExtractor/FaceFeatureExtractor */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/FaceFeatureExtractor.js");
/* harmony import */ var _faceProcessor_FaceProcessor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../faceProcessor/FaceProcessor */ "./node_modules/face-api.js/build/es6/faceProcessor/FaceProcessor.js");
/* harmony import */ var _FaceExpressions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./FaceExpressions */ "./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js");






var FaceExpressionNet = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceExpressionNet, _super);
    function FaceExpressionNet(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) { faceFeatureExtractor = new _faceFeatureExtractor_FaceFeatureExtractor__WEBPACK_IMPORTED_MODULE_3__["FaceFeatureExtractor"](); }
        return _super.call(this, 'FaceExpressionNet', faceFeatureExtractor) || this;
    }
    FaceExpressionNet.prototype.forwardInput = function (input) {
        var _this = this;
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["softmax"](_this.runNet(input)); });
    };
    FaceExpressionNet.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    FaceExpressionNet.prototype.predictExpressions = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var netInput, out, probabilitesByBatch, predictionsByBatch;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["toNetInput"])(input)];
                    case 1:
                        netInput = _a.sent();
                        return [4 /*yield*/, this.forwardInput(netInput)];
                    case 2:
                        out = _a.sent();
                        return [4 /*yield*/, Promise.all(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["unstack"](out).map(function (t) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
                                var data;
                                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, t.data()];
                                        case 1:
                                            data = _a.sent();
                                            t.dispose();
                                            return [2 /*return*/, data];
                                    }
                                });
                            }); }))];
                    case 3:
                        probabilitesByBatch = _a.sent();
                        out.dispose();
                        predictionsByBatch = probabilitesByBatch
                            .map(function (probabilites) { return new _FaceExpressions__WEBPACK_IMPORTED_MODULE_5__["FaceExpressions"](probabilites); });
                        return [2 /*return*/, netInput.isBatchInput
                                ? predictionsByBatch
                                : predictionsByBatch[0]];
                }
            });
        });
    };
    FaceExpressionNet.prototype.getDefaultModelName = function () {
        return 'face_expression_model';
    };
    FaceExpressionNet.prototype.getClassifierChannelsIn = function () {
        return 256;
    };
    FaceExpressionNet.prototype.getClassifierChannelsOut = function () {
        return 7;
    };
    return FaceExpressionNet;
}(_faceProcessor_FaceProcessor__WEBPACK_IMPORTED_MODULE_4__["FaceProcessor"]));

//# sourceMappingURL=FaceExpressionNet.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js ***!
  \*********************************************************************************/
/*! exports provided: FACE_EXPRESSION_LABELS, FaceExpressions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FACE_EXPRESSION_LABELS", function() { return FACE_EXPRESSION_LABELS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceExpressions", function() { return FaceExpressions; });
var FACE_EXPRESSION_LABELS = ['neutral', 'happy', 'sad', 'angry', 'fearful', 'disgusted', 'surprised'];
var FaceExpressions = /** @class */ (function () {
    function FaceExpressions(probabilities) {
        var _this = this;
        if (probabilities.length !== 7) {
            throw new Error("FaceExpressions.constructor - expected probabilities.length to be 7, have: " + probabilities.length);
        }
        FACE_EXPRESSION_LABELS.forEach(function (expression, idx) {
            _this[expression] = probabilities[idx];
        });
    }
    FaceExpressions.prototype.asSortedArray = function () {
        var _this = this;
        return FACE_EXPRESSION_LABELS
            .map(function (expression) { return ({ expression: expression, probability: _this[expression] }); })
            .sort(function (e0, e1) { return e1.probability - e0.probability; });
    };
    return FaceExpressions;
}());

//# sourceMappingURL=FaceExpressions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceExpressionNet/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceExpressionNet/index.js ***!
  \***********************************************************************/
/*! exports provided: FaceExpressionNet, FACE_EXPRESSION_LABELS, FaceExpressions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _FaceExpressionNet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FaceExpressionNet */ "./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressionNet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceExpressionNet", function() { return _FaceExpressionNet__WEBPACK_IMPORTED_MODULE_0__["FaceExpressionNet"]; });

/* harmony import */ var _FaceExpressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FaceExpressions */ "./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FACE_EXPRESSION_LABELS", function() { return _FaceExpressions__WEBPACK_IMPORTED_MODULE_1__["FACE_EXPRESSION_LABELS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceExpressions", function() { return _FaceExpressions__WEBPACK_IMPORTED_MODULE_1__["FaceExpressions"]; });



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/FaceFeatureExtractor.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/FaceFeatureExtractor.js ***!
  \*****************************************************************************************/
/*! exports provided: FaceFeatureExtractor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceFeatureExtractor", function() { return FaceFeatureExtractor; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _denseBlock__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./denseBlock */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/denseBlock.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMap.js");








var FaceFeatureExtractor = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceFeatureExtractor, _super);
    function FaceFeatureExtractor() {
        return _super.call(this, 'FaceFeatureExtractor') || this;
    }
    FaceFeatureExtractor.prototype.forwardInput = function (input) {
        var params = this.params;
        if (!params) {
            throw new Error('FaceFeatureExtractor - load model before inference');
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var batchTensor = input.toBatchTensor(112, true);
            var meanRgb = [122.782, 117.001, 104.298];
            var normalized = Object(_ops__WEBPACK_IMPORTED_MODULE_4__["normalize"])(batchTensor, meanRgb).div(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](255));
            var out = Object(_denseBlock__WEBPACK_IMPORTED_MODULE_5__["denseBlock4"])(normalized, params.dense0, true);
            out = Object(_denseBlock__WEBPACK_IMPORTED_MODULE_5__["denseBlock4"])(out, params.dense1);
            out = Object(_denseBlock__WEBPACK_IMPORTED_MODULE_5__["denseBlock4"])(out, params.dense2);
            out = Object(_denseBlock__WEBPACK_IMPORTED_MODULE_5__["denseBlock4"])(out, params.dense3);
            out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["avgPool"](out, [7, 7], [2, 2], 'valid');
            return out;
        });
    };
    FaceFeatureExtractor.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    FaceFeatureExtractor.prototype.getDefaultModelName = function () {
        return 'face_feature_extractor_model';
    };
    FaceFeatureExtractor.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_7__["extractParamsFromWeigthMap"])(weightMap);
    };
    FaceFeatureExtractor.prototype.extractParams = function (weights) {
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_6__["extractParams"])(weights);
    };
    return FaceFeatureExtractor;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_3__["NeuralNetwork"]));

//# sourceMappingURL=FaceFeatureExtractor.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/TinyFaceFeatureExtractor.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/TinyFaceFeatureExtractor.js ***!
  \*********************************************************************************************/
/*! exports provided: TinyFaceFeatureExtractor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyFaceFeatureExtractor", function() { return TinyFaceFeatureExtractor; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _denseBlock__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./denseBlock */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/denseBlock.js");
/* harmony import */ var _extractParamsFromWeigthMapTiny__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractParamsFromWeigthMapTiny */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMapTiny.js");
/* harmony import */ var _extractParamsTiny__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extractParamsTiny */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsTiny.js");








var TinyFaceFeatureExtractor = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(TinyFaceFeatureExtractor, _super);
    function TinyFaceFeatureExtractor() {
        return _super.call(this, 'TinyFaceFeatureExtractor') || this;
    }
    TinyFaceFeatureExtractor.prototype.forwardInput = function (input) {
        var params = this.params;
        if (!params) {
            throw new Error('TinyFaceFeatureExtractor - load model before inference');
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var batchTensor = input.toBatchTensor(112, true);
            var meanRgb = [122.782, 117.001, 104.298];
            var normalized = Object(_ops__WEBPACK_IMPORTED_MODULE_4__["normalize"])(batchTensor, meanRgb).div(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](255));
            var out = Object(_denseBlock__WEBPACK_IMPORTED_MODULE_5__["denseBlock3"])(normalized, params.dense0, true);
            out = Object(_denseBlock__WEBPACK_IMPORTED_MODULE_5__["denseBlock3"])(out, params.dense1);
            out = Object(_denseBlock__WEBPACK_IMPORTED_MODULE_5__["denseBlock3"])(out, params.dense2);
            out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["avgPool"](out, [14, 14], [2, 2], 'valid');
            return out;
        });
    };
    TinyFaceFeatureExtractor.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    TinyFaceFeatureExtractor.prototype.getDefaultModelName = function () {
        return 'face_feature_extractor_tiny_model';
    };
    TinyFaceFeatureExtractor.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return Object(_extractParamsFromWeigthMapTiny__WEBPACK_IMPORTED_MODULE_6__["extractParamsFromWeigthMapTiny"])(weightMap);
    };
    TinyFaceFeatureExtractor.prototype.extractParams = function (weights) {
        return Object(_extractParamsTiny__WEBPACK_IMPORTED_MODULE_7__["extractParamsTiny"])(weights);
    };
    return TinyFaceFeatureExtractor;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_3__["NeuralNetwork"]));

//# sourceMappingURL=TinyFaceFeatureExtractor.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/denseBlock.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/denseBlock.js ***!
  \*******************************************************************************/
/*! exports provided: denseBlock3, denseBlock4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "denseBlock3", function() { return denseBlock3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "denseBlock4", function() { return denseBlock4; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/depthwiseSeparableConv */ "./node_modules/face-api.js/build/es6/common/depthwiseSeparableConv.js");


function denseBlock3(x, denseBlockParams, isFirstLayer) {
    if (isFirstLayer === void 0) { isFirstLayer = false; }
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out1 = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](isFirstLayer
            ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"](x, denseBlockParams.conv0.filters, [2, 2], 'same'), denseBlockParams.conv0.bias)
            : Object(_common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"])(x, denseBlockParams.conv0, [2, 2]));
        var out2 = Object(_common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"])(out1, denseBlockParams.conv1, [1, 1]);
        var in3 = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out1, out2));
        var out3 = Object(_common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"])(in3, denseBlockParams.conv2, [1, 1]);
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out1, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out2, out3)));
    });
}
function denseBlock4(x, denseBlockParams, isFirstLayer, isScaleDown) {
    if (isFirstLayer === void 0) { isFirstLayer = false; }
    if (isScaleDown === void 0) { isScaleDown = true; }
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out1 = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](isFirstLayer
            ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"](x, denseBlockParams.conv0.filters, isScaleDown ? [2, 2] : [1, 1], 'same'), denseBlockParams.conv0.bias)
            : Object(_common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"])(x, denseBlockParams.conv0, isScaleDown ? [2, 2] : [1, 1]));
        var out2 = Object(_common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"])(out1, denseBlockParams.conv1, [1, 1]);
        var in3 = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out1, out2));
        var out3 = Object(_common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"])(in3, denseBlockParams.conv2, [1, 1]);
        var in4 = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out1, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out2, out3)));
        var out4 = Object(_common_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_1__["depthwiseSeparableConv"])(in4, denseBlockParams.conv3, [1, 1]);
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out1, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out2, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out3, out4))));
    });
}
//# sourceMappingURL=denseBlock.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParams.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParams.js ***!
  \**********************************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _extractorsFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extractorsFactory */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractorsFactory.js");


function extractParams(weights) {
    var paramMappings = [];
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var extractDenseBlock4Params = Object(_extractorsFactory__WEBPACK_IMPORTED_MODULE_1__["extractorsFactory"])(extractWeights, paramMappings).extractDenseBlock4Params;
    var dense0 = extractDenseBlock4Params(3, 32, 'dense0', true);
    var dense1 = extractDenseBlock4Params(32, 64, 'dense1');
    var dense2 = extractDenseBlock4Params(64, 128, 'dense2');
    var dense3 = extractDenseBlock4Params(128, 256, 'dense3');
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return {
        paramMappings: paramMappings,
        params: { dense0: dense0, dense1: dense1, dense2: dense2, dense3: dense3 }
    };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMap.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMap.js ***!
  \***********************************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _loadParamsFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadParamsFactory */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/loadParamsFactory.js");


function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var extractDenseBlock4Params = Object(_loadParamsFactory__WEBPACK_IMPORTED_MODULE_1__["loadParamsFactory"])(weightMap, paramMappings).extractDenseBlock4Params;
    var params = {
        dense0: extractDenseBlock4Params('dense0', true),
        dense1: extractDenseBlock4Params('dense1'),
        dense2: extractDenseBlock4Params('dense2'),
        dense3: extractDenseBlock4Params('dense3')
    };
    Object(_common__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMapTiny.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMapTiny.js ***!
  \***************************************************************************************************/
/*! exports provided: extractParamsFromWeigthMapTiny */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMapTiny", function() { return extractParamsFromWeigthMapTiny; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _loadParamsFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadParamsFactory */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/loadParamsFactory.js");


function extractParamsFromWeigthMapTiny(weightMap) {
    var paramMappings = [];
    var extractDenseBlock3Params = Object(_loadParamsFactory__WEBPACK_IMPORTED_MODULE_1__["loadParamsFactory"])(weightMap, paramMappings).extractDenseBlock3Params;
    var params = {
        dense0: extractDenseBlock3Params('dense0', true),
        dense1: extractDenseBlock3Params('dense1'),
        dense2: extractDenseBlock3Params('dense2')
    };
    Object(_common__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMapTiny.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsTiny.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsTiny.js ***!
  \**************************************************************************************/
/*! exports provided: extractParamsTiny */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsTiny", function() { return extractParamsTiny; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _extractorsFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extractorsFactory */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractorsFactory.js");


function extractParamsTiny(weights) {
    var paramMappings = [];
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var extractDenseBlock3Params = Object(_extractorsFactory__WEBPACK_IMPORTED_MODULE_1__["extractorsFactory"])(extractWeights, paramMappings).extractDenseBlock3Params;
    var dense0 = extractDenseBlock3Params(3, 32, 'dense0', true);
    var dense1 = extractDenseBlock3Params(32, 64, 'dense1');
    var dense2 = extractDenseBlock3Params(64, 128, 'dense2');
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return {
        paramMappings: paramMappings,
        params: { dense0: dense0, dense1: dense1, dense2: dense2 }
    };
}
//# sourceMappingURL=extractParamsTiny.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractorsFactory.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/extractorsFactory.js ***!
  \**************************************************************************************/
/*! exports provided: extractorsFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractorsFactory", function() { return extractorsFactory; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");

function extractorsFactory(extractWeights, paramMappings) {
    var extractConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractConvParamsFactory"])(extractWeights, paramMappings);
    var extractSeparableConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractSeparableConvParamsFactory"])(extractWeights, paramMappings);
    function extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer) {
        if (isFirstLayer === void 0) { isFirstLayer = false; }
        var conv0 = isFirstLayer
            ? extractConvParams(channelsIn, channelsOut, 3, mappedPrefix + "/conv0")
            : extractSeparableConvParams(channelsIn, channelsOut, mappedPrefix + "/conv0");
        var conv1 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv1");
        var conv2 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv2");
        return { conv0: conv0, conv1: conv1, conv2: conv2 };
    }
    function extractDenseBlock4Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer) {
        if (isFirstLayer === void 0) { isFirstLayer = false; }
        var _a = extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer), conv0 = _a.conv0, conv1 = _a.conv1, conv2 = _a.conv2;
        var conv3 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv3");
        return { conv0: conv0, conv1: conv1, conv2: conv2, conv3: conv3 };
    }
    return {
        extractDenseBlock3Params: extractDenseBlock3Params,
        extractDenseBlock4Params: extractDenseBlock4Params
    };
}
//# sourceMappingURL=extractorsFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/loadParamsFactory.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceFeatureExtractor/loadParamsFactory.js ***!
  \**************************************************************************************/
/*! exports provided: loadParamsFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadParamsFactory", function() { return loadParamsFactory; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _common_loadConvParamsFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/loadConvParamsFactory */ "./node_modules/face-api.js/build/es6/common/loadConvParamsFactory.js");


function loadParamsFactory(weightMap, paramMappings) {
    var extractWeightEntry = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightEntryFactory"])(weightMap, paramMappings);
    var extractConvParams = Object(_common_loadConvParamsFactory__WEBPACK_IMPORTED_MODULE_1__["loadConvParamsFactory"])(extractWeightEntry);
    var extractSeparableConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["loadSeparableConvParamsFactory"])(extractWeightEntry);
    function extractDenseBlock3Params(prefix, isFirstLayer) {
        if (isFirstLayer === void 0) { isFirstLayer = false; }
        var conv0 = isFirstLayer
            ? extractConvParams(prefix + "/conv0")
            : extractSeparableConvParams(prefix + "/conv0");
        var conv1 = extractSeparableConvParams(prefix + "/conv1");
        var conv2 = extractSeparableConvParams(prefix + "/conv2");
        return { conv0: conv0, conv1: conv1, conv2: conv2 };
    }
    function extractDenseBlock4Params(prefix, isFirstLayer) {
        if (isFirstLayer === void 0) { isFirstLayer = false; }
        var conv0 = isFirstLayer
            ? extractConvParams(prefix + "/conv0")
            : extractSeparableConvParams(prefix + "/conv0");
        var conv1 = extractSeparableConvParams(prefix + "/conv1");
        var conv2 = extractSeparableConvParams(prefix + "/conv2");
        var conv3 = extractSeparableConvParams(prefix + "/conv3");
        return { conv0: conv0, conv1: conv1, conv2: conv2, conv3: conv3 };
    }
    return {
        extractDenseBlock3Params: extractDenseBlock3Params,
        extractDenseBlock4Params: extractDenseBlock4Params
    };
}
//# sourceMappingURL=loadParamsFactory.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68Net.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68Net.js ***!
  \*********************************************************************************/
/*! exports provided: FaceLandmark68Net */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceLandmark68Net", function() { return FaceLandmark68Net; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _faceFeatureExtractor_FaceFeatureExtractor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../faceFeatureExtractor/FaceFeatureExtractor */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/FaceFeatureExtractor.js");
/* harmony import */ var _FaceLandmark68NetBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FaceLandmark68NetBase */ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68NetBase.js");



var FaceLandmark68Net = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceLandmark68Net, _super);
    function FaceLandmark68Net(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) { faceFeatureExtractor = new _faceFeatureExtractor_FaceFeatureExtractor__WEBPACK_IMPORTED_MODULE_1__["FaceFeatureExtractor"](); }
        return _super.call(this, 'FaceLandmark68Net', faceFeatureExtractor) || this;
    }
    FaceLandmark68Net.prototype.getDefaultModelName = function () {
        return 'face_landmark_68_model';
    };
    FaceLandmark68Net.prototype.getClassifierChannelsIn = function () {
        return 256;
    };
    return FaceLandmark68Net;
}(_FaceLandmark68NetBase__WEBPACK_IMPORTED_MODULE_2__["FaceLandmark68NetBase"]));

//# sourceMappingURL=FaceLandmark68Net.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68NetBase.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68NetBase.js ***!
  \*************************************************************************************/
/*! exports provided: FaceLandmark68NetBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceLandmark68NetBase", function() { return FaceLandmark68NetBase; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _classes_FaceLandmarks68__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../classes/FaceLandmarks68 */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _faceProcessor_FaceProcessor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../faceProcessor/FaceProcessor */ "./node_modules/face-api.js/build/es6/faceProcessor/FaceProcessor.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");







var FaceLandmark68NetBase = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceLandmark68NetBase, _super);
    function FaceLandmark68NetBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FaceLandmark68NetBase.prototype.postProcess = function (output, inputSize, originalDimensions) {
        var inputDimensions = originalDimensions.map(function (_a) {
            var width = _a.width, height = _a.height;
            var scale = inputSize / Math.max(height, width);
            return {
                width: width * scale,
                height: height * scale
            };
        });
        var batchSize = inputDimensions.length;
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var createInterleavedTensor = function (fillX, fillY) {
                return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["stack"]([
                    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["fill"]([68], fillX),
                    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["fill"]([68], fillY)
                ], 1).as2D(1, 136).as1D();
            };
            var getPadding = function (batchIdx, cond) {
                var _a = inputDimensions[batchIdx], width = _a.width, height = _a.height;
                return cond(width, height) ? Math.abs(width - height) / 2 : 0;
            };
            var getPaddingX = function (batchIdx) { return getPadding(batchIdx, function (w, h) { return w < h; }); };
            var getPaddingY = function (batchIdx) { return getPadding(batchIdx, function (w, h) { return h < w; }); };
            var landmarkTensors = output
                .mul(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["fill"]([batchSize, 136], inputSize))
                .sub(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["stack"](Array.from(Array(batchSize), function (_, batchIdx) {
                return createInterleavedTensor(getPaddingX(batchIdx), getPaddingY(batchIdx));
            })))
                .div(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["stack"](Array.from(Array(batchSize), function (_, batchIdx) {
                return createInterleavedTensor(inputDimensions[batchIdx].width, inputDimensions[batchIdx].height);
            })));
            return landmarkTensors;
        });
    };
    FaceLandmark68NetBase.prototype.forwardInput = function (input) {
        var _this = this;
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var out = _this.runNet(input);
            return _this.postProcess(out, input.inputSize, input.inputDimensions.map(function (_a) {
                var height = _a[0], width = _a[1];
                return ({ height: height, width: width });
            }));
        });
    };
    FaceLandmark68NetBase.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_4__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    FaceLandmark68NetBase.prototype.detectLandmarks = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var netInput, landmarkTensors, landmarksForBatch;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_4__["toNetInput"])(input)];
                    case 1:
                        netInput = _a.sent();
                        landmarkTensors = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["unstack"](_this.forwardInput(netInput)); });
                        return [4 /*yield*/, Promise.all(landmarkTensors.map(function (landmarkTensor, batchIdx) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
                                var landmarksArray, _a, _b, xCoords, yCoords;
                                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            _b = (_a = Array).from;
                                            return [4 /*yield*/, landmarkTensor.data()];
                                        case 1:
                                            landmarksArray = _b.apply(_a, [_c.sent()]);
                                            xCoords = landmarksArray.filter(function (_, i) { return Object(_utils__WEBPACK_IMPORTED_MODULE_6__["isEven"])(i); });
                                            yCoords = landmarksArray.filter(function (_, i) { return !Object(_utils__WEBPACK_IMPORTED_MODULE_6__["isEven"])(i); });
                                            return [2 /*return*/, new _classes_FaceLandmarks68__WEBPACK_IMPORTED_MODULE_3__["FaceLandmarks68"](Array(68).fill(0).map(function (_, i) { return new _classes__WEBPACK_IMPORTED_MODULE_2__["Point"](xCoords[i], yCoords[i]); }), {
                                                    height: netInput.getInputHeight(batchIdx),
                                                    width: netInput.getInputWidth(batchIdx),
                                                })];
                                    }
                                });
                            }); }))];
                    case 2:
                        landmarksForBatch = _a.sent();
                        landmarkTensors.forEach(function (t) { return t.dispose(); });
                        return [2 /*return*/, netInput.isBatchInput
                                ? landmarksForBatch
                                : landmarksForBatch[0]];
                }
            });
        });
    };
    FaceLandmark68NetBase.prototype.getClassifierChannelsOut = function () {
        return 136;
    };
    return FaceLandmark68NetBase;
}(_faceProcessor_FaceProcessor__WEBPACK_IMPORTED_MODULE_5__["FaceProcessor"]));

//# sourceMappingURL=FaceLandmark68NetBase.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68TinyNet.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68TinyNet.js ***!
  \*************************************************************************************/
/*! exports provided: FaceLandmark68TinyNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceLandmark68TinyNet", function() { return FaceLandmark68TinyNet; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _faceFeatureExtractor_TinyFaceFeatureExtractor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../faceFeatureExtractor/TinyFaceFeatureExtractor */ "./node_modules/face-api.js/build/es6/faceFeatureExtractor/TinyFaceFeatureExtractor.js");
/* harmony import */ var _FaceLandmark68NetBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FaceLandmark68NetBase */ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68NetBase.js");



var FaceLandmark68TinyNet = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceLandmark68TinyNet, _super);
    function FaceLandmark68TinyNet(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) { faceFeatureExtractor = new _faceFeatureExtractor_TinyFaceFeatureExtractor__WEBPACK_IMPORTED_MODULE_1__["TinyFaceFeatureExtractor"](); }
        return _super.call(this, 'FaceLandmark68TinyNet', faceFeatureExtractor) || this;
    }
    FaceLandmark68TinyNet.prototype.getDefaultModelName = function () {
        return 'face_landmark_68_tiny_model';
    };
    FaceLandmark68TinyNet.prototype.getClassifierChannelsIn = function () {
        return 128;
    };
    return FaceLandmark68TinyNet;
}(_FaceLandmark68NetBase__WEBPACK_IMPORTED_MODULE_2__["FaceLandmark68NetBase"]));

//# sourceMappingURL=FaceLandmark68TinyNet.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceLandmarkNet/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceLandmarkNet/index.js ***!
  \*********************************************************************/
/*! exports provided: FaceLandmark68Net, FaceLandmark68TinyNet, FaceLandmarkNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarkNet", function() { return FaceLandmarkNet; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _FaceLandmark68Net__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FaceLandmark68Net */ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68Net.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmark68Net", function() { return _FaceLandmark68Net__WEBPACK_IMPORTED_MODULE_1__["FaceLandmark68Net"]; });

/* harmony import */ var _FaceLandmark68TinyNet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FaceLandmark68TinyNet */ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68TinyNet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmark68TinyNet", function() { return _FaceLandmark68TinyNet__WEBPACK_IMPORTED_MODULE_2__["FaceLandmark68TinyNet"]; });





var FaceLandmarkNet = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceLandmarkNet, _super);
    function FaceLandmarkNet() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return FaceLandmarkNet;
}(_FaceLandmark68Net__WEBPACK_IMPORTED_MODULE_1__["FaceLandmark68Net"]));

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceProcessor/FaceProcessor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceProcessor/FaceProcessor.js ***!
  \***************************************************************************/
/*! exports provided: FaceProcessor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceProcessor", function() { return FaceProcessor; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/fullyConnectedLayer */ "./node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/faceProcessor/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/faceProcessor/extractParamsFromWeigthMap.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util */ "./node_modules/face-api.js/build/es6/faceProcessor/util.js");








var FaceProcessor = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceProcessor, _super);
    function FaceProcessor(_name, faceFeatureExtractor) {
        var _this = _super.call(this, _name) || this;
        _this._faceFeatureExtractor = faceFeatureExtractor;
        return _this;
    }
    Object.defineProperty(FaceProcessor.prototype, "faceFeatureExtractor", {
        get: function () {
            return this._faceFeatureExtractor;
        },
        enumerable: true,
        configurable: true
    });
    FaceProcessor.prototype.runNet = function (input) {
        var _this = this;
        var params = this.params;
        if (!params) {
            throw new Error(this._name + " - load model before inference");
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var bottleneckFeatures = input instanceof _dom__WEBPACK_IMPORTED_MODULE_3__["NetInput"]
                ? _this.faceFeatureExtractor.forwardInput(input)
                : input;
            return Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__["fullyConnectedLayer"])(bottleneckFeatures.as2D(bottleneckFeatures.shape[0], -1), params.fc);
        });
    };
    FaceProcessor.prototype.dispose = function (throwOnRedispose) {
        if (throwOnRedispose === void 0) { throwOnRedispose = true; }
        this.faceFeatureExtractor.dispose(throwOnRedispose);
        _super.prototype.dispose.call(this, throwOnRedispose);
    };
    FaceProcessor.prototype.loadClassifierParams = function (weights) {
        var _a = this.extractClassifierParams(weights), params = _a.params, paramMappings = _a.paramMappings;
        this._params = params;
        this._paramMappings = paramMappings;
    };
    FaceProcessor.prototype.extractClassifierParams = function (weights) {
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_5__["extractParams"])(weights, this.getClassifierChannelsIn(), this.getClassifierChannelsOut());
    };
    FaceProcessor.prototype.extractParamsFromWeigthMap = function (weightMap) {
        var _a = Object(_util__WEBPACK_IMPORTED_MODULE_7__["seperateWeightMaps"])(weightMap), featureExtractorMap = _a.featureExtractorMap, classifierMap = _a.classifierMap;
        this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_6__["extractParamsFromWeigthMap"])(classifierMap);
    };
    FaceProcessor.prototype.extractParams = function (weights) {
        var cIn = this.getClassifierChannelsIn();
        var cOut = this.getClassifierChannelsOut();
        var classifierWeightSize = (cOut * cIn) + cOut;
        var featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);
        var classifierWeights = weights.slice(weights.length - classifierWeightSize);
        this.faceFeatureExtractor.extractWeights(featureExtractorWeights);
        return this.extractClassifierParams(classifierWeights);
    };
    return FaceProcessor;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_4__["NeuralNetwork"]));

//# sourceMappingURL=FaceProcessor.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceProcessor/extractParams.js":
/*!***************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceProcessor/extractParams.js ***!
  \***************************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");

function extractParams(weights, channelsIn, channelsOut) {
    var paramMappings = [];
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var extractFCParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractFCParamsFactory"])(extractWeights, paramMappings);
    var fc = extractFCParams(channelsIn, channelsOut, 'fc');
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return {
        paramMappings: paramMappings,
        params: { fc: fc }
    };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceProcessor/extractParamsFromWeigthMap.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceProcessor/extractParamsFromWeigthMap.js ***!
  \****************************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");

function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var extractWeightEntry = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightEntryFactory"])(weightMap, paramMappings);
    function extractFcParams(prefix) {
        var weights = extractWeightEntry(prefix + "/weights", 2);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return { weights: weights, bias: bias };
    }
    var params = {
        fc: extractFcParams('fc')
    };
    Object(_common__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceProcessor/util.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceProcessor/util.js ***!
  \******************************************************************/
/*! exports provided: seperateWeightMaps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "seperateWeightMaps", function() { return seperateWeightMaps; });
function seperateWeightMaps(weightMap) {
    var featureExtractorMap = {};
    var classifierMap = {};
    Object.keys(weightMap).forEach(function (key) {
        var map = key.startsWith('fc') ? classifierMap : featureExtractorMap;
        map[key] = weightMap[key];
    });
    return { featureExtractorMap: featureExtractorMap, classifierMap: classifierMap };
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceRecognitionNet/FaceRecognitionNet.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceRecognitionNet/FaceRecognitionNet.js ***!
  \*************************************************************************************/
/*! exports provided: FaceRecognitionNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceRecognitionNet", function() { return FaceRecognitionNet; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _convLayer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./convLayer */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/convLayer.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/extractParamsFromWeigthMap.js");
/* harmony import */ var _residualLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./residualLayer */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/residualLayer.js");









var FaceRecognitionNet = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceRecognitionNet, _super);
    function FaceRecognitionNet() {
        return _super.call(this, 'FaceRecognitionNet') || this;
    }
    FaceRecognitionNet.prototype.forwardInput = function (input) {
        var params = this.params;
        if (!params) {
            throw new Error('FaceRecognitionNet - load model before inference');
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var batchTensor = input.toBatchTensor(150, true).toFloat();
            var meanRgb = [122.782, 117.001, 104.298];
            var normalized = Object(_ops__WEBPACK_IMPORTED_MODULE_4__["normalize"])(batchTensor, meanRgb).div(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](256));
            var out = Object(_convLayer__WEBPACK_IMPORTED_MODULE_5__["convDown"])(normalized, params.conv32_down);
            out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, 3, 2, 'valid');
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv32_1);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv32_2);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv32_3);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residualDown"])(out, params.conv64_down);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv64_1);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv64_2);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv64_3);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residualDown"])(out, params.conv128_down);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv128_1);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv128_2);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residualDown"])(out, params.conv256_down);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv256_1);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residual"])(out, params.conv256_2);
            out = Object(_residualLayer__WEBPACK_IMPORTED_MODULE_8__["residualDown"])(out, params.conv256_down_out);
            var globalAvg = out.mean([1, 2]);
            var fullyConnected = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["matMul"](globalAvg, params.fc);
            return fullyConnected;
        });
    };
    FaceRecognitionNet.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    FaceRecognitionNet.prototype.computeFaceDescriptor = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var netInput, faceDescriptorTensors, faceDescriptorsForBatch;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["toNetInput"])(input)];
                    case 1:
                        netInput = _a.sent();
                        faceDescriptorTensors = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["unstack"](_this.forwardInput(netInput)); });
                        return [4 /*yield*/, Promise.all(faceDescriptorTensors.map(function (t) { return t.data(); }))];
                    case 2:
                        faceDescriptorsForBatch = _a.sent();
                        faceDescriptorTensors.forEach(function (t) { return t.dispose(); });
                        return [2 /*return*/, netInput.isBatchInput
                                ? faceDescriptorsForBatch
                                : faceDescriptorsForBatch[0]];
                }
            });
        });
    };
    FaceRecognitionNet.prototype.getDefaultModelName = function () {
        return 'face_recognition_model';
    };
    FaceRecognitionNet.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_7__["extractParamsFromWeigthMap"])(weightMap);
    };
    FaceRecognitionNet.prototype.extractParams = function (weights) {
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_6__["extractParams"])(weights);
    };
    return FaceRecognitionNet;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_3__["NeuralNetwork"]));

//# sourceMappingURL=FaceRecognitionNet.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceRecognitionNet/convLayer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceRecognitionNet/convLayer.js ***!
  \****************************************************************************/
/*! exports provided: conv, convNoRelu, convDown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv", function() { return conv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convNoRelu", function() { return convNoRelu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convDown", function() { return convDown; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _scaleLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scaleLayer */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/scaleLayer.js");


function convLayer(x, params, strides, withRelu, padding) {
    if (padding === void 0) { padding = 'same'; }
    var _a = params.conv, filters = _a.filters, bias = _a.bias;
    var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"](x, filters, strides, padding);
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out, bias);
    out = Object(_scaleLayer__WEBPACK_IMPORTED_MODULE_1__["scale"])(out, params.scale);
    return withRelu ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](out) : out;
}
function conv(x, params) {
    return convLayer(x, params, [1, 1], true);
}
function convNoRelu(x, params) {
    return convLayer(x, params, [1, 1], false);
}
function convDown(x, params) {
    return convLayer(x, params, [2, 2], true, 'valid');
}
//# sourceMappingURL=convLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceRecognitionNet/extractParams.js":
/*!********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceRecognitionNet/extractParams.js ***!
  \********************************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");



function extractorsFactory(extractWeights, paramMappings) {
    function extractFilterValues(numFilterValues, numFilters, filterSize) {
        var weights = extractWeights(numFilterValues);
        var depth = weights.length / (numFilters * filterSize * filterSize);
        if (Object(_utils__WEBPACK_IMPORTED_MODULE_2__["isFloat"])(depth)) {
            throw new Error("depth has to be an integer: " + depth + ", weights.length: " + weights.length + ", numFilters: " + numFilters + ", filterSize: " + filterSize);
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"](weights, [numFilters, depth, filterSize, filterSize]), [2, 3, 1, 0]); });
    }
    function extractConvParams(numFilterValues, numFilters, filterSize, mappedPrefix) {
        var filters = extractFilterValues(numFilterValues, numFilters, filterSize);
        var bias = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(numFilters));
        paramMappings.push({ paramPath: mappedPrefix + "/filters" }, { paramPath: mappedPrefix + "/bias" });
        return { filters: filters, bias: bias };
    }
    function extractScaleLayerParams(numWeights, mappedPrefix) {
        var weights = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(numWeights));
        var biases = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(numWeights));
        paramMappings.push({ paramPath: mappedPrefix + "/weights" }, { paramPath: mappedPrefix + "/biases" });
        return {
            weights: weights,
            biases: biases
        };
    }
    function extractConvLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix) {
        var conv = extractConvParams(numFilterValues, numFilters, filterSize, mappedPrefix + "/conv");
        var scale = extractScaleLayerParams(numFilters, mappedPrefix + "/scale");
        return { conv: conv, scale: scale };
    }
    function extractResidualLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix, isDown) {
        if (isDown === void 0) { isDown = false; }
        var conv1 = extractConvLayerParams((isDown ? 0.5 : 1) * numFilterValues, numFilters, filterSize, mappedPrefix + "/conv1");
        var conv2 = extractConvLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix + "/conv2");
        return { conv1: conv1, conv2: conv2 };
    }
    return {
        extractConvLayerParams: extractConvLayerParams,
        extractResidualLayerParams: extractResidualLayerParams
    };
}
function extractParams(weights) {
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_1__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var paramMappings = [];
    var _b = extractorsFactory(extractWeights, paramMappings), extractConvLayerParams = _b.extractConvLayerParams, extractResidualLayerParams = _b.extractResidualLayerParams;
    var conv32_down = extractConvLayerParams(4704, 32, 7, 'conv32_down');
    var conv32_1 = extractResidualLayerParams(9216, 32, 3, 'conv32_1');
    var conv32_2 = extractResidualLayerParams(9216, 32, 3, 'conv32_2');
    var conv32_3 = extractResidualLayerParams(9216, 32, 3, 'conv32_3');
    var conv64_down = extractResidualLayerParams(36864, 64, 3, 'conv64_down', true);
    var conv64_1 = extractResidualLayerParams(36864, 64, 3, 'conv64_1');
    var conv64_2 = extractResidualLayerParams(36864, 64, 3, 'conv64_2');
    var conv64_3 = extractResidualLayerParams(36864, 64, 3, 'conv64_3');
    var conv128_down = extractResidualLayerParams(147456, 128, 3, 'conv128_down', true);
    var conv128_1 = extractResidualLayerParams(147456, 128, 3, 'conv128_1');
    var conv128_2 = extractResidualLayerParams(147456, 128, 3, 'conv128_2');
    var conv256_down = extractResidualLayerParams(589824, 256, 3, 'conv256_down', true);
    var conv256_1 = extractResidualLayerParams(589824, 256, 3, 'conv256_1');
    var conv256_2 = extractResidualLayerParams(589824, 256, 3, 'conv256_2');
    var conv256_down_out = extractResidualLayerParams(589824, 256, 3, 'conv256_down_out');
    var fc = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor2d"](extractWeights(256 * 128), [128, 256]), [1, 0]); });
    paramMappings.push({ paramPath: "fc" });
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    var params = {
        conv32_down: conv32_down,
        conv32_1: conv32_1,
        conv32_2: conv32_2,
        conv32_3: conv32_3,
        conv64_down: conv64_down,
        conv64_1: conv64_1,
        conv64_2: conv64_2,
        conv64_3: conv64_3,
        conv128_down: conv128_down,
        conv128_1: conv128_1,
        conv128_2: conv128_2,
        conv256_down: conv256_down,
        conv256_1: conv256_1,
        conv256_2: conv256_2,
        conv256_down_out: conv256_down_out,
        fc: fc
    };
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceRecognitionNet/extractParamsFromWeigthMap.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceRecognitionNet/extractParamsFromWeigthMap.js ***!
  \*********************************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");


function extractorsFactory(weightMap, paramMappings) {
    var extractWeightEntry = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightEntryFactory"])(weightMap, paramMappings);
    function extractScaleLayerParams(prefix) {
        var weights = extractWeightEntry(prefix + "/scale/weights", 1);
        var biases = extractWeightEntry(prefix + "/scale/biases", 1);
        return { weights: weights, biases: biases };
    }
    function extractConvLayerParams(prefix) {
        var filters = extractWeightEntry(prefix + "/conv/filters", 4);
        var bias = extractWeightEntry(prefix + "/conv/bias", 1);
        var scale = extractScaleLayerParams(prefix);
        return { conv: { filters: filters, bias: bias }, scale: scale };
    }
    function extractResidualLayerParams(prefix) {
        return {
            conv1: extractConvLayerParams(prefix + "/conv1"),
            conv2: extractConvLayerParams(prefix + "/conv2")
        };
    }
    return {
        extractConvLayerParams: extractConvLayerParams,
        extractResidualLayerParams: extractResidualLayerParams
    };
}
function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var _a = extractorsFactory(weightMap, paramMappings), extractConvLayerParams = _a.extractConvLayerParams, extractResidualLayerParams = _a.extractResidualLayerParams;
    var conv32_down = extractConvLayerParams('conv32_down');
    var conv32_1 = extractResidualLayerParams('conv32_1');
    var conv32_2 = extractResidualLayerParams('conv32_2');
    var conv32_3 = extractResidualLayerParams('conv32_3');
    var conv64_down = extractResidualLayerParams('conv64_down');
    var conv64_1 = extractResidualLayerParams('conv64_1');
    var conv64_2 = extractResidualLayerParams('conv64_2');
    var conv64_3 = extractResidualLayerParams('conv64_3');
    var conv128_down = extractResidualLayerParams('conv128_down');
    var conv128_1 = extractResidualLayerParams('conv128_1');
    var conv128_2 = extractResidualLayerParams('conv128_2');
    var conv256_down = extractResidualLayerParams('conv256_down');
    var conv256_1 = extractResidualLayerParams('conv256_1');
    var conv256_2 = extractResidualLayerParams('conv256_2');
    var conv256_down_out = extractResidualLayerParams('conv256_down_out');
    var fc = weightMap['fc'];
    paramMappings.push({ originalPath: 'fc', paramPath: 'fc' });
    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isTensor2D"])(fc)) {
        throw new Error("expected weightMap[fc] to be a Tensor2D, instead have " + fc);
    }
    var params = {
        conv32_down: conv32_down,
        conv32_1: conv32_1,
        conv32_2: conv32_2,
        conv32_3: conv32_3,
        conv64_down: conv64_down,
        conv64_1: conv64_1,
        conv64_2: conv64_2,
        conv64_3: conv64_3,
        conv128_down: conv128_down,
        conv128_1: conv128_1,
        conv128_2: conv128_2,
        conv256_down: conv256_down,
        conv256_1: conv256_1,
        conv256_2: conv256_2,
        conv256_down_out: conv256_down_out,
        fc: fc
    };
    Object(_common__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceRecognitionNet/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceRecognitionNet/index.js ***!
  \************************************************************************/
/*! exports provided: FaceRecognitionNet, createFaceRecognitionNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFaceRecognitionNet", function() { return createFaceRecognitionNet; });
/* harmony import */ var _FaceRecognitionNet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FaceRecognitionNet */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/FaceRecognitionNet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceRecognitionNet", function() { return _FaceRecognitionNet__WEBPACK_IMPORTED_MODULE_0__["FaceRecognitionNet"]; });



function createFaceRecognitionNet(weights) {
    var net = new _FaceRecognitionNet__WEBPACK_IMPORTED_MODULE_0__["FaceRecognitionNet"]();
    net.extractWeights(weights);
    return net;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceRecognitionNet/residualLayer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceRecognitionNet/residualLayer.js ***!
  \********************************************************************************/
/*! exports provided: residual, residualDown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "residual", function() { return residual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "residualDown", function() { return residualDown; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _convLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./convLayer */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/convLayer.js");



function residual(x, params) {
    var out = Object(_convLayer__WEBPACK_IMPORTED_MODULE_2__["conv"])(x, params.conv1);
    out = Object(_convLayer__WEBPACK_IMPORTED_MODULE_2__["convNoRelu"])(out, params.conv2);
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["add"](out, x);
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](out);
    return out;
}
function residualDown(x, params) {
    var out = Object(_convLayer__WEBPACK_IMPORTED_MODULE_2__["convDown"])(x, params.conv1);
    out = Object(_convLayer__WEBPACK_IMPORTED_MODULE_2__["convNoRelu"])(out, params.conv2);
    var pooled = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["avgPool"](x, 2, 2, 'valid');
    var zeros = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["zeros"](pooled.shape);
    var isPad = pooled.shape[3] !== out.shape[3];
    var isAdjustShape = pooled.shape[1] !== out.shape[1] || pooled.shape[2] !== out.shape[2];
    if (isAdjustShape) {
        var padShapeX = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spreadArrays"])(out.shape);
        padShapeX[1] = 1;
        var zerosW = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["zeros"](padShapeX);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["concat"]([out, zerosW], 1);
        var padShapeY = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spreadArrays"])(out.shape);
        padShapeY[2] = 1;
        var zerosH = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["zeros"](padShapeY);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["concat"]([out, zerosH], 2);
    }
    pooled = isPad ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["concat"]([pooled, zeros], 3) : pooled;
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["add"](pooled, out);
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](out);
    return out;
}
//# sourceMappingURL=residualLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/faceRecognitionNet/scaleLayer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/faceRecognitionNet/scaleLayer.js ***!
  \*****************************************************************************/
/*! exports provided: scale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function scale(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](x, params.weights), params.biases);
}
//# sourceMappingURL=scaleLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/factories/WithAge.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/factories/WithAge.js ***!
  \*****************************************************************/
/*! exports provided: isWithAge, extendWithAge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWithAge", function() { return isWithAge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendWithAge", function() { return extendWithAge; });
function isWithAge(obj) {
    return typeof obj['age'] === 'number';
}
function extendWithAge(sourceObj, age) {
    var extension = { age: age };
    return Object.assign({}, sourceObj, extension);
}
//# sourceMappingURL=WithAge.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/factories/WithFaceDescriptor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/factories/WithFaceDescriptor.js ***!
  \****************************************************************************/
/*! exports provided: extendWithFaceDescriptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceDescriptor", function() { return extendWithFaceDescriptor; });
function extendWithFaceDescriptor(sourceObj, descriptor) {
    var extension = { descriptor: descriptor };
    return Object.assign({}, sourceObj, extension);
}
//# sourceMappingURL=WithFaceDescriptor.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js":
/*!***************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js ***!
  \***************************************************************************/
/*! exports provided: isWithFaceDetection, extendWithFaceDetection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWithFaceDetection", function() { return isWithFaceDetection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceDetection", function() { return extendWithFaceDetection; });
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");

function isWithFaceDetection(obj) {
    return obj['detection'] instanceof _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_0__["FaceDetection"];
}
function extendWithFaceDetection(sourceObj, detection) {
    var extension = { detection: detection };
    return Object.assign({}, sourceObj, extension);
}
//# sourceMappingURL=WithFaceDetection.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js ***!
  \*****************************************************************************/
/*! exports provided: isWithFaceExpressions, extendWithFaceExpressions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWithFaceExpressions", function() { return isWithFaceExpressions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceExpressions", function() { return extendWithFaceExpressions; });
/* harmony import */ var _faceExpressionNet_FaceExpressions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../faceExpressionNet/FaceExpressions */ "./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js");

function isWithFaceExpressions(obj) {
    return obj['expressions'] instanceof _faceExpressionNet_FaceExpressions__WEBPACK_IMPORTED_MODULE_0__["FaceExpressions"];
}
function extendWithFaceExpressions(sourceObj, expressions) {
    var extension = { expressions: expressions };
    return Object.assign({}, sourceObj, extension);
}
//# sourceMappingURL=WithFaceExpressions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js":
/*!***************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js ***!
  \***************************************************************************/
/*! exports provided: isWithFaceLandmarks, extendWithFaceLandmarks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWithFaceLandmarks", function() { return isWithFaceLandmarks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceLandmarks", function() { return extendWithFaceLandmarks; });
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _classes_FaceLandmarks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/FaceLandmarks */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js");
/* harmony import */ var _WithFaceDetection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WithFaceDetection */ "./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js");



function isWithFaceLandmarks(obj) {
    return Object(_WithFaceDetection__WEBPACK_IMPORTED_MODULE_2__["isWithFaceDetection"])(obj)
        && obj['landmarks'] instanceof _classes_FaceLandmarks__WEBPACK_IMPORTED_MODULE_1__["FaceLandmarks"]
        && obj['unshiftedLandmarks'] instanceof _classes_FaceLandmarks__WEBPACK_IMPORTED_MODULE_1__["FaceLandmarks"]
        && obj['alignedRect'] instanceof _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_0__["FaceDetection"];
}
function extendWithFaceLandmarks(sourceObj, unshiftedLandmarks) {
    var shift = sourceObj.detection.box;
    var landmarks = unshiftedLandmarks.shiftBy(shift.x, shift.y);
    var rect = landmarks.align();
    var imageDims = sourceObj.detection.imageDims;
    var alignedRect = new _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_0__["FaceDetection"](sourceObj.detection.score, rect.rescale(imageDims.reverse()), imageDims);
    var extension = {
        landmarks: landmarks,
        unshiftedLandmarks: unshiftedLandmarks,
        alignedRect: alignedRect
    };
    return Object.assign({}, sourceObj, extension);
}
//# sourceMappingURL=WithFaceLandmarks.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/factories/WithGender.js":
/*!********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/factories/WithGender.js ***!
  \********************************************************************/
/*! exports provided: isWithGender, extendWithGender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWithGender", function() { return isWithGender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendWithGender", function() { return extendWithGender; });
/* harmony import */ var _ageGenderNet_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ageGenderNet/types */ "./node_modules/face-api.js/build/es6/ageGenderNet/types.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");


function isWithGender(obj) {
    return (obj['gender'] === _ageGenderNet_types__WEBPACK_IMPORTED_MODULE_0__["Gender"].MALE || obj['gender'] === _ageGenderNet_types__WEBPACK_IMPORTED_MODULE_0__["Gender"].FEMALE)
        && Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isValidProbablitiy"])(obj['genderProbability']);
}
function extendWithGender(sourceObj, gender, genderProbability) {
    var extension = { gender: gender, genderProbability: genderProbability };
    return Object.assign({}, sourceObj, extension);
}
//# sourceMappingURL=WithGender.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/factories/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/factories/index.js ***!
  \***************************************************************/
/*! exports provided: extendWithFaceDescriptor, isWithFaceDetection, extendWithFaceDetection, isWithFaceExpressions, extendWithFaceExpressions, isWithFaceLandmarks, extendWithFaceLandmarks, isWithAge, extendWithAge, isWithGender, extendWithGender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _WithFaceDescriptor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WithFaceDescriptor */ "./node_modules/face-api.js/build/es6/factories/WithFaceDescriptor.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceDescriptor", function() { return _WithFaceDescriptor__WEBPACK_IMPORTED_MODULE_0__["extendWithFaceDescriptor"]; });

/* harmony import */ var _WithFaceDetection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WithFaceDetection */ "./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithFaceDetection", function() { return _WithFaceDetection__WEBPACK_IMPORTED_MODULE_1__["isWithFaceDetection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceDetection", function() { return _WithFaceDetection__WEBPACK_IMPORTED_MODULE_1__["extendWithFaceDetection"]; });

/* harmony import */ var _WithFaceExpressions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WithFaceExpressions */ "./node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithFaceExpressions", function() { return _WithFaceExpressions__WEBPACK_IMPORTED_MODULE_2__["isWithFaceExpressions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceExpressions", function() { return _WithFaceExpressions__WEBPACK_IMPORTED_MODULE_2__["extendWithFaceExpressions"]; });

/* harmony import */ var _WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WithFaceLandmarks */ "./node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithFaceLandmarks", function() { return _WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__["isWithFaceLandmarks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceLandmarks", function() { return _WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__["extendWithFaceLandmarks"]; });

/* harmony import */ var _WithAge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WithAge */ "./node_modules/face-api.js/build/es6/factories/WithAge.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithAge", function() { return _WithAge__WEBPACK_IMPORTED_MODULE_4__["isWithAge"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithAge", function() { return _WithAge__WEBPACK_IMPORTED_MODULE_4__["extendWithAge"]; });

/* harmony import */ var _WithGender__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WithGender */ "./node_modules/face-api.js/build/es6/factories/WithGender.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithGender", function() { return _WithGender__WEBPACK_IMPORTED_MODULE_5__["isWithGender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithGender", function() { return _WithGender__WEBPACK_IMPORTED_MODULE_5__["extendWithGender"]; });







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js":
/*!************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js ***!
  \************************************************************************/
/*! exports provided: ComposableTask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComposableTask", function() { return ComposableTask; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

var ComposableTask = /** @class */ (function () {
    function ComposableTask() {
    }
    ComposableTask.prototype.then = function (onfulfilled) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = onfulfilled;
                        return [4 /*yield*/, this.run()];
                    case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
                }
            });
        });
    };
    ComposableTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                throw new Error('ComposableTask - run is not implemented');
            });
        });
    };
    return ComposableTask;
}());

//# sourceMappingURL=ComposableTask.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js ***!
  \*************************************************************************************/
/*! exports provided: ComputeFaceDescriptorsTaskBase, ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComputeFaceDescriptorsTaskBase", function() { return ComputeFaceDescriptorsTaskBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComputeAllFaceDescriptorsTask", function() { return ComputeAllFaceDescriptorsTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComputeSingleFaceDescriptorTask", function() { return ComputeSingleFaceDescriptorTask; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _factories_WithFaceDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factories/WithFaceDescriptor */ "./node_modules/face-api.js/build/es6/factories/WithFaceDescriptor.js");
/* harmony import */ var _ComposableTask__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ComposableTask */ "./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js");
/* harmony import */ var _extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extractFacesAndComputeResults */ "./node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js");
/* harmony import */ var _nets__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nets */ "./node_modules/face-api.js/build/es6/globalApi/nets.js");
/* harmony import */ var _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PredictAgeAndGenderTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js");
/* harmony import */ var _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PredictFaceExpressionsTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js");







var ComputeFaceDescriptorsTaskBase = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(ComputeFaceDescriptorsTaskBase, _super);
    function ComputeFaceDescriptorsTaskBase(parentTask, input) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input;
        return _this;
    }
    return ComputeFaceDescriptorsTaskBase;
}(_ComposableTask__WEBPACK_IMPORTED_MODULE_2__["ComposableTask"]));

var ComputeAllFaceDescriptorsTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(ComputeAllFaceDescriptorsTask, _super);
    function ComputeAllFaceDescriptorsTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComputeAllFaceDescriptorsTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResults, descriptors;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResults = _a.sent();
                        return [4 /*yield*/, Object(_extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_3__["extractAllFacesAndComputeResults"])(parentResults, this.input, function (faces) { return Promise.all(faces.map(function (face) {
                                return _nets__WEBPACK_IMPORTED_MODULE_4__["nets"].faceRecognitionNet.computeFaceDescriptor(face);
                            })); }, null, function (parentResult) { return parentResult.landmarks.align(null, { useDlibAlignment: true }); })];
                    case 2:
                        descriptors = _a.sent();
                        return [2 /*return*/, descriptors.map(function (descriptor, i) { return Object(_factories_WithFaceDescriptor__WEBPACK_IMPORTED_MODULE_1__["extendWithFaceDescriptor"])(parentResults[i], descriptor); })];
                }
            });
        });
    };
    ComputeAllFaceDescriptorsTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_6__["PredictAllFaceExpressionsWithFaceAlignmentTask"](this, this.input);
    };
    ComputeAllFaceDescriptorsTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_5__["PredictAllAgeAndGenderWithFaceAlignmentTask"](this, this.input);
    };
    return ComputeAllFaceDescriptorsTask;
}(ComputeFaceDescriptorsTaskBase));

var ComputeSingleFaceDescriptorTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(ComputeSingleFaceDescriptorTask, _super);
    function ComputeSingleFaceDescriptorTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComputeSingleFaceDescriptorTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResult, descriptor;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResult = _a.sent();
                        if (!parentResult) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Object(_extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_3__["extractSingleFaceAndComputeResult"])(parentResult, this.input, function (face) { return _nets__WEBPACK_IMPORTED_MODULE_4__["nets"].faceRecognitionNet.computeFaceDescriptor(face); }, null, function (parentResult) { return parentResult.landmarks.align(null, { useDlibAlignment: true }); })];
                    case 2:
                        descriptor = _a.sent();
                        return [2 /*return*/, Object(_factories_WithFaceDescriptor__WEBPACK_IMPORTED_MODULE_1__["extendWithFaceDescriptor"])(parentResult, descriptor)];
                }
            });
        });
    };
    ComputeSingleFaceDescriptorTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_6__["PredictSingleFaceExpressionsWithFaceAlignmentTask"](this, this.input);
    };
    ComputeSingleFaceDescriptorTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_5__["PredictSingleAgeAndGenderWithFaceAlignmentTask"](this, this.input);
    };
    return ComputeSingleFaceDescriptorTask;
}(ComputeFaceDescriptorsTaskBase));

//# sourceMappingURL=ComputeFaceDescriptorsTasks.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/DetectFaceLandmarksTasks.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/DetectFaceLandmarksTasks.js ***!
  \**********************************************************************************/
/*! exports provided: DetectFaceLandmarksTaskBase, DetectAllFaceLandmarksTask, DetectSingleFaceLandmarksTask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DetectFaceLandmarksTaskBase", function() { return DetectFaceLandmarksTaskBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DetectAllFaceLandmarksTask", function() { return DetectAllFaceLandmarksTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DetectSingleFaceLandmarksTask", function() { return DetectSingleFaceLandmarksTask; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factories/WithFaceLandmarks */ "./node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js");
/* harmony import */ var _ComposableTask__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ComposableTask */ "./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js");
/* harmony import */ var _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ComputeFaceDescriptorsTasks */ "./node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js");
/* harmony import */ var _nets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./nets */ "./node_modules/face-api.js/build/es6/globalApi/nets.js");
/* harmony import */ var _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PredictAgeAndGenderTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js");
/* harmony import */ var _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PredictFaceExpressionsTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js");









var DetectFaceLandmarksTaskBase = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(DetectFaceLandmarksTaskBase, _super);
    function DetectFaceLandmarksTaskBase(parentTask, input, useTinyLandmarkNet) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input;
        _this.useTinyLandmarkNet = useTinyLandmarkNet;
        return _this;
    }
    Object.defineProperty(DetectFaceLandmarksTaskBase.prototype, "landmarkNet", {
        get: function () {
            return this.useTinyLandmarkNet
                ? _nets__WEBPACK_IMPORTED_MODULE_6__["nets"].faceLandmark68TinyNet
                : _nets__WEBPACK_IMPORTED_MODULE_6__["nets"].faceLandmark68Net;
        },
        enumerable: true,
        configurable: true
    });
    return DetectFaceLandmarksTaskBase;
}(_ComposableTask__WEBPACK_IMPORTED_MODULE_4__["ComposableTask"]));

var DetectAllFaceLandmarksTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(DetectAllFaceLandmarksTask, _super);
    function DetectAllFaceLandmarksTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DetectAllFaceLandmarksTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResults, detections, faces, _a, faceLandmarksByFace;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResults = _b.sent();
                        detections = parentResults.map(function (res) { return res.detection; });
                        if (!(this.input instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Tensor"])) return [3 /*break*/, 3];
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["extractFaceTensors"])(this.input, detections)];
                    case 2:
                        _a = _b.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["extractFaces"])(this.input, detections)];
                    case 4:
                        _a = _b.sent();
                        _b.label = 5;
                    case 5:
                        faces = _a;
                        return [4 /*yield*/, Promise.all(faces.map(function (face) { return _this.landmarkNet.detectLandmarks(face); }))];
                    case 6:
                        faceLandmarksByFace = _b.sent();
                        faces.forEach(function (f) { return f instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Tensor"] && f.dispose(); });
                        return [2 /*return*/, parentResults.map(function (parentResult, i) {
                                return Object(_factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__["extendWithFaceLandmarks"])(parentResult, faceLandmarksByFace[i]);
                            })];
                }
            });
        });
    };
    DetectAllFaceLandmarksTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_8__["PredictAllFaceExpressionsWithFaceAlignmentTask"](this, this.input);
    };
    DetectAllFaceLandmarksTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_7__["PredictAllAgeAndGenderWithFaceAlignmentTask"](this, this.input);
    };
    DetectAllFaceLandmarksTask.prototype.withFaceDescriptors = function () {
        return new _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_5__["ComputeAllFaceDescriptorsTask"](this, this.input);
    };
    return DetectAllFaceLandmarksTask;
}(DetectFaceLandmarksTaskBase));

var DetectSingleFaceLandmarksTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(DetectSingleFaceLandmarksTask, _super);
    function DetectSingleFaceLandmarksTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DetectSingleFaceLandmarksTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResult, detection, faces, _a, landmarks;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResult = _b.sent();
                        if (!parentResult) {
                            return [2 /*return*/];
                        }
                        detection = parentResult.detection;
                        if (!(this.input instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Tensor"])) return [3 /*break*/, 3];
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["extractFaceTensors"])(this.input, [detection])];
                    case 2:
                        _a = _b.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["extractFaces"])(this.input, [detection])];
                    case 4:
                        _a = _b.sent();
                        _b.label = 5;
                    case 5:
                        faces = _a;
                        return [4 /*yield*/, this.landmarkNet.detectLandmarks(faces[0])];
                    case 6:
                        landmarks = _b.sent();
                        faces.forEach(function (f) { return f instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Tensor"] && f.dispose(); });
                        return [2 /*return*/, Object(_factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__["extendWithFaceLandmarks"])(parentResult, landmarks)];
                }
            });
        });
    };
    DetectSingleFaceLandmarksTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_8__["PredictSingleFaceExpressionsWithFaceAlignmentTask"](this, this.input);
    };
    DetectSingleFaceLandmarksTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_7__["PredictSingleAgeAndGenderWithFaceAlignmentTask"](this, this.input);
    };
    DetectSingleFaceLandmarksTask.prototype.withFaceDescriptor = function () {
        return new _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_5__["ComputeSingleFaceDescriptorTask"](this, this.input);
    };
    return DetectSingleFaceLandmarksTask;
}(DetectFaceLandmarksTaskBase));

//# sourceMappingURL=DetectFaceLandmarksTasks.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/DetectFacesTasks.js":
/*!**************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/DetectFacesTasks.js ***!
  \**************************************************************************/
/*! exports provided: DetectFacesTaskBase, DetectAllFacesTask, DetectSingleFaceTask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DetectFacesTaskBase", function() { return DetectFacesTaskBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DetectAllFacesTask", function() { return DetectAllFacesTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DetectSingleFaceTask", function() { return DetectSingleFaceTask; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factories/WithFaceDetection */ "./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js");
/* harmony import */ var _mtcnn_MtcnnOptions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mtcnn/MtcnnOptions */ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js");
/* harmony import */ var _ssdMobilenetv1_SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ssdMobilenetv1/SsdMobilenetv1Options */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js");
/* harmony import */ var _tinyFaceDetector_TinyFaceDetectorOptions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tinyFaceDetector/TinyFaceDetectorOptions */ "./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetectorOptions.js");
/* harmony import */ var _tinyYolov2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tinyYolov2 */ "./node_modules/face-api.js/build/es6/tinyYolov2/index.js");
/* harmony import */ var _ComposableTask__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ComposableTask */ "./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js");
/* harmony import */ var _DetectFaceLandmarksTasks__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DetectFaceLandmarksTasks */ "./node_modules/face-api.js/build/es6/globalApi/DetectFaceLandmarksTasks.js");
/* harmony import */ var _nets__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./nets */ "./node_modules/face-api.js/build/es6/globalApi/nets.js");
/* harmony import */ var _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./PredictAgeAndGenderTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js");
/* harmony import */ var _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PredictFaceExpressionsTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js");











var DetectFacesTaskBase = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(DetectFacesTaskBase, _super);
    function DetectFacesTaskBase(input, options) {
        if (options === void 0) { options = new _ssdMobilenetv1_SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_3__["SsdMobilenetv1Options"](); }
        var _this = _super.call(this) || this;
        _this.input = input;
        _this.options = options;
        return _this;
    }
    return DetectFacesTaskBase;
}(_ComposableTask__WEBPACK_IMPORTED_MODULE_6__["ComposableTask"]));

var DetectAllFacesTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(DetectAllFacesTask, _super);
    function DetectAllFacesTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DetectAllFacesTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a, input, options, faceDetectionFunction;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this, input = _a.input, options = _a.options;
                        if (!(options instanceof _mtcnn_MtcnnOptions__WEBPACK_IMPORTED_MODULE_2__["MtcnnOptions"])) return [3 /*break*/, 2];
                        return [4 /*yield*/, _nets__WEBPACK_IMPORTED_MODULE_8__["nets"].mtcnn.forward(input, options)];
                    case 1: return [2 /*return*/, (_b.sent())
                            .map(function (result) { return result.detection; })];
                    case 2:
                        faceDetectionFunction = options instanceof _tinyFaceDetector_TinyFaceDetectorOptions__WEBPACK_IMPORTED_MODULE_4__["TinyFaceDetectorOptions"]
                            ? function (input) { return _nets__WEBPACK_IMPORTED_MODULE_8__["nets"].tinyFaceDetector.locateFaces(input, options); }
                            : (options instanceof _ssdMobilenetv1_SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_3__["SsdMobilenetv1Options"]
                                ? function (input) { return _nets__WEBPACK_IMPORTED_MODULE_8__["nets"].ssdMobilenetv1.locateFaces(input, options); }
                                : (options instanceof _tinyYolov2__WEBPACK_IMPORTED_MODULE_5__["TinyYolov2Options"]
                                    ? function (input) { return _nets__WEBPACK_IMPORTED_MODULE_8__["nets"].tinyYolov2.locateFaces(input, options); }
                                    : null));
                        if (!faceDetectionFunction) {
                            throw new Error('detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options');
                        }
                        return [2 /*return*/, faceDetectionFunction(input)];
                }
            });
        });
    };
    DetectAllFacesTask.prototype.runAndExtendWithFaceDetections = function () {
        var _this = this;
        return new Promise(function (res) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
            var detections;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.run()];
                    case 1:
                        detections = _a.sent();
                        return [2 /*return*/, res(detections.map(function (detection) { return Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_1__["extendWithFaceDetection"])({}, detection); }))];
                }
            });
        }); });
    };
    DetectAllFacesTask.prototype.withFaceLandmarks = function (useTinyLandmarkNet) {
        if (useTinyLandmarkNet === void 0) { useTinyLandmarkNet = false; }
        return new _DetectFaceLandmarksTasks__WEBPACK_IMPORTED_MODULE_7__["DetectAllFaceLandmarksTask"](this.runAndExtendWithFaceDetections(), this.input, useTinyLandmarkNet);
    };
    DetectAllFacesTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_10__["PredictAllFaceExpressionsTask"](this.runAndExtendWithFaceDetections(), this.input);
    };
    DetectAllFacesTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_9__["PredictAllAgeAndGenderTask"](this.runAndExtendWithFaceDetections(), this.input);
    };
    return DetectAllFacesTask;
}(DetectFacesTaskBase));

var DetectSingleFaceTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(DetectSingleFaceTask, _super);
    function DetectSingleFaceTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DetectSingleFaceTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var faceDetections, faceDetectionWithHighestScore;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new DetectAllFacesTask(this.input, this.options)];
                    case 1:
                        faceDetections = _a.sent();
                        faceDetectionWithHighestScore = faceDetections[0];
                        faceDetections.forEach(function (faceDetection) {
                            if (faceDetection.score > faceDetectionWithHighestScore.score) {
                                faceDetectionWithHighestScore = faceDetection;
                            }
                        });
                        return [2 /*return*/, faceDetectionWithHighestScore];
                }
            });
        });
    };
    DetectSingleFaceTask.prototype.runAndExtendWithFaceDetection = function () {
        var _this = this;
        return new Promise(function (res) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
            var detection;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.run()];
                    case 1:
                        detection = _a.sent();
                        return [2 /*return*/, res(detection ? Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_1__["extendWithFaceDetection"])({}, detection) : undefined)];
                }
            });
        }); });
    };
    DetectSingleFaceTask.prototype.withFaceLandmarks = function (useTinyLandmarkNet) {
        if (useTinyLandmarkNet === void 0) { useTinyLandmarkNet = false; }
        return new _DetectFaceLandmarksTasks__WEBPACK_IMPORTED_MODULE_7__["DetectSingleFaceLandmarksTask"](this.runAndExtendWithFaceDetection(), this.input, useTinyLandmarkNet);
    };
    DetectSingleFaceTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_10__["PredictSingleFaceExpressionsTask"](this.runAndExtendWithFaceDetection(), this.input);
    };
    DetectSingleFaceTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_9__["PredictSingleAgeAndGenderTask"](this.runAndExtendWithFaceDetection(), this.input);
    };
    return DetectSingleFaceTask;
}(DetectFacesTaskBase));

//# sourceMappingURL=DetectFacesTasks.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/FaceMatcher.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/FaceMatcher.js ***!
  \*********************************************************************/
/*! exports provided: FaceMatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceMatcher", function() { return FaceMatcher; });
/* harmony import */ var _classes_FaceMatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/FaceMatch */ "./node_modules/face-api.js/build/es6/classes/FaceMatch.js");
/* harmony import */ var _classes_LabeledFaceDescriptors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/LabeledFaceDescriptors */ "./node_modules/face-api.js/build/es6/classes/LabeledFaceDescriptors.js");
/* harmony import */ var _euclideanDistance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../euclideanDistance */ "./node_modules/face-api.js/build/es6/euclideanDistance.js");



var FaceMatcher = /** @class */ (function () {
    function FaceMatcher(inputs, distanceThreshold) {
        if (distanceThreshold === void 0) { distanceThreshold = 0.6; }
        this._distanceThreshold = distanceThreshold;
        var inputArray = Array.isArray(inputs) ? inputs : [inputs];
        if (!inputArray.length) {
            throw new Error("FaceRecognizer.constructor - expected atleast one input");
        }
        var count = 1;
        var createUniqueLabel = function () { return "person " + count++; };
        this._labeledDescriptors = inputArray.map(function (desc) {
            if (desc instanceof _classes_LabeledFaceDescriptors__WEBPACK_IMPORTED_MODULE_1__["LabeledFaceDescriptors"]) {
                return desc;
            }
            if (desc instanceof Float32Array) {
                return new _classes_LabeledFaceDescriptors__WEBPACK_IMPORTED_MODULE_1__["LabeledFaceDescriptors"](createUniqueLabel(), [desc]);
            }
            if (desc.descriptor && desc.descriptor instanceof Float32Array) {
                return new _classes_LabeledFaceDescriptors__WEBPACK_IMPORTED_MODULE_1__["LabeledFaceDescriptors"](createUniqueLabel(), [desc.descriptor]);
            }
            throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>");
        });
    }
    Object.defineProperty(FaceMatcher.prototype, "labeledDescriptors", {
        get: function () { return this._labeledDescriptors; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FaceMatcher.prototype, "distanceThreshold", {
        get: function () { return this._distanceThreshold; },
        enumerable: true,
        configurable: true
    });
    FaceMatcher.prototype.computeMeanDistance = function (queryDescriptor, descriptors) {
        return descriptors
            .map(function (d) { return Object(_euclideanDistance__WEBPACK_IMPORTED_MODULE_2__["euclideanDistance"])(d, queryDescriptor); })
            .reduce(function (d1, d2) { return d1 + d2; }, 0)
            / (descriptors.length || 1);
    };
    FaceMatcher.prototype.matchDescriptor = function (queryDescriptor) {
        var _this = this;
        return this.labeledDescriptors
            .map(function (_a) {
            var descriptors = _a.descriptors, label = _a.label;
            return new _classes_FaceMatch__WEBPACK_IMPORTED_MODULE_0__["FaceMatch"](label, _this.computeMeanDistance(queryDescriptor, descriptors));
        })
            .reduce(function (best, curr) { return best.distance < curr.distance ? best : curr; });
    };
    FaceMatcher.prototype.findBestMatch = function (queryDescriptor) {
        var bestMatch = this.matchDescriptor(queryDescriptor);
        return bestMatch.distance < this.distanceThreshold
            ? bestMatch
            : new _classes_FaceMatch__WEBPACK_IMPORTED_MODULE_0__["FaceMatch"]('unknown', bestMatch.distance);
    };
    FaceMatcher.prototype.toJSON = function () {
        return {
            distanceThreshold: this.distanceThreshold,
            labeledDescriptors: this.labeledDescriptors.map(function (ld) { return ld.toJSON(); })
        };
    };
    FaceMatcher.fromJSON = function (json) {
        var labeledDescriptors = json.labeledDescriptors
            .map(function (ld) { return _classes_LabeledFaceDescriptors__WEBPACK_IMPORTED_MODULE_1__["LabeledFaceDescriptors"].fromJSON(ld); });
        return new FaceMatcher(labeledDescriptors, json.distanceThreshold);
    };
    return FaceMatcher;
}());

//# sourceMappingURL=FaceMatcher.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js ***!
  \*********************************************************************************/
/*! exports provided: PredictAgeAndGenderTaskBase, PredictAllAgeAndGenderTask, PredictSingleAgeAndGenderTask, PredictAllAgeAndGenderWithFaceAlignmentTask, PredictSingleAgeAndGenderWithFaceAlignmentTask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictAgeAndGenderTaskBase", function() { return PredictAgeAndGenderTaskBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictAllAgeAndGenderTask", function() { return PredictAllAgeAndGenderTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictSingleAgeAndGenderTask", function() { return PredictSingleAgeAndGenderTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictAllAgeAndGenderWithFaceAlignmentTask", function() { return PredictAllAgeAndGenderWithFaceAlignmentTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictSingleAgeAndGenderWithFaceAlignmentTask", function() { return PredictSingleAgeAndGenderWithFaceAlignmentTask; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _factories_WithAge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factories/WithAge */ "./node_modules/face-api.js/build/es6/factories/WithAge.js");
/* harmony import */ var _factories_WithGender__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factories/WithGender */ "./node_modules/face-api.js/build/es6/factories/WithGender.js");
/* harmony import */ var _ComposableTask__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ComposableTask */ "./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js");
/* harmony import */ var _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ComputeFaceDescriptorsTasks */ "./node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js");
/* harmony import */ var _extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extractFacesAndComputeResults */ "./node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js");
/* harmony import */ var _nets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./nets */ "./node_modules/face-api.js/build/es6/globalApi/nets.js");
/* harmony import */ var _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PredictFaceExpressionsTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js");








var PredictAgeAndGenderTaskBase = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictAgeAndGenderTaskBase, _super);
    function PredictAgeAndGenderTaskBase(parentTask, input, extractedFaces) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input;
        _this.extractedFaces = extractedFaces;
        return _this;
    }
    return PredictAgeAndGenderTaskBase;
}(_ComposableTask__WEBPACK_IMPORTED_MODULE_3__["ComposableTask"]));

var PredictAllAgeAndGenderTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictAllAgeAndGenderTask, _super);
    function PredictAllAgeAndGenderTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictAllAgeAndGenderTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResults, ageAndGenderByFace;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResults = _a.sent();
                        return [4 /*yield*/, Object(_extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_5__["extractAllFacesAndComputeResults"])(parentResults, this.input, function (faces) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
                                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, Promise.all(faces.map(function (face) { return _nets__WEBPACK_IMPORTED_MODULE_6__["nets"].ageGenderNet.predictAgeAndGender(face); }))];
                                        case 1: return [2 /*return*/, _a.sent()];
                                    }
                                });
                            }); }, this.extractedFaces)];
                    case 2:
                        ageAndGenderByFace = _a.sent();
                        return [2 /*return*/, parentResults.map(function (parentResult, i) {
                                var _a = ageAndGenderByFace[i], age = _a.age, gender = _a.gender, genderProbability = _a.genderProbability;
                                return Object(_factories_WithAge__WEBPACK_IMPORTED_MODULE_1__["extendWithAge"])(Object(_factories_WithGender__WEBPACK_IMPORTED_MODULE_2__["extendWithGender"])(parentResult, gender, genderProbability), age);
                            })];
                }
            });
        });
    };
    PredictAllAgeAndGenderTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_7__["PredictAllFaceExpressionsTask"](this, this.input);
    };
    return PredictAllAgeAndGenderTask;
}(PredictAgeAndGenderTaskBase));

var PredictSingleAgeAndGenderTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictSingleAgeAndGenderTask, _super);
    function PredictSingleAgeAndGenderTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictSingleAgeAndGenderTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResult, _a, age, gender, genderProbability;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResult = _b.sent();
                        if (!parentResult) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Object(_extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_5__["extractSingleFaceAndComputeResult"])(parentResult, this.input, function (face) { return _nets__WEBPACK_IMPORTED_MODULE_6__["nets"].ageGenderNet.predictAgeAndGender(face); }, this.extractedFaces)];
                    case 2:
                        _a = _b.sent(), age = _a.age, gender = _a.gender, genderProbability = _a.genderProbability;
                        return [2 /*return*/, Object(_factories_WithAge__WEBPACK_IMPORTED_MODULE_1__["extendWithAge"])(Object(_factories_WithGender__WEBPACK_IMPORTED_MODULE_2__["extendWithGender"])(parentResult, gender, genderProbability), age)];
                }
            });
        });
    };
    PredictSingleAgeAndGenderTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_7__["PredictSingleFaceExpressionsTask"](this, this.input);
    };
    return PredictSingleAgeAndGenderTask;
}(PredictAgeAndGenderTaskBase));

var PredictAllAgeAndGenderWithFaceAlignmentTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictAllAgeAndGenderWithFaceAlignmentTask, _super);
    function PredictAllAgeAndGenderWithFaceAlignmentTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictAllAgeAndGenderWithFaceAlignmentTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_7__["PredictAllFaceExpressionsWithFaceAlignmentTask"](this, this.input);
    };
    PredictAllAgeAndGenderWithFaceAlignmentTask.prototype.withFaceDescriptors = function () {
        return new _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_4__["ComputeAllFaceDescriptorsTask"](this, this.input);
    };
    return PredictAllAgeAndGenderWithFaceAlignmentTask;
}(PredictAllAgeAndGenderTask));

var PredictSingleAgeAndGenderWithFaceAlignmentTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictSingleAgeAndGenderWithFaceAlignmentTask, _super);
    function PredictSingleAgeAndGenderWithFaceAlignmentTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictSingleAgeAndGenderWithFaceAlignmentTask.prototype.withFaceExpressions = function () {
        return new _PredictFaceExpressionsTask__WEBPACK_IMPORTED_MODULE_7__["PredictSingleFaceExpressionsWithFaceAlignmentTask"](this, this.input);
    };
    PredictSingleAgeAndGenderWithFaceAlignmentTask.prototype.withFaceDescriptor = function () {
        return new _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_4__["ComputeSingleFaceDescriptorTask"](this, this.input);
    };
    return PredictSingleAgeAndGenderWithFaceAlignmentTask;
}(PredictSingleAgeAndGenderTask));

//# sourceMappingURL=PredictAgeAndGenderTask.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js":
/*!************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js ***!
  \************************************************************************************/
/*! exports provided: PredictFaceExpressionsTaskBase, PredictAllFaceExpressionsTask, PredictSingleFaceExpressionsTask, PredictAllFaceExpressionsWithFaceAlignmentTask, PredictSingleFaceExpressionsWithFaceAlignmentTask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictFaceExpressionsTaskBase", function() { return PredictFaceExpressionsTaskBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictAllFaceExpressionsTask", function() { return PredictAllFaceExpressionsTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictSingleFaceExpressionsTask", function() { return PredictSingleFaceExpressionsTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictAllFaceExpressionsWithFaceAlignmentTask", function() { return PredictAllFaceExpressionsWithFaceAlignmentTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PredictSingleFaceExpressionsWithFaceAlignmentTask", function() { return PredictSingleFaceExpressionsWithFaceAlignmentTask; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _factories_WithFaceExpressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factories/WithFaceExpressions */ "./node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js");
/* harmony import */ var _ComposableTask__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ComposableTask */ "./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js");
/* harmony import */ var _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ComputeFaceDescriptorsTasks */ "./node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js");
/* harmony import */ var _extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./extractFacesAndComputeResults */ "./node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js");
/* harmony import */ var _nets__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nets */ "./node_modules/face-api.js/build/es6/globalApi/nets.js");
/* harmony import */ var _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PredictAgeAndGenderTask */ "./node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js");







var PredictFaceExpressionsTaskBase = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictFaceExpressionsTaskBase, _super);
    function PredictFaceExpressionsTaskBase(parentTask, input, extractedFaces) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input;
        _this.extractedFaces = extractedFaces;
        return _this;
    }
    return PredictFaceExpressionsTaskBase;
}(_ComposableTask__WEBPACK_IMPORTED_MODULE_2__["ComposableTask"]));

var PredictAllFaceExpressionsTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictAllFaceExpressionsTask, _super);
    function PredictAllFaceExpressionsTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictAllFaceExpressionsTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResults, faceExpressionsByFace;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResults = _a.sent();
                        return [4 /*yield*/, Object(_extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_4__["extractAllFacesAndComputeResults"])(parentResults, this.input, function (faces) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
                                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, Promise.all(faces.map(function (face) { return _nets__WEBPACK_IMPORTED_MODULE_5__["nets"].faceExpressionNet.predictExpressions(face); }))];
                                        case 1: return [2 /*return*/, _a.sent()];
                                    }
                                });
                            }); }, this.extractedFaces)];
                    case 2:
                        faceExpressionsByFace = _a.sent();
                        return [2 /*return*/, parentResults.map(function (parentResult, i) { return Object(_factories_WithFaceExpressions__WEBPACK_IMPORTED_MODULE_1__["extendWithFaceExpressions"])(parentResult, faceExpressionsByFace[i]); })];
                }
            });
        });
    };
    PredictAllFaceExpressionsTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_6__["PredictAllAgeAndGenderTask"](this, this.input);
    };
    return PredictAllFaceExpressionsTask;
}(PredictFaceExpressionsTaskBase));

var PredictSingleFaceExpressionsTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictSingleFaceExpressionsTask, _super);
    function PredictSingleFaceExpressionsTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictSingleFaceExpressionsTask.prototype.run = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var parentResult, faceExpressions;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.parentTask];
                    case 1:
                        parentResult = _a.sent();
                        if (!parentResult) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Object(_extractFacesAndComputeResults__WEBPACK_IMPORTED_MODULE_4__["extractSingleFaceAndComputeResult"])(parentResult, this.input, function (face) { return _nets__WEBPACK_IMPORTED_MODULE_5__["nets"].faceExpressionNet.predictExpressions(face); }, this.extractedFaces)];
                    case 2:
                        faceExpressions = _a.sent();
                        return [2 /*return*/, Object(_factories_WithFaceExpressions__WEBPACK_IMPORTED_MODULE_1__["extendWithFaceExpressions"])(parentResult, faceExpressions)];
                }
            });
        });
    };
    PredictSingleFaceExpressionsTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_6__["PredictSingleAgeAndGenderTask"](this, this.input);
    };
    return PredictSingleFaceExpressionsTask;
}(PredictFaceExpressionsTaskBase));

var PredictAllFaceExpressionsWithFaceAlignmentTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictAllFaceExpressionsWithFaceAlignmentTask, _super);
    function PredictAllFaceExpressionsWithFaceAlignmentTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictAllFaceExpressionsWithFaceAlignmentTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_6__["PredictAllAgeAndGenderWithFaceAlignmentTask"](this, this.input);
    };
    PredictAllFaceExpressionsWithFaceAlignmentTask.prototype.withFaceDescriptors = function () {
        return new _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_3__["ComputeAllFaceDescriptorsTask"](this, this.input);
    };
    return PredictAllFaceExpressionsWithFaceAlignmentTask;
}(PredictAllFaceExpressionsTask));

var PredictSingleFaceExpressionsWithFaceAlignmentTask = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PredictSingleFaceExpressionsWithFaceAlignmentTask, _super);
    function PredictSingleFaceExpressionsWithFaceAlignmentTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PredictSingleFaceExpressionsWithFaceAlignmentTask.prototype.withAgeAndGender = function () {
        return new _PredictAgeAndGenderTask__WEBPACK_IMPORTED_MODULE_6__["PredictSingleAgeAndGenderWithFaceAlignmentTask"](this, this.input);
    };
    PredictSingleFaceExpressionsWithFaceAlignmentTask.prototype.withFaceDescriptor = function () {
        return new _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_3__["ComputeSingleFaceDescriptorTask"](this, this.input);
    };
    return PredictSingleFaceExpressionsWithFaceAlignmentTask;
}(PredictSingleFaceExpressionsTask));

//# sourceMappingURL=PredictFaceExpressionsTask.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/allFaces.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/allFaces.js ***!
  \******************************************************************/
/*! exports provided: allFacesSsdMobilenetv1, allFacesTinyYolov2, allFacesMtcnn, allFaces */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allFacesSsdMobilenetv1", function() { return allFacesSsdMobilenetv1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allFacesTinyYolov2", function() { return allFacesTinyYolov2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allFacesMtcnn", function() { return allFacesMtcnn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allFaces", function() { return allFaces; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _mtcnn_MtcnnOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mtcnn/MtcnnOptions */ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js");
/* harmony import */ var _ssdMobilenetv1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ssdMobilenetv1 */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/index.js");
/* harmony import */ var _tinyYolov2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tinyYolov2 */ "./node_modules/face-api.js/build/es6/tinyYolov2/index.js");
/* harmony import */ var _detectFaces__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./detectFaces */ "./node_modules/face-api.js/build/es6/globalApi/detectFaces.js");





// export allFaces API for backward compatibility
function allFacesSsdMobilenetv1(input, minConfidence) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0:
                    console.warn('allFacesSsdMobilenetv1 is deprecated and will be removed soon, use the high level api instead');
                    return [4 /*yield*/, Object(_detectFaces__WEBPACK_IMPORTED_MODULE_4__["detectAllFaces"])(input, new _ssdMobilenetv1__WEBPACK_IMPORTED_MODULE_2__["SsdMobilenetv1Options"](minConfidence ? { minConfidence: minConfidence } : {}))
                            .withFaceLandmarks()
                            .withFaceDescriptors()];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function allFacesTinyYolov2(input, forwardParams) {
    if (forwardParams === void 0) { forwardParams = {}; }
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0:
                    console.warn('allFacesTinyYolov2 is deprecated and will be removed soon, use the high level api instead');
                    return [4 /*yield*/, Object(_detectFaces__WEBPACK_IMPORTED_MODULE_4__["detectAllFaces"])(input, new _tinyYolov2__WEBPACK_IMPORTED_MODULE_3__["TinyYolov2Options"](forwardParams))
                            .withFaceLandmarks()
                            .withFaceDescriptors()];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function allFacesMtcnn(input, forwardParams) {
    if (forwardParams === void 0) { forwardParams = {}; }
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0:
                    console.warn('allFacesMtcnn is deprecated and will be removed soon, use the high level api instead');
                    return [4 /*yield*/, Object(_detectFaces__WEBPACK_IMPORTED_MODULE_4__["detectAllFaces"])(input, new _mtcnn_MtcnnOptions__WEBPACK_IMPORTED_MODULE_1__["MtcnnOptions"](forwardParams))
                            .withFaceLandmarks()
                            .withFaceDescriptors()];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
var allFaces = allFacesSsdMobilenetv1;
//# sourceMappingURL=allFaces.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/detectFaces.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/detectFaces.js ***!
  \*********************************************************************/
/*! exports provided: detectSingleFace, detectAllFaces */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectSingleFace", function() { return detectSingleFace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectAllFaces", function() { return detectAllFaces; });
/* harmony import */ var _ssdMobilenetv1_SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ssdMobilenetv1/SsdMobilenetv1Options */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js");
/* harmony import */ var _DetectFacesTasks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DetectFacesTasks */ "./node_modules/face-api.js/build/es6/globalApi/DetectFacesTasks.js");


function detectSingleFace(input, options) {
    if (options === void 0) { options = new _ssdMobilenetv1_SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_0__["SsdMobilenetv1Options"](); }
    return new _DetectFacesTasks__WEBPACK_IMPORTED_MODULE_1__["DetectSingleFaceTask"](input, options);
}
function detectAllFaces(input, options) {
    if (options === void 0) { options = new _ssdMobilenetv1_SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_0__["SsdMobilenetv1Options"](); }
    return new _DetectFacesTasks__WEBPACK_IMPORTED_MODULE_1__["DetectAllFacesTask"](input, options);
}
//# sourceMappingURL=detectFaces.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js ***!
  \***************************************************************************************/
/*! exports provided: extractAllFacesAndComputeResults, extractSingleFaceAndComputeResult */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractAllFacesAndComputeResults", function() { return extractAllFacesAndComputeResults; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractSingleFaceAndComputeResult", function() { return extractSingleFaceAndComputeResult; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../factories/WithFaceLandmarks */ "./node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js");




function extractAllFacesAndComputeResults(parentResults, input, computeResults, extractedFaces, getRectForAlignment) {
    if (getRectForAlignment === void 0) { getRectForAlignment = function (_a) {
        var alignedRect = _a.alignedRect;
        return alignedRect;
    }; }
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var faceBoxes, faces, _a, _b, results;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_c) {
            switch (_c.label) {
                case 0:
                    faceBoxes = parentResults.map(function (parentResult) {
                        return Object(_factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_3__["isWithFaceLandmarks"])(parentResult)
                            ? getRectForAlignment(parentResult)
                            : parentResult.detection;
                    });
                    _a = extractedFaces;
                    if (_a) return [3 /*break*/, 5];
                    if (!(input instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Tensor"])) return [3 /*break*/, 2];
                    return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["extractFaceTensors"])(input, faceBoxes)];
                case 1:
                    _b = _c.sent();
                    return [3 /*break*/, 4];
                case 2: return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_2__["extractFaces"])(input, faceBoxes)];
                case 3:
                    _b = _c.sent();
                    _c.label = 4;
                case 4:
                    _a = (_b);
                    _c.label = 5;
                case 5:
                    faces = _a;
                    return [4 /*yield*/, computeResults(faces)];
                case 6:
                    results = _c.sent();
                    faces.forEach(function (f) { return f instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["Tensor"] && f.dispose(); });
                    return [2 /*return*/, results];
            }
        });
    });
}
function extractSingleFaceAndComputeResult(parentResult, input, computeResult, extractedFaces, getRectForAlignment) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var _this = this;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            return [2 /*return*/, extractAllFacesAndComputeResults([parentResult], input, function (faces) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                    return [2 /*return*/, computeResult(faces[0])];
                }); }); }, extractedFaces, getRectForAlignment)];
        });
    });
}
//# sourceMappingURL=extractFacesAndComputeResults.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/index.js ***!
  \***************************************************************/
/*! exports provided: allFacesSsdMobilenetv1, allFacesTinyYolov2, allFacesMtcnn, allFaces, ComposableTask, ComputeFaceDescriptorsTaskBase, ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask, detectSingleFace, detectAllFaces, DetectFacesTaskBase, DetectAllFacesTask, DetectSingleFaceTask, DetectFaceLandmarksTaskBase, DetectAllFaceLandmarksTask, DetectSingleFaceLandmarksTask, FaceMatcher, nets, ssdMobilenetv1, tinyFaceDetector, tinyYolov2, mtcnn, detectFaceLandmarks, detectFaceLandmarksTiny, computeFaceDescriptor, recognizeFaceExpressions, predictAgeAndGender, loadSsdMobilenetv1Model, loadTinyFaceDetectorModel, loadMtcnnModel, loadTinyYolov2Model, loadFaceLandmarkModel, loadFaceLandmarkTinyModel, loadFaceRecognitionModel, loadFaceExpressionModel, loadAgeGenderModel, loadFaceDetectionModel, locateFaces, detectLandmarks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _allFaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./allFaces */ "./node_modules/face-api.js/build/es6/globalApi/allFaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFacesSsdMobilenetv1", function() { return _allFaces__WEBPACK_IMPORTED_MODULE_0__["allFacesSsdMobilenetv1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFacesTinyYolov2", function() { return _allFaces__WEBPACK_IMPORTED_MODULE_0__["allFacesTinyYolov2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFacesMtcnn", function() { return _allFaces__WEBPACK_IMPORTED_MODULE_0__["allFacesMtcnn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFaces", function() { return _allFaces__WEBPACK_IMPORTED_MODULE_0__["allFaces"]; });

/* harmony import */ var _ComposableTask__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComposableTask */ "./node_modules/face-api.js/build/es6/globalApi/ComposableTask.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComposableTask", function() { return _ComposableTask__WEBPACK_IMPORTED_MODULE_1__["ComposableTask"]; });

/* harmony import */ var _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ComputeFaceDescriptorsTasks */ "./node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComputeFaceDescriptorsTaskBase", function() { return _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_2__["ComputeFaceDescriptorsTaskBase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComputeAllFaceDescriptorsTask", function() { return _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_2__["ComputeAllFaceDescriptorsTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComputeSingleFaceDescriptorTask", function() { return _ComputeFaceDescriptorsTasks__WEBPACK_IMPORTED_MODULE_2__["ComputeSingleFaceDescriptorTask"]; });

/* harmony import */ var _detectFaces__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./detectFaces */ "./node_modules/face-api.js/build/es6/globalApi/detectFaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectSingleFace", function() { return _detectFaces__WEBPACK_IMPORTED_MODULE_3__["detectSingleFace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectAllFaces", function() { return _detectFaces__WEBPACK_IMPORTED_MODULE_3__["detectAllFaces"]; });

/* harmony import */ var _DetectFacesTasks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DetectFacesTasks */ "./node_modules/face-api.js/build/es6/globalApi/DetectFacesTasks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectFacesTaskBase", function() { return _DetectFacesTasks__WEBPACK_IMPORTED_MODULE_4__["DetectFacesTaskBase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectAllFacesTask", function() { return _DetectFacesTasks__WEBPACK_IMPORTED_MODULE_4__["DetectAllFacesTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectSingleFaceTask", function() { return _DetectFacesTasks__WEBPACK_IMPORTED_MODULE_4__["DetectSingleFaceTask"]; });

/* harmony import */ var _DetectFaceLandmarksTasks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DetectFaceLandmarksTasks */ "./node_modules/face-api.js/build/es6/globalApi/DetectFaceLandmarksTasks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectFaceLandmarksTaskBase", function() { return _DetectFaceLandmarksTasks__WEBPACK_IMPORTED_MODULE_5__["DetectFaceLandmarksTaskBase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectAllFaceLandmarksTask", function() { return _DetectFaceLandmarksTasks__WEBPACK_IMPORTED_MODULE_5__["DetectAllFaceLandmarksTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectSingleFaceLandmarksTask", function() { return _DetectFaceLandmarksTasks__WEBPACK_IMPORTED_MODULE_5__["DetectSingleFaceLandmarksTask"]; });

/* harmony import */ var _FaceMatcher__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FaceMatcher */ "./node_modules/face-api.js/build/es6/globalApi/FaceMatcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceMatcher", function() { return _FaceMatcher__WEBPACK_IMPORTED_MODULE_6__["FaceMatcher"]; });

/* harmony import */ var _nets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./nets */ "./node_modules/face-api.js/build/es6/globalApi/nets.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nets", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["nets"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ssdMobilenetv1", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["ssdMobilenetv1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tinyFaceDetector", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["tinyFaceDetector"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tinyYolov2", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["tinyYolov2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mtcnn", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["mtcnn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectFaceLandmarks", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["detectFaceLandmarks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectFaceLandmarksTiny", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["detectFaceLandmarksTiny"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeFaceDescriptor", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["computeFaceDescriptor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "recognizeFaceExpressions", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["recognizeFaceExpressions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "predictAgeAndGender", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["predictAgeAndGender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadSsdMobilenetv1Model", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadSsdMobilenetv1Model"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadTinyFaceDetectorModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadTinyFaceDetectorModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadMtcnnModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadMtcnnModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadTinyYolov2Model", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadTinyYolov2Model"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceLandmarkModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadFaceLandmarkModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceLandmarkTinyModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadFaceLandmarkTinyModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceRecognitionModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadFaceRecognitionModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceExpressionModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadFaceExpressionModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadAgeGenderModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadAgeGenderModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceDetectionModel", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["loadFaceDetectionModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "locateFaces", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["locateFaces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectLandmarks", function() { return _nets__WEBPACK_IMPORTED_MODULE_7__["detectLandmarks"]; });









//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/globalApi/nets.js":
/*!**************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/globalApi/nets.js ***!
  \**************************************************************/
/*! exports provided: nets, ssdMobilenetv1, tinyFaceDetector, tinyYolov2, mtcnn, detectFaceLandmarks, detectFaceLandmarksTiny, computeFaceDescriptor, recognizeFaceExpressions, predictAgeAndGender, loadSsdMobilenetv1Model, loadTinyFaceDetectorModel, loadMtcnnModel, loadTinyYolov2Model, loadFaceLandmarkModel, loadFaceLandmarkTinyModel, loadFaceRecognitionModel, loadFaceExpressionModel, loadAgeGenderModel, loadFaceDetectionModel, locateFaces, detectLandmarks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nets", function() { return nets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ssdMobilenetv1", function() { return ssdMobilenetv1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tinyFaceDetector", function() { return tinyFaceDetector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tinyYolov2", function() { return tinyYolov2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mtcnn", function() { return mtcnn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectFaceLandmarks", function() { return detectFaceLandmarks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectFaceLandmarksTiny", function() { return detectFaceLandmarksTiny; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeFaceDescriptor", function() { return computeFaceDescriptor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recognizeFaceExpressions", function() { return recognizeFaceExpressions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "predictAgeAndGender", function() { return predictAgeAndGender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadSsdMobilenetv1Model", function() { return loadSsdMobilenetv1Model; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadTinyFaceDetectorModel", function() { return loadTinyFaceDetectorModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadMtcnnModel", function() { return loadMtcnnModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadTinyYolov2Model", function() { return loadTinyYolov2Model; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFaceLandmarkModel", function() { return loadFaceLandmarkModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFaceLandmarkTinyModel", function() { return loadFaceLandmarkTinyModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFaceRecognitionModel", function() { return loadFaceRecognitionModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFaceExpressionModel", function() { return loadFaceExpressionModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadAgeGenderModel", function() { return loadAgeGenderModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFaceDetectionModel", function() { return loadFaceDetectionModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locateFaces", function() { return locateFaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectLandmarks", function() { return detectLandmarks; });
/* harmony import */ var _ageGenderNet_AgeGenderNet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ageGenderNet/AgeGenderNet */ "./node_modules/face-api.js/build/es6/ageGenderNet/AgeGenderNet.js");
/* harmony import */ var _faceExpressionNet_FaceExpressionNet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../faceExpressionNet/FaceExpressionNet */ "./node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressionNet.js");
/* harmony import */ var _faceLandmarkNet_FaceLandmark68Net__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../faceLandmarkNet/FaceLandmark68Net */ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68Net.js");
/* harmony import */ var _faceLandmarkNet_FaceLandmark68TinyNet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../faceLandmarkNet/FaceLandmark68TinyNet */ "./node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68TinyNet.js");
/* harmony import */ var _faceRecognitionNet_FaceRecognitionNet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../faceRecognitionNet/FaceRecognitionNet */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/FaceRecognitionNet.js");
/* harmony import */ var _mtcnn_Mtcnn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../mtcnn/Mtcnn */ "./node_modules/face-api.js/build/es6/mtcnn/Mtcnn.js");
/* harmony import */ var _ssdMobilenetv1_SsdMobilenetv1__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../ssdMobilenetv1/SsdMobilenetv1 */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1.js");
/* harmony import */ var _tinyFaceDetector_TinyFaceDetector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tinyFaceDetector/TinyFaceDetector */ "./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetector.js");
/* harmony import */ var _tinyYolov2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tinyYolov2 */ "./node_modules/face-api.js/build/es6/tinyYolov2/index.js");









var nets = {
    ssdMobilenetv1: new _ssdMobilenetv1_SsdMobilenetv1__WEBPACK_IMPORTED_MODULE_6__["SsdMobilenetv1"](),
    tinyFaceDetector: new _tinyFaceDetector_TinyFaceDetector__WEBPACK_IMPORTED_MODULE_7__["TinyFaceDetector"](),
    tinyYolov2: new _tinyYolov2__WEBPACK_IMPORTED_MODULE_8__["TinyYolov2"](),
    mtcnn: new _mtcnn_Mtcnn__WEBPACK_IMPORTED_MODULE_5__["Mtcnn"](),
    faceLandmark68Net: new _faceLandmarkNet_FaceLandmark68Net__WEBPACK_IMPORTED_MODULE_2__["FaceLandmark68Net"](),
    faceLandmark68TinyNet: new _faceLandmarkNet_FaceLandmark68TinyNet__WEBPACK_IMPORTED_MODULE_3__["FaceLandmark68TinyNet"](),
    faceRecognitionNet: new _faceRecognitionNet_FaceRecognitionNet__WEBPACK_IMPORTED_MODULE_4__["FaceRecognitionNet"](),
    faceExpressionNet: new _faceExpressionNet_FaceExpressionNet__WEBPACK_IMPORTED_MODULE_1__["FaceExpressionNet"](),
    ageGenderNet: new _ageGenderNet_AgeGenderNet__WEBPACK_IMPORTED_MODULE_0__["AgeGenderNet"]()
};
/**
 * Attempts to detect all faces in an image using SSD Mobilenetv1 Network.
 *
 * @param input The input image.
 * @param options (optional, default: see SsdMobilenetv1Options constructor for default parameters).
 * @returns Bounding box of each face with score.
 */
var ssdMobilenetv1 = function (input, options) {
    return nets.ssdMobilenetv1.locateFaces(input, options);
};
/**
 * Attempts to detect all faces in an image using the Tiny Face Detector.
 *
 * @param input The input image.
 * @param options (optional, default: see TinyFaceDetectorOptions constructor for default parameters).
 * @returns Bounding box of each face with score.
 */
var tinyFaceDetector = function (input, options) {
    return nets.tinyFaceDetector.locateFaces(input, options);
};
/**
 * Attempts to detect all faces in an image using the Tiny Yolov2 Network.
 *
 * @param input The input image.
 * @param options (optional, default: see TinyYolov2Options constructor for default parameters).
 * @returns Bounding box of each face with score.
 */
var tinyYolov2 = function (input, options) {
    return nets.tinyYolov2.locateFaces(input, options);
};
/**
 * Attempts to detect all faces in an image and the 5 point face landmarks
 * of each detected face using the MTCNN Network.
 *
 * @param input The input image.
 * @param options (optional, default: see MtcnnOptions constructor for default parameters).
 * @returns Bounding box of each face with score and 5 point face landmarks.
 */
var mtcnn = function (input, options) {
    return nets.mtcnn.forward(input, options);
};
/**
 * Detects the 68 point face landmark positions of the face shown in an image.
 *
 * @param inputs The face image extracted from the bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns 68 point face landmarks or array thereof in case of batch input.
 */
var detectFaceLandmarks = function (input) {
    return nets.faceLandmark68Net.detectLandmarks(input);
};
/**
 * Detects the 68 point face landmark positions of the face shown in an image
 * using a tinier version of the 68 point face landmark model, which is slightly
 * faster at inference, but also slightly less accurate.
 *
 * @param inputs The face image extracted from the bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns 68 point face landmarks or array thereof in case of batch input.
 */
var detectFaceLandmarksTiny = function (input) {
    return nets.faceLandmark68TinyNet.detectLandmarks(input);
};
/**
 * Computes a 128 entry vector (face descriptor / face embeddings) from the face shown in an image,
 * which uniquely represents the features of that persons face. The computed face descriptor can
 * be used to measure the similarity between faces, by computing the euclidean distance of two
 * face descriptors.
 *
 * @param inputs The face image extracted from the aligned bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns Face descriptor with 128 entries or array thereof in case of batch input.
 */
var computeFaceDescriptor = function (input) {
    return nets.faceRecognitionNet.computeFaceDescriptor(input);
};
/**
 * Recognizes the facial expressions from a face image.
 *
 * @param inputs The face image extracted from the bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns Facial expressions with corresponding probabilities or array thereof in case of batch input.
 */
var recognizeFaceExpressions = function (input) {
    return nets.faceExpressionNet.predictExpressions(input);
};
/**
 * Predicts age and gender from a face image.
 *
 * @param inputs The face image extracted from the bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns Predictions with age, gender and gender probability or array thereof in case of batch input.
 */
var predictAgeAndGender = function (input) {
    return nets.ageGenderNet.predictAgeAndGender(input);
};
var loadSsdMobilenetv1Model = function (url) { return nets.ssdMobilenetv1.load(url); };
var loadTinyFaceDetectorModel = function (url) { return nets.tinyFaceDetector.load(url); };
var loadMtcnnModel = function (url) { return nets.mtcnn.load(url); };
var loadTinyYolov2Model = function (url) { return nets.tinyYolov2.load(url); };
var loadFaceLandmarkModel = function (url) { return nets.faceLandmark68Net.load(url); };
var loadFaceLandmarkTinyModel = function (url) { return nets.faceLandmark68TinyNet.load(url); };
var loadFaceRecognitionModel = function (url) { return nets.faceRecognitionNet.load(url); };
var loadFaceExpressionModel = function (url) { return nets.faceExpressionNet.load(url); };
var loadAgeGenderModel = function (url) { return nets.ageGenderNet.load(url); };
// backward compatibility
var loadFaceDetectionModel = loadSsdMobilenetv1Model;
var locateFaces = ssdMobilenetv1;
var detectLandmarks = detectFaceLandmarks;
//# sourceMappingURL=nets.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/index.js ***!
  \*****************************************************/
/*! exports provided: draw, utils, tf, AgeGenderNet, Gender, BoundingBox, Box, Dimensions, FaceDetection, FaceLandmarks, FaceLandmarks5, FaceLandmarks68, FaceMatch, LabeledBox, LabeledFaceDescriptors, ObjectDetection, Point, PredictedBox, Rect, awaitMediaLoaded, bufferToImage, createCanvas, createCanvasFromMedia, extractFaces, extractFaceTensors, fetchImage, fetchJson, fetchNetWeights, fetchOrThrow, getContext2dOrThrow, getMediaDimensions, imageTensorToCanvas, imageToSquare, isMediaElement, isMediaLoaded, loadWeightMap, matchDimensions, NetInput, resolveInput, toNetInput, env, FaceExpressionNet, FACE_EXPRESSION_LABELS, FaceExpressions, FaceLandmark68Net, FaceLandmark68TinyNet, FaceLandmarkNet, FaceRecognitionNet, createFaceRecognitionNet, extendWithFaceDescriptor, isWithFaceDetection, extendWithFaceDetection, isWithFaceExpressions, extendWithFaceExpressions, isWithFaceLandmarks, extendWithFaceLandmarks, isWithAge, extendWithAge, isWithGender, extendWithGender, allFacesSsdMobilenetv1, allFacesTinyYolov2, allFacesMtcnn, allFaces, ComposableTask, ComputeFaceDescriptorsTaskBase, ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask, detectSingleFace, detectAllFaces, DetectFacesTaskBase, DetectAllFacesTask, DetectSingleFaceTask, DetectFaceLandmarksTaskBase, DetectAllFaceLandmarksTask, DetectSingleFaceLandmarksTask, FaceMatcher, nets, ssdMobilenetv1, tinyFaceDetector, tinyYolov2, mtcnn, detectFaceLandmarks, detectFaceLandmarksTiny, computeFaceDescriptor, recognizeFaceExpressions, predictAgeAndGender, loadSsdMobilenetv1Model, loadTinyFaceDetectorModel, loadMtcnnModel, loadTinyYolov2Model, loadFaceLandmarkModel, loadFaceLandmarkTinyModel, loadFaceRecognitionModel, loadFaceExpressionModel, loadAgeGenderModel, loadFaceDetectionModel, locateFaces, detectLandmarks, Mtcnn, MtcnnOptions, createMtcnn, iou, minBbox, nonMaxSuppression, normalize, padToSquare, shuffleArray, sigmoid, inverseSigmoid, SsdMobilenetv1, SsdMobilenetv1Options, createSsdMobilenetv1, createFaceDetectionNet, FaceDetectionNet, TinyFaceDetector, TinyFaceDetectorOptions, createTinyFaceDetector, TinyYolov2SizeType, TinyYolov2Options, validateConfig, TinyYolov2, createTinyYolov2, euclideanDistance, NeuralNetwork, resizeResults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "tf", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./draw */ "./node_modules/face-api.js/build/es6/draw/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return _draw__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "utils", function() { return _utils__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _ageGenderNet_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ageGenderNet/index */ "./node_modules/face-api.js/build/es6/ageGenderNet/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AgeGenderNet", function() { return _ageGenderNet_index__WEBPACK_IMPORTED_MODULE_3__["AgeGenderNet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Gender", function() { return _ageGenderNet_index__WEBPACK_IMPORTED_MODULE_3__["Gender"]; });

/* harmony import */ var _classes_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./classes/index */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoundingBox", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["BoundingBox"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Box", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["Box"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Dimensions", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["Dimensions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceDetection", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["FaceDetection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["FaceLandmarks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks5", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["FaceLandmarks5"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarks68", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["FaceLandmarks68"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceMatch", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["FaceMatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LabeledBox", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["LabeledBox"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LabeledFaceDescriptors", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["LabeledFaceDescriptors"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ObjectDetection", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["ObjectDetection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["Point"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PredictedBox", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["PredictedBox"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Rect", function() { return _classes_index__WEBPACK_IMPORTED_MODULE_4__["Rect"]; });

/* harmony import */ var _dom_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dom/index */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "awaitMediaLoaded", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["awaitMediaLoaded"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferToImage", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["bufferToImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createCanvas", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["createCanvas"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createCanvasFromMedia", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["createCanvasFromMedia"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractFaces", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["extractFaces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractFaceTensors", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["extractFaceTensors"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchImage", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["fetchImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchJson", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["fetchJson"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchNetWeights", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["fetchNetWeights"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchOrThrow", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["fetchOrThrow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContext2dOrThrow", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["getContext2dOrThrow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMediaDimensions", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["getMediaDimensions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "imageTensorToCanvas", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["imageTensorToCanvas"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "imageToSquare", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["imageToSquare"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMediaElement", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["isMediaElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMediaLoaded", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["isMediaLoaded"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadWeightMap", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["loadWeightMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matchDimensions", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["matchDimensions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NetInput", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["NetInput"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveInput", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["resolveInput"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toNetInput", function() { return _dom_index__WEBPACK_IMPORTED_MODULE_5__["toNetInput"]; });

/* harmony import */ var _env_index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./env/index */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "env", function() { return _env_index__WEBPACK_IMPORTED_MODULE_6__["env"]; });

/* harmony import */ var _faceExpressionNet_index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./faceExpressionNet/index */ "./node_modules/face-api.js/build/es6/faceExpressionNet/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceExpressionNet", function() { return _faceExpressionNet_index__WEBPACK_IMPORTED_MODULE_7__["FaceExpressionNet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FACE_EXPRESSION_LABELS", function() { return _faceExpressionNet_index__WEBPACK_IMPORTED_MODULE_7__["FACE_EXPRESSION_LABELS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceExpressions", function() { return _faceExpressionNet_index__WEBPACK_IMPORTED_MODULE_7__["FaceExpressions"]; });

/* harmony import */ var _faceLandmarkNet_index__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./faceLandmarkNet/index */ "./node_modules/face-api.js/build/es6/faceLandmarkNet/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmark68Net", function() { return _faceLandmarkNet_index__WEBPACK_IMPORTED_MODULE_8__["FaceLandmark68Net"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmark68TinyNet", function() { return _faceLandmarkNet_index__WEBPACK_IMPORTED_MODULE_8__["FaceLandmark68TinyNet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceLandmarkNet", function() { return _faceLandmarkNet_index__WEBPACK_IMPORTED_MODULE_8__["FaceLandmarkNet"]; });

/* harmony import */ var _faceRecognitionNet_index__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./faceRecognitionNet/index */ "./node_modules/face-api.js/build/es6/faceRecognitionNet/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceRecognitionNet", function() { return _faceRecognitionNet_index__WEBPACK_IMPORTED_MODULE_9__["FaceRecognitionNet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createFaceRecognitionNet", function() { return _faceRecognitionNet_index__WEBPACK_IMPORTED_MODULE_9__["createFaceRecognitionNet"]; });

/* harmony import */ var _factories_index__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./factories/index */ "./node_modules/face-api.js/build/es6/factories/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceDescriptor", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["extendWithFaceDescriptor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithFaceDetection", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["isWithFaceDetection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceDetection", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["extendWithFaceDetection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithFaceExpressions", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["isWithFaceExpressions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceExpressions", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["extendWithFaceExpressions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithFaceLandmarks", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["isWithFaceLandmarks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithFaceLandmarks", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["extendWithFaceLandmarks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithAge", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["isWithAge"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithAge", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["extendWithAge"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWithGender", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["isWithGender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendWithGender", function() { return _factories_index__WEBPACK_IMPORTED_MODULE_10__["extendWithGender"]; });

/* harmony import */ var _globalApi_index__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./globalApi/index */ "./node_modules/face-api.js/build/es6/globalApi/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFacesSsdMobilenetv1", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["allFacesSsdMobilenetv1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFacesTinyYolov2", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["allFacesTinyYolov2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFacesMtcnn", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["allFacesMtcnn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allFaces", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["allFaces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComposableTask", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["ComposableTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComputeFaceDescriptorsTaskBase", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["ComputeFaceDescriptorsTaskBase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComputeAllFaceDescriptorsTask", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["ComputeAllFaceDescriptorsTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComputeSingleFaceDescriptorTask", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["ComputeSingleFaceDescriptorTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectSingleFace", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["detectSingleFace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectAllFaces", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["detectAllFaces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectFacesTaskBase", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["DetectFacesTaskBase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectAllFacesTask", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["DetectAllFacesTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectSingleFaceTask", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["DetectSingleFaceTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectFaceLandmarksTaskBase", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["DetectFaceLandmarksTaskBase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectAllFaceLandmarksTask", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["DetectAllFaceLandmarksTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DetectSingleFaceLandmarksTask", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["DetectSingleFaceLandmarksTask"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceMatcher", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["FaceMatcher"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nets", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["nets"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ssdMobilenetv1", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["ssdMobilenetv1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tinyFaceDetector", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["tinyFaceDetector"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tinyYolov2", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["tinyYolov2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mtcnn", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["mtcnn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectFaceLandmarks", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["detectFaceLandmarks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectFaceLandmarksTiny", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["detectFaceLandmarksTiny"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeFaceDescriptor", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["computeFaceDescriptor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "recognizeFaceExpressions", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["recognizeFaceExpressions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "predictAgeAndGender", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["predictAgeAndGender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadSsdMobilenetv1Model", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadSsdMobilenetv1Model"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadTinyFaceDetectorModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadTinyFaceDetectorModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadMtcnnModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadMtcnnModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadTinyYolov2Model", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadTinyYolov2Model"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceLandmarkModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadFaceLandmarkModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceLandmarkTinyModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadFaceLandmarkTinyModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceRecognitionModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadFaceRecognitionModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceExpressionModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadFaceExpressionModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadAgeGenderModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadAgeGenderModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFaceDetectionModel", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["loadFaceDetectionModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "locateFaces", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["locateFaces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectLandmarks", function() { return _globalApi_index__WEBPACK_IMPORTED_MODULE_11__["detectLandmarks"]; });

/* harmony import */ var _mtcnn_index__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mtcnn/index */ "./node_modules/face-api.js/build/es6/mtcnn/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Mtcnn", function() { return _mtcnn_index__WEBPACK_IMPORTED_MODULE_12__["Mtcnn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MtcnnOptions", function() { return _mtcnn_index__WEBPACK_IMPORTED_MODULE_12__["MtcnnOptions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createMtcnn", function() { return _mtcnn_index__WEBPACK_IMPORTED_MODULE_12__["createMtcnn"]; });

/* harmony import */ var _ops_index__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./ops/index */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "iou", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["iou"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "minBbox", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["minBbox"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nonMaxSuppression", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["nonMaxSuppression"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["normalize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padToSquare", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["padToSquare"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffleArray", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["shuffleArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sigmoid", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["sigmoid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inverseSigmoid", function() { return _ops_index__WEBPACK_IMPORTED_MODULE_13__["inverseSigmoid"]; });

/* harmony import */ var _ssdMobilenetv1_index__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ssdMobilenetv1/index */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SsdMobilenetv1", function() { return _ssdMobilenetv1_index__WEBPACK_IMPORTED_MODULE_14__["SsdMobilenetv1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SsdMobilenetv1Options", function() { return _ssdMobilenetv1_index__WEBPACK_IMPORTED_MODULE_14__["SsdMobilenetv1Options"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createSsdMobilenetv1", function() { return _ssdMobilenetv1_index__WEBPACK_IMPORTED_MODULE_14__["createSsdMobilenetv1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createFaceDetectionNet", function() { return _ssdMobilenetv1_index__WEBPACK_IMPORTED_MODULE_14__["createFaceDetectionNet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceDetectionNet", function() { return _ssdMobilenetv1_index__WEBPACK_IMPORTED_MODULE_14__["FaceDetectionNet"]; });

/* harmony import */ var _tinyFaceDetector_index__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tinyFaceDetector/index */ "./node_modules/face-api.js/build/es6/tinyFaceDetector/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyFaceDetector", function() { return _tinyFaceDetector_index__WEBPACK_IMPORTED_MODULE_15__["TinyFaceDetector"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyFaceDetectorOptions", function() { return _tinyFaceDetector_index__WEBPACK_IMPORTED_MODULE_15__["TinyFaceDetectorOptions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createTinyFaceDetector", function() { return _tinyFaceDetector_index__WEBPACK_IMPORTED_MODULE_15__["createTinyFaceDetector"]; });

/* harmony import */ var _tinyYolov2_index__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./tinyYolov2/index */ "./node_modules/face-api.js/build/es6/tinyYolov2/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2SizeType", function() { return _tinyYolov2_index__WEBPACK_IMPORTED_MODULE_16__["TinyYolov2SizeType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2Options", function() { return _tinyYolov2_index__WEBPACK_IMPORTED_MODULE_16__["TinyYolov2Options"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "validateConfig", function() { return _tinyYolov2_index__WEBPACK_IMPORTED_MODULE_16__["validateConfig"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2", function() { return _tinyYolov2_index__WEBPACK_IMPORTED_MODULE_16__["TinyYolov2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createTinyYolov2", function() { return _tinyYolov2_index__WEBPACK_IMPORTED_MODULE_16__["createTinyYolov2"]; });

/* harmony import */ var _euclideanDistance__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./euclideanDistance */ "./node_modules/face-api.js/build/es6/euclideanDistance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "euclideanDistance", function() { return _euclideanDistance__WEBPACK_IMPORTED_MODULE_17__["euclideanDistance"]; });

/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NeuralNetwork", function() { return _NeuralNetwork__WEBPACK_IMPORTED_MODULE_18__["NeuralNetwork"]; });

/* harmony import */ var _resizeResults__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./resizeResults */ "./node_modules/face-api.js/build/es6/resizeResults.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resizeResults", function() { return _resizeResults__WEBPACK_IMPORTED_MODULE_19__["resizeResults"]; });






















//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/Mtcnn.js":
/*!***********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/Mtcnn.js ***!
  \***********************************************************/
/*! exports provided: Mtcnn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mtcnn", function() { return Mtcnn; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _classes_FaceLandmarks5__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../classes/FaceLandmarks5 */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks5.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _factories__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../factories */ "./node_modules/face-api.js/build/es6/factories/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _bgrToRgbTensor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./bgrToRgbTensor */ "./node_modules/face-api.js/build/es6/mtcnn/bgrToRgbTensor.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./config */ "./node_modules/face-api.js/build/es6/mtcnn/config.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/mtcnn/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/mtcnn/extractParamsFromWeigthMap.js");
/* harmony import */ var _getSizesForScale__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./getSizesForScale */ "./node_modules/face-api.js/build/es6/mtcnn/getSizesForScale.js");
/* harmony import */ var _MtcnnOptions__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./MtcnnOptions */ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js");
/* harmony import */ var _pyramidDown__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./pyramidDown */ "./node_modules/face-api.js/build/es6/mtcnn/pyramidDown.js");
/* harmony import */ var _stage1__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./stage1 */ "./node_modules/face-api.js/build/es6/mtcnn/stage1.js");
/* harmony import */ var _stage2__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./stage2 */ "./node_modules/face-api.js/build/es6/mtcnn/stage2.js");
/* harmony import */ var _stage3__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./stage3 */ "./node_modules/face-api.js/build/es6/mtcnn/stage3.js");


















var Mtcnn = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(Mtcnn, _super);
    function Mtcnn() {
        return _super.call(this, 'Mtcnn') || this;
    }
    Mtcnn.prototype.load = function (weightsOrUrl) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                console.warn('mtcnn is deprecated and will be removed soon');
                return [2 /*return*/, _super.prototype.load.call(this, weightsOrUrl)];
            });
        });
    };
    Mtcnn.prototype.loadFromDisk = function (filePath) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                console.warn('mtcnn is deprecated and will be removed soon');
                return [2 /*return*/, _super.prototype.loadFromDisk.call(this, filePath)];
            });
        });
    };
    Mtcnn.prototype.forwardInput = function (input, forwardParams) {
        if (forwardParams === void 0) { forwardParams = {}; }
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var params, inputCanvas, stats, tsTotal, imgTensor, onReturn, _a, height, width, _b, minFaceSize, scaleFactor, maxNumScales, scoreThresholds, scaleSteps, scales, ts, out1, out2, out3, results;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        params = this.params;
                        if (!params) {
                            throw new Error('Mtcnn - load model before inference');
                        }
                        inputCanvas = input.canvases[0];
                        if (!inputCanvas) {
                            throw new Error('Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet.');
                        }
                        stats = {};
                        tsTotal = Date.now();
                        imgTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
                            return Object(_bgrToRgbTensor__WEBPACK_IMPORTED_MODULE_8__["bgrToRgbTensor"])(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["expandDims"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["browser"].fromPixels(inputCanvas)).toFloat());
                        });
                        onReturn = function (results) {
                            // dispose tensors on return
                            imgTensor.dispose();
                            stats.total = Date.now() - tsTotal;
                            return results;
                        };
                        _a = imgTensor.shape.slice(1), height = _a[0], width = _a[1];
                        _b = new _MtcnnOptions__WEBPACK_IMPORTED_MODULE_13__["MtcnnOptions"](forwardParams), minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;
                        scales = (scaleSteps || Object(_pyramidDown__WEBPACK_IMPORTED_MODULE_14__["pyramidDown"])(minFaceSize, scaleFactor, [height, width]))
                            .filter(function (scale) {
                            var sizes = Object(_getSizesForScale__WEBPACK_IMPORTED_MODULE_12__["getSizesForScale"])(scale, [height, width]);
                            return Math.min(sizes.width, sizes.height) > _config__WEBPACK_IMPORTED_MODULE_9__["CELL_SIZE"];
                        })
                            .slice(0, maxNumScales);
                        stats.scales = scales;
                        stats.pyramid = scales.map(function (scale) { return Object(_getSizesForScale__WEBPACK_IMPORTED_MODULE_12__["getSizesForScale"])(scale, [height, width]); });
                        ts = Date.now();
                        return [4 /*yield*/, Object(_stage1__WEBPACK_IMPORTED_MODULE_15__["stage1"])(imgTensor, scales, scoreThresholds[0], params.pnet, stats)];
                    case 1:
                        out1 = _c.sent();
                        stats.total_stage1 = Date.now() - ts;
                        if (!out1.boxes.length) {
                            return [2 /*return*/, onReturn({ results: [], stats: stats })];
                        }
                        stats.stage2_numInputBoxes = out1.boxes.length;
                        // using the inputCanvas to extract and resize the image patches, since it is faster
                        // than doing this on the gpu
                        ts = Date.now();
                        return [4 /*yield*/, Object(_stage2__WEBPACK_IMPORTED_MODULE_16__["stage2"])(inputCanvas, out1.boxes, scoreThresholds[1], params.rnet, stats)];
                    case 2:
                        out2 = _c.sent();
                        stats.total_stage2 = Date.now() - ts;
                        if (!out2.boxes.length) {
                            return [2 /*return*/, onReturn({ results: [], stats: stats })];
                        }
                        stats.stage3_numInputBoxes = out2.boxes.length;
                        ts = Date.now();
                        return [4 /*yield*/, Object(_stage3__WEBPACK_IMPORTED_MODULE_17__["stage3"])(inputCanvas, out2.boxes, scoreThresholds[2], params.onet, stats)];
                    case 3:
                        out3 = _c.sent();
                        stats.total_stage3 = Date.now() - ts;
                        results = out3.boxes.map(function (box, idx) { return Object(_factories__WEBPACK_IMPORTED_MODULE_6__["extendWithFaceLandmarks"])(Object(_factories__WEBPACK_IMPORTED_MODULE_6__["extendWithFaceDetection"])({}, new _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_3__["FaceDetection"](out3.scores[idx], new _classes__WEBPACK_IMPORTED_MODULE_2__["Rect"](box.left / width, box.top / height, box.width / width, box.height / height), {
                            height: height,
                            width: width
                        })), new _classes_FaceLandmarks5__WEBPACK_IMPORTED_MODULE_4__["FaceLandmarks5"](out3.points[idx].map(function (pt) { return pt.sub(new _classes__WEBPACK_IMPORTED_MODULE_2__["Point"](box.left, box.top)).div(new _classes__WEBPACK_IMPORTED_MODULE_2__["Point"](box.width, box.height)); }), { width: box.width, height: box.height })); });
                        return [2 /*return*/, onReturn({ results: results, stats: stats })];
                }
            });
        });
    };
    Mtcnn.prototype.forward = function (input, forwardParams) {
        if (forwardParams === void 0) { forwardParams = {}; }
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_5__["toNetInput"])(input)];
                    case 1: return [4 /*yield*/, _a.apply(this, [_b.sent(),
                            forwardParams])];
                    case 2: return [2 /*return*/, (_b.sent()).results];
                }
            });
        });
    };
    Mtcnn.prototype.forwardWithStats = function (input, forwardParams) {
        if (forwardParams === void 0) { forwardParams = {}; }
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_5__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent(),
                            forwardParams])];
                }
            });
        });
    };
    Mtcnn.prototype.getDefaultModelName = function () {
        return 'mtcnn_model';
    };
    Mtcnn.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_11__["extractParamsFromWeigthMap"])(weightMap);
    };
    Mtcnn.prototype.extractParams = function (weights) {
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_10__["extractParams"])(weights);
    };
    return Mtcnn;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_7__["NeuralNetwork"]));

//# sourceMappingURL=Mtcnn.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js":
/*!**************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js ***!
  \**************************************************************/
/*! exports provided: MtcnnBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MtcnnBox", function() { return MtcnnBox; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");


var MtcnnBox = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(MtcnnBox, _super);
    function MtcnnBox(left, top, right, bottom) {
        return _super.call(this, { left: left, top: top, right: right, bottom: bottom }, true) || this;
    }
    return MtcnnBox;
}(_classes__WEBPACK_IMPORTED_MODULE_1__["Box"]));

//# sourceMappingURL=MtcnnBox.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js ***!
  \******************************************************************/
/*! exports provided: MtcnnOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MtcnnOptions", function() { return MtcnnOptions; });
var MtcnnOptions = /** @class */ (function () {
    function MtcnnOptions(_a) {
        var _b = _a === void 0 ? {} : _a, minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;
        this._name = 'MtcnnOptions';
        this._minFaceSize = minFaceSize || 20;
        this._scaleFactor = scaleFactor || 0.709;
        this._maxNumScales = maxNumScales || 10;
        this._scoreThresholds = scoreThresholds || [0.6, 0.7, 0.7];
        this._scaleSteps = scaleSteps;
        if (typeof this._minFaceSize !== 'number' || this._minFaceSize < 0) {
            throw new Error(this._name + " - expected minFaceSize to be a number > 0");
        }
        if (typeof this._scaleFactor !== 'number' || this._scaleFactor <= 0 || this._scaleFactor >= 1) {
            throw new Error(this._name + " - expected scaleFactor to be a number between 0 and 1");
        }
        if (typeof this._maxNumScales !== 'number' || this._maxNumScales < 0) {
            throw new Error(this._name + " - expected maxNumScales to be a number > 0");
        }
        if (!Array.isArray(this._scoreThresholds)
            || this._scoreThresholds.length !== 3
            || this._scoreThresholds.some(function (th) { return typeof th !== 'number'; })) {
            throw new Error(this._name + " - expected scoreThresholds to be an array of numbers of length 3");
        }
        if (this._scaleSteps
            && (!Array.isArray(this._scaleSteps) || this._scaleSteps.some(function (th) { return typeof th !== 'number'; }))) {
            throw new Error(this._name + " - expected scaleSteps to be an array of numbers");
        }
    }
    Object.defineProperty(MtcnnOptions.prototype, "minFaceSize", {
        get: function () { return this._minFaceSize; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MtcnnOptions.prototype, "scaleFactor", {
        get: function () { return this._scaleFactor; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MtcnnOptions.prototype, "maxNumScales", {
        get: function () { return this._maxNumScales; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MtcnnOptions.prototype, "scoreThresholds", {
        get: function () { return this._scoreThresholds; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MtcnnOptions.prototype, "scaleSteps", {
        get: function () { return this._scaleSteps; },
        enumerable: true,
        configurable: true
    });
    return MtcnnOptions;
}());

//# sourceMappingURL=MtcnnOptions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/ONet.js":
/*!**********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/ONet.js ***!
  \**********************************************************/
/*! exports provided: ONet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONet", function() { return ONet; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/fullyConnectedLayer */ "./node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js");
/* harmony import */ var _prelu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./prelu */ "./node_modules/face-api.js/build/es6/mtcnn/prelu.js");
/* harmony import */ var _sharedLayers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sharedLayers */ "./node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js");





function ONet(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = Object(_sharedLayers__WEBPACK_IMPORTED_MODULE_4__["sharedLayer"])(x, params);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(out, params.conv4, 'valid');
        out = Object(_prelu__WEBPACK_IMPORTED_MODULE_3__["prelu"])(out, params.prelu4_alpha);
        var vectorized = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](out, [out.shape[0], params.fc1.weights.shape[0]]);
        var fc1 = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__["fullyConnectedLayer"])(vectorized, params.fc1);
        var prelu5 = Object(_prelu__WEBPACK_IMPORTED_MODULE_3__["prelu"])(fc1, params.prelu5_alpha);
        var fc2_1 = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__["fullyConnectedLayer"])(prelu5, params.fc2_1);
        var max = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"](fc2_1, 1), 1);
        var prob = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](fc2_1, max), 1);
        var regions = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__["fullyConnectedLayer"])(prelu5, params.fc2_2);
        var points = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_2__["fullyConnectedLayer"])(prelu5, params.fc2_3);
        var scores = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](prob, 1)[1];
        return { scores: scores, regions: regions, points: points };
    });
}
//# sourceMappingURL=ONet.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/PNet.js":
/*!**********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/PNet.js ***!
  \**********************************************************/
/*! exports provided: PNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PNet", function() { return PNet; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _sharedLayers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sharedLayers */ "./node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js");



function PNet(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = Object(_sharedLayers__WEBPACK_IMPORTED_MODULE_2__["sharedLayer"])(x, params, true);
        var conv = Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(out, params.conv4_1, 'valid');
        var max = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"](conv, 3), 3);
        var prob = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](conv, max), 3);
        var regions = Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(out, params.conv4_2, 'valid');
        return { prob: prob, regions: regions };
    });
}
//# sourceMappingURL=PNet.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/RNet.js":
/*!**********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/RNet.js ***!
  \**********************************************************/
/*! exports provided: RNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RNet", function() { return RNet; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/fullyConnectedLayer */ "./node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js");
/* harmony import */ var _prelu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prelu */ "./node_modules/face-api.js/build/es6/mtcnn/prelu.js");
/* harmony import */ var _sharedLayers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sharedLayers */ "./node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js");




function RNet(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var convOut = Object(_sharedLayers__WEBPACK_IMPORTED_MODULE_3__["sharedLayer"])(x, params);
        var vectorized = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](convOut, [convOut.shape[0], params.fc1.weights.shape[0]]);
        var fc1 = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_1__["fullyConnectedLayer"])(vectorized, params.fc1);
        var prelu4 = Object(_prelu__WEBPACK_IMPORTED_MODULE_2__["prelu"])(fc1, params.prelu4_alpha);
        var fc2_1 = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_1__["fullyConnectedLayer"])(prelu4, params.fc2_1);
        var max = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"](fc2_1, 1), 1);
        var prob = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](fc2_1, max), 1);
        var regions = Object(_common_fullyConnectedLayer__WEBPACK_IMPORTED_MODULE_1__["fullyConnectedLayer"])(prelu4, params.fc2_2);
        var scores = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](prob, 1)[1];
        return { scores: scores, regions: regions };
    });
}
//# sourceMappingURL=RNet.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/bgrToRgbTensor.js":
/*!********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/bgrToRgbTensor.js ***!
  \********************************************************************/
/*! exports provided: bgrToRgbTensor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bgrToRgbTensor", function() { return bgrToRgbTensor; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function bgrToRgbTensor(tensor) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](tensor, 3).reverse(), 3); });
}
//# sourceMappingURL=bgrToRgbTensor.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/config.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/config.js ***!
  \************************************************************/
/*! exports provided: CELL_STRIDE, CELL_SIZE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CELL_STRIDE", function() { return CELL_STRIDE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CELL_SIZE", function() { return CELL_SIZE; });
var CELL_STRIDE = 2;
var CELL_SIZE = 12;
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/extractImagePatches.js":
/*!*************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/extractImagePatches.js ***!
  \*************************************************************************/
/*! exports provided: extractImagePatches */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractImagePatches", function() { return extractImagePatches; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../env */ "./node_modules/face-api.js/build/es6/env/index.js");
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./normalize */ "./node_modules/face-api.js/build/es6/mtcnn/normalize.js");





function extractImagePatches(img, boxes, _a) {
    var width = _a.width, height = _a.height;
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var imgCtx, bitmaps, imagePatchesDatas;
        var _this = this;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
            switch (_b.label) {
                case 0:
                    imgCtx = Object(_dom__WEBPACK_IMPORTED_MODULE_2__["getContext2dOrThrow"])(img);
                    return [4 /*yield*/, Promise.all(boxes.map(function (box) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
                            var _a, y, ey, x, ex, fromX, fromY, imgData;
                            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                                _a = box.padAtBorders(img.height, img.width), y = _a.y, ey = _a.ey, x = _a.x, ex = _a.ex;
                                fromX = x - 1;
                                fromY = y - 1;
                                imgData = imgCtx.getImageData(fromX, fromY, (ex - fromX), (ey - fromY));
                                return [2 /*return*/, _env__WEBPACK_IMPORTED_MODULE_3__["env"].isNodejs() ? Object(_dom__WEBPACK_IMPORTED_MODULE_2__["createCanvasFromMedia"])(imgData) : createImageBitmap(imgData)];
                            });
                        }); }))];
                case 1:
                    bitmaps = _b.sent();
                    imagePatchesDatas = [];
                    bitmaps.forEach(function (bmp) {
                        var patch = Object(_dom__WEBPACK_IMPORTED_MODULE_2__["createCanvas"])({ width: width, height: height });
                        var patchCtx = Object(_dom__WEBPACK_IMPORTED_MODULE_2__["getContext2dOrThrow"])(patch);
                        patchCtx.drawImage(bmp, 0, 0, width, height);
                        var data = patchCtx.getImageData(0, 0, width, height).data;
                        var currData = [];
                        // RGBA -> BGR
                        for (var i = 0; i < data.length; i += 4) {
                            currData.push(data[i + 2]);
                            currData.push(data[i + 1]);
                            currData.push(data[i]);
                        }
                        imagePatchesDatas.push(currData);
                    });
                    return [2 /*return*/, imagePatchesDatas.map(function (data) {
                            var t = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
                                var imagePatchTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["transpose"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tensor4d"](data, [1, width, height, 3]), [0, 2, 1, 3]).toFloat();
                                return Object(_normalize__WEBPACK_IMPORTED_MODULE_4__["normalize"])(imagePatchTensor);
                            });
                            return t;
                        })];
            }
        });
    });
}
//# sourceMappingURL=extractImagePatches.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/extractParams.js":
/*!*******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/extractParams.js ***!
  \*******************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");



function extractorsFactory(extractWeights, paramMappings) {
    var extractConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_2__["extractConvParamsFactory"])(extractWeights, paramMappings);
    var extractFCParams = Object(_common__WEBPACK_IMPORTED_MODULE_2__["extractFCParamsFactory"])(extractWeights, paramMappings);
    function extractPReluParams(size, paramPath) {
        var alpha = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tensor1d"](extractWeights(size));
        paramMappings.push({ paramPath: paramPath });
        return alpha;
    }
    function extractSharedParams(numFilters, mappedPrefix, isRnet) {
        if (isRnet === void 0) { isRnet = false; }
        var conv1 = extractConvParams(numFilters[0], numFilters[1], 3, mappedPrefix + "/conv1");
        var prelu1_alpha = extractPReluParams(numFilters[1], mappedPrefix + "/prelu1_alpha");
        var conv2 = extractConvParams(numFilters[1], numFilters[2], 3, mappedPrefix + "/conv2");
        var prelu2_alpha = extractPReluParams(numFilters[2], mappedPrefix + "/prelu2_alpha");
        var conv3 = extractConvParams(numFilters[2], numFilters[3], isRnet ? 2 : 3, mappedPrefix + "/conv3");
        var prelu3_alpha = extractPReluParams(numFilters[3], mappedPrefix + "/prelu3_alpha");
        return { conv1: conv1, prelu1_alpha: prelu1_alpha, conv2: conv2, prelu2_alpha: prelu2_alpha, conv3: conv3, prelu3_alpha: prelu3_alpha };
    }
    function extractPNetParams() {
        var sharedParams = extractSharedParams([3, 10, 16, 32], 'pnet');
        var conv4_1 = extractConvParams(32, 2, 1, 'pnet/conv4_1');
        var conv4_2 = extractConvParams(32, 4, 1, 'pnet/conv4_2');
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, sharedParams), { conv4_1: conv4_1, conv4_2: conv4_2 });
    }
    function extractRNetParams() {
        var sharedParams = extractSharedParams([3, 28, 48, 64], 'rnet', true);
        var fc1 = extractFCParams(576, 128, 'rnet/fc1');
        var prelu4_alpha = extractPReluParams(128, 'rnet/prelu4_alpha');
        var fc2_1 = extractFCParams(128, 2, 'rnet/fc2_1');
        var fc2_2 = extractFCParams(128, 4, 'rnet/fc2_2');
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, sharedParams), { fc1: fc1, prelu4_alpha: prelu4_alpha, fc2_1: fc2_1, fc2_2: fc2_2 });
    }
    function extractONetParams() {
        var sharedParams = extractSharedParams([3, 32, 64, 64], 'onet');
        var conv4 = extractConvParams(64, 128, 2, 'onet/conv4');
        var prelu4_alpha = extractPReluParams(128, 'onet/prelu4_alpha');
        var fc1 = extractFCParams(1152, 256, 'onet/fc1');
        var prelu5_alpha = extractPReluParams(256, 'onet/prelu5_alpha');
        var fc2_1 = extractFCParams(256, 2, 'onet/fc2_1');
        var fc2_2 = extractFCParams(256, 4, 'onet/fc2_2');
        var fc2_3 = extractFCParams(256, 10, 'onet/fc2_3');
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, sharedParams), { conv4: conv4, prelu4_alpha: prelu4_alpha, fc1: fc1, prelu5_alpha: prelu5_alpha, fc2_1: fc2_1, fc2_2: fc2_2, fc2_3: fc2_3 });
    }
    return {
        extractPNetParams: extractPNetParams,
        extractRNetParams: extractRNetParams,
        extractONetParams: extractONetParams
    };
}
function extractParams(weights) {
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_2__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var paramMappings = [];
    var _b = extractorsFactory(extractWeights, paramMappings), extractPNetParams = _b.extractPNetParams, extractRNetParams = _b.extractRNetParams, extractONetParams = _b.extractONetParams;
    var pnet = extractPNetParams();
    var rnet = extractRNetParams();
    var onet = extractONetParams();
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return { params: { pnet: pnet, rnet: rnet, onet: onet }, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/extractParamsFromWeigthMap.js":
/*!********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/extractParamsFromWeigthMap.js ***!
  \********************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");


function extractorsFactory(weightMap, paramMappings) {
    var extractWeightEntry = Object(_common__WEBPACK_IMPORTED_MODULE_1__["extractWeightEntryFactory"])(weightMap, paramMappings);
    function extractConvParams(prefix) {
        var filters = extractWeightEntry(prefix + "/weights", 4, prefix + "/filters");
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return { filters: filters, bias: bias };
    }
    function extractFCParams(prefix) {
        var weights = extractWeightEntry(prefix + "/weights", 2);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return { weights: weights, bias: bias };
    }
    function extractPReluParams(paramPath) {
        return extractWeightEntry(paramPath, 1);
    }
    function extractSharedParams(prefix) {
        var conv1 = extractConvParams(prefix + "/conv1");
        var prelu1_alpha = extractPReluParams(prefix + "/prelu1_alpha");
        var conv2 = extractConvParams(prefix + "/conv2");
        var prelu2_alpha = extractPReluParams(prefix + "/prelu2_alpha");
        var conv3 = extractConvParams(prefix + "/conv3");
        var prelu3_alpha = extractPReluParams(prefix + "/prelu3_alpha");
        return { conv1: conv1, prelu1_alpha: prelu1_alpha, conv2: conv2, prelu2_alpha: prelu2_alpha, conv3: conv3, prelu3_alpha: prelu3_alpha };
    }
    function extractPNetParams() {
        var sharedParams = extractSharedParams('pnet');
        var conv4_1 = extractConvParams('pnet/conv4_1');
        var conv4_2 = extractConvParams('pnet/conv4_2');
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, sharedParams), { conv4_1: conv4_1, conv4_2: conv4_2 });
    }
    function extractRNetParams() {
        var sharedParams = extractSharedParams('rnet');
        var fc1 = extractFCParams('rnet/fc1');
        var prelu4_alpha = extractPReluParams('rnet/prelu4_alpha');
        var fc2_1 = extractFCParams('rnet/fc2_1');
        var fc2_2 = extractFCParams('rnet/fc2_2');
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, sharedParams), { fc1: fc1, prelu4_alpha: prelu4_alpha, fc2_1: fc2_1, fc2_2: fc2_2 });
    }
    function extractONetParams() {
        var sharedParams = extractSharedParams('onet');
        var conv4 = extractConvParams('onet/conv4');
        var prelu4_alpha = extractPReluParams('onet/prelu4_alpha');
        var fc1 = extractFCParams('onet/fc1');
        var prelu5_alpha = extractPReluParams('onet/prelu5_alpha');
        var fc2_1 = extractFCParams('onet/fc2_1');
        var fc2_2 = extractFCParams('onet/fc2_2');
        var fc2_3 = extractFCParams('onet/fc2_3');
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, sharedParams), { conv4: conv4, prelu4_alpha: prelu4_alpha, fc1: fc1, prelu5_alpha: prelu5_alpha, fc2_1: fc2_1, fc2_2: fc2_2, fc2_3: fc2_3 });
    }
    return {
        extractPNetParams: extractPNetParams,
        extractRNetParams: extractRNetParams,
        extractONetParams: extractONetParams
    };
}
function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var _a = extractorsFactory(weightMap, paramMappings), extractPNetParams = _a.extractPNetParams, extractRNetParams = _a.extractRNetParams, extractONetParams = _a.extractONetParams;
    var pnet = extractPNetParams();
    var rnet = extractRNetParams();
    var onet = extractONetParams();
    Object(_common__WEBPACK_IMPORTED_MODULE_1__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: { pnet: pnet, rnet: rnet, onet: onet }, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/getSizesForScale.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/getSizesForScale.js ***!
  \**********************************************************************/
/*! exports provided: getSizesForScale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSizesForScale", function() { return getSizesForScale; });
function getSizesForScale(scale, _a) {
    var height = _a[0], width = _a[1];
    return {
        height: Math.floor(height * scale),
        width: Math.floor(width * scale)
    };
}
//# sourceMappingURL=getSizesForScale.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/index.js ***!
  \***********************************************************/
/*! exports provided: Mtcnn, MtcnnOptions, createMtcnn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMtcnn", function() { return createMtcnn; });
/* harmony import */ var _Mtcnn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mtcnn */ "./node_modules/face-api.js/build/es6/mtcnn/Mtcnn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Mtcnn", function() { return _Mtcnn__WEBPACK_IMPORTED_MODULE_0__["Mtcnn"]; });

/* harmony import */ var _MtcnnOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MtcnnOptions */ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MtcnnOptions", function() { return _MtcnnOptions__WEBPACK_IMPORTED_MODULE_1__["MtcnnOptions"]; });




function createMtcnn(weights) {
    var net = new _Mtcnn__WEBPACK_IMPORTED_MODULE_0__["Mtcnn"]();
    net.extractWeights(weights);
    return net;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/normalize.js":
/*!***************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/normalize.js ***!
  \***************************************************************/
/*! exports provided: normalize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function normalize(x) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](x, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](127.5)), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](0.0078125)); });
}
//# sourceMappingURL=normalize.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/prelu.js":
/*!***********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/prelu.js ***!
  \***********************************************************/
/*! exports provided: prelu */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prelu", function() { return prelu; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function prelu(x, alpha) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](x), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](alpha, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"](x)))));
    });
}
//# sourceMappingURL=prelu.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/pyramidDown.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/pyramidDown.js ***!
  \*****************************************************************/
/*! exports provided: pyramidDown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pyramidDown", function() { return pyramidDown; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ "./node_modules/face-api.js/build/es6/mtcnn/config.js");

function pyramidDown(minFaceSize, scaleFactor, dims) {
    var height = dims[0], width = dims[1];
    var m = _config__WEBPACK_IMPORTED_MODULE_0__["CELL_SIZE"] / minFaceSize;
    var scales = [];
    var minLayer = Math.min(height, width) * m;
    var exp = 0;
    while (minLayer >= 12) {
        scales.push(m * Math.pow(scaleFactor, exp));
        minLayer = minLayer * scaleFactor;
        exp += 1;
    }
    return scales;
}
//# sourceMappingURL=pyramidDown.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js":
/*!******************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js ***!
  \******************************************************************/
/*! exports provided: sharedLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sharedLayer", function() { return sharedLayer; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _prelu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prelu */ "./node_modules/face-api.js/build/es6/mtcnn/prelu.js");



function sharedLayer(x, params, isPnet) {
    if (isPnet === void 0) { isPnet = false; }
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(x, params.conv1, 'valid');
        out = Object(_prelu__WEBPACK_IMPORTED_MODULE_2__["prelu"])(out, params.prelu1_alpha);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"](out, isPnet ? [2, 2] : [3, 3], [2, 2], 'same');
        out = Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(out, params.conv2, 'valid');
        out = Object(_prelu__WEBPACK_IMPORTED_MODULE_2__["prelu"])(out, params.prelu2_alpha);
        out = isPnet ? out : _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"](out, [3, 3], [2, 2], 'valid');
        out = Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(out, params.conv3, 'valid');
        out = Object(_prelu__WEBPACK_IMPORTED_MODULE_2__["prelu"])(out, params.prelu3_alpha);
        return out;
    });
}
//# sourceMappingURL=sharedLayers.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/stage1.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/stage1.js ***!
  \************************************************************/
/*! exports provided: stage1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stage1", function() { return stage1; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config */ "./node_modules/face-api.js/build/es6/mtcnn/config.js");
/* harmony import */ var _getSizesForScale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getSizesForScale */ "./node_modules/face-api.js/build/es6/mtcnn/getSizesForScale.js");
/* harmony import */ var _MtcnnBox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MtcnnBox */ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js");
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./normalize */ "./node_modules/face-api.js/build/es6/mtcnn/normalize.js");
/* harmony import */ var _PNet__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PNet */ "./node_modules/face-api.js/build/es6/mtcnn/PNet.js");








function rescaleAndNormalize(x, scale) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var _a = Object(_getSizesForScale__WEBPACK_IMPORTED_MODULE_4__["getSizesForScale"])(scale, x.shape.slice(1)), height = _a.height, width = _a.width;
        var resized = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].resizeBilinear(x, [height, width]);
        var normalized = Object(_normalize__WEBPACK_IMPORTED_MODULE_6__["normalize"])(resized);
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"](normalized, [0, 2, 1, 3]);
    });
}
function extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold) {
    // TODO: fix this!, maybe better to use tf.gather here
    var indices = [];
    var scoresData = scoresTensor.arraySync();
    for (var y = 0; y < scoresTensor.shape[0]; y++) {
        for (var x = 0; x < scoresTensor.shape[1]; x++) {
            if (scoresData[y][x] >= scoreThreshold) {
                indices.push(new _classes__WEBPACK_IMPORTED_MODULE_1__["Point"](x, y));
            }
        }
    }
    var boundingBoxes = indices.map(function (idx) {
        var cell = new _classes__WEBPACK_IMPORTED_MODULE_1__["BoundingBox"](Math.round((idx.y * _config__WEBPACK_IMPORTED_MODULE_3__["CELL_STRIDE"] + 1) / scale), Math.round((idx.x * _config__WEBPACK_IMPORTED_MODULE_3__["CELL_STRIDE"] + 1) / scale), Math.round((idx.y * _config__WEBPACK_IMPORTED_MODULE_3__["CELL_STRIDE"] + _config__WEBPACK_IMPORTED_MODULE_3__["CELL_SIZE"]) / scale), Math.round((idx.x * _config__WEBPACK_IMPORTED_MODULE_3__["CELL_STRIDE"] + _config__WEBPACK_IMPORTED_MODULE_3__["CELL_SIZE"]) / scale));
        var score = scoresData[idx.y][idx.x];
        var regionsData = regionsTensor.arraySync();
        var region = new _MtcnnBox__WEBPACK_IMPORTED_MODULE_5__["MtcnnBox"](regionsData[idx.y][idx.x][0], regionsData[idx.y][idx.x][1], regionsData[idx.y][idx.x][2], regionsData[idx.y][idx.x][3]);
        return {
            cell: cell,
            score: score,
            region: region
        };
    });
    return boundingBoxes;
}
function stage1(imgTensor, scales, scoreThreshold, params, stats) {
    stats.stage1 = [];
    var pnetOutputs = scales.map(function (scale) { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var statsForScale = { scale: scale };
        var resized = rescaleAndNormalize(imgTensor, scale);
        var ts = Date.now();
        var _a = Object(_PNet__WEBPACK_IMPORTED_MODULE_7__["PNet"])(resized, params), prob = _a.prob, regions = _a.regions;
        statsForScale.pnet = Date.now() - ts;
        var scoresTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](prob, 3)[1])[0];
        var regionsTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](regions)[0];
        return {
            scoresTensor: scoresTensor,
            regionsTensor: regionsTensor,
            scale: scale,
            statsForScale: statsForScale
        };
    }); });
    var boxesForScale = pnetOutputs.map(function (_a) {
        var scoresTensor = _a.scoresTensor, regionsTensor = _a.regionsTensor, scale = _a.scale, statsForScale = _a.statsForScale;
        var boundingBoxes = extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold);
        scoresTensor.dispose();
        regionsTensor.dispose();
        if (!boundingBoxes.length) {
            stats.stage1.push(statsForScale);
            return [];
        }
        var ts = Date.now();
        var indices = Object(_ops__WEBPACK_IMPORTED_MODULE_2__["nonMaxSuppression"])(boundingBoxes.map(function (bbox) { return bbox.cell; }), boundingBoxes.map(function (bbox) { return bbox.score; }), 0.5);
        statsForScale.nms = Date.now() - ts;
        statsForScale.numBoxes = indices.length;
        stats.stage1.push(statsForScale);
        return indices.map(function (boxIdx) { return boundingBoxes[boxIdx]; });
    });
    var allBoxes = boxesForScale.reduce(function (all, boxes) { return all.concat(boxes); }, []);
    var finalBoxes = [];
    var finalScores = [];
    if (allBoxes.length > 0) {
        var ts = Date.now();
        var indices = Object(_ops__WEBPACK_IMPORTED_MODULE_2__["nonMaxSuppression"])(allBoxes.map(function (bbox) { return bbox.cell; }), allBoxes.map(function (bbox) { return bbox.score; }), 0.7);
        stats.stage1_nms = Date.now() - ts;
        finalScores = indices.map(function (idx) { return allBoxes[idx].score; });
        finalBoxes = indices
            .map(function (idx) { return allBoxes[idx]; })
            .map(function (_a) {
            var cell = _a.cell, region = _a.region;
            return new _classes__WEBPACK_IMPORTED_MODULE_1__["BoundingBox"](cell.left + (region.left * cell.width), cell.top + (region.top * cell.height), cell.right + (region.right * cell.width), cell.bottom + (region.bottom * cell.height)).toSquare().round();
        });
    }
    return {
        boxes: finalBoxes,
        scores: finalScores
    };
}
//# sourceMappingURL=stage1.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/stage2.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/stage2.js ***!
  \************************************************************/
/*! exports provided: stage2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stage2", function() { return stage2; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _extractImagePatches__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extractImagePatches */ "./node_modules/face-api.js/build/es6/mtcnn/extractImagePatches.js");
/* harmony import */ var _MtcnnBox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MtcnnBox */ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js");
/* harmony import */ var _RNet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RNet */ "./node_modules/face-api.js/build/es6/mtcnn/RNet.js");






function stage2(img, inputBoxes, scoreThreshold, params, stats) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var ts, rnetInputs, rnetOuts, scoresTensor, scores, _a, _b, indices, filteredBoxes, filteredScores, finalBoxes, finalScores, indicesNms, regions_1;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_c) {
            switch (_c.label) {
                case 0:
                    ts = Date.now();
                    return [4 /*yield*/, Object(_extractImagePatches__WEBPACK_IMPORTED_MODULE_3__["extractImagePatches"])(img, inputBoxes, { width: 24, height: 24 })];
                case 1:
                    rnetInputs = _c.sent();
                    stats.stage2_extractImagePatches = Date.now() - ts;
                    ts = Date.now();
                    rnetOuts = rnetInputs.map(function (rnetInput) {
                        var out = Object(_RNet__WEBPACK_IMPORTED_MODULE_5__["RNet"])(rnetInput, params);
                        rnetInput.dispose();
                        return out;
                    });
                    stats.stage2_rnet = Date.now() - ts;
                    scoresTensor = rnetOuts.length > 1
                        ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["concat"](rnetOuts.map(function (out) { return out.scores; }))
                        : rnetOuts[0].scores;
                    _b = (_a = Array).from;
                    return [4 /*yield*/, scoresTensor.data()];
                case 2:
                    scores = _b.apply(_a, [_c.sent()]);
                    scoresTensor.dispose();
                    indices = scores
                        .map(function (score, idx) { return ({ score: score, idx: idx }); })
                        .filter(function (c) { return c.score > scoreThreshold; })
                        .map(function (_a) {
                        var idx = _a.idx;
                        return idx;
                    });
                    filteredBoxes = indices.map(function (idx) { return inputBoxes[idx]; });
                    filteredScores = indices.map(function (idx) { return scores[idx]; });
                    finalBoxes = [];
                    finalScores = [];
                    if (filteredBoxes.length > 0) {
                        ts = Date.now();
                        indicesNms = Object(_ops__WEBPACK_IMPORTED_MODULE_2__["nonMaxSuppression"])(filteredBoxes, filteredScores, 0.7);
                        stats.stage2_nms = Date.now() - ts;
                        regions_1 = indicesNms.map(function (idx) {
                            var regionsData = rnetOuts[indices[idx]].regions.arraySync();
                            return new _MtcnnBox__WEBPACK_IMPORTED_MODULE_4__["MtcnnBox"](regionsData[0][0], regionsData[0][1], regionsData[0][2], regionsData[0][3]);
                        });
                        finalScores = indicesNms.map(function (idx) { return filteredScores[idx]; });
                        finalBoxes = indicesNms.map(function (idx, i) { return filteredBoxes[idx].calibrate(regions_1[i]); });
                    }
                    rnetOuts.forEach(function (t) {
                        t.regions.dispose();
                        t.scores.dispose();
                    });
                    return [2 /*return*/, {
                            boxes: finalBoxes,
                            scores: finalScores
                        }];
            }
        });
    });
}
//# sourceMappingURL=stage2.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/mtcnn/stage3.js":
/*!************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/mtcnn/stage3.js ***!
  \************************************************************/
/*! exports provided: stage3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stage3", function() { return stage3; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _extractImagePatches__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./extractImagePatches */ "./node_modules/face-api.js/build/es6/mtcnn/extractImagePatches.js");
/* harmony import */ var _MtcnnBox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MtcnnBox */ "./node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js");
/* harmony import */ var _ONet__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ONet */ "./node_modules/face-api.js/build/es6/mtcnn/ONet.js");







function stage3(img, inputBoxes, scoreThreshold, params, stats) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
        var ts, onetInputs, onetOuts, scoresTensor, scores, _a, _b, indices, filteredRegions, filteredBoxes, filteredScores, finalBoxes, finalScores, points, indicesNms;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_c) {
            switch (_c.label) {
                case 0:
                    ts = Date.now();
                    return [4 /*yield*/, Object(_extractImagePatches__WEBPACK_IMPORTED_MODULE_4__["extractImagePatches"])(img, inputBoxes, { width: 48, height: 48 })];
                case 1:
                    onetInputs = _c.sent();
                    stats.stage3_extractImagePatches = Date.now() - ts;
                    ts = Date.now();
                    onetOuts = onetInputs.map(function (onetInput) {
                        var out = Object(_ONet__WEBPACK_IMPORTED_MODULE_6__["ONet"])(onetInput, params);
                        onetInput.dispose();
                        return out;
                    });
                    stats.stage3_onet = Date.now() - ts;
                    scoresTensor = onetOuts.length > 1
                        ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["concat"](onetOuts.map(function (out) { return out.scores; }))
                        : onetOuts[0].scores;
                    _b = (_a = Array).from;
                    return [4 /*yield*/, scoresTensor.data()];
                case 2:
                    scores = _b.apply(_a, [_c.sent()]);
                    scoresTensor.dispose();
                    indices = scores
                        .map(function (score, idx) { return ({ score: score, idx: idx }); })
                        .filter(function (c) { return c.score > scoreThreshold; })
                        .map(function (_a) {
                        var idx = _a.idx;
                        return idx;
                    });
                    filteredRegions = indices.map(function (idx) {
                        var regionsData = onetOuts[idx].regions.arraySync();
                        return new _MtcnnBox__WEBPACK_IMPORTED_MODULE_5__["MtcnnBox"](regionsData[0][0], regionsData[0][1], regionsData[0][2], regionsData[0][3]);
                    });
                    filteredBoxes = indices
                        .map(function (idx, i) { return inputBoxes[idx].calibrate(filteredRegions[i]); });
                    filteredScores = indices.map(function (idx) { return scores[idx]; });
                    finalBoxes = [];
                    finalScores = [];
                    points = [];
                    if (filteredBoxes.length > 0) {
                        ts = Date.now();
                        indicesNms = Object(_ops__WEBPACK_IMPORTED_MODULE_3__["nonMaxSuppression"])(filteredBoxes, filteredScores, 0.7, false);
                        stats.stage3_nms = Date.now() - ts;
                        finalBoxes = indicesNms.map(function (idx) { return filteredBoxes[idx]; });
                        finalScores = indicesNms.map(function (idx) { return filteredScores[idx]; });
                        points = indicesNms.map(function (idx, i) {
                            return Array(5).fill(0).map(function (_, ptIdx) {
                                var pointsData = onetOuts[idx].points.arraySync();
                                return new _classes__WEBPACK_IMPORTED_MODULE_2__["Point"](((pointsData[0][ptIdx] * (finalBoxes[i].width + 1)) + finalBoxes[i].left), ((pointsData[0][ptIdx + 5] * (finalBoxes[i].height + 1)) + finalBoxes[i].top));
                            });
                        });
                    }
                    onetOuts.forEach(function (t) {
                        t.regions.dispose();
                        t.scores.dispose();
                        t.points.dispose();
                    });
                    return [2 /*return*/, {
                            boxes: finalBoxes,
                            scores: finalScores,
                            points: points
                        }];
            }
        });
    });
}
//# sourceMappingURL=stage3.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ops/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ops/index.js ***!
  \*********************************************************/
/*! exports provided: iou, minBbox, nonMaxSuppression, normalize, padToSquare, shuffleArray, sigmoid, inverseSigmoid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sigmoid", function() { return sigmoid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverseSigmoid", function() { return inverseSigmoid; });
/* harmony import */ var _iou__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./iou */ "./node_modules/face-api.js/build/es6/ops/iou.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "iou", function() { return _iou__WEBPACK_IMPORTED_MODULE_0__["iou"]; });

/* harmony import */ var _minBbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./minBbox */ "./node_modules/face-api.js/build/es6/ops/minBbox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "minBbox", function() { return _minBbox__WEBPACK_IMPORTED_MODULE_1__["minBbox"]; });

/* harmony import */ var _nonMaxSuppression__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nonMaxSuppression */ "./node_modules/face-api.js/build/es6/ops/nonMaxSuppression.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nonMaxSuppression", function() { return _nonMaxSuppression__WEBPACK_IMPORTED_MODULE_2__["nonMaxSuppression"]; });

/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./normalize */ "./node_modules/face-api.js/build/es6/ops/normalize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return _normalize__WEBPACK_IMPORTED_MODULE_3__["normalize"]; });

/* harmony import */ var _padToSquare__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./padToSquare */ "./node_modules/face-api.js/build/es6/ops/padToSquare.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padToSquare", function() { return _padToSquare__WEBPACK_IMPORTED_MODULE_4__["padToSquare"]; });

/* harmony import */ var _shuffleArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shuffleArray */ "./node_modules/face-api.js/build/es6/ops/shuffleArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffleArray", function() { return _shuffleArray__WEBPACK_IMPORTED_MODULE_5__["shuffleArray"]; });







function sigmoid(x) {
    return 1 / (1 + Math.exp(-x));
}
function inverseSigmoid(x) {
    return Math.log(x / (1 - x));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ops/iou.js":
/*!*******************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ops/iou.js ***!
  \*******************************************************/
/*! exports provided: iou */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iou", function() { return iou; });
function iou(box1, box2, isIOU) {
    if (isIOU === void 0) { isIOU = true; }
    var width = Math.max(0.0, Math.min(box1.right, box2.right) - Math.max(box1.left, box2.left));
    var height = Math.max(0.0, Math.min(box1.bottom, box2.bottom) - Math.max(box1.top, box2.top));
    var interSection = width * height;
    return isIOU
        ? interSection / (box1.area + box2.area - interSection)
        : interSection / Math.min(box1.area, box2.area);
}
//# sourceMappingURL=iou.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ops/minBbox.js":
/*!***********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ops/minBbox.js ***!
  \***********************************************************/
/*! exports provided: minBbox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minBbox", function() { return minBbox; });
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");

function minBbox(pts) {
    var xs = pts.map(function (pt) { return pt.x; });
    var ys = pts.map(function (pt) { return pt.y; });
    var minX = xs.reduce(function (min, x) { return x < min ? x : min; }, Infinity);
    var minY = ys.reduce(function (min, y) { return y < min ? y : min; }, Infinity);
    var maxX = xs.reduce(function (max, x) { return max < x ? x : max; }, 0);
    var maxY = ys.reduce(function (max, y) { return max < y ? y : max; }, 0);
    return new _classes__WEBPACK_IMPORTED_MODULE_0__["BoundingBox"](minX, minY, maxX, maxY);
}
//# sourceMappingURL=minBbox.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ops/nonMaxSuppression.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ops/nonMaxSuppression.js ***!
  \*********************************************************************/
/*! exports provided: nonMaxSuppression */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonMaxSuppression", function() { return nonMaxSuppression; });
/* harmony import */ var _iou__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./iou */ "./node_modules/face-api.js/build/es6/ops/iou.js");

function nonMaxSuppression(boxes, scores, iouThreshold, isIOU) {
    if (isIOU === void 0) { isIOU = true; }
    var indicesSortedByScore = scores
        .map(function (score, boxIndex) { return ({ score: score, boxIndex: boxIndex }); })
        .sort(function (c1, c2) { return c1.score - c2.score; })
        .map(function (c) { return c.boxIndex; });
    var pick = [];
    var _loop_1 = function () {
        var curr = indicesSortedByScore.pop();
        pick.push(curr);
        var indices = indicesSortedByScore;
        var outputs = [];
        for (var i = 0; i < indices.length; i++) {
            var idx = indices[i];
            var currBox = boxes[curr];
            var idxBox = boxes[idx];
            outputs.push(Object(_iou__WEBPACK_IMPORTED_MODULE_0__["iou"])(currBox, idxBox, isIOU));
        }
        indicesSortedByScore = indicesSortedByScore.filter(function (_, j) { return outputs[j] <= iouThreshold; });
    };
    while (indicesSortedByScore.length > 0) {
        _loop_1();
    }
    return pick;
}
//# sourceMappingURL=nonMaxSuppression.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ops/normalize.js":
/*!*************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ops/normalize.js ***!
  \*************************************************************/
/*! exports provided: normalize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");


function normalize(x, meanRgb) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
        var r = meanRgb[0], g = meanRgb[1], b = meanRgb[2];
        var avg_r = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["fill"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spreadArrays"])(x.shape.slice(0, 3), [1]), r);
        var avg_g = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["fill"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spreadArrays"])(x.shape.slice(0, 3), [1]), g);
        var avg_b = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["fill"](Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spreadArrays"])(x.shape.slice(0, 3), [1]), b);
        var avg_rgb = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["concat"]([avg_r, avg_g, avg_b], 3);
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["sub"](x, avg_rgb);
    });
}
//# sourceMappingURL=normalize.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ops/padToSquare.js":
/*!***************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ops/padToSquare.js ***!
  \***************************************************************/
/*! exports provided: padToSquare */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padToSquare", function() { return padToSquare; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

/**
 * Pads the smaller dimension of an image tensor with zeros, such that width === height.
 *
 * @param imgTensor The image tensor.
 * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on
 * both sides of the minor dimension oof the image.
 * @returns The padded tensor with width === height.
 */
function padToSquare(imgTensor, isCenterImage) {
    if (isCenterImage === void 0) { isCenterImage = false; }
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var _a = imgTensor.shape.slice(1), height = _a[0], width = _a[1];
        if (height === width) {
            return imgTensor;
        }
        var dimDiff = Math.abs(height - width);
        var paddingAmount = Math.round(dimDiff * (isCenterImage ? 0.5 : 1));
        var paddingAxis = height > width ? 2 : 1;
        var createPaddingTensor = function (paddingAmount) {
            var paddingTensorShape = imgTensor.shape.slice();
            paddingTensorShape[paddingAxis] = paddingAmount;
            return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fill"](paddingTensorShape, 0);
        };
        var paddingTensorAppend = createPaddingTensor(paddingAmount);
        var remainingPaddingAmount = dimDiff - paddingTensorAppend.shape[paddingAxis];
        var paddingTensorPrepend = isCenterImage && remainingPaddingAmount
            ? createPaddingTensor(remainingPaddingAmount)
            : null;
        var tensorsToStack = [
            paddingTensorPrepend,
            imgTensor,
            paddingTensorAppend
        ]
            .filter(function (t) { return !!t; })
            .map(function (t) { return t.toFloat(); });
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"](tensorsToStack, paddingAxis);
    });
}
//# sourceMappingURL=padToSquare.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ops/shuffleArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ops/shuffleArray.js ***!
  \****************************************************************/
/*! exports provided: shuffleArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shuffleArray", function() { return shuffleArray; });
function shuffleArray(inputArray) {
    var array = inputArray.slice();
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var x = array[i];
        array[i] = array[j];
        array[j] = x;
    }
    return array;
}
//# sourceMappingURL=shuffleArray.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/resizeResults.js":
/*!*************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/resizeResults.js ***!
  \*************************************************************/
/*! exports provided: resizeResults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeResults", function() { return resizeResults; });
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _classes_FaceLandmarks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/FaceLandmarks */ "./node_modules/face-api.js/build/es6/classes/FaceLandmarks.js");
/* harmony import */ var _factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./factories/WithFaceDetection */ "./node_modules/face-api.js/build/es6/factories/WithFaceDetection.js");
/* harmony import */ var _factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./factories/WithFaceLandmarks */ "./node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js");





function resizeResults(results, dimensions) {
    var _a = new _classes__WEBPACK_IMPORTED_MODULE_0__["Dimensions"](dimensions.width, dimensions.height), width = _a.width, height = _a.height;
    if (width <= 0 || height <= 0) {
        throw new Error("resizeResults - invalid dimensions: " + JSON.stringify({ width: width, height: height }));
    }
    if (Array.isArray(results)) {
        return results.map(function (obj) { return resizeResults(obj, { width: width, height: height }); });
    }
    if (Object(_factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_4__["isWithFaceLandmarks"])(results)) {
        var resizedDetection = results.detection.forSize(width, height);
        var resizedLandmarks = results.unshiftedLandmarks.forSize(resizedDetection.box.width, resizedDetection.box.height);
        return Object(_factories_WithFaceLandmarks__WEBPACK_IMPORTED_MODULE_4__["extendWithFaceLandmarks"])(Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_3__["extendWithFaceDetection"])(results, resizedDetection), resizedLandmarks);
    }
    if (Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_3__["isWithFaceDetection"])(results)) {
        return Object(_factories_WithFaceDetection__WEBPACK_IMPORTED_MODULE_3__["extendWithFaceDetection"])(results, results.detection.forSize(width, height));
    }
    if (results instanceof _classes_FaceLandmarks__WEBPACK_IMPORTED_MODULE_2__["FaceLandmarks"] || results instanceof _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_1__["FaceDetection"]) {
        return results.forSize(width, height);
    }
    return results;
}
//# sourceMappingURL=resizeResults.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1.js ***!
  \*****************************************************************************/
/*! exports provided: SsdMobilenetv1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SsdMobilenetv1", function() { return SsdMobilenetv1; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../classes/FaceDetection */ "./node_modules/face-api.js/build/es6/classes/FaceDetection.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParamsFromWeigthMap.js");
/* harmony import */ var _mobileNetV1__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mobileNetV1 */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/mobileNetV1.js");
/* harmony import */ var _nonMaxSuppression__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./nonMaxSuppression */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/nonMaxSuppression.js");
/* harmony import */ var _outputLayer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./outputLayer */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/outputLayer.js");
/* harmony import */ var _predictionLayer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./predictionLayer */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/predictionLayer.js");
/* harmony import */ var _SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./SsdMobilenetv1Options */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js");













var SsdMobilenetv1 = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(SsdMobilenetv1, _super);
    function SsdMobilenetv1() {
        return _super.call(this, 'SsdMobilenetv1') || this;
    }
    SsdMobilenetv1.prototype.forwardInput = function (input) {
        var params = this.params;
        if (!params) {
            throw new Error('SsdMobilenetv1 - load model before inference');
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var batchTensor = input.toBatchTensor(512, false).toFloat();
            var x = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["sub"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["mul"](batchTensor, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](0.007843137718737125)), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](1));
            var features = Object(_mobileNetV1__WEBPACK_IMPORTED_MODULE_8__["mobileNetV1"])(x, params.mobilenetv1);
            var _a = Object(_predictionLayer__WEBPACK_IMPORTED_MODULE_11__["predictionLayer"])(features.out, features.conv11, params.prediction_layer), boxPredictions = _a.boxPredictions, classPredictions = _a.classPredictions;
            return Object(_outputLayer__WEBPACK_IMPORTED_MODULE_10__["outputLayer"])(boxPredictions, classPredictions, params.output_layer);
        });
    };
    SsdMobilenetv1.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_4__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    SsdMobilenetv1.prototype.locateFaces = function (input, options) {
        if (options === void 0) { options = {}; }
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a, maxResults, minConfidence, netInput, _b, _boxes, _scores, boxes, scores, i, scoresData, _c, _d, iouThreshold, indices, reshapedDims, inputSize, padX, padY, boxesData, results;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _a = new _SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_12__["SsdMobilenetv1Options"](options), maxResults = _a.maxResults, minConfidence = _a.minConfidence;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_4__["toNetInput"])(input)];
                    case 1:
                        netInput = _e.sent();
                        _b = this.forwardInput(netInput), _boxes = _b.boxes, _scores = _b.scores;
                        boxes = _boxes[0];
                        scores = _scores[0];
                        for (i = 1; i < _boxes.length; i++) {
                            _boxes[i].dispose();
                            _scores[i].dispose();
                        }
                        _d = (_c = Array).from;
                        return [4 /*yield*/, scores.data()];
                    case 2:
                        scoresData = _d.apply(_c, [_e.sent()]);
                        iouThreshold = 0.5;
                        indices = Object(_nonMaxSuppression__WEBPACK_IMPORTED_MODULE_9__["nonMaxSuppression"])(boxes, scoresData, maxResults, iouThreshold, minConfidence);
                        reshapedDims = netInput.getReshapedInputDimensions(0);
                        inputSize = netInput.inputSize;
                        padX = inputSize / reshapedDims.width;
                        padY = inputSize / reshapedDims.height;
                        boxesData = boxes.arraySync();
                        results = indices
                            .map(function (idx) {
                            var _a = [
                                Math.max(0, boxesData[idx][0]),
                                Math.min(1.0, boxesData[idx][2])
                            ].map(function (val) { return val * padY; }), top = _a[0], bottom = _a[1];
                            var _b = [
                                Math.max(0, boxesData[idx][1]),
                                Math.min(1.0, boxesData[idx][3])
                            ].map(function (val) { return val * padX; }), left = _b[0], right = _b[1];
                            return new _classes_FaceDetection__WEBPACK_IMPORTED_MODULE_3__["FaceDetection"](scoresData[idx], new _classes__WEBPACK_IMPORTED_MODULE_2__["Rect"](left, top, right - left, bottom - top), {
                                height: netInput.getInputHeight(0),
                                width: netInput.getInputWidth(0)
                            });
                        });
                        boxes.dispose();
                        scores.dispose();
                        return [2 /*return*/, results];
                }
            });
        });
    };
    SsdMobilenetv1.prototype.getDefaultModelName = function () {
        return 'ssd_mobilenetv1_model';
    };
    SsdMobilenetv1.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_7__["extractParamsFromWeigthMap"])(weightMap);
    };
    SsdMobilenetv1.prototype.extractParams = function (weights) {
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_6__["extractParams"])(weights);
    };
    return SsdMobilenetv1;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_5__["NeuralNetwork"]));

//# sourceMappingURL=SsdMobilenetv1.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js":
/*!************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js ***!
  \************************************************************************************/
/*! exports provided: SsdMobilenetv1Options */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SsdMobilenetv1Options", function() { return SsdMobilenetv1Options; });
var SsdMobilenetv1Options = /** @class */ (function () {
    function SsdMobilenetv1Options(_a) {
        var _b = _a === void 0 ? {} : _a, minConfidence = _b.minConfidence, maxResults = _b.maxResults;
        this._name = 'SsdMobilenetv1Options';
        this._minConfidence = minConfidence || 0.5;
        this._maxResults = maxResults || 100;
        if (typeof this._minConfidence !== 'number' || this._minConfidence <= 0 || this._minConfidence >= 1) {
            throw new Error(this._name + " - expected minConfidence to be a number between 0 and 1");
        }
        if (typeof this._maxResults !== 'number') {
            throw new Error(this._name + " - expected maxResults to be a number");
        }
    }
    Object.defineProperty(SsdMobilenetv1Options.prototype, "minConfidence", {
        get: function () { return this._minConfidence; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SsdMobilenetv1Options.prototype, "maxResults", {
        get: function () { return this._maxResults; },
        enumerable: true,
        configurable: true
    });
    return SsdMobilenetv1Options;
}());

//# sourceMappingURL=SsdMobilenetv1Options.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/boxPredictionLayer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/boxPredictionLayer.js ***!
  \*********************************************************************************/
/*! exports provided: boxPredictionLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boxPredictionLayer", function() { return boxPredictionLayer; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");


function boxPredictionLayer(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var batchSize = x.shape[0];
        var boxPredictionEncoding = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(x, params.box_encoding_predictor), [batchSize, -1, 1, 4]);
        var classPrediction = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](Object(_common__WEBPACK_IMPORTED_MODULE_1__["convLayer"])(x, params.class_predictor), [batchSize, -1, 3]);
        return {
            boxPredictionEncoding: boxPredictionEncoding,
            classPrediction: classPrediction
        };
    });
}
//# sourceMappingURL=boxPredictionLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParams.js":
/*!****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParams.js ***!
  \****************************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");


function extractorsFactory(extractWeights, paramMappings) {
    function extractDepthwiseConvParams(numChannels, mappedPrefix) {
        var filters = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"](extractWeights(3 * 3 * numChannels), [3, 3, numChannels, 1]);
        var batch_norm_scale = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(numChannels));
        var batch_norm_offset = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(numChannels));
        var batch_norm_mean = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(numChannels));
        var batch_norm_variance = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(numChannels));
        paramMappings.push({ paramPath: mappedPrefix + "/filters" }, { paramPath: mappedPrefix + "/batch_norm_scale" }, { paramPath: mappedPrefix + "/batch_norm_offset" }, { paramPath: mappedPrefix + "/batch_norm_mean" }, { paramPath: mappedPrefix + "/batch_norm_variance" });
        return {
            filters: filters,
            batch_norm_scale: batch_norm_scale,
            batch_norm_offset: batch_norm_offset,
            batch_norm_mean: batch_norm_mean,
            batch_norm_variance: batch_norm_variance
        };
    }
    function extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, isPointwiseConv) {
        var filters = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"](extractWeights(channelsIn * channelsOut * filterSize * filterSize), [filterSize, filterSize, channelsIn, channelsOut]);
        var bias = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(channelsOut));
        paramMappings.push({ paramPath: mappedPrefix + "/filters" }, { paramPath: mappedPrefix + "/" + (isPointwiseConv ? 'batch_norm_offset' : 'bias') });
        return { filters: filters, bias: bias };
    }
    function extractPointwiseConvParams(channelsIn, channelsOut, filterSize, mappedPrefix) {
        var _a = extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, true), filters = _a.filters, bias = _a.bias;
        return {
            filters: filters,
            batch_norm_offset: bias
        };
    }
    function extractConvPairParams(channelsIn, channelsOut, mappedPrefix) {
        var depthwise_conv = extractDepthwiseConvParams(channelsIn, mappedPrefix + "/depthwise_conv");
        var pointwise_conv = extractPointwiseConvParams(channelsIn, channelsOut, 1, mappedPrefix + "/pointwise_conv");
        return { depthwise_conv: depthwise_conv, pointwise_conv: pointwise_conv };
    }
    function extractMobilenetV1Params() {
        var conv_0 = extractPointwiseConvParams(3, 32, 3, 'mobilenetv1/conv_0');
        var conv_1 = extractConvPairParams(32, 64, 'mobilenetv1/conv_1');
        var conv_2 = extractConvPairParams(64, 128, 'mobilenetv1/conv_2');
        var conv_3 = extractConvPairParams(128, 128, 'mobilenetv1/conv_3');
        var conv_4 = extractConvPairParams(128, 256, 'mobilenetv1/conv_4');
        var conv_5 = extractConvPairParams(256, 256, 'mobilenetv1/conv_5');
        var conv_6 = extractConvPairParams(256, 512, 'mobilenetv1/conv_6');
        var conv_7 = extractConvPairParams(512, 512, 'mobilenetv1/conv_7');
        var conv_8 = extractConvPairParams(512, 512, 'mobilenetv1/conv_8');
        var conv_9 = extractConvPairParams(512, 512, 'mobilenetv1/conv_9');
        var conv_10 = extractConvPairParams(512, 512, 'mobilenetv1/conv_10');
        var conv_11 = extractConvPairParams(512, 512, 'mobilenetv1/conv_11');
        var conv_12 = extractConvPairParams(512, 1024, 'mobilenetv1/conv_12');
        var conv_13 = extractConvPairParams(1024, 1024, 'mobilenetv1/conv_13');
        return {
            conv_0: conv_0,
            conv_1: conv_1,
            conv_2: conv_2,
            conv_3: conv_3,
            conv_4: conv_4,
            conv_5: conv_5,
            conv_6: conv_6,
            conv_7: conv_7,
            conv_8: conv_8,
            conv_9: conv_9,
            conv_10: conv_10,
            conv_11: conv_11,
            conv_12: conv_12,
            conv_13: conv_13
        };
    }
    function extractPredictionLayerParams() {
        var conv_0 = extractPointwiseConvParams(1024, 256, 1, 'prediction_layer/conv_0');
        var conv_1 = extractPointwiseConvParams(256, 512, 3, 'prediction_layer/conv_1');
        var conv_2 = extractPointwiseConvParams(512, 128, 1, 'prediction_layer/conv_2');
        var conv_3 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_3');
        var conv_4 = extractPointwiseConvParams(256, 128, 1, 'prediction_layer/conv_4');
        var conv_5 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_5');
        var conv_6 = extractPointwiseConvParams(256, 64, 1, 'prediction_layer/conv_6');
        var conv_7 = extractPointwiseConvParams(64, 128, 3, 'prediction_layer/conv_7');
        var box_encoding_0_predictor = extractConvParams(512, 12, 1, 'prediction_layer/box_predictor_0/box_encoding_predictor');
        var class_predictor_0 = extractConvParams(512, 9, 1, 'prediction_layer/box_predictor_0/class_predictor');
        var box_encoding_1_predictor = extractConvParams(1024, 24, 1, 'prediction_layer/box_predictor_1/box_encoding_predictor');
        var class_predictor_1 = extractConvParams(1024, 18, 1, 'prediction_layer/box_predictor_1/class_predictor');
        var box_encoding_2_predictor = extractConvParams(512, 24, 1, 'prediction_layer/box_predictor_2/box_encoding_predictor');
        var class_predictor_2 = extractConvParams(512, 18, 1, 'prediction_layer/box_predictor_2/class_predictor');
        var box_encoding_3_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_3/box_encoding_predictor');
        var class_predictor_3 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_3/class_predictor');
        var box_encoding_4_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_4/box_encoding_predictor');
        var class_predictor_4 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_4/class_predictor');
        var box_encoding_5_predictor = extractConvParams(128, 24, 1, 'prediction_layer/box_predictor_5/box_encoding_predictor');
        var class_predictor_5 = extractConvParams(128, 18, 1, 'prediction_layer/box_predictor_5/class_predictor');
        var box_predictor_0 = {
            box_encoding_predictor: box_encoding_0_predictor,
            class_predictor: class_predictor_0
        };
        var box_predictor_1 = {
            box_encoding_predictor: box_encoding_1_predictor,
            class_predictor: class_predictor_1
        };
        var box_predictor_2 = {
            box_encoding_predictor: box_encoding_2_predictor,
            class_predictor: class_predictor_2
        };
        var box_predictor_3 = {
            box_encoding_predictor: box_encoding_3_predictor,
            class_predictor: class_predictor_3
        };
        var box_predictor_4 = {
            box_encoding_predictor: box_encoding_4_predictor,
            class_predictor: class_predictor_4
        };
        var box_predictor_5 = {
            box_encoding_predictor: box_encoding_5_predictor,
            class_predictor: class_predictor_5
        };
        return {
            conv_0: conv_0,
            conv_1: conv_1,
            conv_2: conv_2,
            conv_3: conv_3,
            conv_4: conv_4,
            conv_5: conv_5,
            conv_6: conv_6,
            conv_7: conv_7,
            box_predictor_0: box_predictor_0,
            box_predictor_1: box_predictor_1,
            box_predictor_2: box_predictor_2,
            box_predictor_3: box_predictor_3,
            box_predictor_4: box_predictor_4,
            box_predictor_5: box_predictor_5
        };
    }
    return {
        extractMobilenetV1Params: extractMobilenetV1Params,
        extractPredictionLayerParams: extractPredictionLayerParams
    };
}
function extractParams(weights) {
    var paramMappings = [];
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_1__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var _b = extractorsFactory(extractWeights, paramMappings), extractMobilenetV1Params = _b.extractMobilenetV1Params, extractPredictionLayerParams = _b.extractPredictionLayerParams;
    var mobilenetv1 = extractMobilenetV1Params();
    var prediction_layer = extractPredictionLayerParams();
    var extra_dim = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor3d"](extractWeights(5118 * 4), [1, 5118, 4]);
    var output_layer = {
        extra_dim: extra_dim
    };
    paramMappings.push({ paramPath: 'output_layer/extra_dim' });
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return {
        params: {
            mobilenetv1: mobilenetv1,
            prediction_layer: prediction_layer,
            output_layer: output_layer
        },
        paramMappings: paramMappings
    };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParamsFromWeigthMap.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParamsFromWeigthMap.js ***!
  \*****************************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");


function extractorsFactory(weightMap, paramMappings) {
    var extractWeightEntry = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightEntryFactory"])(weightMap, paramMappings);
    function extractPointwiseConvParams(prefix, idx, mappedPrefix) {
        var filters = extractWeightEntry(prefix + "/Conv2d_" + idx + "_pointwise/weights", 4, mappedPrefix + "/filters");
        var batch_norm_offset = extractWeightEntry(prefix + "/Conv2d_" + idx + "_pointwise/convolution_bn_offset", 1, mappedPrefix + "/batch_norm_offset");
        return { filters: filters, batch_norm_offset: batch_norm_offset };
    }
    function extractConvPairParams(idx) {
        var mappedPrefix = "mobilenetv1/conv_" + idx;
        var prefixDepthwiseConv = "MobilenetV1/Conv2d_" + idx + "_depthwise";
        var mappedPrefixDepthwiseConv = mappedPrefix + "/depthwise_conv";
        var mappedPrefixPointwiseConv = mappedPrefix + "/pointwise_conv";
        var filters = extractWeightEntry(prefixDepthwiseConv + "/depthwise_weights", 4, mappedPrefixDepthwiseConv + "/filters");
        var batch_norm_scale = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/gamma", 1, mappedPrefixDepthwiseConv + "/batch_norm_scale");
        var batch_norm_offset = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/beta", 1, mappedPrefixDepthwiseConv + "/batch_norm_offset");
        var batch_norm_mean = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/moving_mean", 1, mappedPrefixDepthwiseConv + "/batch_norm_mean");
        var batch_norm_variance = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/moving_variance", 1, mappedPrefixDepthwiseConv + "/batch_norm_variance");
        return {
            depthwise_conv: {
                filters: filters,
                batch_norm_scale: batch_norm_scale,
                batch_norm_offset: batch_norm_offset,
                batch_norm_mean: batch_norm_mean,
                batch_norm_variance: batch_norm_variance
            },
            pointwise_conv: extractPointwiseConvParams('MobilenetV1', idx, mappedPrefixPointwiseConv)
        };
    }
    function extractMobilenetV1Params() {
        return {
            conv_0: extractPointwiseConvParams('MobilenetV1', 0, 'mobilenetv1/conv_0'),
            conv_1: extractConvPairParams(1),
            conv_2: extractConvPairParams(2),
            conv_3: extractConvPairParams(3),
            conv_4: extractConvPairParams(4),
            conv_5: extractConvPairParams(5),
            conv_6: extractConvPairParams(6),
            conv_7: extractConvPairParams(7),
            conv_8: extractConvPairParams(8),
            conv_9: extractConvPairParams(9),
            conv_10: extractConvPairParams(10),
            conv_11: extractConvPairParams(11),
            conv_12: extractConvPairParams(12),
            conv_13: extractConvPairParams(13)
        };
    }
    function extractConvParams(prefix, mappedPrefix) {
        var filters = extractWeightEntry(prefix + "/weights", 4, mappedPrefix + "/filters");
        var bias = extractWeightEntry(prefix + "/biases", 1, mappedPrefix + "/bias");
        return { filters: filters, bias: bias };
    }
    function extractBoxPredictorParams(idx) {
        var box_encoding_predictor = extractConvParams("Prediction/BoxPredictor_" + idx + "/BoxEncodingPredictor", "prediction_layer/box_predictor_" + idx + "/box_encoding_predictor");
        var class_predictor = extractConvParams("Prediction/BoxPredictor_" + idx + "/ClassPredictor", "prediction_layer/box_predictor_" + idx + "/class_predictor");
        return { box_encoding_predictor: box_encoding_predictor, class_predictor: class_predictor };
    }
    function extractPredictionLayerParams() {
        return {
            conv_0: extractPointwiseConvParams('Prediction', 0, 'prediction_layer/conv_0'),
            conv_1: extractPointwiseConvParams('Prediction', 1, 'prediction_layer/conv_1'),
            conv_2: extractPointwiseConvParams('Prediction', 2, 'prediction_layer/conv_2'),
            conv_3: extractPointwiseConvParams('Prediction', 3, 'prediction_layer/conv_3'),
            conv_4: extractPointwiseConvParams('Prediction', 4, 'prediction_layer/conv_4'),
            conv_5: extractPointwiseConvParams('Prediction', 5, 'prediction_layer/conv_5'),
            conv_6: extractPointwiseConvParams('Prediction', 6, 'prediction_layer/conv_6'),
            conv_7: extractPointwiseConvParams('Prediction', 7, 'prediction_layer/conv_7'),
            box_predictor_0: extractBoxPredictorParams(0),
            box_predictor_1: extractBoxPredictorParams(1),
            box_predictor_2: extractBoxPredictorParams(2),
            box_predictor_3: extractBoxPredictorParams(3),
            box_predictor_4: extractBoxPredictorParams(4),
            box_predictor_5: extractBoxPredictorParams(5)
        };
    }
    return {
        extractMobilenetV1Params: extractMobilenetV1Params,
        extractPredictionLayerParams: extractPredictionLayerParams
    };
}
function extractParamsFromWeigthMap(weightMap) {
    var paramMappings = [];
    var _a = extractorsFactory(weightMap, paramMappings), extractMobilenetV1Params = _a.extractMobilenetV1Params, extractPredictionLayerParams = _a.extractPredictionLayerParams;
    var extra_dim = weightMap['Output/extra_dim'];
    paramMappings.push({ originalPath: 'Output/extra_dim', paramPath: 'output_layer/extra_dim' });
    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isTensor3D"])(extra_dim)) {
        throw new Error("expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have " + extra_dim);
    }
    var params = {
        mobilenetv1: extractMobilenetV1Params(),
        prediction_layer: extractPredictionLayerParams(),
        output_layer: {
            extra_dim: extra_dim
        }
    };
    Object(_common__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/index.js ***!
  \********************************************************************/
/*! exports provided: SsdMobilenetv1, SsdMobilenetv1Options, createSsdMobilenetv1, createFaceDetectionNet, FaceDetectionNet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSsdMobilenetv1", function() { return createSsdMobilenetv1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFaceDetectionNet", function() { return createFaceDetectionNet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceDetectionNet", function() { return FaceDetectionNet; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _SsdMobilenetv1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SsdMobilenetv1 */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SsdMobilenetv1", function() { return _SsdMobilenetv1__WEBPACK_IMPORTED_MODULE_1__["SsdMobilenetv1"]; });

/* harmony import */ var _SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SsdMobilenetv1Options */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SsdMobilenetv1Options", function() { return _SsdMobilenetv1Options__WEBPACK_IMPORTED_MODULE_2__["SsdMobilenetv1Options"]; });





function createSsdMobilenetv1(weights) {
    var net = new _SsdMobilenetv1__WEBPACK_IMPORTED_MODULE_1__["SsdMobilenetv1"]();
    net.extractWeights(weights);
    return net;
}
function createFaceDetectionNet(weights) {
    return createSsdMobilenetv1(weights);
}
// alias for backward compatibily
var FaceDetectionNet = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(FaceDetectionNet, _super);
    function FaceDetectionNet() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return FaceDetectionNet;
}(_SsdMobilenetv1__WEBPACK_IMPORTED_MODULE_1__["SsdMobilenetv1"]));

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/mobileNetV1.js":
/*!**************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/mobileNetV1.js ***!
  \**************************************************************************/
/*! exports provided: mobileNetV1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mobileNetV1", function() { return mobileNetV1; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pointwiseConvLayer */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/pointwiseConvLayer.js");


var epsilon = 0.0010000000474974513;
function depthwiseConvLayer(x, params, strides) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthwiseConv2d"](x, params.filters, strides, 'same');
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm"](out, params.batch_norm_mean, params.batch_norm_variance, params.batch_norm_offset, params.batch_norm_scale, epsilon);
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"](out, 0, 6);
    });
}
function getStridesForLayerIdx(layerIdx) {
    return [2, 4, 6, 12].some(function (idx) { return idx === layerIdx; }) ? [2, 2] : [1, 1];
}
function mobileNetV1(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var conv11 = null;
        var out = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_1__["pointwiseConvLayer"])(x, params.conv_0, [2, 2]);
        var convPairParams = [
            params.conv_1,
            params.conv_2,
            params.conv_3,
            params.conv_4,
            params.conv_5,
            params.conv_6,
            params.conv_7,
            params.conv_8,
            params.conv_9,
            params.conv_10,
            params.conv_11,
            params.conv_12,
            params.conv_13
        ];
        convPairParams.forEach(function (param, i) {
            var layerIdx = i + 1;
            var depthwiseConvStrides = getStridesForLayerIdx(layerIdx);
            out = depthwiseConvLayer(out, param.depthwise_conv, depthwiseConvStrides);
            out = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_1__["pointwiseConvLayer"])(out, param.pointwise_conv, [1, 1]);
            if (layerIdx === 11) {
                conv11 = out;
            }
        });
        if (conv11 === null) {
            throw new Error('mobileNetV1 - output of conv layer 11 is null');
        }
        return {
            out: out,
            conv11: conv11
        };
    });
}
//# sourceMappingURL=mobileNetV1.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/nonMaxSuppression.js":
/*!********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/nonMaxSuppression.js ***!
  \********************************************************************************/
/*! exports provided: nonMaxSuppression */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonMaxSuppression", function() { return nonMaxSuppression; });
function nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
    var numBoxes = boxes.shape[0];
    var outputSize = Math.min(maxOutputSize, numBoxes);
    var candidates = scores
        .map(function (score, boxIndex) { return ({ score: score, boxIndex: boxIndex }); })
        .filter(function (c) { return c.score > scoreThreshold; })
        .sort(function (c1, c2) { return c2.score - c1.score; });
    var suppressFunc = function (x) { return x <= iouThreshold ? 1 : 0; };
    var selected = [];
    candidates.forEach(function (c) {
        if (selected.length >= outputSize) {
            return;
        }
        var originalScore = c.score;
        for (var j = selected.length - 1; j >= 0; --j) {
            var iou = IOU(boxes, c.boxIndex, selected[j]);
            if (iou === 0.0) {
                continue;
            }
            c.score *= suppressFunc(iou);
            if (c.score <= scoreThreshold) {
                break;
            }
        }
        if (originalScore === c.score) {
            selected.push(c.boxIndex);
        }
    });
    return selected;
}
function IOU(boxes, i, j) {
    var boxesData = boxes.arraySync();
    var yminI = Math.min(boxesData[i][0], boxesData[i][2]);
    var xminI = Math.min(boxesData[i][1], boxesData[i][3]);
    var ymaxI = Math.max(boxesData[i][0], boxesData[i][2]);
    var xmaxI = Math.max(boxesData[i][1], boxesData[i][3]);
    var yminJ = Math.min(boxesData[j][0], boxesData[j][2]);
    var xminJ = Math.min(boxesData[j][1], boxesData[j][3]);
    var ymaxJ = Math.max(boxesData[j][0], boxesData[j][2]);
    var xmaxJ = Math.max(boxesData[j][1], boxesData[j][3]);
    var areaI = (ymaxI - yminI) * (xmaxI - xminI);
    var areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
    if (areaI <= 0 || areaJ <= 0) {
        return 0.0;
    }
    var intersectionYmin = Math.max(yminI, yminJ);
    var intersectionXmin = Math.max(xminI, xminJ);
    var intersectionYmax = Math.min(ymaxI, ymaxJ);
    var intersectionXmax = Math.min(xmaxI, xmaxJ);
    var intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) *
        Math.max(intersectionXmax - intersectionXmin, 0.0);
    return intersectionArea / (areaI + areaJ - intersectionArea);
}
//# sourceMappingURL=nonMaxSuppression.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/outputLayer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/outputLayer.js ***!
  \**************************************************************************/
/*! exports provided: outputLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outputLayer", function() { return outputLayer; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function getCenterCoordinatesAndSizesLayer(x) {
    var vec = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"](x, [1, 0]));
    var sizes = [
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](vec[2], vec[0]),
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](vec[3], vec[1])
    ];
    var centers = [
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](vec[0], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](sizes[0], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](2))),
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](vec[1], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](sizes[1], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](2)))
    ];
    return {
        sizes: sizes,
        centers: centers
    };
}
function decodeBoxesLayer(x0, x1) {
    var _a = getCenterCoordinatesAndSizesLayer(x0), sizes = _a.sizes, centers = _a.centers;
    var vec = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"](x1, [1, 0]));
    var div0_out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["exp"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](vec[2], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](5))), sizes[0]), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](2));
    var add0_out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](vec[0], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](10)), sizes[0]), centers[0]);
    var div1_out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["exp"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](vec[3], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](5))), sizes[1]), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](2));
    var add1_out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"](vec[1], _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](10)), sizes[1]), centers[1]);
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"]([
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](add0_out, div0_out),
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](add1_out, div1_out),
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](add0_out, div0_out),
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](add1_out, div1_out)
    ]), [1, 0]);
}
function outputLayer(boxPredictions, classPredictions, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var batchSize = boxPredictions.shape[0];
        var boxes = decodeBoxesLayer(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tile"](params.extra_dim, [batchSize, 1, 1]), [-1, 4]), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](boxPredictions, [-1, 4]));
        boxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](boxes, [batchSize, (boxes.shape[0] / batchSize), 4]);
        var scoresAndClasses = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sigmoid"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"](classPredictions, [0, 0, 1], [-1, -1, -1]));
        var scores = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"](scoresAndClasses, [0, 0, 0], [-1, -1, 1]);
        scores = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"](scores, [batchSize, scores.shape[1]]);
        var boxesByBatch = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](boxes);
        var scoresByBatch = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"](scores);
        return {
            boxes: boxesByBatch,
            scores: scoresByBatch
        };
    });
}
//# sourceMappingURL=outputLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/pointwiseConvLayer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/pointwiseConvLayer.js ***!
  \*********************************************************************************/
/*! exports provided: pointwiseConvLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointwiseConvLayer", function() { return pointwiseConvLayer; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function pointwiseConvLayer(x, params, strides) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"](x, params.filters, strides, 'same');
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out, params.batch_norm_offset);
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"](out, 0, 6);
    });
}
//# sourceMappingURL=pointwiseConvLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/predictionLayer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/ssdMobilenetv1/predictionLayer.js ***!
  \******************************************************************************/
/*! exports provided: predictionLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "predictionLayer", function() { return predictionLayer; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _boxPredictionLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./boxPredictionLayer */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/boxPredictionLayer.js");
/* harmony import */ var _pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pointwiseConvLayer */ "./node_modules/face-api.js/build/es6/ssdMobilenetv1/pointwiseConvLayer.js");



function predictionLayer(x, conv11, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var conv0 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(x, params.conv_0, [1, 1]);
        var conv1 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(conv0, params.conv_1, [2, 2]);
        var conv2 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(conv1, params.conv_2, [1, 1]);
        var conv3 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(conv2, params.conv_3, [2, 2]);
        var conv4 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(conv3, params.conv_4, [1, 1]);
        var conv5 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(conv4, params.conv_5, [2, 2]);
        var conv6 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(conv5, params.conv_6, [1, 1]);
        var conv7 = Object(_pointwiseConvLayer__WEBPACK_IMPORTED_MODULE_2__["pointwiseConvLayer"])(conv6, params.conv_7, [2, 2]);
        var boxPrediction0 = Object(_boxPredictionLayer__WEBPACK_IMPORTED_MODULE_1__["boxPredictionLayer"])(conv11, params.box_predictor_0);
        var boxPrediction1 = Object(_boxPredictionLayer__WEBPACK_IMPORTED_MODULE_1__["boxPredictionLayer"])(x, params.box_predictor_1);
        var boxPrediction2 = Object(_boxPredictionLayer__WEBPACK_IMPORTED_MODULE_1__["boxPredictionLayer"])(conv1, params.box_predictor_2);
        var boxPrediction3 = Object(_boxPredictionLayer__WEBPACK_IMPORTED_MODULE_1__["boxPredictionLayer"])(conv3, params.box_predictor_3);
        var boxPrediction4 = Object(_boxPredictionLayer__WEBPACK_IMPORTED_MODULE_1__["boxPredictionLayer"])(conv5, params.box_predictor_4);
        var boxPrediction5 = Object(_boxPredictionLayer__WEBPACK_IMPORTED_MODULE_1__["boxPredictionLayer"])(conv7, params.box_predictor_5);
        var boxPredictions = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"]([
            boxPrediction0.boxPredictionEncoding,
            boxPrediction1.boxPredictionEncoding,
            boxPrediction2.boxPredictionEncoding,
            boxPrediction3.boxPredictionEncoding,
            boxPrediction4.boxPredictionEncoding,
            boxPrediction5.boxPredictionEncoding
        ], 1);
        var classPredictions = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"]([
            boxPrediction0.classPrediction,
            boxPrediction1.classPrediction,
            boxPrediction2.classPrediction,
            boxPrediction3.classPrediction,
            boxPrediction4.classPrediction,
            boxPrediction5.classPrediction
        ], 1);
        return {
            boxPredictions: boxPredictions,
            classPredictions: classPredictions
        };
    });
}
//# sourceMappingURL=predictionLayer.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetector.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetector.js ***!
  \*********************************************************************************/
/*! exports provided: TinyFaceDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyFaceDetector", function() { return TinyFaceDetector; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _tinyYolov2_TinyYolov2Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tinyYolov2/TinyYolov2Base */ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Base.js");
/* harmony import */ var _const__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./const */ "./node_modules/face-api.js/build/es6/tinyFaceDetector/const.js");




var TinyFaceDetector = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(TinyFaceDetector, _super);
    function TinyFaceDetector() {
        var _this = this;
        var config = {
            withSeparableConvs: true,
            iouThreshold: _const__WEBPACK_IMPORTED_MODULE_3__["IOU_THRESHOLD"],
            classes: ['face'],
            anchors: _const__WEBPACK_IMPORTED_MODULE_3__["BOX_ANCHORS"],
            meanRgb: _const__WEBPACK_IMPORTED_MODULE_3__["MEAN_RGB"],
            isFirstLayerConv2d: true,
            filterSizes: [3, 16, 32, 64, 128, 256, 512]
        };
        _this = _super.call(this, config) || this;
        return _this;
    }
    Object.defineProperty(TinyFaceDetector.prototype, "anchors", {
        get: function () {
            return this.config.anchors;
        },
        enumerable: true,
        configurable: true
    });
    TinyFaceDetector.prototype.locateFaces = function (input, forwardParams) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var objectDetections;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.detect(input, forwardParams)];
                    case 1:
                        objectDetections = _a.sent();
                        return [2 /*return*/, objectDetections.map(function (det) { return new _classes__WEBPACK_IMPORTED_MODULE_1__["FaceDetection"](det.score, det.relativeBox, { width: det.imageWidth, height: det.imageHeight }); })];
                }
            });
        });
    };
    TinyFaceDetector.prototype.getDefaultModelName = function () {
        return 'tiny_face_detector_model';
    };
    TinyFaceDetector.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return _super.prototype.extractParamsFromWeigthMap.call(this, weightMap);
    };
    return TinyFaceDetector;
}(_tinyYolov2_TinyYolov2Base__WEBPACK_IMPORTED_MODULE_2__["TinyYolov2Base"]));

//# sourceMappingURL=TinyFaceDetector.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetectorOptions.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetectorOptions.js ***!
  \****************************************************************************************/
/*! exports provided: TinyFaceDetectorOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyFaceDetectorOptions", function() { return TinyFaceDetectorOptions; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tinyYolov2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tinyYolov2 */ "./node_modules/face-api.js/build/es6/tinyYolov2/index.js");


var TinyFaceDetectorOptions = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(TinyFaceDetectorOptions, _super);
    function TinyFaceDetectorOptions() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._name = 'TinyFaceDetectorOptions';
        return _this;
    }
    return TinyFaceDetectorOptions;
}(_tinyYolov2__WEBPACK_IMPORTED_MODULE_1__["TinyYolov2Options"]));

//# sourceMappingURL=TinyFaceDetectorOptions.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyFaceDetector/const.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyFaceDetector/const.js ***!
  \**********************************************************************/
/*! exports provided: IOU_THRESHOLD, BOX_ANCHORS, MEAN_RGB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IOU_THRESHOLD", function() { return IOU_THRESHOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOX_ANCHORS", function() { return BOX_ANCHORS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MEAN_RGB", function() { return MEAN_RGB; });
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");

var IOU_THRESHOLD = 0.4;
var BOX_ANCHORS = [
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](1.603231, 2.094468),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](6.041143, 7.080126),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](2.882459, 3.518061),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](4.266906, 5.178857),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](9.041765, 10.66308)
];
var MEAN_RGB = [117.001, 114.697, 97.404];
//# sourceMappingURL=const.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyFaceDetector/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyFaceDetector/index.js ***!
  \**********************************************************************/
/*! exports provided: TinyFaceDetector, TinyFaceDetectorOptions, createTinyFaceDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTinyFaceDetector", function() { return createTinyFaceDetector; });
/* harmony import */ var _TinyFaceDetector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TinyFaceDetector */ "./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyFaceDetector", function() { return _TinyFaceDetector__WEBPACK_IMPORTED_MODULE_0__["TinyFaceDetector"]; });

/* harmony import */ var _TinyFaceDetectorOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TinyFaceDetectorOptions */ "./node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetectorOptions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyFaceDetectorOptions", function() { return _TinyFaceDetectorOptions__WEBPACK_IMPORTED_MODULE_1__["TinyFaceDetectorOptions"]; });




function createTinyFaceDetector(weights) {
    var net = new _TinyFaceDetector__WEBPACK_IMPORTED_MODULE_0__["TinyFaceDetector"]();
    net.extractWeights(weights);
    return net;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2.js ***!
  \*********************************************************************/
/*! exports provided: TinyYolov2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2", function() { return TinyYolov2; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _const__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./const */ "./node_modules/face-api.js/build/es6/tinyYolov2/const.js");
/* harmony import */ var _TinyYolov2Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TinyYolov2Base */ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Base.js");




var TinyYolov2 = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(TinyYolov2, _super);
    function TinyYolov2(withSeparableConvs) {
        if (withSeparableConvs === void 0) { withSeparableConvs = true; }
        var _this = this;
        var config = Object.assign({}, {
            withSeparableConvs: withSeparableConvs,
            iouThreshold: _const__WEBPACK_IMPORTED_MODULE_2__["IOU_THRESHOLD"],
            classes: ['face']
        }, withSeparableConvs
            ? {
                anchors: _const__WEBPACK_IMPORTED_MODULE_2__["BOX_ANCHORS_SEPARABLE"],
                meanRgb: _const__WEBPACK_IMPORTED_MODULE_2__["MEAN_RGB_SEPARABLE"]
            }
            : {
                anchors: _const__WEBPACK_IMPORTED_MODULE_2__["BOX_ANCHORS"],
                withClassScores: true
            });
        _this = _super.call(this, config) || this;
        return _this;
    }
    Object.defineProperty(TinyYolov2.prototype, "withSeparableConvs", {
        get: function () {
            return this.config.withSeparableConvs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TinyYolov2.prototype, "anchors", {
        get: function () {
            return this.config.anchors;
        },
        enumerable: true,
        configurable: true
    });
    TinyYolov2.prototype.locateFaces = function (input, forwardParams) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var objectDetections;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.detect(input, forwardParams)];
                    case 1:
                        objectDetections = _a.sent();
                        return [2 /*return*/, objectDetections.map(function (det) { return new _classes__WEBPACK_IMPORTED_MODULE_1__["FaceDetection"](det.score, det.relativeBox, { width: det.imageWidth, height: det.imageHeight }); })];
                }
            });
        });
    };
    TinyYolov2.prototype.getDefaultModelName = function () {
        return this.withSeparableConvs ? _const__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_MODEL_NAME_SEPARABLE_CONV"] : _const__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_MODEL_NAME"];
    };
    TinyYolov2.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return _super.prototype.extractParamsFromWeigthMap.call(this, weightMap);
    };
    return TinyYolov2;
}(_TinyYolov2Base__WEBPACK_IMPORTED_MODULE_3__["TinyYolov2Base"]));

//# sourceMappingURL=TinyYolov2.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Base.js":
/*!*************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Base.js ***!
  \*************************************************************************/
/*! exports provided: TinyYolov2Base */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2Base", function() { return TinyYolov2Base; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes_BoundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes/BoundingBox */ "./node_modules/face-api.js/build/es6/classes/BoundingBox.js");
/* harmony import */ var _classes_ObjectDetection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../classes/ObjectDetection */ "./node_modules/face-api.js/build/es6/classes/ObjectDetection.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _ops_nonMaxSuppression__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../ops/nonMaxSuppression */ "./node_modules/face-api.js/build/es6/ops/nonMaxSuppression.js");
/* harmony import */ var _ops_normalize__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../ops/normalize */ "./node_modules/face-api.js/build/es6/ops/normalize.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./config */ "./node_modules/face-api.js/build/es6/tinyYolov2/config.js");
/* harmony import */ var _convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./convWithBatchNorm */ "./node_modules/face-api.js/build/es6/tinyYolov2/convWithBatchNorm.js");
/* harmony import */ var _depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./depthwiseSeparableConv */ "./node_modules/face-api.js/build/es6/tinyYolov2/depthwiseSeparableConv.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/tinyYolov2/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/tinyYolov2/extractParamsFromWeigthMap.js");
/* harmony import */ var _leaky__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./leaky */ "./node_modules/face-api.js/build/es6/tinyYolov2/leaky.js");
/* harmony import */ var _TinyYolov2Options__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./TinyYolov2Options */ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Options.js");

















var TinyYolov2Base = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(TinyYolov2Base, _super);
    function TinyYolov2Base(config) {
        var _this = _super.call(this, 'TinyYolov2') || this;
        Object(_config__WEBPACK_IMPORTED_MODULE_10__["validateConfig"])(config);
        _this._config = config;
        return _this;
    }
    Object.defineProperty(TinyYolov2Base.prototype, "config", {
        get: function () {
            return this._config;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TinyYolov2Base.prototype, "withClassScores", {
        get: function () {
            return this.config.withClassScores || this.config.classes.length > 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TinyYolov2Base.prototype, "boxEncodingSize", {
        get: function () {
            return 5 + (this.withClassScores ? this.config.classes.length : 0);
        },
        enumerable: true,
        configurable: true
    });
    TinyYolov2Base.prototype.runTinyYolov2 = function (x, params) {
        var out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(x, params.conv0);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(out, params.conv1);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(out, params.conv2);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(out, params.conv3);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(out, params.conv4);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(out, params.conv5);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [1, 1], 'same');
        out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(out, params.conv6);
        out = Object(_convWithBatchNorm__WEBPACK_IMPORTED_MODULE_11__["convWithBatchNorm"])(out, params.conv7);
        return Object(_common__WEBPACK_IMPORTED_MODULE_4__["convLayer"])(out, params.conv8, 'valid', false);
    };
    TinyYolov2Base.prototype.runMobilenet = function (x, params) {
        var out = this.config.isFirstLayerConv2d
            ? Object(_leaky__WEBPACK_IMPORTED_MODULE_15__["leaky"])(Object(_common__WEBPACK_IMPORTED_MODULE_4__["convLayer"])(x, params.conv0, 'valid', false))
            : Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(x, params.conv0);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(out, params.conv1);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(out, params.conv2);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(out, params.conv3);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(out, params.conv4);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [2, 2], 'same');
        out = Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(out, params.conv5);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [2, 2], [1, 1], 'same');
        out = params.conv6 ? Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(out, params.conv6) : out;
        out = params.conv7 ? Object(_depthwiseSeparableConv__WEBPACK_IMPORTED_MODULE_12__["depthwiseSeparableConv"])(out, params.conv7) : out;
        return Object(_common__WEBPACK_IMPORTED_MODULE_4__["convLayer"])(out, params.conv8, 'valid', false);
    };
    TinyYolov2Base.prototype.forwardInput = function (input, inputSize) {
        var _this = this;
        var params = this.params;
        if (!params) {
            throw new Error('TinyYolov2 - load model before inference');
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var batchTensor = input.toBatchTensor(inputSize, false).toFloat();
            batchTensor = _this.config.meanRgb
                ? Object(_ops_normalize__WEBPACK_IMPORTED_MODULE_9__["normalize"])(batchTensor, _this.config.meanRgb)
                : batchTensor;
            batchTensor = batchTensor.div(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](256));
            return _this.config.withSeparableConvs
                ? _this.runMobilenet(batchTensor, params)
                : _this.runTinyYolov2(batchTensor, params);
        });
    };
    TinyYolov2Base.prototype.forward = function (input, inputSize) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_5__["toNetInput"])(input)];
                    case 1: return [4 /*yield*/, _a.apply(this, [_b.sent(), inputSize])];
                    case 2: return [2 /*return*/, _b.sent()];
                }
            });
        });
    };
    TinyYolov2Base.prototype.detect = function (input, forwardParams) {
        if (forwardParams === void 0) { forwardParams = {}; }
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a, inputSize, scoreThreshold, netInput, out, out0, inputDimensions, results, boxes, scores, classScores, classNames, indices, detections;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = new _TinyYolov2Options__WEBPACK_IMPORTED_MODULE_16__["TinyYolov2Options"](forwardParams), inputSize = _a.inputSize, scoreThreshold = _a.scoreThreshold;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_5__["toNetInput"])(input)];
                    case 1:
                        netInput = _b.sent();
                        return [4 /*yield*/, this.forwardInput(netInput, inputSize)];
                    case 2:
                        out = _b.sent();
                        out0 = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["unstack"](out)[0].expandDims(); });
                        inputDimensions = {
                            width: netInput.getInputWidth(0),
                            height: netInput.getInputHeight(0)
                        };
                        return [4 /*yield*/, this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold)];
                    case 3:
                        results = _b.sent();
                        out.dispose();
                        out0.dispose();
                        boxes = results.map(function (res) { return res.box; });
                        scores = results.map(function (res) { return res.score; });
                        classScores = results.map(function (res) { return res.classScore; });
                        classNames = results.map(function (res) { return _this.config.classes[res.label]; });
                        indices = Object(_ops_nonMaxSuppression__WEBPACK_IMPORTED_MODULE_8__["nonMaxSuppression"])(boxes.map(function (box) { return box.rescale(inputSize); }), scores, this.config.iouThreshold, true);
                        detections = indices.map(function (idx) {
                            return new _classes_ObjectDetection__WEBPACK_IMPORTED_MODULE_3__["ObjectDetection"](scores[idx], classScores[idx], classNames[idx], boxes[idx], inputDimensions);
                        });
                        return [2 /*return*/, detections];
                }
            });
        });
    };
    TinyYolov2Base.prototype.getDefaultModelName = function () {
        return '';
    };
    TinyYolov2Base.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_14__["extractParamsFromWeigthMap"])(weightMap, this.config);
    };
    TinyYolov2Base.prototype.extractParams = function (weights) {
        var filterSizes = this.config.filterSizes || TinyYolov2Base.DEFAULT_FILTER_SIZES;
        var numFilters = filterSizes ? filterSizes.length : undefined;
        if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) {
            throw new Error("TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found " + numFilters + " filterSizes in config");
        }
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_13__["extractParams"])(weights, this.config, this.boxEncodingSize, filterSizes);
    };
    TinyYolov2Base.prototype.extractBoxes = function (outputTensor, inputBlobDimensions, scoreThreshold) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var width, height, inputSize, correctionFactorX, correctionFactorY, numCells, numBoxes, _a, boxesTensor, scoresTensor, classScoresTensor, results, scoresData, boxesData, row, col, anchor, score, ctX, ctY, width_1, height_1, x, y, pos, _b, classScore, label, _c;
            var _this = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        width = inputBlobDimensions.width, height = inputBlobDimensions.height;
                        inputSize = Math.max(width, height);
                        correctionFactorX = inputSize / width;
                        correctionFactorY = inputSize / height;
                        numCells = outputTensor.shape[1];
                        numBoxes = this.config.anchors.length;
                        _a = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
                            var reshaped = outputTensor.reshape([numCells, numCells, numBoxes, _this.boxEncodingSize]);
                            var boxes = reshaped.slice([0, 0, 0, 0], [numCells, numCells, numBoxes, 4]);
                            var scores = reshaped.slice([0, 0, 0, 4], [numCells, numCells, numBoxes, 1]);
                            var classScores = _this.withClassScores
                                ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["softmax"](reshaped.slice([0, 0, 0, 5], [numCells, numCells, numBoxes, _this.config.classes.length]), 3)
                                : _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](0);
                            return [boxes, scores, classScores];
                        }), boxesTensor = _a[0], scoresTensor = _a[1], classScoresTensor = _a[2];
                        results = [];
                        return [4 /*yield*/, scoresTensor.array()];
                    case 1:
                        scoresData = _d.sent();
                        return [4 /*yield*/, boxesTensor.array()];
                    case 2:
                        boxesData = _d.sent();
                        row = 0;
                        _d.label = 3;
                    case 3:
                        if (!(row < numCells)) return [3 /*break*/, 12];
                        col = 0;
                        _d.label = 4;
                    case 4:
                        if (!(col < numCells)) return [3 /*break*/, 11];
                        anchor = 0;
                        _d.label = 5;
                    case 5:
                        if (!(anchor < numBoxes)) return [3 /*break*/, 10];
                        score = Object(_ops__WEBPACK_IMPORTED_MODULE_7__["sigmoid"])(scoresData[row][col][anchor][0]);
                        if (!(!scoreThreshold || score > scoreThreshold)) return [3 /*break*/, 9];
                        ctX = ((col + Object(_ops__WEBPACK_IMPORTED_MODULE_7__["sigmoid"])(boxesData[row][col][anchor][0])) / numCells) * correctionFactorX;
                        ctY = ((row + Object(_ops__WEBPACK_IMPORTED_MODULE_7__["sigmoid"])(boxesData[row][col][anchor][1])) / numCells) * correctionFactorY;
                        width_1 = ((Math.exp(boxesData[row][col][anchor][2]) * this.config.anchors[anchor].x) / numCells) * correctionFactorX;
                        height_1 = ((Math.exp(boxesData[row][col][anchor][3]) * this.config.anchors[anchor].y) / numCells) * correctionFactorY;
                        x = (ctX - (width_1 / 2));
                        y = (ctY - (height_1 / 2));
                        pos = { row: row, col: col, anchor: anchor };
                        if (!this.withClassScores) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.extractPredictedClass(classScoresTensor, pos)];
                    case 6:
                        _c = _d.sent();
                        return [3 /*break*/, 8];
                    case 7:
                        _c = { classScore: 1, label: 0 };
                        _d.label = 8;
                    case 8:
                        _b = _c, classScore = _b.classScore, label = _b.label;
                        results.push(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({ box: new _classes_BoundingBox__WEBPACK_IMPORTED_MODULE_2__["BoundingBox"](x, y, x + width_1, y + height_1), score: score, classScore: score * classScore, label: label }, pos));
                        _d.label = 9;
                    case 9:
                        anchor++;
                        return [3 /*break*/, 5];
                    case 10:
                        col++;
                        return [3 /*break*/, 4];
                    case 11:
                        row++;
                        return [3 /*break*/, 3];
                    case 12:
                        boxesTensor.dispose();
                        scoresTensor.dispose();
                        classScoresTensor.dispose();
                        return [2 /*return*/, results];
                }
            });
        });
    };
    TinyYolov2Base.prototype.extractPredictedClass = function (classesTensor, pos) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var row, col, anchor, classesData;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        row = pos.row, col = pos.col, anchor = pos.anchor;
                        return [4 /*yield*/, classesTensor.array()];
                    case 1:
                        classesData = _a.sent();
                        return [2 /*return*/, Array(this.config.classes.length).fill(0)
                                .map(function (_, i) { return classesData[row][col][anchor][i]; })
                                .map(function (classScore, label) { return ({
                                classScore: classScore,
                                label: label
                            }); })
                                .reduce(function (max, curr) { return max.classScore > curr.classScore ? max : curr; })];
                }
            });
        });
    };
    TinyYolov2Base.DEFAULT_FILTER_SIZES = [
        3, 16, 32, 64, 128, 256, 512, 1024, 1024
    ];
    return TinyYolov2Base;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_6__["NeuralNetwork"]));

//# sourceMappingURL=TinyYolov2Base.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Options.js":
/*!****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Options.js ***!
  \****************************************************************************/
/*! exports provided: TinyYolov2SizeType, TinyYolov2Options */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2SizeType", function() { return TinyYolov2SizeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2Options", function() { return TinyYolov2Options; });
var TinyYolov2SizeType;
(function (TinyYolov2SizeType) {
    TinyYolov2SizeType[TinyYolov2SizeType["XS"] = 224] = "XS";
    TinyYolov2SizeType[TinyYolov2SizeType["SM"] = 320] = "SM";
    TinyYolov2SizeType[TinyYolov2SizeType["MD"] = 416] = "MD";
    TinyYolov2SizeType[TinyYolov2SizeType["LG"] = 608] = "LG";
})(TinyYolov2SizeType || (TinyYolov2SizeType = {}));
var TinyYolov2Options = /** @class */ (function () {
    function TinyYolov2Options(_a) {
        var _b = _a === void 0 ? {} : _a, inputSize = _b.inputSize, scoreThreshold = _b.scoreThreshold;
        this._name = 'TinyYolov2Options';
        this._inputSize = inputSize || 416;
        this._scoreThreshold = scoreThreshold || 0.5;
        if (typeof this._inputSize !== 'number' || this._inputSize % 32 !== 0) {
            throw new Error(this._name + " - expected inputSize to be a number divisible by 32");
        }
        if (typeof this._scoreThreshold !== 'number' || this._scoreThreshold <= 0 || this._scoreThreshold >= 1) {
            throw new Error(this._name + " - expected scoreThreshold to be a number between 0 and 1");
        }
    }
    Object.defineProperty(TinyYolov2Options.prototype, "inputSize", {
        get: function () { return this._inputSize; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TinyYolov2Options.prototype, "scoreThreshold", {
        get: function () { return this._scoreThreshold; },
        enumerable: true,
        configurable: true
    });
    return TinyYolov2Options;
}());

//# sourceMappingURL=TinyYolov2Options.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/config.js":
/*!*****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/config.js ***!
  \*****************************************************************/
/*! exports provided: validateConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateConfig", function() { return validateConfig; });
var isNumber = function (arg) { return typeof arg === 'number'; };
function validateConfig(config) {
    if (!config) {
        throw new Error("invalid config: " + config);
    }
    if (typeof config.withSeparableConvs !== 'boolean') {
        throw new Error("config.withSeparableConvs has to be a boolean, have: " + config.withSeparableConvs);
    }
    if (!isNumber(config.iouThreshold) || config.iouThreshold < 0 || config.iouThreshold > 1.0) {
        throw new Error("config.iouThreshold has to be a number between [0, 1], have: " + config.iouThreshold);
    }
    if (!Array.isArray(config.classes)
        || !config.classes.length
        || !config.classes.every(function (c) { return typeof c === 'string'; })) {
        throw new Error("config.classes has to be an array class names: string[], have: " + JSON.stringify(config.classes));
    }
    if (!Array.isArray(config.anchors)
        || !config.anchors.length
        || !config.anchors.map(function (a) { return a || {}; }).every(function (a) { return isNumber(a.x) && isNumber(a.y); })) {
        throw new Error("config.anchors has to be an array of { x: number, y: number }, have: " + JSON.stringify(config.anchors));
    }
    if (config.meanRgb && (!Array.isArray(config.meanRgb)
        || config.meanRgb.length !== 3
        || !config.meanRgb.every(isNumber))) {
        throw new Error("config.meanRgb has to be an array of shape [number, number, number], have: " + JSON.stringify(config.meanRgb));
    }
}
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/const.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/const.js ***!
  \****************************************************************/
/*! exports provided: IOU_THRESHOLD, BOX_ANCHORS, BOX_ANCHORS_SEPARABLE, MEAN_RGB_SEPARABLE, DEFAULT_MODEL_NAME, DEFAULT_MODEL_NAME_SEPARABLE_CONV */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IOU_THRESHOLD", function() { return IOU_THRESHOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOX_ANCHORS", function() { return BOX_ANCHORS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOX_ANCHORS_SEPARABLE", function() { return BOX_ANCHORS_SEPARABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MEAN_RGB_SEPARABLE", function() { return MEAN_RGB_SEPARABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_MODEL_NAME", function() { return DEFAULT_MODEL_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_MODEL_NAME_SEPARABLE_CONV", function() { return DEFAULT_MODEL_NAME_SEPARABLE_CONV; });
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");

var IOU_THRESHOLD = 0.4;
var BOX_ANCHORS = [
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](0.738768, 0.874946),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](2.42204, 2.65704),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](4.30971, 7.04493),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](10.246, 4.59428),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](12.6868, 11.8741)
];
var BOX_ANCHORS_SEPARABLE = [
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](1.603231, 2.094468),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](6.041143, 7.080126),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](2.882459, 3.518061),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](4.266906, 5.178857),
    new _classes__WEBPACK_IMPORTED_MODULE_0__["Point"](9.041765, 10.66308)
];
var MEAN_RGB_SEPARABLE = [117.001, 114.697, 97.404];
var DEFAULT_MODEL_NAME = 'tiny_yolov2_model';
var DEFAULT_MODEL_NAME_SEPARABLE_CONV = 'tiny_yolov2_separable_conv_model';
//# sourceMappingURL=const.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/convWithBatchNorm.js":
/*!****************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/convWithBatchNorm.js ***!
  \****************************************************************************/
/*! exports provided: convWithBatchNorm */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convWithBatchNorm", function() { return convWithBatchNorm; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _leaky__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./leaky */ "./node_modules/face-api.js/build/es6/tinyYolov2/leaky.js");


function convWithBatchNorm(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"](x, [[0, 0], [1, 1], [1, 1], [0, 0]]);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"](out, params.conv.filters, [1, 1], 'valid');
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](out, params.bn.sub);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](out, params.bn.truediv);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out, params.conv.bias);
        return Object(_leaky__WEBPACK_IMPORTED_MODULE_1__["leaky"])(out);
    });
}
//# sourceMappingURL=convWithBatchNorm.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/depthwiseSeparableConv.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/depthwiseSeparableConv.js ***!
  \*********************************************************************************/
/*! exports provided: depthwiseSeparableConv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthwiseSeparableConv", function() { return depthwiseSeparableConv; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _leaky__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./leaky */ "./node_modules/face-api.js/build/es6/tinyYolov2/leaky.js");


function depthwiseSeparableConv(x, params) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"](x, [[0, 0], [1, 1], [1, 1], [0, 0]]);
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["separableConv2d"](out, params.depthwise_filter, params.pointwise_filter, [1, 1], 'valid');
        out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](out, params.bias);
        return Object(_leaky__WEBPACK_IMPORTED_MODULE_1__["leaky"])(out);
    });
}
//# sourceMappingURL=depthwiseSeparableConv.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/extractParams.js":
/*!************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/extractParams.js ***!
  \************************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _common_extractSeparableConvParamsFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/extractSeparableConvParamsFactory */ "./node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js");
/* harmony import */ var _common_extractWeightsFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/extractWeightsFactory */ "./node_modules/face-api.js/build/es6/common/extractWeightsFactory.js");




function extractorsFactory(extractWeights, paramMappings) {
    var extractConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_1__["extractConvParamsFactory"])(extractWeights, paramMappings);
    function extractBatchNormParams(size, mappedPrefix) {
        var sub = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(size));
        var truediv = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"](extractWeights(size));
        paramMappings.push({ paramPath: mappedPrefix + "/sub" }, { paramPath: mappedPrefix + "/truediv" });
        return { sub: sub, truediv: truediv };
    }
    function extractConvWithBatchNormParams(channelsIn, channelsOut, mappedPrefix) {
        var conv = extractConvParams(channelsIn, channelsOut, 3, mappedPrefix + "/conv");
        var bn = extractBatchNormParams(channelsOut, mappedPrefix + "/bn");
        return { conv: conv, bn: bn };
    }
    var extractSeparableConvParams = Object(_common_extractSeparableConvParamsFactory__WEBPACK_IMPORTED_MODULE_2__["extractSeparableConvParamsFactory"])(extractWeights, paramMappings);
    return {
        extractConvParams: extractConvParams,
        extractConvWithBatchNormParams: extractConvWithBatchNormParams,
        extractSeparableConvParams: extractSeparableConvParams
    };
}
function extractParams(weights, config, boxEncodingSize, filterSizes) {
    var _a = Object(_common_extractWeightsFactory__WEBPACK_IMPORTED_MODULE_3__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var paramMappings = [];
    var _b = extractorsFactory(extractWeights, paramMappings), extractConvParams = _b.extractConvParams, extractConvWithBatchNormParams = _b.extractConvWithBatchNormParams, extractSeparableConvParams = _b.extractSeparableConvParams;
    var params;
    if (config.withSeparableConvs) {
        var s0 = filterSizes[0], s1 = filterSizes[1], s2 = filterSizes[2], s3 = filterSizes[3], s4 = filterSizes[4], s5 = filterSizes[5], s6 = filterSizes[6], s7 = filterSizes[7], s8 = filterSizes[8];
        var conv0 = config.isFirstLayerConv2d
            ? extractConvParams(s0, s1, 3, 'conv0')
            : extractSeparableConvParams(s0, s1, 'conv0');
        var conv1 = extractSeparableConvParams(s1, s2, 'conv1');
        var conv2 = extractSeparableConvParams(s2, s3, 'conv2');
        var conv3 = extractSeparableConvParams(s3, s4, 'conv3');
        var conv4 = extractSeparableConvParams(s4, s5, 'conv4');
        var conv5 = extractSeparableConvParams(s5, s6, 'conv5');
        var conv6 = s7 ? extractSeparableConvParams(s6, s7, 'conv6') : undefined;
        var conv7 = s8 ? extractSeparableConvParams(s7, s8, 'conv7') : undefined;
        var conv8 = extractConvParams(s8 || s7 || s6, 5 * boxEncodingSize, 1, 'conv8');
        params = { conv0: conv0, conv1: conv1, conv2: conv2, conv3: conv3, conv4: conv4, conv5: conv5, conv6: conv6, conv7: conv7, conv8: conv8 };
    }
    else {
        var s0 = filterSizes[0], s1 = filterSizes[1], s2 = filterSizes[2], s3 = filterSizes[3], s4 = filterSizes[4], s5 = filterSizes[5], s6 = filterSizes[6], s7 = filterSizes[7], s8 = filterSizes[8];
        var conv0 = extractConvWithBatchNormParams(s0, s1, 'conv0');
        var conv1 = extractConvWithBatchNormParams(s1, s2, 'conv1');
        var conv2 = extractConvWithBatchNormParams(s2, s3, 'conv2');
        var conv3 = extractConvWithBatchNormParams(s3, s4, 'conv3');
        var conv4 = extractConvWithBatchNormParams(s4, s5, 'conv4');
        var conv5 = extractConvWithBatchNormParams(s5, s6, 'conv5');
        var conv6 = extractConvWithBatchNormParams(s6, s7, 'conv6');
        var conv7 = extractConvWithBatchNormParams(s7, s8, 'conv7');
        var conv8 = extractConvParams(s8, 5 * boxEncodingSize, 1, 'conv8');
        params = { conv0: conv0, conv1: conv1, conv2: conv2, conv3: conv3, conv4: conv4, conv5: conv5, conv6: conv6, conv7: conv7, conv8: conv8 };
    }
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/extractParamsFromWeigthMap.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/extractParamsFromWeigthMap.js ***!
  \*************************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var _common_disposeUnusedWeightTensors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/disposeUnusedWeightTensors */ "./node_modules/face-api.js/build/es6/common/disposeUnusedWeightTensors.js");
/* harmony import */ var _common_extractSeparableConvParamsFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/extractSeparableConvParamsFactory */ "./node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js");
/* harmony import */ var _common_extractWeightEntryFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/extractWeightEntryFactory */ "./node_modules/face-api.js/build/es6/common/extractWeightEntryFactory.js");



function extractorsFactory(weightMap, paramMappings) {
    var extractWeightEntry = Object(_common_extractWeightEntryFactory__WEBPACK_IMPORTED_MODULE_2__["extractWeightEntryFactory"])(weightMap, paramMappings);
    function extractBatchNormParams(prefix) {
        var sub = extractWeightEntry(prefix + "/sub", 1);
        var truediv = extractWeightEntry(prefix + "/truediv", 1);
        return { sub: sub, truediv: truediv };
    }
    function extractConvParams(prefix) {
        var filters = extractWeightEntry(prefix + "/filters", 4);
        var bias = extractWeightEntry(prefix + "/bias", 1);
        return { filters: filters, bias: bias };
    }
    function extractConvWithBatchNormParams(prefix) {
        var conv = extractConvParams(prefix + "/conv");
        var bn = extractBatchNormParams(prefix + "/bn");
        return { conv: conv, bn: bn };
    }
    var extractSeparableConvParams = Object(_common_extractSeparableConvParamsFactory__WEBPACK_IMPORTED_MODULE_1__["loadSeparableConvParamsFactory"])(extractWeightEntry);
    return {
        extractConvParams: extractConvParams,
        extractConvWithBatchNormParams: extractConvWithBatchNormParams,
        extractSeparableConvParams: extractSeparableConvParams
    };
}
function extractParamsFromWeigthMap(weightMap, config) {
    var paramMappings = [];
    var _a = extractorsFactory(weightMap, paramMappings), extractConvParams = _a.extractConvParams, extractConvWithBatchNormParams = _a.extractConvWithBatchNormParams, extractSeparableConvParams = _a.extractSeparableConvParams;
    var params;
    if (config.withSeparableConvs) {
        var numFilters = (config.filterSizes && config.filterSizes.length || 9);
        params = {
            conv0: config.isFirstLayerConv2d ? extractConvParams('conv0') : extractSeparableConvParams('conv0'),
            conv1: extractSeparableConvParams('conv1'),
            conv2: extractSeparableConvParams('conv2'),
            conv3: extractSeparableConvParams('conv3'),
            conv4: extractSeparableConvParams('conv4'),
            conv5: extractSeparableConvParams('conv5'),
            conv6: numFilters > 7 ? extractSeparableConvParams('conv6') : undefined,
            conv7: numFilters > 8 ? extractSeparableConvParams('conv7') : undefined,
            conv8: extractConvParams('conv8')
        };
    }
    else {
        params = {
            conv0: extractConvWithBatchNormParams('conv0'),
            conv1: extractConvWithBatchNormParams('conv1'),
            conv2: extractConvWithBatchNormParams('conv2'),
            conv3: extractConvWithBatchNormParams('conv3'),
            conv4: extractConvWithBatchNormParams('conv4'),
            conv5: extractConvWithBatchNormParams('conv5'),
            conv6: extractConvWithBatchNormParams('conv6'),
            conv7: extractConvWithBatchNormParams('conv7'),
            conv8: extractConvParams('conv8')
        };
    }
    Object(_common_disposeUnusedWeightTensors__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: params, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/index.js ***!
  \****************************************************************/
/*! exports provided: TinyYolov2SizeType, TinyYolov2Options, validateConfig, TinyYolov2, createTinyYolov2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTinyYolov2", function() { return createTinyYolov2; });
/* harmony import */ var _TinyYolov2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TinyYolov2 */ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2", function() { return _TinyYolov2__WEBPACK_IMPORTED_MODULE_0__["TinyYolov2"]; });

/* harmony import */ var _TinyYolov2Options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TinyYolov2Options */ "./node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Options.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2SizeType", function() { return _TinyYolov2Options__WEBPACK_IMPORTED_MODULE_1__["TinyYolov2SizeType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyYolov2Options", function() { return _TinyYolov2Options__WEBPACK_IMPORTED_MODULE_1__["TinyYolov2Options"]; });

/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ "./node_modules/face-api.js/build/es6/tinyYolov2/config.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "validateConfig", function() { return _config__WEBPACK_IMPORTED_MODULE_2__["validateConfig"]; });





function createTinyYolov2(weights, withSeparableConvs) {
    if (withSeparableConvs === void 0) { withSeparableConvs = true; }
    var net = new _TinyYolov2__WEBPACK_IMPORTED_MODULE_0__["TinyYolov2"](withSeparableConvs);
    net.extractWeights(weights);
    return net;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/tinyYolov2/leaky.js":
/*!****************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/tinyYolov2/leaky.js ***!
  \****************************************************************/
/*! exports provided: leaky */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leaky", function() { return leaky; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");

function leaky(x) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"](function () {
        var min = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"](x, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"](0.10000000149011612));
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"](x, min)), min);
        //return tf.maximum(x, min)
    });
}
//# sourceMappingURL=leaky.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/utils/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/utils/index.js ***!
  \***********************************************************/
/*! exports provided: isTensor, isTensor1D, isTensor2D, isTensor3D, isTensor4D, isFloat, isEven, round, isDimensions, computeReshapedDimensions, getCenterPoint, range, isValidNumber, isValidProbablitiy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTensor", function() { return isTensor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTensor1D", function() { return isTensor1D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTensor2D", function() { return isTensor2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTensor3D", function() { return isTensor3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTensor4D", function() { return isTensor4D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFloat", function() { return isFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEven", function() { return isEven; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDimensions", function() { return isDimensions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeReshapedDimensions", function() { return computeReshapedDimensions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCenterPoint", function() { return getCenterPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidNumber", function() { return isValidNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidProbablitiy", function() { return isValidProbablitiy; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes */ "./node_modules/face-api.js/build/es6/classes/index.js");
/* harmony import */ var _classes_Dimensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes/Dimensions */ "./node_modules/face-api.js/build/es6/classes/Dimensions.js");



function isTensor(tensor, dim) {
    return tensor instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"] && tensor.shape.length === dim;
}
function isTensor1D(tensor) {
    return isTensor(tensor, 1);
}
function isTensor2D(tensor) {
    return isTensor(tensor, 2);
}
function isTensor3D(tensor) {
    return isTensor(tensor, 3);
}
function isTensor4D(tensor) {
    return isTensor(tensor, 4);
}
function isFloat(num) {
    return num % 1 !== 0;
}
function isEven(num) {
    return num % 2 === 0;
}
function round(num, prec) {
    if (prec === void 0) { prec = 2; }
    var f = Math.pow(10, prec);
    return Math.floor(num * f) / f;
}
function isDimensions(obj) {
    return obj && obj.width && obj.height;
}
function computeReshapedDimensions(_a, inputSize) {
    var width = _a.width, height = _a.height;
    var scale = inputSize / Math.max(height, width);
    return new _classes_Dimensions__WEBPACK_IMPORTED_MODULE_2__["Dimensions"](Math.round(width * scale), Math.round(height * scale));
}
function getCenterPoint(pts) {
    return pts.reduce(function (sum, pt) { return sum.add(pt); }, new _classes__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0))
        .div(new _classes__WEBPACK_IMPORTED_MODULE_1__["Point"](pts.length, pts.length));
}
function range(num, start, step) {
    return Array(num).fill(0).map(function (_, i) { return start + (i * step); });
}
function isValidNumber(num) {
    return !!num && num !== Infinity && num !== -Infinity && !isNaN(num) || num === 0;
}
function isValidProbablitiy(num) {
    return isValidNumber(num) && 0 <= num && num <= 1.0;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/xception/TinyXception.js":
/*!*********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/xception/TinyXception.js ***!
  \*********************************************************************/
/*! exports provided: TinyXception */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TinyXception", function() { return TinyXception; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom */ "./node_modules/face-api.js/build/es6/dom/index.js");
/* harmony import */ var _NeuralNetwork__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../NeuralNetwork */ "./node_modules/face-api.js/build/es6/NeuralNetwork.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ops */ "./node_modules/face-api.js/build/es6/ops/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");
/* harmony import */ var _extractParams__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extractParams */ "./node_modules/face-api.js/build/es6/xception/extractParams.js");
/* harmony import */ var _extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./extractParamsFromWeigthMap */ "./node_modules/face-api.js/build/es6/xception/extractParamsFromWeigthMap.js");









function conv(x, params, stride) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["add"](_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["conv2d"](x, params.filters, stride, 'same'), params.bias);
}
function reductionBlock(x, params, isActivateInput) {
    if (isActivateInput === void 0) { isActivateInput = true; }
    var out = isActivateInput ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](x) : x;
    out = Object(_common__WEBPACK_IMPORTED_MODULE_2__["depthwiseSeparableConv"])(out, params.separable_conv0, [1, 1]);
    out = Object(_common__WEBPACK_IMPORTED_MODULE_2__["depthwiseSeparableConv"])(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](out), params.separable_conv1, [1, 1]);
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["maxPool"](out, [3, 3], [2, 2], 'same');
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["add"](out, conv(x, params.expansion_conv, [2, 2]));
    return out;
}
function mainBlock(x, params) {
    var out = Object(_common__WEBPACK_IMPORTED_MODULE_2__["depthwiseSeparableConv"])(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](x), params.separable_conv0, [1, 1]);
    out = Object(_common__WEBPACK_IMPORTED_MODULE_2__["depthwiseSeparableConv"])(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](out), params.separable_conv1, [1, 1]);
    out = Object(_common__WEBPACK_IMPORTED_MODULE_2__["depthwiseSeparableConv"])(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](out), params.separable_conv2, [1, 1]);
    out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["add"](out, x);
    return out;
}
var TinyXception = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(TinyXception, _super);
    function TinyXception(numMainBlocks) {
        var _this = _super.call(this, 'TinyXception') || this;
        _this._numMainBlocks = numMainBlocks;
        return _this;
    }
    TinyXception.prototype.forwardInput = function (input) {
        var _this = this;
        var params = this.params;
        if (!params) {
            throw new Error('TinyXception - load model before inference');
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["tidy"](function () {
            var batchTensor = input.toBatchTensor(112, true);
            var meanRgb = [122.782, 117.001, 104.298];
            var normalized = Object(_ops__WEBPACK_IMPORTED_MODULE_5__["normalize"])(batchTensor, meanRgb).div(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["scalar"](256));
            var out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](conv(normalized, params.entry_flow.conv_in, [2, 2]));
            out = reductionBlock(out, params.entry_flow.reduction_block_0, false);
            out = reductionBlock(out, params.entry_flow.reduction_block_1);
            Object(_utils__WEBPACK_IMPORTED_MODULE_6__["range"])(_this._numMainBlocks, 0, 1).forEach(function (idx) {
                out = mainBlock(out, params.middle_flow["main_block_" + idx]);
            });
            out = reductionBlock(out, params.exit_flow.reduction_block);
            out = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__["relu"](Object(_common__WEBPACK_IMPORTED_MODULE_2__["depthwiseSeparableConv"])(out, params.exit_flow.separable_conv, [1, 1]));
            return out;
        });
    };
    TinyXception.prototype.forward = function (input) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function () {
            var _a;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.forwardInput;
                        return [4 /*yield*/, Object(_dom__WEBPACK_IMPORTED_MODULE_3__["toNetInput"])(input)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    TinyXception.prototype.getDefaultModelName = function () {
        return 'tiny_xception_model';
    };
    TinyXception.prototype.extractParamsFromWeigthMap = function (weightMap) {
        return Object(_extractParamsFromWeigthMap__WEBPACK_IMPORTED_MODULE_8__["extractParamsFromWeigthMap"])(weightMap, this._numMainBlocks);
    };
    TinyXception.prototype.extractParams = function (weights) {
        return Object(_extractParams__WEBPACK_IMPORTED_MODULE_7__["extractParams"])(weights, this._numMainBlocks);
    };
    return TinyXception;
}(_NeuralNetwork__WEBPACK_IMPORTED_MODULE_4__["NeuralNetwork"]));

//# sourceMappingURL=TinyXception.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/xception/extractParams.js":
/*!**********************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/xception/extractParams.js ***!
  \**********************************************************************/
/*! exports provided: extractParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParams", function() { return extractParams; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");


function extractorsFactory(extractWeights, paramMappings) {
    var extractConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractConvParamsFactory"])(extractWeights, paramMappings);
    var extractSeparableConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractSeparableConvParamsFactory"])(extractWeights, paramMappings);
    function extractReductionBlockParams(channelsIn, channelsOut, mappedPrefix) {
        var separable_conv0 = extractSeparableConvParams(channelsIn, channelsOut, mappedPrefix + "/separable_conv0");
        var separable_conv1 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/separable_conv1");
        var expansion_conv = extractConvParams(channelsIn, channelsOut, 1, mappedPrefix + "/expansion_conv");
        return { separable_conv0: separable_conv0, separable_conv1: separable_conv1, expansion_conv: expansion_conv };
    }
    function extractMainBlockParams(channels, mappedPrefix) {
        var separable_conv0 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv0");
        var separable_conv1 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv1");
        var separable_conv2 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv2");
        return { separable_conv0: separable_conv0, separable_conv1: separable_conv1, separable_conv2: separable_conv2 };
    }
    return {
        extractConvParams: extractConvParams,
        extractSeparableConvParams: extractSeparableConvParams,
        extractReductionBlockParams: extractReductionBlockParams,
        extractMainBlockParams: extractMainBlockParams
    };
}
function extractParams(weights, numMainBlocks) {
    var paramMappings = [];
    var _a = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightsFactory"])(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;
    var _b = extractorsFactory(extractWeights, paramMappings), extractConvParams = _b.extractConvParams, extractSeparableConvParams = _b.extractSeparableConvParams, extractReductionBlockParams = _b.extractReductionBlockParams, extractMainBlockParams = _b.extractMainBlockParams;
    var entry_flow_conv_in = extractConvParams(3, 32, 3, 'entry_flow/conv_in');
    var entry_flow_reduction_block_0 = extractReductionBlockParams(32, 64, 'entry_flow/reduction_block_0');
    var entry_flow_reduction_block_1 = extractReductionBlockParams(64, 128, 'entry_flow/reduction_block_1');
    var entry_flow = {
        conv_in: entry_flow_conv_in,
        reduction_block_0: entry_flow_reduction_block_0,
        reduction_block_1: entry_flow_reduction_block_1
    };
    var middle_flow = {};
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["range"])(numMainBlocks, 0, 1).forEach(function (idx) {
        middle_flow["main_block_" + idx] = extractMainBlockParams(128, "middle_flow/main_block_" + idx);
    });
    var exit_flow_reduction_block = extractReductionBlockParams(128, 256, 'exit_flow/reduction_block');
    var exit_flow_separable_conv = extractSeparableConvParams(256, 512, 'exit_flow/separable_conv');
    var exit_flow = {
        reduction_block: exit_flow_reduction_block,
        separable_conv: exit_flow_separable_conv
    };
    if (getRemainingWeights().length !== 0) {
        throw new Error("weights remaing after extract: " + getRemainingWeights().length);
    }
    return {
        paramMappings: paramMappings,
        params: { entry_flow: entry_flow, middle_flow: middle_flow, exit_flow: exit_flow }
    };
}
//# sourceMappingURL=extractParams.js.map

/***/ }),

/***/ "./node_modules/face-api.js/build/es6/xception/extractParamsFromWeigthMap.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/face-api.js/build/es6/xception/extractParamsFromWeigthMap.js ***!
  \***********************************************************************************/
/*! exports provided: extractParamsFromWeigthMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractParamsFromWeigthMap", function() { return extractParamsFromWeigthMap; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "./node_modules/face-api.js/build/es6/common/index.js");
/* harmony import */ var _common_loadConvParamsFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/loadConvParamsFactory */ "./node_modules/face-api.js/build/es6/common/loadConvParamsFactory.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./node_modules/face-api.js/build/es6/utils/index.js");



function loadParamsFactory(weightMap, paramMappings) {
    var extractWeightEntry = Object(_common__WEBPACK_IMPORTED_MODULE_0__["extractWeightEntryFactory"])(weightMap, paramMappings);
    var extractConvParams = Object(_common_loadConvParamsFactory__WEBPACK_IMPORTED_MODULE_1__["loadConvParamsFactory"])(extractWeightEntry);
    var extractSeparableConvParams = Object(_common__WEBPACK_IMPORTED_MODULE_0__["loadSeparableConvParamsFactory"])(extractWeightEntry);
    function extractReductionBlockParams(mappedPrefix) {
        var separable_conv0 = extractSeparableConvParams(mappedPrefix + "/separable_conv0");
        var separable_conv1 = extractSeparableConvParams(mappedPrefix + "/separable_conv1");
        var expansion_conv = extractConvParams(mappedPrefix + "/expansion_conv");
        return { separable_conv0: separable_conv0, separable_conv1: separable_conv1, expansion_conv: expansion_conv };
    }
    function extractMainBlockParams(mappedPrefix) {
        var separable_conv0 = extractSeparableConvParams(mappedPrefix + "/separable_conv0");
        var separable_conv1 = extractSeparableConvParams(mappedPrefix + "/separable_conv1");
        var separable_conv2 = extractSeparableConvParams(mappedPrefix + "/separable_conv2");
        return { separable_conv0: separable_conv0, separable_conv1: separable_conv1, separable_conv2: separable_conv2 };
    }
    return {
        extractConvParams: extractConvParams,
        extractSeparableConvParams: extractSeparableConvParams,
        extractReductionBlockParams: extractReductionBlockParams,
        extractMainBlockParams: extractMainBlockParams
    };
}
function extractParamsFromWeigthMap(weightMap, numMainBlocks) {
    var paramMappings = [];
    var _a = loadParamsFactory(weightMap, paramMappings), extractConvParams = _a.extractConvParams, extractSeparableConvParams = _a.extractSeparableConvParams, extractReductionBlockParams = _a.extractReductionBlockParams, extractMainBlockParams = _a.extractMainBlockParams;
    var entry_flow_conv_in = extractConvParams('entry_flow/conv_in');
    var entry_flow_reduction_block_0 = extractReductionBlockParams('entry_flow/reduction_block_0');
    var entry_flow_reduction_block_1 = extractReductionBlockParams('entry_flow/reduction_block_1');
    var entry_flow = {
        conv_in: entry_flow_conv_in,
        reduction_block_0: entry_flow_reduction_block_0,
        reduction_block_1: entry_flow_reduction_block_1
    };
    var middle_flow = {};
    Object(_utils__WEBPACK_IMPORTED_MODULE_2__["range"])(numMainBlocks, 0, 1).forEach(function (idx) {
        middle_flow["main_block_" + idx] = extractMainBlockParams("middle_flow/main_block_" + idx);
    });
    var exit_flow_reduction_block = extractReductionBlockParams('exit_flow/reduction_block');
    var exit_flow_separable_conv = extractSeparableConvParams('exit_flow/separable_conv');
    var exit_flow = {
        reduction_block: exit_flow_reduction_block,
        separable_conv: exit_flow_separable_conv
    };
    Object(_common__WEBPACK_IMPORTED_MODULE_0__["disposeUnusedWeightTensors"])(weightMap, paramMappings);
    return { params: { entry_flow: entry_flow, middle_flow: middle_flow, exit_flow: exit_flow }, paramMappings: paramMappings };
}
//# sourceMappingURL=extractParamsFromWeigthMap.js.map

/***/ }),

/***/ "./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js ***!
  \*****************************************************************************************/
/*! exports provided: AdadeltaOptimizer, AdagradOptimizer, AdamOptimizer, AdamaxOptimizer, DataStorage, ENV, Environment, KernelBackend, MomentumOptimizer, Optimizer, RMSPropOptimizer, Rank, Reduction, SGDOptimizer, Tensor, TensorBuffer, Variable, abs, acos, acosh, add, addN, addStrict, all, any, argMax, argMin, asin, asinh, atan, atan2, atanh, avgPool, avgPool3d, backend, backend_util, basicLSTMCell, batchNorm, batchNorm2d, batchNorm3d, batchNorm4d, batchNormalization, batchNormalization2d, batchNormalization3d, batchNormalization4d, batchToSpaceND, booleanMaskAsync, broadcastTo, browser, buffer, cast, ceil, clipByValue, clone, complex, concat, concat1d, concat2d, concat3d, concat4d, conv1d, conv2d, conv2dTranspose, conv3d, conv3dTranspose, cos, cosh, cumsum, customGrad, deprecationWarn, depthToSpace, depthwiseConv2d, diag, disableDeprecationWarnings, dispose, disposeVariables, div, divNoNan, divStrict, dot, dropout, elu, enableDebugMode, enableProdMode, engine, env, equal, equalStrict, erf, exp, expandDims, expm1, eye, fft, fill, findBackend, findBackendFactory, floor, floorDiv, frame, fused, gather, gatherND, gather_util, getBackend, getGradient, getKernel, getKernelsForBackend, grad, grads, greater, greaterEqual, greaterEqualStrict, greaterStrict, hammingWindow, hannWindow, ifft, imag, image, inTopKAsync, io, irfft, isFinite, isInf, isNaN, keep, leakyRelu, less, lessEqual, lessEqualStrict, lessStrict, linalg, linspace, localResponseNormalization, log, log1p, logSigmoid, logSoftmax, logSumExp, logicalAnd, logicalNot, logicalOr, logicalXor, losses, matMul, math, max, maxPool, maxPool3d, maximum, maximumStrict, mean, memory, min, minimum, minimumStrict, mod, modStrict, moments, movingAverage, mul, mulStrict, multiRNNCell, multinomial, neg, nextFrame, norm, notEqual, notEqualStrict, oneHot, ones, onesLike, op, outerProduct, pad, pad1d, pad2d, pad3d, pad4d, pool, pow, powStrict, prelu, print, prod, profile, rand, randomGamma, randomNormal, randomUniform, range, ready, real, reciprocal, registerBackend, registerGradient, registerKernel, relu, relu6, removeBackend, reshape, reverse, reverse1d, reverse2d, reverse3d, reverse4d, rfft, round, rsqrt, scalar, scatterND, scatter_util, selu, separableConv2d, serialization, setBackend, setPlatform, setdiff1dAsync, sigmoid, sign, signal, sin, sinh, slice, slice1d, slice2d, slice3d, slice4d, slice_util, softmax, softplus, spaceToBatchND, sparseToDense, spectral, split, sqrt, square, squaredDifference, squaredDifferenceStrict, squeeze, stack, step, stft, stridedSlice, sub, subStrict, sum, sumOutType, tan, tanh, tensor, tensor1d, tensor2d, tensor3d, tensor4d, tensor5d, tensor6d, tensor_util, test_util, tidy, tile, time, topk, train, transpose, truncatedNormal, unregisterGradient, unregisterKernel, unsortedSegmentSum, unstack, util, valueAndGrad, valueAndGrads, variable, variableGrads, version_core, webgl, where, whereAsync, zeros, zerosLike */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process, Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdadeltaOptimizer", function() { return bd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdagradOptimizer", function() { return wd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdamOptimizer", function() { return Cd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdamaxOptimizer", function() { return Ed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataStorage", function() { return xo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENV", function() { return s; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Environment", function() { return o; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KernelBackend", function() { return bo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MomentumOptimizer", function() { return Id; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Optimizer", function() { return xd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RMSPropOptimizer", function() { return kd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rank", function() { return Ct; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Reduction", function() { return ch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SGDOptimizer", function() { return Rd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tensor", function() { return wt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TensorBuffer", function() { return gt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Variable", function() { return St; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return ru; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return ou; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acosh", function() { return au; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return rc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addN", function() { return oc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addStrict", function() { return ac; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "all", function() { return Cl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "any", function() { return El; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argMax", function() { return Rl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argMin", function() { return Il; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return iu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asinh", function() { return su; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return uu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return ic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atanh", function() { return cu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "avgPool", function() { return fl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "avgPool3d", function() { return vl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backend", function() { return hn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backend_util", function() { return Uo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basicLSTMCell", function() { return zl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm", function() { return ju; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm2d", function() { return Xu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm3d", function() { return Yu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm4d", function() { return $u; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization", function() { return Ku; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization2d", function() { return Gu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization3d", function() { return Hu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization4d", function() { return qu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchToSpaceND", function() { return vr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "booleanMaskAsync", function() { return Uc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "broadcastTo", function() { return mr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "browser", function() { return id; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return dr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cast", function() { return gr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return lu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipByValue", function() { return hu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return yr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "complex", function() { return Dn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return Yn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat1d", function() { return $n; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat2d", function() { return Qn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat3d", function() { return Jn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat4d", function() { return Zn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv1d", function() { return Hc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2d", function() { return qc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2dTranspose", function() { return Zc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv3d", function() { return Kc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv3dTranspose", function() { return tl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return fu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return du; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cumsum", function() { return xr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customGrad", function() { return vo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deprecationWarn", function() { return Xe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthToSpace", function() { return br; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthwiseConv2d", function() { return Yc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "diag", function() { return eh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disableDeprecationWarnings", function() { return je; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispose", function() { return tn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disposeVariables", function() { return Ye; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return sc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divNoNan", function() { return uc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divStrict", function() { return cc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return nl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dropout", function() { return nh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elu", function() { return _l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableDebugMode", function() { return Ke; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableProdMode", function() { return qe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "engine", function() { return $e; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "env", function() { return i; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equal", function() { return Rc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equalStrict", function() { return Ic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "erf", function() { return pu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return vu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandDims", function() { return wr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expm1", function() { return mu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eye", function() { return Cr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fft", function() { return Xl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fill", function() { return Hn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findBackend", function() { return un; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findBackendFactory", function() { return cn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return gu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floorDiv", function() { return lc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frame", function() { return ih; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fused", function() { return zh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gather", function() { return Lc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gatherND", function() { return th; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gather_util", function() { return Xr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBackend", function() { return an; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGradient", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKernel", function() { return l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKernelsForBackend", function() { return f; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grad", function() { return co; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grads", function() { return lo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greater", function() { return kc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterEqual", function() { return Sc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterEqualStrict", function() { return Ac; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterStrict", function() { return Dc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hammingWindow", function() { return ah; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hannWindow", function() { return oh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ifft", function() { return Yl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "imag", function() { return Nn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "image", function() { return Oh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inTopKAsync", function() { return lh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "io", function() { return ed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "irfft", function() { return Ql; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return Du; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInf", function() { return Au; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return Su; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keep", function() { return en; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leakyRelu", function() { return Ol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "less", function() { return Tc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessEqual", function() { return Nc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessEqualStrict", function() { return Fc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessStrict", function() { return _c; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linalg", function() { return Ih; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linspace", function() { return qn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "localResponseNormalization", function() { return Ul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return yu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log1p", function() { return xu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSigmoid", function() { return bu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSoftmax", function() { return yo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSumExp", function() { return kl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalAnd", function() { return Qu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalNot", function() { return Ju; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalOr", function() { return Zu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalXor", function() { return tc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "losses", function() { return bh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matMul", function() { return el; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "math", function() { return od; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return Sl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxPool", function() { return hl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxPool3d", function() { return pl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maximum", function() { return hc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maximumStrict", function() { return fc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return Al; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "memory", function() { return Qe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return Dl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minimum", function() { return dc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minimumStrict", function() { return pc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return vc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modStrict", function() { return mc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moments", function() { return Tl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "movingAverage", function() { return Hl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return gc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulStrict", function() { return yc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiRNNCell", function() { return Gl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multinomial", function() { return Er; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "neg", function() { return wu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextFrame", function() { return Td; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "norm", function() { return Vl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEqual", function() { return Oc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEqualStrict", function() { return Mc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oneHot", function() { return Rr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ones", function() { return zn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onesLike", function() { return jn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "op", function() { return An; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerProduct", function() { return rl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad", function() { return Ir; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad1d", function() { return kr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad2d", function() { return Sr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad3d", function() { return Ar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad4d", function() { return Dr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pool", function() { return dl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return xc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "powStrict", function() { return bc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prelu", function() { return Ml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "print", function() { return pr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prod", function() { return Fl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "profile", function() { return Je; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return Tr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomGamma", function() { return Fr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomNormal", function() { return Nr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomUniform", function() { return _r; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return Kn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ready", function() { return on; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "real", function() { return Tn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reciprocal", function() { return Cu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerBackend", function() { return ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerGradient", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerKernel", function() { return d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relu", function() { return Bl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relu6", function() { return Pl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeBackend", function() { return sn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reshape", function() { return Or; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return ol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse1d", function() { return al; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse2d", function() { return il; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse3d", function() { return sl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse4d", function() { return ul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rfft", function() { return $l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return Eu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rsqrt", function() { return Ru; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return On; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scatterND", function() { return jl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scatter_util", function() { return to; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selu", function() { return Ll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "separableConv2d", function() { return Jc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serialization", function() { return ld; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setBackend", function() { return rn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPlatform", function() { return fn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setdiff1dAsync", function() { return Vr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sigmoid", function() { return Iu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return ku; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "signal", function() { return uh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return Tu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinh", function() { return Nu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return ml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice1d", function() { return gl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice2d", function() { return yl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice3d", function() { return xl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice4d", function() { return bl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice_util", function() { return uo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "softmax", function() { return go; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "softplus", function() { return Fu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceToBatchND", function() { return Mr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sparseToDense", function() { return Zl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spectral", function() { return Jl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "split", function() { return tr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return _u; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "square", function() { return tu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDifference", function() { return nu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDifferenceStrict", function() { return wc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squeeze", function() { return Br; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return Pr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "step", function() { return Ou; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stft", function() { return sh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stridedSlice", function() { return ql; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return Cc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subStrict", function() { return Ec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return Nl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sumOutType", function() { return Tt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return Mu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tanh", function() { return Bu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor", function() { return Fn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor1d", function() { return Mn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor2d", function() { return Bn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor3d", function() { return Pn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor4d", function() { return Ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor5d", function() { return Wn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor6d", function() { return Un; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor_util", function() { return Mt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "test_util", function() { return md; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tidy", function() { return Ze; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tile", function() { return Lr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "time", function() { return nn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "topk", function() { return Kl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "train", function() { return Ad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return Wl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "truncatedNormal", function() { return Wr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unregisterGradient", function() { return m; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unregisterKernel", function() { return v; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unsortedSegmentSum", function() { return Wc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstack", function() { return Ur; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "util", function() { return st; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueAndGrad", function() { return ho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueAndGrads", function() { return fo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variable", function() { return Vn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variableGrads", function() { return po; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_core", function() { return gd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "webgl", function() { return yd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "where", function() { return ec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whereAsync", function() { return nc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zeros", function() { return Gn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zerosLike", function() { return Xn; });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(e,n)};function e(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}function n(t,e,n,r){return new(n||(n=Promise))((function(o,a){function i(t){try{u(r.next(t))}catch(t){a(t)}}function s(t){try{u(r.throw(t))}catch(t){a(t)}}function u(t){t.done?o(t.value):new n((function(e){e(t.value)})).then(i,s)}u((r=r.apply(t,e||[])).next())}))}function r(t,e){var n,r,o,a,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(o=2&a[0]?r.return:a[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,a[1])).done)return o;switch(r=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,r=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!(o=(o=i.trys).length>0&&o[o.length-1])&&(6===a[0]||2===a[0])){i=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){i.label=a[1];break}if(6===a[0]&&i.label<o[1]){i.label=o[1],o=a;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(a);break}o[2]&&i.ops.pop(),i.trys.pop();continue}a=e.call(t,i)}catch(t){a=[6,t],r=0}finally{n=o=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}var o=function(){function t(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}return t.prototype.setPlatform=function(t,e){null!=this.platform&&console.warn("Platform "+this.platformName+" has already been set. Overwriting the platform with "+e+"."),this.platformName=t,this.platform=e},t.prototype.registerFlag=function(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){var r=this.urlFlags[t];console.warn("Setting feature override from URL "+t+": "+r+"."),this.set(t,r)}},t.prototype.get=function(t){return t in this.flags?this.flags[t]:(this.flags[t]=this.evaluateFlag(t),this.flags[t])},t.prototype.getNumber=function(t){return this.get(t)},t.prototype.getBool=function(t){return this.get(t)},t.prototype.getFlags=function(){return this.flags},Object.defineProperty(t.prototype,"features",{get:function(){return this.flags},enumerable:!0,configurable:!0}),t.prototype.set=function(t,e){if(null==this.flagRegistry[t])throw new Error("Cannot set flag "+t+" as it has not been registered.");this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)},t.prototype.evaluateFlag=function(t){if(null==this.flagRegistry[t])throw new Error("Cannot evaluate flag '"+t+"': no evaluation function found.");return this.flagRegistry[t].evaluationFn()},t.prototype.setFlags=function(t){this.flags=Object.assign({},t)},t.prototype.reset=function(){this.flags={},this.urlFlags={},this.populateURLFlags()},t.prototype.populateURLFlags=function(){var t=this;if(void 0!==this.global&&void 0!==this.global.location&&void 0!==this.global.location.search){var e,n,r=(e=this.global.location.search,n={},e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];return a(n,e[0],e[1]),e.join("=")})),n);if("tfjsflags"in r)r.tfjsflags.split(",").forEach((function(e){var n=e.split(":"),r=n[0],o=n[1];t.urlFlags[r]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error("Could not parse value flag value "+e+" for flag "+t+".")}(r,o)}))}},t}();function a(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function i(){return s}var s=null;var u=new Map,c=new Map;function l(t,e){var n=g(t,e);return u.get(n)}function h(t){return c.get(t)}function f(t){for(var e=u.entries(),n=[];;){var r=e.next(),o=r.done,a=r.value;if(o)break;var i=a[0],s=a[1];i.split("_")[0]===t&&n.push(s)}return n}function d(t){var e=t.kernelName,n=t.backendName,r=g(e,n);if(u.has(r))throw new Error("The kernel '"+e+"' for backend '"+n+"' is already registered");u.set(r,t)}function p(t){var e=t.kernelName;c.has(e)&&console.warn("Overriding the gradient for '"+e+"'"),c.set(e,t)}function v(t,e){var n=g(t,e);if(!u.has(n))throw new Error("The kernel '"+t+"' for backend '"+e+"' is not registered");u.delete(n)}function m(t){if(!c.has(t))throw new Error("The gradient '"+t+"' for backend is not registered");c.delete(t)}function g(t,e){return e+"_"+t}function y(t){for(var e=t.length,n=0,r=0;e>0;)r=Math.random()*e|0,n=t[--e],t[e]=t[r],t[r]=n}function x(t,e,n){return Math.max(t,Math.min(e,n))}function b(t){return t%2==0?t:t+1}function w(t){for(var e=0,n=0;n<t.length;n++)e+=t[n];return e}function C(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function E(t,e,n){void 0===n&&(n=""),C(S(t,e),(function(){return n+" Shapes "+t+" and "+e+" must match"}))}function R(t){C(null!=t,(function(){return"The input to the tensor constructor must be a non-null value."}))}function I(t,e,n){if(void 0===e&&(e=[]),void 0===n&&(n=!1),null==e&&(e=[]),Array.isArray(t)||V(t)&&!n)for(var r=0;r<t.length;++r)I(t[r],e,n);else e.push(t);return e}function k(t){if(0===t.length)return 1;for(var e=t[0],n=1;n<t.length;n++)e*=t[n];return e}function S(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function A(t){return t%1==0}function D(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;var e=Math.exp(2*t);return(e-1)/(e+1)}function T(t){var e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function N(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function F(t,e,n){return void 0===e&&(e=function(t){return 0}),new Promise((function(r,o){var a=0,i=function(){if(t())r();else{a++;var s=e(a);null!=n&&a>=n?o():setTimeout(i,s)}};i()}))}function _(t,e){for(var n=1,r=-1,o=0;o<t.length;++o)if(t[o]>=0)n*=t[o];else if(-1===t[o]){if(-1!==r)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+r+" and dim "+o);r=o}else if(t[o]<0)throw Error("Shapes can not be < 0. Found "+t[o]+" at dim "+o);if(-1===r){if(e>0&&e!==n)throw Error("Size("+e+") must match the product of shape "+t);return t}if(0===n)throw Error("Cannot infer the missing size in ["+t+"] when there are 0 elements");if(e%n!=0)throw Error("The implicit shape can't be a fractional number. Got "+e+" / "+n);var a=t.slice();return a[r]=e/n,a}function O(t,e){var n=e.length;return C((t=null==t?e.map((function(t,e){return e})):[].concat(t)).every((function(t){return t>=-n&&t<n})),(function(){return"All values in axis param must be in range [-"+n+", "+n+") but got axis "+t})),C(t.every((function(t){return A(t)})),(function(){return"All values in axis param must be integers but got axis "+t})),t.map((function(t){return t<0?n+t:t}))}function M(t,e){for(var n=[],r=[],o=null!=e&&Array.isArray(e)&&0===e.length,a=null==e||o?null:O(e,t).sort(),i=0,s=0;s<t.length;++s){if(null!=a){if(a[i]===s&&1!==t[s])throw new Error("Can't squeeze axis "+s+" since its dim '"+t[s]+"' is not 1");(null==a[i]||a[i]>s)&&1===t[s]&&(n.push(t[s]),r.push(s)),a[i]<=s&&i++}1!==t[s]&&(n.push(t[s]),r.push(s))}return{newShape:n,keptDims:r}}function B(t,e){var n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error("Unknown data type "+t);n=new Uint8Array(e)}return n}function P(t,e){var n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type "+t);n=new Array(e)}return n}function L(t,e){for(var n=0;n<t.length;n++){var r=t[n];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type "+e+" being uploaded contains "+r+".")}}function W(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function U(t,e){return"complex64"!==e&&(("float32"!==e||"complex64"===t)&&(("int32"!==e||"float32"===t||"complex64"===t)&&("bool"!==e||"bool"!==t)))}function V(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function z(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype "+t)}function G(t){if(null==t)return 0;var e=0;return t.forEach((function(t){return e+=t.length})),e}function H(t){return"string"==typeof t||t instanceof String}function q(t){return"boolean"==typeof t}function K(t){return"number"==typeof t}function j(t){return Array.isArray(t)?j(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":K(t)?"float32":H(t)?"string":q(t)?"bool":"float32"}function X(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Y(t,e){for(var n=e;n<t;++n)if(t%n==0)return n;return t}function $(t){var e=t.length;if(e<2)return[];var n=new Array(e-1);n[e-2]=t[e-1];for(var r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function Q(t,e,n){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=I(t)),n&&L(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){for(var r=new Uint8Array(t.length),o=0;o<r.length;++o)0!==Math.round(t[o])&&(r[o]=1);return r}throw new Error("Unknown data type "+e)}function J(t,e){if(0===t.length)return e[0];var n=t.reduce((function(t,e){return t*e}));if(0===n)return[];if(n!==e.length)throw new Error("["+t+"] does not match the input size.");return function t(e,n,r){var o=new Array;if(1===n.length)for(var a=n[0],i=0;i<a;i++)o[i]=r[e+i];else{a=n[0];var s=n.slice(1),u=s.reduce((function(t,e){return t*e}));for(i=0;i<a;i++)o[i]=t(e+i*u,s,r)}return o}(0,t,e)}function Z(t,e){for(var n=tt(t,e),r=0;r<n.length;r++)n[r]=1;return n}function tt(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type "+e)}function et(){return i().platform.now()}function nt(t){t.forEach((function(e){C(Number.isInteger(e)&&e>=0,(function(){return"Tensor must have a shape comprised of positive integers but got shape ["+t+"]."}))}))}function rt(t,e){return void 0===e&&(e="utf-8"),e=e||"utf-8",i().platform.encode(t,e)}function ot(t,e){return void 0===e&&(e="utf-8"),e=e||"utf-8",i().platform.decode(t,e)}function at(t,e,n){if(0===e)return 0;if(1===e)return t[0];for(var r=t[t.length-1],o=0;o<t.length-1;++o)r+=n[o]*t[o];return r}function it(t,e,n){if(0===e)return[];if(1===e)return[t];for(var r=new Array(e),o=0;o<r.length-1;++o)r[o]=Math.floor(t/n[o]),t-=r[o]*n[o];return r[r.length-1]=t,r}var st=Object.freeze({shuffle:y,clamp:x,nearestLargerEven:b,sum:w,randUniform:function(t,e){var n=Math.random();return e*n+(1-n)*t},distSquared:function(t,e){for(var n=0,r=0;r<t.length;r++){var o=Number(t[r])-Number(e[r]);n+=o*o}return n},assert:C,assertShapesMatch:E,assertNonNull:R,flatten:I,sizeFromShape:k,isScalarShape:function(t){return 0===t.length},arraysEqual:S,isInt:A,tanh:D,sizeToSquarishShape:T,createShuffledIndices:function(t){for(var e=new Uint32Array(t),n=0;n<t;++n)e[n]=n;return y(e),e},rightPad:N,repeatedTry:F,inferFromImplicitShape:_,parseAxisParam:O,squeezeShape:M,getTypedArrayFromDType:B,getArrayFromDType:P,checkConversionForErrors:L,isValidDtype:W,hasEncodingLoss:U,isTypedArray:V,bytesPerElement:z,bytesFromStringArray:G,isString:H,isBoolean:q,isNumber:K,inferDtype:j,isFunction:X,nearestDivisor:Y,computeStrides:$,toTypedArray:Q,toNestedArray:J,makeOnesTypedArray:Z,makeZerosTypedArray:tt,now:et,assertNonNegativeIntegerDimensions:nt,fetch:function(t,e){return i().platform.fetch(t,e)},encodeString:rt,decodeString:ot,locToIndex:at,indexToLoc:it}),ut=function(){function t(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new ct)}return t.prototype.profileKernel=function(t,e,n){var r,o=this,a=this.backendTimer.time((function(){r=n()}));return r.forEach((function(n){n.data().then((function(r){!function(t,e,n){if("float32"!==e)return!1;for(var r=0;r<t.length;r++){var o=t[r];if(isNaN(o)||!isFinite(o))return console.warn("Found "+o+" in the result of '"+n+"'"),!0}}(r,n.dtype,t),a.then((function(a){var i="";null!=a.getExtraProfileInfo&&(i=a.getExtraProfileInfo()),o.logger.logKernelProfile(t,n,r,a.kernelMs,e,i)}))}))})),r},t}();var ct=function(){function t(){}return t.prototype.logKernelProfile=function(t,e,n,r,o,a){var i="number"==typeof r?N(r+"ms",9):r.error,s=N(t,25),u=e.rank,c=e.size,l=N(e.shape.toString(),14),h="";for(var f in o){var d=o[f].shape||e.shape,p=d.length;h+=f+": "+p+"D "+(p>0?d:"")+" "}console.log("%c"+s+"\t%c"+i+"\t%c"+u+"D "+l+"\t%c"+c+"\t%c"+h+"\t%c"+a,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")},t}();var lt=20,ht=3,ft=7;function dt(t,e,n,r){var o=$(e),a=function(t,e,n,r){var o=k(e),a=r[r.length-1],i=new Array(a).fill(0),s=e.length,u="complex64"===n?mt(t):t;if(s>1)for(var c=0;c<o/a;c++)for(var l=c*a,h=0;h<a;h++)i[h]=Math.max(i[h],pt(u[l+h],0,n).length);return i}(t,e,n,o),i=e.length,s=function t(e,n,r,o,a,i){void 0===i&&(i=!0);var s="complex64"===r?2:1,u=n[0],c=n.length;if(0===c){return"complex64"===r?[pt(mt(e)[0],0,r)]:"bool"===r?[vt(e[0])]:[e[0].toString()]}if(1===c){if(u>lt){var l=ht*s,h=Array.from(e.slice(0,l)),f=Array.from(e.slice((u-ht)*s,u*s));return"complex64"===r&&(h=mt(h),f=mt(f)),["["+h.map((function(t,e){return pt(t,a[e],r)})).join(", ")+", ..., "+f.map((function(t,e){return pt(t,a[u-ht+e],r)})).join(", ")+"]"]}return["["+("complex64"===r?mt(e):Array.from(e)).map((function(t,e){return pt(t,a[e],r)})).join(", ")+"]"]}var d=n.slice(1),p=o.slice(1),v=o[0]*s,m=[];if(u>lt){for(var g=0;g<ht;g++){var y=(x=g*v)+v;m.push.apply(m,t(e.slice(x,y),d,r,p,a,!1))}m.push("...");for(g=u-ht;g<u;g++){y=(x=g*v)+v;m.push.apply(m,t(e.slice(x,y),d,r,p,a,g===u-1))}}else for(g=0;g<u;g++){var x;y=(x=g*v)+v;m.push.apply(m,t(e.slice(x,y),d,r,p,a,g===u-1))}var b=2===c?",":"";m[0]="["+m[0]+b;for(g=1;g<m.length-1;g++)m[g]=" "+m[g]+b;var w=",\n";for(g=2;g<c;g++)w+="\n";return m[m.length-1]=" "+m[m.length-1]+"]"+(i?"":w),m}(t,e,n,o,a),u=["Tensor"];return r&&(u.push("  dtype: "+n),u.push("  rank: "+i),u.push("  shape: ["+e+"]"),u.push("  values:")),u.push(s.map((function(t){return"    "+t})).join("\n")),u.join("\n")}function pt(t,e,n){return N(Array.isArray(t)?parseFloat(t[0].toFixed(ft))+" + "+parseFloat(t[1].toFixed(ft))+"j":H(t)?"'"+t+"'":"bool"===n?vt(t):parseFloat(t.toFixed(ft)).toString(),e)}function vt(t){return 0===t?"false":"true"}function mt(t){for(var e=[],n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}var gt=function(){function t(t,e,n){var r=this;if(this.dtype=e,this.shape=t.slice(),this.size=k(t),null!=n){var o=n.length;C(o===this.size,(function(){return"Length of values '"+o+"' does not match the size inferred by the shape '"+r.size+"'."}))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||P(e,this.size),this.strides=$(t)}return t.prototype.set=function(t){for(var e=this,n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),C(n.length===this.rank,(function(){return"The number of provided coordinates ("+n.length+") must match the rank ("+e.rank+")"}));var o=this.locToIndex(n);this.values[o]=t},t.prototype.get=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];0===t.length&&(t=[0]);for(var n=0,r=0,o=t;r<o.length;r++){var a=o[r];if(a<0||a>=this.shape[n]){var i="Requested out of range element at "+t+".   Buffer shape="+this.shape;throw new Error(i)}n++}for(var s=t[t.length-1],u=0;u<t.length-1;++u)s+=this.strides[u]*t[u];return this.values[s]},t.prototype.locToIndex=function(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];for(var e=t[t.length-1],n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e},t.prototype.indexToLoc=function(t){if(0===this.rank)return[];if(1===this.rank)return[t];for(var e=new Array(this.shape.length),n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.toTensor=function(){return yt().makeTensor(this.values,this.shape,this.dtype)},t}(),yt=null,xt=null,bt=null;var wt=function(){function t(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=k(t),this.strides=$(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}return t.prototype.flatten=function(){return this.throwIfDisposed(),this.as1D()},t.prototype.asScalar=function(){return this.throwIfDisposed(),C(1===this.size,(function(){return"The array must have only 1 element."})),this.reshape([])},t.prototype.as1D=function(){return this.throwIfDisposed(),this.reshape([this.size])},t.prototype.as2D=function(t,e){return this.throwIfDisposed(),this.reshape([t,e])},t.prototype.as3D=function(t,e,n){return this.throwIfDisposed(),this.reshape([t,e,n])},t.prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),this.reshape([t,e,n,r])},t.prototype.as5D=function(t,e,n,r,o){return this.throwIfDisposed(),this.reshape([t,e,n,r,o])},t.prototype.asType=function(t){return this.throwIfDisposed(),xt.cast(this,t)},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.buffer=function(){return n(this,void 0,void 0,(function(){var t;return r(this,(function(e){switch(e.label){case 0:return[4,this.data()];case 1:return t=e.sent(),[2,xt.buffer(this.shape,this.dtype,t)]}}))}))},t.prototype.bufferSync=function(){return xt.buffer(this.shape,this.dtype,this.dataSync())},t.prototype.array=function(){return n(this,void 0,void 0,(function(){var t;return r(this,(function(e){switch(e.label){case 0:return[4,this.data()];case 1:return t=e.sent(),[2,J(this.shape,t)]}}))}))},t.prototype.arraySync=function(){return J(this.shape,this.dataSync())},t.prototype.data=function(){return n(this,void 0,void 0,(function(){var t,e;return r(this,(function(n){switch(n.label){case 0:return this.throwIfDisposed(),t=yt().read(this.dataId),"string"!==this.dtype?[3,2]:[4,t];case 1:e=n.sent();try{return[2,e.map((function(t){return ot(t)}))]}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}n.label=2;case 2:return[2,t]}}))}))},t.prototype.dataSync=function(){this.throwIfDisposed();var t=yt().readSync(this.dataId);if("string"===this.dtype)try{return t.map((function(t){return ot(t)}))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t},t.prototype.bytes=function(){return n(this,void 0,void 0,(function(){var t;return r(this,(function(e){switch(e.label){case 0:return this.throwIfDisposed(),[4,yt().read(this.dataId)];case 1:return t=e.sent(),"string"===this.dtype?[2,t]:[2,new Uint8Array(t.buffer)]}}))}))},t.prototype.dispose=function(){this.isDisposed||(yt().disposeTensor(this),this.isDisposedInternal=!0)},Object.defineProperty(t.prototype,"isDisposed",{get:function(){return this.isDisposedInternal},enumerable:!0,configurable:!0}),t.prototype.throwIfDisposed=function(){if(this.isDisposed)throw new Error("Tensor is disposed.")},t.prototype.toFloat=function(){return this.asType("float32")},t.prototype.toInt=function(){return this.asType("int32")},t.prototype.toBool=function(){return this.asType("bool")},t.prototype.print=function(t){return void 0===t&&(t=!1),xt.print(this,t)},t.prototype.reshape=function(t){return this.throwIfDisposed(),xt.reshape(this,t)},t.prototype.reshapeAs=function(t){return this.throwIfDisposed(),this.reshape(t.shape)},t.prototype.expandDims=function(t){return void 0===t&&(t=0),xt.expandDims(this,t)},t.prototype.cumsum=function(t,e,n){return void 0===t&&(t=0),void 0===e&&(e=!1),void 0===n&&(n=!1),xt.cumsum(this,t,e,n)},t.prototype.squeeze=function(t){return this.throwIfDisposed(),xt.squeeze(this,t)},t.prototype.clone=function(){return this.throwIfDisposed(),xt.clone(this)},t.prototype.oneHot=function(t,e,n){return this.throwIfDisposed(),xt.oneHot(this,t,e,n)},t.prototype.toString=function(t){return void 0===t&&(t=!1),dt(this.dataSync(),this.shape,this.dtype,t)},t.prototype.tile=function(t){return this.throwIfDisposed(),xt.tile(this,t)},t.prototype.gather=function(t,e){return void 0===e&&(e=0),this.throwIfDisposed(),xt.gather(this,t,e)},t.prototype.matMul=function(t,e,n){return void 0===e&&(e=!1),void 0===n&&(n=!1),this.throwIfDisposed(),xt.matMul(this,t,e,n)},t.prototype.dot=function(t){return this.throwIfDisposed(),xt.dot(this,t)},t.prototype.norm=function(t,e,n){return void 0===t&&(t="euclidean"),void 0===e&&(e=null),void 0===n&&(n=!1),this.throwIfDisposed(),xt.norm(this,t,e,n)},t.prototype.slice=function(t,e){return this.throwIfDisposed(),xt.slice(this,t,e)},t.prototype.reverse=function(t){return this.throwIfDisposed(),xt.reverse(this,t)},t.prototype.concat=function(e,n){return void 0===n&&(n=0),this.throwIfDisposed(),e instanceof t&&(e=[e]),xt.concat([this].concat(e),n)},t.prototype.split=function(t,e){return void 0===e&&(e=0),this.throwIfDisposed(),xt.split(this,t,e)},t.prototype.stack=function(t,e){return void 0===e&&(e=0),xt.stack([this,t],e)},t.prototype.unstack=function(t){return void 0===t&&(t=0),xt.unstack(this,t)},t.prototype.pad=function(t,e){return void 0===e&&(e=0),xt.pad(this,t,e)},t.prototype.batchNormalization=function(t,e,n,r,o){return void 0===n&&(n=.001),bt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"),this.batchNorm(t,e,o,r,n)},t.prototype.batchNorm=function(t,e,n,r,o){return void 0===o&&(o=.001),this.throwIfDisposed(),xt.batchNorm(this,t,e,n,r,o)},t.prototype.all=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.all(this,t,e)},t.prototype.any=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.any(this,t,e)},t.prototype.logSumExp=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.logSumExp(this,t,e)},t.prototype.sum=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.sum(this,t,e)},t.prototype.prod=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.prod(this,t,e)},t.prototype.mean=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.mean(this,t,e)},t.prototype.min=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.min(this,t,e)},t.prototype.max=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),xt.max(this,t,e)},t.prototype.argMin=function(t){return void 0===t&&(t=null),this.throwIfDisposed(),xt.argMin(this,t)},t.prototype.argMax=function(t){return void 0===t&&(t=null),this.throwIfDisposed(),xt.argMax(this,t)},t.prototype.cast=function(t){return this.throwIfDisposed(),xt.cast(this,t)},t.prototype.add=function(t){return this.throwIfDisposed(),xt.add(this,t)},t.prototype.addStrict=function(t){return this.throwIfDisposed(),xt.addStrict(this,t)},t.prototype.atan2=function(t){return this.throwIfDisposed(),xt.atan2(this,t)},t.prototype.sub=function(t){return this.throwIfDisposed(),xt.sub(this,t)},t.prototype.subStrict=function(t){return this.throwIfDisposed(),xt.subStrict(this,t)},t.prototype.pow=function(t){return this.throwIfDisposed(),xt.pow(this,t)},t.prototype.powStrict=function(t){return this.throwIfDisposed(),xt.powStrict(this,t)},t.prototype.mul=function(t){return this.throwIfDisposed(),xt.mul(this,t)},t.prototype.mulStrict=function(t){return this.throwIfDisposed(),xt.mulStrict(this,t)},t.prototype.div=function(t){return this.throwIfDisposed(),xt.div(this,t)},t.prototype.divNoNan=function(t){return this.throwIfDisposed(),xt.divNoNan(this,t)},t.prototype.floorDiv=function(t){return this.throwIfDisposed(),xt.floorDiv(this,t)},t.prototype.divStrict=function(t){return this.throwIfDisposed(),xt.divStrict(this,t)},t.prototype.minimum=function(t){return this.throwIfDisposed(),xt.minimum(this,t)},t.prototype.minimumStrict=function(t){return this.throwIfDisposed(),xt.minimumStrict(this,t)},t.prototype.maximum=function(t){return this.throwIfDisposed(),xt.maximum(this,t)},t.prototype.maximumStrict=function(t){return this.throwIfDisposed(),xt.maximumStrict(this,t)},t.prototype.mod=function(t){return this.throwIfDisposed(),xt.mod(this,t)},t.prototype.modStrict=function(t){return this.throwIfDisposed(),xt.modStrict(this,t)},t.prototype.squaredDifferenceStrict=function(t){return this.throwIfDisposed(),xt.squaredDifferenceStrict(this,t)},t.prototype.transpose=function(t){return this.throwIfDisposed(),xt.transpose(this,t)},t.prototype.notEqual=function(t){return this.throwIfDisposed(),xt.notEqual(this,t)},t.prototype.notEqualStrict=function(t){return this.throwIfDisposed(),xt.notEqualStrict(this,t)},t.prototype.less=function(t){return this.throwIfDisposed(),xt.less(this,t)},t.prototype.lessStrict=function(t){return this.throwIfDisposed(),xt.lessStrict(this,t)},t.prototype.equal=function(t){return this.throwIfDisposed(),xt.equal(this,t)},t.prototype.equalStrict=function(t){return this.throwIfDisposed(),xt.equalStrict(this,t)},t.prototype.lessEqual=function(t){return this.throwIfDisposed(),xt.lessEqual(this,t)},t.prototype.lessEqualStrict=function(t){return this.throwIfDisposed(),xt.lessEqualStrict(this,t)},t.prototype.greater=function(t){return this.throwIfDisposed(),xt.greater(this,t)},t.prototype.greaterStrict=function(t){return this.throwIfDisposed(),xt.greaterStrict(this,t)},t.prototype.greaterEqual=function(t){return this.throwIfDisposed(),xt.greaterEqual(this,t)},t.prototype.greaterEqualStrict=function(t){return this.throwIfDisposed(),xt.greaterEqualStrict(this,t)},t.prototype.logicalAnd=function(t){return this.throwIfDisposed(),xt.logicalAnd(this,t)},t.prototype.logicalOr=function(t){return this.throwIfDisposed(),xt.logicalOr(this,t)},t.prototype.logicalNot=function(){return this.throwIfDisposed(),xt.logicalNot(this)},t.prototype.logicalXor=function(t){return this.throwIfDisposed(),xt.logicalXor(this,t)},t.prototype.where=function(t,e){return this.throwIfDisposed(),xt.where(t,this,e)},t.prototype.neg=function(){return this.throwIfDisposed(),xt.neg(this)},t.prototype.ceil=function(){return this.throwIfDisposed(),xt.ceil(this)},t.prototype.floor=function(){return this.throwIfDisposed(),xt.floor(this)},t.prototype.sign=function(){return this.throwIfDisposed(),xt.sign(this)},t.prototype.isNaN=function(){return this.throwIfDisposed(),xt.isNaN(this)},t.prototype.isInf=function(){return this.throwIfDisposed(),xt.isInf(this)},t.prototype.isFinite=function(){return this.throwIfDisposed(),xt.isFinite(this)},t.prototype.exp=function(){return this.throwIfDisposed(),xt.exp(this)},t.prototype.expm1=function(){return this.throwIfDisposed(),xt.expm1(this)},t.prototype.log=function(){return this.throwIfDisposed(),xt.log(this)},t.prototype.log1p=function(){return this.throwIfDisposed(),xt.log1p(this)},t.prototype.sqrt=function(){return this.throwIfDisposed(),xt.sqrt(this)},t.prototype.rsqrt=function(){return this.throwIfDisposed(),xt.rsqrt(this)},t.prototype.square=function(){return this.throwIfDisposed(),xt.square(this)},t.prototype.reciprocal=function(){return this.throwIfDisposed(),xt.reciprocal(this)},t.prototype.abs=function(){return this.throwIfDisposed(),xt.abs(this)},t.prototype.clipByValue=function(t,e){return this.throwIfDisposed(),xt.clipByValue(this,t,e)},t.prototype.relu=function(){return this.throwIfDisposed(),xt.relu(this)},t.prototype.relu6=function(){return this.throwIfDisposed(),xt.relu6(this)},t.prototype.elu=function(){return this.throwIfDisposed(),xt.elu(this)},t.prototype.selu=function(){return this.throwIfDisposed(),xt.selu(this)},t.prototype.leakyRelu=function(t){return void 0===t&&(t=.2),this.throwIfDisposed(),xt.leakyRelu(this,t)},t.prototype.prelu=function(t){return this.throwIfDisposed(),xt.prelu(this,t)},t.prototype.sigmoid=function(){return this.throwIfDisposed(),xt.sigmoid(this)},t.prototype.logSigmoid=function(){return this.throwIfDisposed(),xt.logSigmoid(this)},t.prototype.softplus=function(){return this.throwIfDisposed(),xt.softplus(this)},t.prototype.zerosLike=function(){return this.throwIfDisposed(),xt.zerosLike(this)},t.prototype.onesLike=function(){return this.throwIfDisposed(),xt.onesLike(this)},t.prototype.sin=function(){return this.throwIfDisposed(),xt.sin(this)},t.prototype.cos=function(){return this.throwIfDisposed(),xt.cos(this)},t.prototype.tan=function(){return this.throwIfDisposed(),xt.tan(this)},t.prototype.asin=function(){return this.throwIfDisposed(),xt.asin(this)},t.prototype.acos=function(){return this.throwIfDisposed(),xt.acos(this)},t.prototype.atan=function(){return this.throwIfDisposed(),xt.atan(this)},t.prototype.sinh=function(){return this.throwIfDisposed(),xt.sinh(this)},t.prototype.cosh=function(){return this.throwIfDisposed(),xt.cosh(this)},t.prototype.tanh=function(){return this.throwIfDisposed(),xt.tanh(this)},t.prototype.asinh=function(){return this.throwIfDisposed(),xt.asinh(this)},t.prototype.acosh=function(){return this.throwIfDisposed(),xt.acosh(this)},t.prototype.atanh=function(){return this.throwIfDisposed(),xt.atanh(this)},t.prototype.erf=function(){return this.throwIfDisposed(),xt.erf(this)},t.prototype.round=function(){return this.throwIfDisposed(),xt.round(this)},t.prototype.step=function(t){return void 0===t&&(t=0),this.throwIfDisposed(),xt.step(this,t)},t.prototype.softmax=function(t){return void 0===t&&(t=-1),this.throwIfDisposed(),xt.softmax(this,t)},t.prototype.logSoftmax=function(t){return void 0===t&&(t=-1),this.throwIfDisposed(),xt.logSoftmax(this,t)},t.prototype.resizeBilinear=function(t,e){return void 0===e&&(e=!1),this.throwIfDisposed(),xt.image.resizeBilinear(this,t,e)},t.prototype.resizeNearestNeighbor=function(t,e){return void 0===e&&(e=!1),this.throwIfDisposed(),xt.image.resizeNearestNeighbor(this,t,e)},t.prototype.conv1d=function(t,e,n,r,o,a){return void 0===r&&(r="NWC"),void 0===o&&(o=1),this.throwIfDisposed(),xt.conv1d(this,t,e,n,r,o,a)},t.prototype.conv2d=function(t,e,n,r,o,a){return void 0===r&&(r="NHWC"),void 0===o&&(o=[1,1]),this.throwIfDisposed(),xt.conv2d(this,t,e,n,r,o,a)},t.prototype.conv2dTranspose=function(t,e,n,r,o){return this.throwIfDisposed(),xt.conv2dTranspose(this,t,e,n,r,o)},t.prototype.depthwiseConv2D=function(t,e,n,r,o,a){return void 0===r&&(r="NHWC"),void 0===o&&(o=[1,1]),this.throwIfDisposed(),xt.depthwiseConv2d(this,t,e,n,r,o,a)},t.prototype.separableConv2d=function(t,e,n,r,o,a){return void 0===o&&(o=[1,1]),void 0===a&&(a="NHWC"),this.throwIfDisposed(),xt.separableConv2d(this,t,e,n,r,o,a)},t.prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),xt.avgPool(this,t,e,n,r)},t.prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),xt.maxPool(this,t,e,n,r)},t.prototype.localResponseNormalization=function(t,e,n,r){return void 0===t&&(t=5),void 0===e&&(e=1),void 0===n&&(n=1),void 0===r&&(r=.5),xt.localResponseNormalization(this,t,e,n,r)},t.prototype.pool=function(t,e,n,r,o){return this.throwIfDisposed(),xt.pool(this,t,e,n,r,o)},t.prototype.variable=function(t,e,n){return void 0===t&&(t=!0),this.throwIfDisposed(),yt().makeVariable(this,t,e,n)},t.prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),xt.unsortedSegmentSum(this,t,e)},t.prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),xt.batchToSpaceND(this,t,e)},t.prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),xt.spaceToBatchND(this,t,e)},t.prototype.topk=function(t,e){return void 0===t&&(t=1),void 0===e&&(e=!0),this.throwIfDisposed(),xt.topk(this,t,e)},t.prototype.stridedSlice=function(t,e,n,r,o,a,i,s){return void 0===r&&(r=0),void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),this.throwIfDisposed(),xt.stridedSlice(this,t,e,n,r,o,a,i,s)},t.prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),xt.depthToSpace(this,t,e)},t.prototype.fft=function(){return this.throwIfDisposed(),xt.spectral.fft(this)},t.prototype.ifft=function(){return this.throwIfDisposed(),xt.spectral.ifft(this)},t.prototype.rfft=function(){return this.throwIfDisposed(),xt.spectral.rfft(this)},t.prototype.irfft=function(){return this.throwIfDisposed(),xt.spectral.irfft(this)},t}();Object.defineProperty(wt,Symbol.hasInstance,{value:function(t){return!!t&&null!=t.dataId&&null!=t.shape&&null!=t.dtype}});var Ct,Et,Rt,It,kt,St=function(t){function n(e,n,r,o){var a=t.call(this,e.shape,e.dtype,e.dataId,o)||this;return a.trainable=n,a.name=r,a}return e(n,t),n.prototype.assign=function(t){if(t.dtype!==this.dtype)throw new Error("dtype of the new value ("+t.dtype+") and previous value ("+this.dtype+") must match");if(!S(t.shape,this.shape))throw new Error("shape of the new value ("+t.shape+") and previous value ("+this.shape+") must match");yt().disposeTensor(this),this.dataId=t.dataId,yt().incRef(this,null)},n.prototype.dispose=function(){yt().disposeVariable(this),this.isDisposedInternal=!0},n}(wt);Object.defineProperty(St,Symbol.hasInstance,{value:function(t){return t instanceof wt&&null!=t.assign&&t.assign instanceof Function}}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Ct||(Ct={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Et||(Et={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Rt||(Rt={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(It||(It={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(kt||(kt={}));var At={float32:It,int32:Et,bool:Rt,complex64:kt};function Dt(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error("Can not upcast "+t+" with "+e)}return At[t][e]}function Tt(t){return Dt(t,"int32")}function Nt(t,e){if(t.dtype===e.dtype)return[t,e];var n=Dt(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Ft(t,e){C(t.dtype===e.dtype,(function(){return"The dtypes of the first("+t.dtype+") and second("+e.dtype+") input must match"}))}function _t(t){var e=[];return function t(e,n,r){if(null==e)return;if(e instanceof wt)return void n.push(e);if(o=e,!Array.isArray(o)&&"object"!=typeof o)return;var o;var a=e;for(var i in a){var s=a[i];r.has(s)||(r.add(s),t(s,n,r))}}(t,e,new Set),e}var Ot,Mt=Object.freeze({makeTypesMatch:Nt,assertTypesMatch:Ft,isTensorInList:function(t,e){return e.some((function(e){return e.id===t.id}))},getTensorsInContainer:_t}),Bt=function(){function t(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}return t.prototype.dispose=function(){for(var t in this.registeredVariables)this.registeredVariables[t].dispose()},t}(),Pt=function(){function t(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Bt}return t.prototype.ready=function(){return n(this,void 0,void 0,(function(){var t,e,n;return r(this,(function(r){switch(r.label){case 0:if(null!=this.pendingBackendInit)return[2,this.pendingBackendInit.then((function(){}))];if(null!=this.backendInstance)return[2];t=this.getSortedBackends(),e=0,r.label=1;case 1:return e<t.length?(n=t[e],[4,this.initializeBackend(n).success]):[3,5];case 2:return r.sent()?[4,this.setBackend(n)]:[3,4];case 3:return r.sent(),[2];case 4:return e++,[3,1];case 5:throw new Error("Could not initialize any backends, all backend initializations failed.")}}))}))},Object.defineProperty(t.prototype,"backend",{get:function(){if(null!=this.pendingBackendInit)throw new Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){var t=this.initializeBackendsAndReturnBest(),e=t.name;if(t.asyncInit)throw new Error("The highest priority backend '"+e+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance},enumerable:!0,configurable:!0}),t.prototype.backendNames=function(){return Object.keys(this.registryFactory)},t.prototype.findBackend=function(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;if(this.initializeBackend(t).asyncInit)return null}return this.registry[t]},t.prototype.findBackendFactory=function(t){return t in this.registryFactory?this.registryFactory[t].factory:null},t.prototype.registerBackend=function(t,e,n){return void 0===n&&(n=1),t in this.registryFactory?(console.warn(t+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:n},!0)},t.prototype.setBackend=function(t){return n(this,void 0,void 0,(function(){var e,n,o;return r(this,(function(r){switch(r.label){case 0:if(null==this.registryFactory[t])throw new Error("Backend name '"+t+"' not found in registry");return this.backendName=t,null!=this.registry[t]?[3,4]:(this.backendInstance=null,e=this.initializeBackend(t),n=e.success,e.asyncInit?[4,n]:[3,2]);case 1:return o=r.sent(),[3,3];case 2:o=n,r.label=3;case 3:if(!o)return[2,!1];r.label=4;case 4:return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new ut(this.backendInstance),[2,!0]}}))}))},t.prototype.setupRegisteredKernels=function(){var t=this;f(this.backendName).forEach((function(e){null!=e.setupFunc&&e.setupFunc(t.backendInstance)}))},t.prototype.disposeRegisteredKernels=function(t){var e=this;f(t).forEach((function(n){null!=n.disposeFunc&&n.disposeFunc(e.registry[t])}))},t.prototype.initializeBackend=function(t){var e=this,n=this.registryFactory[t];if(null==n)throw new Error("Cannot initialize backend "+t+", no registration found.");try{var r=n.factory();if(Promise.resolve(r)===r){var o=++this.pendingBackendInitId,a=r.then((function(n){return!(o<e.pendingBackendInitId)&&(e.registry[t]=n,e.pendingBackendInit=null,!0)})).catch((function(n){return!(o<e.pendingBackendInitId)&&(e.pendingBackendInit=null,console.warn("Initialization of backend "+t+" failed"),console.warn(n.stack||n.message),!1)}));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(e){return console.warn("Initialization of backend "+t+" failed"),console.warn(e.stack||e.message),{success:!1,asyncInit:!1}}},t.prototype.removeBackend=function(t){if(!(t in this.registryFactory))throw new Error(t+" backend not found in registry");this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)},t.prototype.getSortedBackends=function(){var t=this;if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((function(e,n){return t.registryFactory[n].priority-t.registryFactory[e].priority}))},t.prototype.initializeBackendsAndReturnBest=function(){for(var t=this.getSortedBackends(),e=0;e<t.length;e++){var n=t[e],r=this.initializeBackend(n),o=r.success,a=r.asyncInit;if(a||o)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")},t.prototype.moveData=function(t,e){var n=this.state.tensorInfo.get(e),r=n.backend,o=this.readSync(e);r.disposeData(e),n.backend=t,t.move(e,o,n.shape,n.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++},t.prototype.tidy=function(t,e){var n,r=this,o=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=t}return this.scopedRun((function(){return r.startScope(o)}),(function(){return r.endScope(n)}),(function(){return(n=e())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n}))},t.prototype.scopedRun=function(t,e,n){t();try{var r=n();return e(),r}catch(t){throw e(),t}},t.prototype.nextTensorId=function(){return t.nextTensorId++},t.prototype.nextVariableId=function(){return t.nextVariableId++},t.prototype.clone=function(t){var e=this.makeTensorFromDataId(t.dataId,t.shape,t.dtype),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(function(t){return{x:function(){return t.toFloat()}}}),[]),e},t.prototype.runKernel=function(t,e,n,r,o){return this.runKernelFunc(null,e,null,t,n,r,o)},t.prototype.shouldCheckForMemLeaks=function(){return this.ENV.getBool("IS_TEST")},t.prototype.checkKernelForMemLeak=function(t,e,n){var r=this.backend.numDataIds(),o=0;n.forEach((function(t){o+="complex64"===t.dtype?3:1}));var a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-e-o-a;if(i>0)throw new Error("Backend '"+this.backendName+"' has an internal memory leak ("+i+" data ids) after running '"+t+"'")},t.prototype.runKernelFunc=function(t,e,n,r,o,a,i){var s,u=this;void 0===a&&(a=[]),void 0===i&&(i=[]);var c=[],h=this.isTapeOn();null==r&&(r=null!=this.state.activeScope?this.state.activeScope.name:"");var f,d=function(t){h&&(c=t.map((function(t){return u.keep(u.clone(t))})))},p=this.state.numBytes,v=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);var m,g=l(r,this.backendName);return f=null!=g?function(){var t=u.backend.numDataIds();m=g.kernelFunc({inputs:e,attrs:o,backend:u.backend});var n=Array.isArray(m)?m:[m];u.shouldCheckForMemLeaks()&&u.checkKernelForMemLeak(r,t,n);var s=n.map((function(t){var e=t.dataId,n=t.shape,r=t.dtype;return u.makeTensorFromDataId(e,n,r)})),c=s.filter((function(t,e){return i[e]}));return d((a||[]).slice().concat(c)),s}:function(){var e=u.backend.numDataIds();m=u.tidy((function(){return t(u.backend,d)}));var n=Array.isArray(m)?m:[m];return u.shouldCheckForMemLeaks()&&u.checkKernelForMemLeak(r,e,n),n},this.scopedRun((function(){return u.state.kernelDepth++}),(function(){return u.state.kernelDepth--}),(function(){s=u.ENV.getBool("DEBUG")?u.profiler.profileKernel(r,e,(function(){return f()})):f()})),h&&this.addTapeNode(r,e,s,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:r,bytesAdded:this.state.numBytes-p,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-v,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(e).map((function(t){return e[t].shape})),outputShapes:s.map((function(t){return t.shape}))}),Array.isArray(m)?s:s[0]},t.prototype.makeTensor=function(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;var o=t;"string"===n&&H(t[0])&&(o=t.map((function(t){return rt(t)})));var a=r.write(o,e,n),i=new wt(e,n,a,this.nextTensorId());if(this.incRef(i,r),"string"===n){var s=this.state.tensorInfo.get(a),u=G(o);this.state.numBytes+=u-s.bytes,s.bytes=u}return i},t.prototype.makeTensorFromDataId=function(t,e,n,r){var o=new wt(e,n=n||"float32",t,this.nextTensorId());return this.incRef(o,r),o},t.prototype.makeVariable=function(t,e,n,r){void 0===e&&(e=!0),n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.asType(r));var o=new St(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error("Variable with name "+o.name+" was already registered");return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o},t.prototype.incRef=function(t,e){var n=this.state.tensorInfo.has(t.dataId)?this.state.tensorInfo.get(t.dataId).refCount:0;if(this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++,0===n){this.state.numDataBuffers++;var r=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(r=t.size*z(t.dtype)),this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:r,refCount:0}),this.state.numBytes+=r}this.state.tensorInfo.get(t.dataId).refCount++,t instanceof St||this.track(t)},t.prototype.disposeTensor=function(t){if(this.state.tensorInfo.has(t.dataId)){this.state.numTensors--,"string"===t.dtype&&this.state.numStringTensors--;var e=this.state.tensorInfo.get(t.dataId);e.refCount<=1?("complex64"!==t.dtype&&(this.state.numBytes-=e.bytes),this.state.numDataBuffers--,e.backend.disposeData(t.dataId),this.state.tensorInfo.delete(t.dataId)):this.state.tensorInfo.get(t.dataId).refCount--}},t.prototype.disposeVariables=function(){for(var t in this.state.registeredVariables){var e=this.state.registeredVariables[t];this.disposeVariable(e)}},t.prototype.disposeVariable=function(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]},t.prototype.memory=function(){var t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t},t.prototype.profile=function(t){return n(this,void 0,void 0,(function(){var e,n;return r(this,(function(r){return this.state.profiling=!0,e=this.state.numBytes,n=this.state.numTensors,this.state.activeProfile.kernels=[],this.state.activeProfile.result=t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max.apply(Math,this.state.activeProfile.kernels.map((function(t){return t.totalBytesSnapshot}))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n,[2,this.state.activeProfile]}))}))},t.prototype.isTapeOn=function(){return this.state.gradientDepth>0&&0===this.state.kernelDepth},t.prototype.addTapeNode=function(t,e,n,r,o){var a=this,i={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:o},s=h(t);null!=s&&(r=s.gradFunc),null!=r&&(i.gradient=function(t){return t=t.map((function(t,e){if(null==t){var r=n[e],o=tt(r.size,r.dtype);return a.makeTensor(o,r.shape,r.dtype)}return t})),r(t.length>1?t:t[0],o)}),this.state.activeTape.push(i)},t.prototype.keep=function(t){return t.kept=!0,t},t.prototype.startTape=function(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++},t.prototype.endTape=function(){this.state.gradientDepth--},t.prototype.startScope=function(t){var e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e},t.prototype.endScope=function(t){for(var e=this,n=_t(t),r=new Set(n.map((function(t){return t.id}))),o=0;o<this.state.activeScope.track.length;o++){var a=this.state.activeScope.track[o];a.kept||r.has(a.id)||a.dispose()}var i=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach((function(t){t.kept||t.scopeId!==i.id||e.track(t)}))},t.prototype.gradients=function(t,e,n,r){var o=this;if(void 0===r&&(r=!1),C(e.length>0,(function(){return"gradients() received an empty list of xs."})),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '"+n.dtype+"'");var a=this.scopedRun((function(){return o.startTape()}),(function(){return o.endTape()}),(function(){return o.tidy("forward",t)}));C(a instanceof wt,(function(){return"The result y returned by f() must be a tensor."}));var i=function(t,e,n){for(var r={},o={},a=0;a<e.length;a++)r[e[a].id]=!0;for(a=0;a<t.length;a++){var i=(p=t[a]).inputs;for(var s in i){for(var u=i[s],c=!1,l=0;l<e.length;l++)if(r[u.id]){p.outputs.forEach((function(t){return r[t.id]=!0})),c=!0,o[p.id]=!0;break}if(c)break}}var h={};h[n.id]=!0;var f={};for(a=t.length-1;a>=0;a--)for(i=(p=t[a]).inputs,l=0;l<p.outputs.length;l++)if(h[p.outputs[l].id]){for(var s in i)h[i[s].id]=!0,f[p.id]=!0;break}var d=[];for(a=0;a<t.length;a++){var p;if(o[(p=t[a]).id]&&f[p.id]){var v={};for(var s in p.inputs){var m=p.inputs[s];r[m.id]&&(v[s]=m)}var g=Object.assign({},p);g.inputs=v,g.outputs=p.outputs,d.push(g)}}return d}(this.state.activeTape,e,a);if(!r&&0===i.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(function(){var t,r,s={};s[a.id]=null==n?(t=a.shape,r=Z(k(t),"float32"),Lt.makeTensor(r,t,"float32")):n,function(t,e,n){for(var r=function(r){var o=e[r],a=[];if(o.outputs.forEach((function(e){var n=t[e.id];null!=n?a.push(n):a.push(null)})),null==o.gradient)throw new Error("Cannot compute gradient: gradient function not found for "+o.kernelName+".");var i=o.gradient(a),s=function(e){if(!(e in i))throw new Error("Cannot backprop through input "+e+". Available gradients found: "+Object.keys(i)+".");var r=n((function(){return i[e]()}));if("float32"!==r.dtype)throw new Error("Error in gradient for op "+o.kernelName+". The gradient of input "+e+" must have 'float32' dtype, but has '"+r.dtype+"'");var a=o.inputs[e];if(!S(r.shape,a.shape))throw new Error("Error in gradient for op "+o.kernelName+". The gradient of input '"+e+"' has shape '"+r.shape+"', which does not match the shape of the input '"+a.shape+"'");if(null==t[a.id])t[a.id]=r;else{var s=t[a.id];t[a.id]=s.add(r),s.dispose()}};for(var u in o.inputs)s(u)},o=e.length-1;o>=0;o--)r(o)}(s,i,(function(t){return o.tidy(t)}));var u=e.map((function(t){return s[t.id]}));return 0===o.state.gradientDepth&&(o.state.activeTape.forEach((function(t){for(var e=0,n=t.saved;e<n.length;e++){n[e].dispose()}})),o.state.activeTape=null),{value:a,grads:u}}))},t.prototype.customGrad=function(t){var e=this;return C(X(t),(function(){return"The f passed in customGrad(f) must be a function."})),function(){for(var n,r=[],o=0;o<arguments.length;o++)r[o]=arguments[o];C(r.every((function(t){return t instanceof wt})),(function(){return"The args passed in customGrad(f)(x1, x2,...) must all be tensors"}));var a={};return r.forEach((function(t,e){a[e]=t})),e.runKernelFunc((function(e,o){return C((n=t.apply(void 0,r.concat([o]))).value instanceof wt,(function(){return"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"})),C(X(n.gradFunc),(function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."})),n.value}),a,(function(t,e){var o=n.gradFunc(t,e),a=Array.isArray(o)?o:[o];C(a.length===r.length,(function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."})),C(a.every((function(t){return t instanceof wt})),(function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."}));var i={};return a.forEach((function(t,e){i[e]=function(){return t}})),i}))}},t.prototype.readSync=function(t){return this.state.tensorInfo.get(t).backend.readSync(t)},t.prototype.read=function(t){return this.state.tensorInfo.get(t).backend.read(t)},t.prototype.time=function(t){return n(this,void 0,void 0,(function(){var e,n;return r(this,(function(r){switch(r.label){case 0:return e=et(),[4,this.backend.time(t)];case 1:return(n=r.sent()).wallMs=et()-e,[2,n]}}))}))},t.prototype.track=function(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t},Object.defineProperty(t.prototype,"registeredVariables",{get:function(){return this.state.registeredVariables},enumerable:!0,configurable:!0}),t.prototype.reset=function(){for(var t in this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Bt,this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null},t.nextTensorId=0,t.nextVariableId=0,t}();var Lt=function(){var t=function(){if(null==Ot){var t=void 0;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}Ot=t}return Ot}();if(null==t._tfengine){var e=new o(t);t._tfengine=new Pt(e)}return function(t){s=t}(t._tfengine.ENV),yt=function(){return t._tfengine},t._tfengine}();function Wt(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var Ut=i();Ut.registerFlag("DEBUG",(function(){return!1}),(function(t){t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Ut.registerFlag("IS_BROWSER",(function(){return Wt()})),Ut.registerFlag("IS_NODE",(function(){return"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node})),Ut.registerFlag("IS_CHROME",(function(){return"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)})),Ut.registerFlag("PROD",(function(){return!1})),Ut.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(function(){return Ut.getBool("DEBUG")})),Ut.registerFlag("DEPRECATION_WARNINGS_ENABLED",(function(){return!0})),Ut.registerFlag("IS_TEST",(function(){return!1}));var Vt,zt,Gt,Ht={},qt={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Kt(t,e){Ht[t]=e}function jt(t){t in Ht||(Ht[t]=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");var e=function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);if(e.addEventListener("webglcontextlost",(function(e){e.preventDefault(),delete Ht[t]}),!1),1===t)return e.getContext("webgl",qt)||e.getContext("experimental-webgl",qt);return e.getContext("webgl2",qt)}(t));var e=Ht[t];return e.isContextLost()?(delete Ht[t],jt(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Ht[t])}function Xt(t,e){return[e,t]}function Yt(t){var e=k(t);return T(Math.ceil(e/4))}function $t(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function Qt(t,e){var n,r,o,a,s,u,c,l,h,f=t;return 2===i().getNumber("WEBGL_VERSION")?(n=f.R32F,r=f.R16F,o=f.RGBA16F,a=f.RGBA32F,s=f.RED,u=4,c=1,l=f.HALF_FLOAT,h=f.FLOAT):(n=t.RGBA,r=t.RGBA,o=t.RGBA,a=f.RGBA,s=t.RGBA,u=4,c=4,l=null!=e?e.HALF_FLOAT_OES:null,h=t.FLOAT),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:a,textureFormatFloat:s,downloadTextureFormat:t.RGBA,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:l,textureTypeFloat:h}}function Jt(t,e,n){var r=n();return e&&function(t){var e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+ne(t,e))}(t),r}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(Vt||(Vt={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(zt||(zt={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(Gt||(Gt={}));var Zt=5.96e-8,te=65504;function ee(t){return!!(i().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||Zt<Math.abs(t)&&Math.abs(t)<te)}function ne(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+e}}function re(t,e,n){return ke(t,e,(function(){return t.getExtension(n)}),'Extension "'+n+'" not supported on this browser.')}function oe(t,e,n){var r=ke(t,e,(function(){return t.createShader(t.VERTEX_SHADER)}),"Unable to create vertex WebGLShader.");if(Jt(t,e,(function(){return t.shaderSource(r,n)})),Jt(t,e,(function(){return t.compileShader(r)})),!1===t.getShaderParameter(r,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(r)),new Error("Failed to compile vertex shader.");return r}function ae(t,e,n){var r=ke(t,e,(function(){return t.createShader(t.FRAGMENT_SHADER)}),"Unable to create fragment WebGLShader.");if(Jt(t,e,(function(){return t.shaderSource(r,n)})),Jt(t,e,(function(){return t.compileShader(r)})),!1===t.getShaderParameter(r,t.COMPILE_STATUS))throw function(t,e){var n=ue.exec(e);if(null==n)return console.log("Couldn't parse line number in error: "+e),void console.log(t);for(var r=+n[1],o=t.split("\n"),a=o.length.toString().length+2,i=o.map((function(t,e){return N((e+1).toString(),a)+t})),s=0,u=0;u<i.length;u++)s=Math.max(i[u].length,s);var c=i.slice(0,r-1),l=i.slice(r-1,r),h=i.slice(r);console.log(c.join("\n")),console.log(e.split("\n")[0]),console.log("%c "+N(l[0],s),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join("\n"))}(n,t.getShaderInfoLog(r)),new Error("Failed to compile fragment shader.");return r}var ie,se,ue=/ERROR: [0-9]+:([0-9]+):/g;function ce(t,e){return ke(t,e,(function(){return t.createProgram()}),"Unable to create WebGLProgram.")}function le(t,e,n){if(Jt(t,e,(function(){return t.linkProgram(n)})),!1===t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}function he(t,e,n){if(Jt(t,e,(function(){return t.validateProgram(n)})),!1===t.getProgramParameter(n,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function fe(t,e,n){var r=ke(t,e,(function(){return t.createBuffer()}),"Unable to create WebGLBuffer");return Jt(t,e,(function(){return t.bindBuffer(t.ARRAY_BUFFER,r)})),Jt(t,e,(function(){return t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)})),r}function de(t,e,n){var r=ke(t,e,(function(){return t.createBuffer()}),"Unable to create WebGLBuffer");return Jt(t,e,(function(){return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,r)})),Jt(t,e,(function(){return t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)})),r}function pe(t,e){return ke(t,e,(function(){return t.createTexture()}),"Unable to create WebGLTexture.")}function ve(t,e){var n=i().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){var r="["+t+"x"+e+"]";throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){r="["+t+"x"+e+"]";throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+("["+n+"x"+n+"]")+".")}}function me(t,e){return ke(t,e,(function(){return t.createFramebuffer()}),"Unable to create WebGLFramebuffer.")}function ge(t,e,n,r,o,a,i,s){var u=t.getAttribLocation(n,r);return-1!==u&&(Jt(t,e,(function(){return t.bindBuffer(t.ARRAY_BUFFER,o)})),Jt(t,e,(function(){return t.vertexAttribPointer(u,a,t.FLOAT,!1,i,s)})),Jt(t,e,(function(){return t.enableVertexAttribArray(u)})),!0)}function ye(t,e,n,r){Se(t,r),Jt(t,e,(function(){return t.activeTexture(t.TEXTURE0+r)})),Jt(t,e,(function(){return t.bindTexture(t.TEXTURE_2D,n)}))}function xe(t,e,n,r){return ke(t,e,(function(){return t.getUniformLocation(n,r)}),'uniform "'+r+'" not present in program.')}function be(t,e,n){return t.getUniformLocation(e,n)}function we(t,e,n,r,o,a){Jt(t,e,(function(){return ye(t,e,r,a)})),Jt(t,e,(function(){return t.uniform1i(o,a)}))}function Ce(t,e,n,r){Jt(t,e,(function(){return t.bindFramebuffer(t.FRAMEBUFFER,r)})),Jt(t,e,(function(){return t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0)}))}function Ee(t,e,n){Jt(t,e,(function(){return t.bindFramebuffer(t.FRAMEBUFFER,n)})),Jt(t,e,(function(){return t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)}))}function Re(t){var e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Ie(t,e))}function Ie(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+e}}function ke(t,e,n,r){var o=Jt(t,e,(function(){return n()}));if(null==o)throw new Error(r);return o}function Se(t,e){var n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n)throw new Error("textureUnit must be in "+("[gl.TEXTURE0, gl.TEXTURE"+n+"]")+".")}function Ae(t,e){return void 0===e&&(e=2),k(t.slice(0,t.length-e))}function De(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function Te(t){var e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[Ae(t)].concat(De(t))),e}function Ne(t,e){var n;void 0===e&&(e=!1);var r=i().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(r*=2,1===(t=t.map((function(e,n){return n>=t.length-2?b(t[n]):t[n]}))).length&&(t=[2,t[0]])),2!==t.length){var o=M(t);t=o.newShape}var a=k(t);if(t.length<=1&&a<=r)return[1,a];if(2===t.length&&t[0]<=r&&t[1]<=r)return t;if(3===t.length&&t[0]*t[1]<=r&&t[2]<=r)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=r&&t[1]*t[2]<=r)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=r&&t[3]<=r)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=r&&t[1]*t[2]*t[3]<=r)return[t[0],t[1]*t[2]*t[3]];if(e){var s=Ae(t),u=2,c=2;return t.length&&(u=(n=De(t))[0],c=n[1]),T(a=s*(u/2)*(c/2)).map((function(t){return 2*t}))}return T(a)}function Fe(t){return t%2==0}function _e(t,e){if(S(t=t.slice(-2),e=e.slice(-2)))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){var n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r)return!0;if(Fe(n)&&Fe(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&Fe(t[0])&&Fe(e[0])}function Oe(t){if(null==ie){var e=jt(t);ie=e.getParameter(e.MAX_TEXTURE_SIZE)}return ie}function Me(t){if(null==se){var e=jt(t);se=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,se)}function Be(t){if(0===t)return 0;var e=jt(t);return Pe(e,"EXT_disjoint_timer_query_webgl2")&&2===t?2:Pe(e,"EXT_disjoint_timer_query")?1:0}function Pe(t,e){return null!=t.getExtension(e)}function Le(t){try{if(null!=jt(t))return!0}catch(t){return!1}return!1}function We(t){if(0===t)return!1;var e=jt(t);if(1===t){if(!Pe(e,"OES_texture_float"))return!1}else if(!Pe(e,"EXT_color_buffer_float"))return!1;return Ve(e)}function Ue(t){if(0===t)return!1;var e=jt(t);if(1!==t){if(Pe(e,"EXT_color_buffer_float"))return Ve(e);if(Pe(e,"EXT_color_buffer_half_float")){var n=e.getExtension("EXT_color_buffer_half_float");return function(t,e){var n=Qt(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r);t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);var o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);var a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(o),a}(e,n)}return!1}return!!Pe(e,"OES_texture_float")&&(!!Pe(e,"WEBGL_color_buffer_float")&&Ve(e))}function Ve(t){var e=Qt(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n);t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);var r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);var o=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),o}function ze(t){return 2===t&&null!=jt(t).fenceSync}var Ge=Object.freeze({callAndCheck:Jt,canBeRepresented:ee,getWebGLErrorMessage:ne,getExtensionOrThrow:re,createVertexShader:oe,createFragmentShader:ae,createProgram:ce,linkProgram:le,validateProgram:he,createStaticVertexBuffer:fe,createStaticIndexBuffer:de,getNumChannels:function(){return 2===i().getNumber("WEBGL_VERSION")?1:4},createTexture:pe,validateTextureSize:ve,createFramebuffer:me,bindVertexBufferToProgramAttribute:ge,bindTextureUnit:ye,unbindTextureUnit:function(t,e,n){Se(t,n),Jt(t,e,(function(){return t.activeTexture(t.TEXTURE0+n)})),Jt(t,e,(function(){return t.bindTexture(t.TEXTURE_2D,null)}))},getProgramUniformLocationOrThrow:xe,getProgramUniformLocation:be,bindTextureToProgramUniformSampler:we,bindCanvasToFramebuffer:function(t,e){Jt(t,e,(function(){return t.bindFramebuffer(t.FRAMEBUFFER,null)})),Jt(t,e,(function(){return t.viewport(0,0,t.canvas.width,t.canvas.height)})),Jt(t,e,(function(){return t.scissor(0,0,t.canvas.width,t.canvas.height)}))},bindColorTextureToFramebuffer:Ce,unbindColorTextureFromFramebuffer:Ee,validateFramebuffer:Re,getFramebufferErrorMessage:Ie,getBatchDim:Ae,getRowsCols:De,getShapeAs3D:Te,getTextureShapeFromLogicalShape:Ne,isReshapeFree:_e,getWebGLMaxTextureSize:Oe,resetMaxTextureSize:function(){ie=null},resetMaxTexturesInShader:function(){se=null},getMaxTexturesInShader:Me,getWebGLDisjointQueryTimerVersion:Be,hasExtension:Pe,isWebGLVersionEnabled:Le,isCapableOfRenderingToFloatTexture:We,isDownloadFloatTextureEnabled:Ue,isWebGLFenceEnabled:ze}),He=i();function qe(){i().set("PROD",!0)}function Ke(){i().set("DEBUG",!0)}function je(){i().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Xe(t){i().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Ye(){Lt.disposeVariables()}function $e(){return Lt}function Qe(){return Lt.memory()}function Je(t){return Lt.profile(t)}function Ze(t,e){return Lt.tidy(t,e)}function tn(t){_t(t).forEach((function(t){return t.dispose()}))}function en(t){return Lt.keep(t)}function nn(t){return Lt.time(t)}function rn(t){return Lt.setBackend(t)}function on(){return Lt.ready()}function an(){return Lt.backendName}function sn(t){Lt.removeBackend(t)}function un(t){return Lt.findBackend(t)}function cn(t){return Lt.findBackendFactory(t)}function ln(t,e,n){return void 0===n&&(n=1),Lt.registerBackend(t,e,n)}function hn(){return Lt.backend}function fn(t,e){i().setPlatform(t,e)}function dn(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];i().getBool("IS_TEST")||console.warn.apply(console,t)}function pn(t,e){var n=t;if(V(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];for(var r=[];Array.isArray(n)||V(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&i().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function t(e,n,r){if(r=r||[],!Array.isArray(e)&&!V(e))return void C(0===n.length,(function(){return"Element arr["+r.join("][")+"] is a primitive, but should be an array/TypedArray of "+n[0]+" elements"}));C(n.length>0,(function(){return"Element arr["+r.join("][")+"] should be a primitive, but is an array of "+e.length+" elements"})),C(e.length===n[0],(function(){return"Element arr["+r.join("][")+"] should have "+n[0]+" elements, but has "+e.length+" elements"}));for(var o=n.slice(1),a=0;a<e.length;++a)t(e[a],o,r.concat(a))}(t,r,[]),r}function vn(t,e,n,r){if(null!=t&&("numeric"!==t&&t!==e||"numeric"===t&&"string"===e))throw new Error("Argument '"+n+"' passed to '"+r+"' must be "+t+" tensor, but got "+e+" tensor")}function mn(t,e,n,r){if(void 0===r&&(r="numeric"),t instanceof wt)return vn(r,t.dtype,e,n),t;var o=j(t);if("string"!==o&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),vn(r,o,e,n),null==t||!V(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){var a=null==t?"null":t.constructor.name;throw new Error("Argument '"+e+"' passed to '"+n+"' must be a Tensor or TensorLike, but got '"+a+"'")}var s=pn(t,o);V(t)||Array.isArray(t)||(t=[t]);var u="string"!==o?Q(t,o,i().getBool("DEBUG")):I(t,[],!0);return Lt.makeTensor(u,s,o)}function gn(t,e,n,r){if(void 0===r&&(r="numeric"),!Array.isArray(t))throw new Error("Argument "+e+" passed to "+n+" must be a `Tensor[]` or `TensorLike[]`");return t.map((function(t,r){return mn(t,e+"["+r+"]",n)}),r)}function yn(t,e){for(var n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function xn(t,e,n){for(var r=t.length+e.length,o=[],a=0,i=0,s=0;s<r;s++)-1===n.indexOf(s)?o.push(t[a++]):o.push(e[i++]);return o}function bn(t,e){for(var n=[],r=t.length,o=0;o<r;o++)-1===e.indexOf(o)&&n.push(t[o]);return[n,e.map((function(e){return t[e]}))]}function wn(t,e){return xn(t,e.map((function(t){return 1})),e)}function Cn(t,e,n){C(yn(e,n),(function(){return t+" supports only inner-most axes for now. Got axes "+e+" and rank-"+n+" input."}))}function En(t,e){if(yn(t,e))return null;for(var n=[],r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((function(t){return n.push(t)})),n}function Rn(t){return t.map((function(t,e){return[e,t]})).sort((function(t,e){return t[1]-e[1]})).map((function(t){return t[0]}))}function In(t,e){for(var n=[],r=e-t;r<e;++r)n.push(r);return n}function kn(t,e){var n=t[0].length;t.forEach((function(t,e){C(t.length===n,(function(){return"Error in concat"+n+"D: rank of tensors["+e+"] must be the same as the rank of the rest ("+n+")"}))})),C(e>=0&&e<n,(function(){return"Error in concat"+n+"D: axis must be between 0 and "+(n-1)+"."}));var r=t[0];t.forEach((function(t,o){for(var a=0;a<n;a++)C(a===e||t[a]===r[a],(function(){return"Error in concat"+n+"D: Shape of tensors["+o+"] ("+t+") does not match the shape of the rest ("+r+") along the non-concatenated axis "+o+"."}))}))}function Sn(t,e){for(var n=t[0].slice(),r=1;r<t.length;r++)n[e]+=t[r][e];return n}function An(t){var e=Object.keys(t);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+e.length+" keys.");var n=e[0],r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1));var o=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];Lt.startScope(n);try{var o=r.apply(void 0,t);return o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),Lt.endScope(o),o}catch(t){throw Lt.endScope(null),t}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}He.registerFlag("HAS_WEBGL",(function(){return He.getNumber("WEBGL_VERSION")>0})),He.registerFlag("WEBGL_VERSION",(function(){return Le(2)?2:Le(1)?1:0})),He.registerFlag("WEBGL_BUFFER_SUPPORTED",(function(){return 2===He.get("WEBGL_VERSION")})),He.registerFlag("WEBGL_CPU_FORWARD",(function(){return!0})),He.registerFlag("WEBGL_FORCE_F16_TEXTURES",(function(){return!1})),He.registerFlag("WEBGL_PACK",(function(){return He.getBool("HAS_WEBGL")})),He.registerFlag("WEBGL_PACK_NORMALIZATION",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_PACK_CLIP",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_PACK_DEPTHWISECONV",(function(){return!1})),He.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_PACK_REDUCE",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_LAZILY_UNPACK",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_CONV_IM2COL",(function(){return He.getBool("WEBGL_PACK")})),He.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(function(){return Oe(He.getNumber("WEBGL_VERSION"))})),He.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(function(){return Me(He.getNumber("WEBGL_VERSION"))})),He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(function(){var t=He.getNumber("WEBGL_VERSION");return 0===t?0:Be(t)})),He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(function(){return He.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&(t=navigator.userAgent||navigator.vendor||window.opera,!(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))));var t})),He.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(function(){return We(He.getNumber("WEBGL_VERSION"))})),He.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(function(){return!He.getBool("WEBGL_FORCE_F16_TEXTURES")&&He.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")})),He.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(function(){return Ue(He.getNumber("WEBGL_VERSION"))})),He.registerFlag("WEBGL_FENCE_API_ENABLED",(function(){return ze(He.getNumber("WEBGL_VERSION"))})),He.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(function(){return He.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0})),bt=Xe;var Dn=An({complex_:function(t,e){var n=mn(t,"real","complex"),r=mn(e,"imag","complex");return E(n.shape,r.shape,"real and imag shapes, "+n.shape+" and "+r.shape+", must match in call to tf.complex()."),Lt.runKernelFunc((function(t){return t.complex(n,r)}),{$real:n,$imag:r})}}),Tn=An({real_:function(t){var e=mn(t,"input","real");return Lt.runKernelFunc((function(t){return t.real(e)}),{$input:e})}}),Nn=An({imag_:function(t){var e=mn(t,"input","imag");return Lt.runKernelFunc((function(t){return t.imag(e)}),{$input:e})}});function Fn(t,e,n){return _n(t,e,pn(t,n),n)}function _n(t,e,n,r){if(null==r&&(r=j(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!V(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){nt(e);var o=k(e),a=k(n);C(o===a,(function(){return"Based on the provided shape, ["+e+"], the tensor should have "+o+" values but has "+a}));for(var s=0;s<n.length;++s){var u=n[s],c=s!==n.length-1||u!==k(e.slice(s));C(n[s]===e[s]||!c,(function(){return"Error creating a new Tensor. Inferred shape ("+n+") does not match the provided shape ("+e+"). "}))}}return V(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?Q(t,r,i().getBool("DEBUG")):I(t,[],!0),Lt.makeTensor(t,e,r)}function On(t,e){if((V(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&V(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return _n(t,[],[],e)}function Mn(t,e){R(t);var n=pn(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return _n(t,null,n,e)}function Bn(t,e,n){if(R(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");var r=pn(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return _n(t,e,r,n)}function Pn(t,e,n){if(R(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");var r=pn(t,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return _n(t,e,r,n)}function Ln(t,e,n){if(R(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");var r=pn(t,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return _n(t,e,r,n)}function Wn(t,e,n){if(R(t),null!=e&&5!==e.length)throw new Error("tensor5d() requires shape to have five numbers");var r=pn(t,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return _n(t,e,r,n)}function Un(t,e,n){if(R(t),null!=e&&6!==e.length)throw new Error("tensor6d() requires shape to have six numbers");var r=pn(t,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return _n(t,e=e||r,r,n)}function Vn(t,e,n,r){return void 0===e&&(e=!0),Lt.makeVariable(t,e,n,r)}function zn(t,e){if(void 0===e&&(e="float32"),"complex64"===e){var n=zn(t,"float32"),r=Gn(t,"float32");return Dn(n,r)}var o=Z(k(t),e);return Lt.makeTensor(o,t,e)}function Gn(t,e){if(void 0===e&&(e="float32"),"complex64"===e){var n=Gn(t,"float32"),r=Gn(t,"float32");return Dn(n,r)}var o=tt(k(t),e);return Lt.makeTensor(o,t,e)}function Hn(t,e,n){return Lt.runKernelFunc((function(r){return r.fill(t,e,n)}),{})}function qn(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");return Lt.runKernelFunc((function(r){return r.linspace(t,e,n)}),{})}function Kn(t,e,n,r){if(void 0===n&&(n=1),void 0===r&&(r="float32"),0===n)throw new Error("Cannot have a step of zero");if(t===e||t<e&&n<0||e<t&&n>1)return Gn([0],r);var o=tt(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),o[0]=t;for(var a=1;a<o.length;a++)o[a]=o[a-1]+n;return Mn(o,r)}var jn=An({onesLike_:function(t){var e=mn(t,"x","onesLike");if("complex64"===e.dtype){var n=jn(Tn(e)),r=Xn(Nn(e));return Dn(n,r)}return Lt.runKernelFunc((function(t){return t.onesLike(e)}),{$x:e},(function(t,e){return{$x:function(){return Xn(t)}}}))}}),Xn=An({zerosLike_:function(t){var e=mn(t,"x","zerosLike");return Lt.runKernelFunc((function(t){return t.zerosLike(e)}),{$x:e},(function(t,e){return{$x:function(){return Xn(t)}}}))}});var Yn=An({concat_:function(t,e){void 0===e&&(e=0),C(t.length>=1,(function(){return"Pass at least one tensor to concat"}));var n=gn(t,"tensors","concat");"complex64"===n[0].dtype&&n.forEach((function(t){if("complex64"!==t.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype "+t.dtype+". ")})),e=O(e,n[0].shape)[0];var r=Sn(n.map((function(t){return t.shape})),e);if(0===k(r))return Fn([],r);if(1===(n=n.filter((function(t){return t.size>0}))).length)return n[0];var o=n.map((function(t){return t.shape}));kn(o,e);var a=n,i={axis:e};return Lt.runKernelFunc((function(t){return t.concat(n,e)}),a,(function(t){var n=o.map((function(t){return t[e]}));return tr(t,n,e).map((function(t){return function(){return t}}))}),"Concat",i)}}),$n=An({concat1d_:function(t){return Yn(t,0)}}),Qn=An({concat2d_:function(t,e){return Yn(t,e)}}),Jn=An({concat3d_:function(t,e){return Yn(t,e)}}),Zn=An({concat4d_:function(t,e){return Yn(t,e)}}),tr=An({split_:function(t,e,n){void 0===n&&(n=0);var r,o=mn(t,"x","split");return n=O(n,o.shape)[0],"number"==typeof e?(C(o.shape[n]%e==0,(function(){return"Number of splits must evenly divide the axis."})),r=new Array(e).fill(o.shape[n]/e)):(C(o.shape[n]===e.reduce((function(t,e){return t+e})),(function(){return"The sum of sizes must match the size of the axis dimension."})),r=e),Lt.runKernelFunc((function(t){return t.split(o,r,n)}),{$x:o},(function(t){return{$x:function(){return Yn(t,n)}}}))}});"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function er(t,e){return t(e={exports:{}},e.exports),e.exports}var nr=er((function(t){!function(t,e,n){function r(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function o(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function a(t,e){var n=new r(t),a=e&&e.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.alea=a}(0,t,!1)})),rr=er((function(t){!function(t,e,n){function r(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.xor128=a}(0,t,!1)})),or=er((function(t){!function(t,e,n){function r(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.xorwow=a}(0,t,!1)})),ar=er((function(t){!function(t,e,n){function r(t){var e=this;e.next=function(){var t,n,r=e.x,o=e.i;return t=r[o],n=(t^=t>>>7)^t<<24,n^=(t=r[o+1&7])^t>>>10,n^=(t=r[o+3&7])^t>>>3,n^=(t=r[o+4&7])^t<<7,t=r[o+7&7],n^=(t^=t<<13)^t<<9,r[o]=n,e.i=o+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function o(t,e){return e.x=t.x.slice(),e.i=t.i,e}function a(t,e){null==t&&(t=+new Date);var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&(a.x&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.xorshift7=a}(0,t,!1)})),ir=er((function(t){!function(t,e,n){function r(t){var e=this;e.next=function(){var t,n,r=e.w,o=e.X,a=e.i;return e.w=r=r+1640531527|0,n=o[a+34&127],t=o[a=a+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=o[a]=n^t,e.i=a,n+(r^r>>>16)|0},function(t,e){var n,r,o,a,i,s=[],u=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,u=Math.max(u,e.length)),o=0,a=-32;a<u;++a)e&&(r^=e.charCodeAt((a+32)%e.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(e&&e.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;t.w=i,t.X=s,t.i=o}(e,t)}function o(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function a(t,e){null==t&&(t=+new Date);var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&(a.X&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.xor4096=a}(0,t,!1)})),sr=er((function(t){!function(t,e,n){function r(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,o=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^o,e.a=o-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.tychei=a}(0,t,!1)})),ur=er((function(t){!function(e,n){var r,o=this,a=256,i=6,s="random",u=n.pow(a,i),c=n.pow(2,52),l=2*c,h=a-1;function f(t,h,f){var g=[],y=v(function t(e,n){var r,o=[],a=typeof e;if(n&&"object"==a)for(r in e)try{o.push(t(e[r],n-1))}catch(t){}return o.length?o:"string"==a?e:e+"\0"}((h=1==h?{entropy:!0}:h||{}).entropy?[t,m(e)]:null==t?function(){try{var t;return r&&(t=r.randomBytes)?t=t(a):(t=new Uint8Array(a),(o.crypto||o.msCrypto).getRandomValues(t)),m(t)}catch(t){var n=o.navigator,i=n&&n.plugins;return[+new Date,o,i,o.screen,m(e)]}}():t,3),g),x=new d(g),b=function(){for(var t=x.g(i),e=u,n=0;t<c;)t=(t+n)*a,e*=a,n=x.g(1);for(;t>=l;)t/=2,e/=2,n>>>=1;return(t+n)/e};return b.int32=function(){return 0|x.g(4)},b.quick=function(){return x.g(4)/4294967296},b.double=b,v(m(x.S),e),(h.pass||f||function(t,e,r,o){return o&&(o.S&&p(o,x),t.state=function(){return p(x,{})}),r?(n[s]=t,e):t})(b,y,"global"in h?h.global:this==n,h.state)}function d(t){var e,n=t.length,r=this,o=0,i=r.i=r.j=0,s=r.S=[];for(n||(t=[n++]);o<a;)s[o]=o++;for(o=0;o<a;o++)s[o]=s[i=h&i+t[o%n]+(e=s[o])],s[i]=e;(r.g=function(t){for(var e,n=0,o=r.i,i=r.j,s=r.S;t--;)e=s[o=h&o+1],n=n*a+s[h&(s[o]=s[i=h&i+e])+(s[i]=e)];return r.i=o,r.j=i,n})(a)}function p(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function v(t,e){for(var n,r=t+"",o=0;o<r.length;)e[h&o]=h&(n^=19*e[h&o])+r.charCodeAt(o++);return m(e)}function m(t){return String.fromCharCode.apply(0,t)}if(n["seed"+s]=f,v(n.random(),e),t.exports){t.exports=f;try{r=__webpack_require__(/*! crypto */ 1)}catch(t){}}}([],Math)}));ur.alea=nr,ur.xor128=rr,ur.xorwow=or,ur.xorshift7=ar,ur.xor4096=ir,ur.tychei=sr;var cr=ur.alea,lr=function(){function t(t,e,n,r,o){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);var a=o||Math.random();this.random=cr(a.toString())}return t.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var t=this.nextVal;return this.nextVal=NaN,t}for(var e,n,r=!1;!r;){var o=void 0,a=void 0,i=void 0;do{i=(o=2*this.random()-1)*o+(a=2*this.random()-1)*a}while(i>=1||0===i);var s=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*o*s,n=this.mean+this.stdDev*a*s,this.truncated&&!this.isValidTruncated(e)||(r=!0)}return this.truncated&&!this.isValidTruncated(n)||(this.nextVal=this.convertValue(n)),this.convertValue(e)},t.prototype.convertValue=function(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)},t.prototype.isValidTruncated=function(t){return t<=this.upper&&t>=this.lower},t}(),hr=function(){function t(t,e,n,r){this.alpha=t,this.beta=1/e,this.dtype=n;var o=r||Math.random();this.randu=cr(o.toString()),this.randn=new lr(0,1,n,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}return t.prototype.nextValue=function(){for(var t,e,n,r,o,a;;){do{r=this.randn.nextValue(),a=1+this.c*r}while(a<=0);if(a*=a*a,e=1-.331*(t=r*r)*t,n=.5*t+this.d*(1-a+Math.log(a)),(o=this.randu())<e||Math.log(o)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)},t.prototype.convertValue=function(t){return"float32"===this.dtype?t:Math.round(t)},t}(),fr=function(){function t(t,e,n,r){var o=this;if(void 0===t&&(t=0),void 0===e&&(e=1),this.canReturnFloat=function(){return null==o.dtype||"float32"===o.dtype},this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between "+t+" - "+e+" <= 1 and dtype is not float");this.random=cr(r)}return t.prototype.convertValue=function(t){return this.canReturnFloat()?t:Math.round(t)},t.prototype.nextValue=function(){return this.convertValue(this.min+this.range*this.random())},t}();function dr(t,e,n){return void 0===e&&(e="float32"),e=e||"float32",nt(t),new gt(t,e,n)}function pr(t,e){void 0===e&&(e=!1),console.log(t.toString(e))}var vr=An({batchToSpaceND_:function(t,e,n){var r=mn(t,"x","batchToSpaceND"),o=e.reduce((function(t,e){return t*e}));return C(r.rank>=1+e.length,(function(){return"input rank is "+r.rank+" but should be > than blockShape.length "+e.length})),C(n.length===e.length,(function(){return"crops.length is "+n.length+" but should be equal to blockShape.length  "+e.length})),C(r.shape[0]%o==0,(function(){return"input tensor batch is "+r.shape[0]+" but is not divisible by the product of the elements of blockShape "+e.join(" * ")+" === "+o})),Lt.runKernelFunc((function(t){return t.batchToSpaceND(r,e,n)}),{$x:r},(function(t){return{$x:function(){return t.spaceToBatchND(e,n)}}}))}}),mr=An({broadcastTo_:function(t,e){var n=mn(t,"broadcastTo","x"),r=n.shape;if(e.some((function(t){return!(t>0)||t%1!=0})))throw new Error("broadcastTo(): Invalid broadcast shape ["+e+"].");if(e.length<n.rank)throw new Error("broadcastTo(): shape.length="+e.length+" < input.rank="+n.rank+".");if(e.length>n.rank){for(var o=n.shape.slice();o.length<e.length;)o.unshift(1);n=n.reshape(o)}for(var a=Array.from(e),i=e.length-1;i>=0;i--)if(n.shape[i]===e[i])a[i]=1;else if(1!==n.shape[i])throw new Error("broadcastTo(): ["+r+"] cannot be broadcast to ["+e+"].");var s=a.map((function(t,e){return t>1?e:-1})).filter((function(t){return t>=0}));return 0===s.length?n.clone():Lt.runKernelFunc((function(t){return t.tile(n,a)}),{input:n},(function(t){return{input:function(){return t.sum(s,!0)}}}))}}),gr=An({cast_:function(t,e){var n=mn(t,"x","cast");if(!W(e))throw new Error("Failed to cast to unknown dtype "+e);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");var r={dtype:e};return Lt.runKernelFunc((function(t){return t.cast(n,e)}),{x:n},(function(t){return{x:function(){return t.clone()}}}),"Cast",r)}}),yr=An({clone_:function(t){var e=mn(t,"x","clone",null);return Lt.runKernelFunc((function(){return Lt.makeTensorFromDataId(e.dataId,e.shape,e.dtype)}),{$x:e},(function(t){return{$x:function(){return t.toFloat()}}}))}}),xr=An({cumsum_:function(t,e,n,r){void 0===e&&(e=0),void 0===n&&(n=!1),void 0===r&&(r=!1);var o=mn(t,"x","cumsum"),a=En([e|=0],o.rank),i=o;null!=a&&(i=o.transpose(a));var s=In(1,o.rank)[0],u=Lt.runKernelFunc((function(t){return t.cumsum(i,s,n,r)}),{permutedX:i},(function(t){return{permutedX:function(){return t.cumsum(e,n,!r)}}}));return null!=a&&(u=u.transpose(a)),u}}),br=An({depthToSpace_:function(t,e,n){void 0===n&&(n="NHWC");var r=mn(t,"x","depthToSpace"),o="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];return C(o*e>=0,(function(){return"Negative dimension size caused by overflow when multiplying\n      "+o+" and "+e+"  for depthToSpace with input shape\n      "+r.shape})),C(a*e>=0,(function(){return"Negative dimension size caused by overflow when multiplying\n      "+a+" and "+e+" for depthToSpace with input shape\n          "+r.shape})),C(i%(e*e)==0,(function(){return"Dimension size must be evenly divisible by "+e*e+" but is "+i+" for depthToSpace with input shape "+r.shape})),Lt.runKernelFunc((function(t){return t.depthToSpace(r,e,n)}),{$x:r})}}),wr=An({expandDims_:function(t,e){void 0===e&&(e=0);var n=mn(t,"x","expandDims",null);C(e<=n.rank,(function(){return"Axis must be <= rank of the tensor"}));var r=n.shape.slice();return e<0&&(C(-(n.rank+1)<=e,(function(){return"Axis must be in the interval ["+-(n.rank+1)+", "+n.rank+"]"})),e=n.rank+e+1),r.splice(e,0,1),Or(n,r)}}),Cr=An({eye_:function(t,e,n,r){void 0===r&&(r="float32"),null==e&&(e=t);for(var o=dr([t,e],r),a=t<=e?t:e,i=0;i<a;++i)o.set(1,i,i);var s=o.toTensor().as2D(t,e);if(null==n)return s;if(1===n.length)return Lr(wr(s,0),[n[0],1,1]);if(2===n.length)return Lr(wr(wr(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return Lr(wr(wr(wr(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D batchShapes, but received "+n.length+"D.")}}),Er=An({multinomial_:function(t,e,n,r){void 0===r&&(r=!1);var o=mn(t,"logits","multinomial"),a=o.size,i=o.rank;if(a<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+a+".");if(i>2)throw new Error("Rank of probabilities must be 1 or 2, but is "+i);n=n||Math.random();var s=1===i?o.as2D(1,-1):o,u=Lt.runKernelFunc((function(t){return t.multinomial(s,r,e,n)}),{logits2D:s});return 1===i?u.as1D():u}}),Rr=An({oneHot_:function(t,e,n,r){if(void 0===n&&(n=1),void 0===r&&(r=0),e<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+e);var o=mn(t,"indices","oneHot","int32"),a=o.shape.concat([e]);return o=o.flatten(),Lt.runKernelFunc((function(t){return t.oneHot(o,e,n,r)}),{$indices:o},(function(t){return{$indices:function(){return Gn(o.shape,"float32")}}})).reshape(a)}}),Ir=An({pad_:function(t,e,n){void 0===n&&(n=0);var r=mn(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");var o={paddings:e,constantValue:n};return Lt.runKernelFunc((function(t){return t.pad(r,e,n)}),{x:r},(function(t){var n=e.map((function(t){return t[0]}));return{x:function(){return t.slice(n,r.shape)}}}),"PadV2",o)}}),kr=An({pad1d_:function(t,e,n){return void 0===n&&(n=0),C(2===e.length,(function(){return"Invalid number of paddings. Must be length of 2."})),Ir(t,[e],n)}}),Sr=An({pad2d_:function(t,e,n){return void 0===n&&(n=0),C(2===e.length&&2===e[0].length&&2===e[1].length,(function(){return"Invalid number of paddings. Must be length of 2 each."})),Ir(t,e,n)}}),Ar=An({pad3d_:function(t,e,n){return void 0===n&&(n=0),C(3===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length,(function(){return"Invalid number of paddings. Must be length of 2 each."})),Ir(t,e,n)}}),Dr=An({pad4d_:function(t,e,n){return void 0===n&&(n=0),C(4===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length&&2===e[3].length,(function(){return"Invalid number of paddings. Must be length of 2 each."})),Ir(t,e,n)}}),Tr=An({rand_:function(t,e,n){var r=k(t),o=null;if(null==n||"float32"===n)o=new Float32Array(r);else if("int32"===n)o=new Int32Array(r);else{if("bool"!==n)throw new Error("Unknown data type "+n);o=new Uint8Array(r)}for(var a=0;a<r;a++)o[a]=e();return Lt.makeTensor(o,t,n)}}),Nr=An({randomNormal_:function(t,e,n,r,o){if(void 0===e&&(e=0),void 0===n&&(n=1),null!=r&&"bool"===r)throw new Error("Unsupported data type "+r);for(var a=new lr(e,n,r,!1,o),i=dr(t,r),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}}),Fr=An({randomGamma_:function(t,e,n,r,o){if(void 0===n&&(n=1),void 0===r&&(r="float32"),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error("Unsupported data type "+r);for(var a=new hr(e,n,r,o),i=dr(t,r),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}}),_r=An({randomUniform_:function(t,e,n,r,o){void 0===e&&(e=0),void 0===n&&(n=1),void 0===r&&(r="float32");for(var a=dr(t,r),i=new fr(e,n,null,o),s=0;s<a.values.length;s++)a.values[s]=i.nextValue();return a.toTensor()}}),Or=An({reshape_:function(t,e){var n=mn(t,"x","reshape",null);e=_(e,n.size),C(n.size===k(e),(function(){return"new shape and old shape must have the same number of elements."}));var r={shape:e};return Lt.runKernelFunc((function(t){return t.reshape(n,e)}),{x:n},(function(t){return{x:function(){return t.reshape(n.shape)}}}),"Reshape",r)}}),Mr=An({spaceToBatchND_:function(t,e,n){var r=mn(t,"x","spaceToBatchND");return C(r.rank>=1+e.length,(function(){return"input rank "+r.rank+" should be > than [blockShape] "+e.length})),C(n.length===e.length,(function(){return"paddings.shape[0] "+n.length+" must be equal to [blockShape] "+e.length})),C(r.shape.reduce((function(t,r,o){return o>0&&o<=e.length?t&&(r+n[o-1][0]+n[o-1][1])%e[o-1]==0:t}),!0),(function(){return"input spatial dimensions "+r.shape.slice(1)+" with paddings "+n.toString()+" must be divisible by blockShapes "+e.toString()})),Lt.runKernelFunc((function(t){return t.spaceToBatchND(r,e,n)}),{$x:r},(function(t){return{$x:function(){return t.batchToSpaceND(e,n)}}}))}}),Br=An({squeeze_:function(t,e){var n=mn(t,"x","squeeze");return Or(n,M(n.shape,e).newShape)}}),Pr=An({stack_:function(t,e){void 0===e&&(e=0);var n=gn(t,"tensors","stack");if(C(n.length>=1,(function(){return"Pass at least one tensor to tf.stack"})),1===n.length)return n[0].expandDims(e);var r=n[0].rank,o=n[0].shape,a=n[0].dtype;C(e<=r,(function(){return"Axis must be <= rank of the tensor"})),n.forEach((function(t){E(o,t.shape,"All tensors passed to stack must have matching shapes")})),n.forEach((function(t){C(a===t.dtype,(function(){return"All tensors passed to stack must have matching dtypes"}))}));var i=n.map((function(t){return t.expandDims(e)}));return Yn(i,e)}}),Lr=An({tile_:function(t,e){var n=mn(t,"x","tile",null);C(n.rank===e.length,(function(){return"Error in transpose: rank of input "+n.rank+" must match length of reps "+e+"."}));var r=[n],o={reps:e};return Lt.runKernelFunc((function(t,r){var o=t.tile(n,e);return r([n]),o}),{x:n},(function(t,n){var r=n[0];return{x:function(){var n=Xn(r);if(1===r.rank)for(var o=0;o<e[0];++o)n=n.add(t.slice([o*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(o=0;o<e[0];++o)for(var a=0;a<e[1];++a)n=n.add(t.slice([o*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(o=0;o<e[0];++o)for(a=0;a<e[1];++a)for(var i=0;i<e[2];++i)n=n.add(t.slice([o*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+r.rank+" tensors yet.");for(o=0;o<e[0];++o)for(a=0;a<e[1];++a)for(i=0;i<e[2];++i)for(var s=0;s<e[3];++s)n=n.add(t.slice([o*r.shape[0],a*r.shape[1],i*r.shape[2],s*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return n}}}),"Tile",o,r)}}),Wr=An({truncatedNormal_:function(t,e,n,r,o){if(void 0===e&&(e=0),void 0===n&&(n=1),null!=r&&"bool"===r)throw new Error("Unsupported data type "+r);for(var a=new lr(e,n,r,!0,o),i=dr(t,r),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}}),Ur=An({unstack_:function(t,e){void 0===e&&(e=0),e=e||0;var n=mn(t,"x","unstack");C(e>=-n.shape.length&&e<n.shape.length,(function(){return"Axis = "+e+" is not in [-"+n.shape.length+", "+n.shape.length+")"})),e<0&&(e+=n.shape.length);var r={axis:e};return Lt.runKernelFunc((function(t){return t.unstack(n,e)}),{x:n},(function(t){return{x:function(){return Pr(t,e)}}}),"Unpack",r)}}),Vr=function(t,e){return n(this,void 0,void 0,(function(){var n,o,a,i,s,u,c,l,h,f;return r(this,(function(r){switch(r.label){case 0:return n=mn(t,"x","setdiff1d"),o=mn(e,"y","setdiff1d"),C(n.dtype===o.dtype,(function(){return"x and y should have the same dtype, but got x ("+n.dtype+") and y ("+o.dtype+")."})),C(1===n.rank,(function(){return"x should be 1D tensor, but got x ("+n.shape+")."})),C(1===o.rank,(function(){return"y should be 1D tensor, but got y ("+o.shape+")."})),[4,n.data()];case 1:return a=r.sent(),[4,o.data()];case 2:for(i=r.sent(),s=new Set(i),u=0,h=0;h<a.length;h++)s.has(a[h])||u++;for(c=new gt([u],n.dtype),l=new gt([u],"int32"),h=0,f=0;h<a.length;h++)s.has(a[h])||(c.values[f]=a[h],l.values[f]=h,f++);return[2,[c.toTensor(),l.toTensor()]]}}))}))};function zr(t,e,n,r){void 0===r&&(r=!0);var o=[];if(r)(o=o.concat(e.slice(0))).push(t[0]/n),o=o.concat(t.slice(1));else{o=o.concat(t[0]);for(var a=e.length,i=0;i<a;++i)o=o.concat([t[i+1]/e[i],e[i]]);o=o.concat(t.slice(a+1))}return o}function Gr(t,e,n){void 0===n&&(n=!0);var r=[];if(n){r.push(e);for(var o=e+1;o<t;++o)o<=2*e?(r.push(o),r.push(o-(e+1))):r.push(o)}else{var a=[],i=[];for(o=1;o<t;++o)o>=2*e+1||o%2==1?i.push(o):a.push(o);r.push.apply(r,a),r.push(0),r.push.apply(r,i)}return r}function Hr(t,e,n,r){void 0===r&&(r=!0);var o=[];r?o.push(t[0]/n):o.push(t[0]*n);for(var a=1;a<t.length;++a)a<=e.length?r?o.push(e[a-1]*t[a]):o.push(t[a]/e[a-1]):o.push(t[a]);return o}function qr(t,e){for(var n=[0],r=0;r<e;++r)n.push(t[r][0]);return n}function Kr(t,e,n){for(var r=t.slice(0,1),o=0;o<n;++o)r.push(t[o+1]-e[o][0]-e[o][1]);return r}function jr(t,e){if(t.rank<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+t.rank+".");if(e.rank<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+e.rank+".");if("int32"!==e.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+e.dtype+".");if(e.shape[e.rank-1]>t.rank)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+e.shape[e.rank-1]+" vs. "+t.rank);if(0===t.size)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+t.shape+".");for(var n=e.shape,r=n[n.length-1],o=1,a=0;a<n.length-1;++a)o*=n[a];var i=t.shape,s=n.slice();s.pop();var u=1;for(a=r;a<t.rank;++a)u*=i[a],s.push(i[a]);var c=$(t.shape).map((function(t){return t/u})).concat([1]).slice(0,r);return[s,o,u,c]}var Xr=Object.freeze({prepareAndValidate:jr}),Yr=30;function $r(t){return t<=Yr?t:Y(t,Math.floor(Math.sqrt(t)))}function Qr(t,e,n){var r=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,a="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+n.shape+", indices.shape: "+e.shape+", shape: "+t+", sliceDim: "+r+", and batchDim: "+o+".";if(n.rank<o)throw new Error(a+" update.rank < "+o+". ");if(t.length<r+(n.rank-o))throw new Error(a+" Output shape length < "+(r+(n.rank-o)));if(n.rank!==o+t.length-r)throw new Error(a+" update.rank != "+(o+t.length-r));for(var i=0;i<o;++i)if(n.shape[i]!==e.shape[i])throw new Error(a+" updates.shape["+i+"] ("+n.shape[i]+") != indices.shape["+i+"] ("+e.shape[i]+").");for(i=0;i<n.rank-o;++i)if(n.shape[i+o]!==t[i+r])throw new Error(a+" updates.shape["+(i+o)+"] ("+n.shape[i+o]+") != shape["+(i+o)+"] ("+t[i+o]+")")}function Jr(t,e,n){if(e.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+e.rank+".");if(t.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+t.rank+".");if("int32"!==e.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: "+e.dtype);if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+n);if(0===n.length){if(0===e.size)throw new Error("Indices specified for empty output. indices shape: "+e.shape);if(0===t.size)throw new Error("Updates specified for empty output. updates shape: "+t.shape)}Qr(n,e,t)}function Zr(t,e,n){for(var r=e.shape.length,o=r>1?e.shape[r-1]:1,a=n.length,i=1,s=o;s<a;++s)i*=n[s];var u=o<1?1:o;return{sliceRank:o,numUpdates:k(e.shape)/u,sliceSize:i,strides:$(n.slice(0,o)).concat([1]),outputSize:k(n)}}var to=Object.freeze({validateUpdateShape:Qr,validateInput:Jr,calculateShapes:Zr});function eo(t,e,n){C(t.rank===e.length,(function(){return"Error in slice"+t.rank+"D: Length of begin "+e+" must match the rank of the array ("+t.rank+")."})),C(t.rank===n.length,(function(){return"Error in slice"+t.rank+"D: Length of size "+n+" must match the rank of the array ("+t.rank+")."}));for(var r=function(r){C(e[r]+n[r]<=t.shape[r],(function(){return"Error in slice"+t.rank+"D: begin["+r+"] + size["+r+"] ("+(e[r]+n[r])+") would overflow input.shape["+r+"] ("+t.shape[r]+")"}))},o=0;o<t.rank;++o)r(o)}function no(t){for(var e=[],n=0;t>0;)1&t&&e.push(n),t/=2,n++;return e}function ro(t,e,n){for(var r=[],o=0;o<t.length;o++)r[o]=Math.ceil((e[o]-t[o])/n[o]);return r}function oo(t,e,n,r,o){var a=e[o],i=n[o]||1;(t&1<<o||null==a)&&(a=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);var s=r[o];return a<0&&(a+=s),a=x(0,a,s-1)}function ao(t,e,n,r,o){var a=e[o],i=n[o]||1;(t&1<<o||null==a)&&(a=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);var s=r[o];return a<0&&(a+=s),a=i>0?x(0,a,s):x(-1,a,s-1)}function io(t,e,n){for(var r=n.length,o=0;o<n.length;o++)if(n[o]>1){r=o;break}for(o=r+1;o<n.length;o++)if(e[o]>0||n[o]!==t[o])return!1;return!0}function so(t,e){for(var n=t.length>0?t[t.length-1]:1,r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}var uo=Object.freeze({assertParamsValid:eo,maskToAxes:no,computeOutShape:ro,startForAxis:oo,stopForAxis:ao,isSliceContinous:io,computeFlatOffset:so});function co(t){return C(X(t),(function(){return"The f passed in grad(f) must be a function"})),function(e,n){var r=mn(e,"x","tf.grad",null),o=null!=n?mn(n,"dy","tf.grad"):null;return Lt.tidy((function(){var e=Lt.gradients((function(){return t(r)}),[r],o),n=e.value,a=e.grads;return null!=o&&E(n.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),mo(a),a[0]}))}}function lo(t){return C(X(t),(function(){return"The f passed in grads(f) must be a function"})),function(e,n){C(Array.isArray(e),(function(){return"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"}));var r=gn(e,"args","tf.grads",null),o=null!=n?mn(n,"dy","tf.grads"):null;return Lt.tidy((function(){var e=Lt.gradients((function(){return t.apply(void 0,r)}),r,o),n=e.value,a=e.grads;return null!=o&&E(n.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),mo(a),a}))}}function ho(t){return C(X(t),(function(){return"The f passed in valueAndGrad(f) must be a function"})),function(e,n){C(e instanceof wt,(function(){return"The x passed in valueAndGrad(f)(x) must be a tensor"})),C(null==n||n instanceof wt,(function(){return"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"}));var r=Lt.gradients((function(){return t(e)}),[e],n),o=r.grads,a=r.value;return mo(o),{grad:o[0],value:a}}}function fo(t){return C(X(t),(function(){return"The f passed in valueAndGrads(f) must be a function"})),function(e,n){C(Array.isArray(e)&&e.every((function(t){return t instanceof wt})),(function(){return"The args passed in valueAndGrads(f)(args) must be array of tensors"})),C(null==n||n instanceof wt,(function(){return"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"}));var r=Lt.gradients((function(){return t.apply(void 0,e)}),e,n);return null!=n&&E(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),mo(r.grads),r}}function po(t,e){C(X(t),(function(){return"The f passed in variableGrads(f) must be a function"})),C(null==e||Array.isArray(e)&&e.every((function(t){return t instanceof St})),(function(){return"The varList passed in variableGrads(f, varList) must be an array of variables"}));var n=null!=e;if(!n)for(var r in e=[],Lt.registeredVariables)e.push(Lt.registeredVariables[r]);var o=n?e.filter((function(t){return!t.trainable})):null,a=e.length;C((e=e.filter((function(t){return t.trainable}))).length>0,(function(){return"variableGrads() expects at least one of the input variables to be trainable, but none of the "+a+" variables is trainable."}));var i=Lt.gradients(t,e,null,!0),s=i.value,u=i.grads;C(u.some((function(t){return null!=t})),(function(){return"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."})),C(0===s.rank,(function(){return"The f passed in variableGrads(f) must return a scalar, but it returned a rank-"+s.rank+" tensor"}));var c={};return e.forEach((function(t,e){null!=u[e]&&(c[t.name]=u[e])})),null!=o&&o.forEach((function(t){return c[t.name]=null})),{value:s,grads:c}}function vo(t){return Lt.customGrad(t)}function mo(t){if(t.filter((function(t){return null==t})).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}var go=An({softmax_:function(t,e){void 0===e&&(e=-1);var n=mn(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+n.rank+" and dim was "+e);return Lt.runKernelFunc((function(t,r){var o=t.softmax(n,e);return r([o]),o}),{logits:n},(function(t,n){var r=n[0],o=t.mul(r);return{logits:function(){return o.sub(o.sum([e],!0).mul(r))}}}),"Softmax",{dim:e},[],[!0])}}),yo=An({logSoftmax_:function(t,e){void 0===e&&(e=-1);var n=mn(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank "+n.rank+" and axis was "+e);return vo((function(t,n){var r=t.max(e,!0),o=t.sub(r),a=o.toFloat().sub(o.exp().sum(e,!0).log());n([a]);return{value:a,gradFunc:function(t,n){var r=n[0].exp();return t.sub(t.sum(e,!0).mul(r))}}}))(n)}}),xo=function(){function t(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}return t.prototype.get=function(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)},t.prototype.set=function(t,e){this.dataIdsCount++,this.data.set(t,e)},t.prototype.has=function(t){return this.data.has(t)},t.prototype.delete=function(t){return this.dataIdsCount--,this.data.delete(t)},t.prototype.numDataIds=function(){return this.dataIdsCount},t}(),bo=function(){function t(){}return t.prototype.time=function(t){return wo("time")},t.prototype.read=function(t){return wo("read")},t.prototype.readSync=function(t){return wo("readSync")},t.prototype.numDataIds=function(){return wo("numDataIds")},t.prototype.disposeData=function(t){return wo("disposeData")},t.prototype.write=function(t,e,n){return wo("write")},t.prototype.move=function(t,e,n,r){return wo("move")},t.prototype.memory=function(){return wo("memory")},t.prototype.floatPrecision=function(){return wo("floatPrecision")},t.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},t.prototype.batchMatMul=function(t,e,n,r){return wo("batchMatMul")},t.prototype.fusedBatchMatMul=function(t){t.a,t.b,t.transposeA,t.transposeB,t.bias,t.activation,t.preluActivationWeights;return wo("fusedBatchMatMul")},t.prototype.slice=function(t,e,n){return wo("slice")},t.prototype.stridedSlice=function(t,e,n,r){return wo("stridedSlice")},t.prototype.unstack=function(t,e){return wo("unstack")},t.prototype.reverse=function(t,e){return wo("reverse")},t.prototype.concat=function(t,e){return wo("concat")},t.prototype.neg=function(t){return wo("neg")},t.prototype.add=function(t,e){return wo("add")},t.prototype.addN=function(t){return wo("addN")},t.prototype.subtract=function(t,e){return wo("subtract")},t.prototype.multiply=function(t,e){return wo("multiply")},t.prototype.realDivide=function(t,e){return wo("realDivide")},t.prototype.floorDiv=function(t,e){return wo("floorDiv")},t.prototype.sum=function(t,e){return wo("sum")},t.prototype.prod=function(t,e){return wo("prod")},t.prototype.unsortedSegmentSum=function(t,e,n){return wo("unsortedSegmentSum")},t.prototype.argMin=function(t,e){return wo("argMin")},t.prototype.argMax=function(t,e){return wo("argMax")},t.prototype.equal=function(t,e){return wo("equal")},t.prototype.notEqual=function(t,e){return wo("notEqual")},t.prototype.less=function(t,e){return wo("less")},t.prototype.lessEqual=function(t,e){return wo("lessEqual")},t.prototype.greater=function(t,e){return wo("greater")},t.prototype.greaterEqual=function(t,e){return wo("greaterEqual")},t.prototype.logicalNot=function(t){return wo("logicalNot")},t.prototype.logicalAnd=function(t,e){return wo("logicalAnd")},t.prototype.logicalOr=function(t,e){return wo("logicalOr")},t.prototype.where=function(t){return wo("where")},t.prototype.select=function(t,e,n){return wo("select")},t.prototype.topk=function(t,e,n){return wo("topk")},t.prototype.min=function(t,e){return wo("min")},t.prototype.minimum=function(t,e){return wo("minimum")},t.prototype.mod=function(t,e){return wo("mod")},t.prototype.max=function(t,e){return wo("max")},t.prototype.maximum=function(t,e){return wo("maximum")},t.prototype.all=function(t,e){return wo("all")},t.prototype.any=function(t,e){return wo("any")},t.prototype.squaredDifference=function(t,e){return wo("squaredDifference")},t.prototype.ceil=function(t){return wo("ceil")},t.prototype.floor=function(t){return wo("floor")},t.prototype.round=function(t){return wo("round")},t.prototype.sign=function(t){return wo("sign")},t.prototype.isNaN=function(t){return wo("isNaN")},t.prototype.isInf=function(t){return wo("isInf")},t.prototype.isFinite=function(t){return wo("isFinite")},t.prototype.pow=function(t,e){return wo("pow")},t.prototype.exp=function(t){return wo("exp")},t.prototype.expm1=function(t){return wo("expm1")},t.prototype.softmax=function(t,e){return wo("softmax")},t.prototype.log=function(t){return wo("log")},t.prototype.log1p=function(t){return wo("log1p")},t.prototype.sqrt=function(t){return wo("sqrt")},t.prototype.rsqrt=function(t){return wo("rsqrt")},t.prototype.square=function(t){return wo("square")},t.prototype.reciprocal=function(t){return wo("reciprocal")},t.prototype.relu=function(t){return wo("relu")},t.prototype.relu6=function(t){return wo("relu6")},t.prototype.prelu=function(t,e){return wo("prelu")},t.prototype.elu=function(t){return wo("elu")},t.prototype.eluDer=function(t,e){return wo("eluDer")},t.prototype.selu=function(t){return wo("selu")},t.prototype.int=function(t){return wo("int")},t.prototype.clip=function(t,e,n){return wo("clip")},t.prototype.abs=function(t){return wo("abs")},t.prototype.complexAbs=function(t){return wo("complexAbs")},t.prototype.sigmoid=function(t){return wo("sigmoid")},t.prototype.softplus=function(t){return wo("softplus")},t.prototype.sin=function(t){return wo("sin")},t.prototype.cos=function(t){return wo("cos")},t.prototype.tan=function(t){return wo("tan")},t.prototype.asin=function(t){return wo("asin")},t.prototype.acos=function(t){return wo("acos")},t.prototype.atan=function(t){return wo("atan")},t.prototype.atan2=function(t,e){return wo("atan2")},t.prototype.sinh=function(t){return wo("sinh")},t.prototype.cosh=function(t){return wo("cosh")},t.prototype.tanh=function(t){return wo("tanh")},t.prototype.asinh=function(t){return wo("asinh")},t.prototype.acosh=function(t){return wo("acosh")},t.prototype.atanh=function(t){return wo("atanh")},t.prototype.erf=function(t){return wo("erf")},t.prototype.step=function(t,e){return wo("step")},t.prototype.fusedConv2d=function(t){t.input,t.filter,t.convInfo,t.bias,t.activation,t.preluActivationWeights;return wo("fusedConv2d")},t.prototype.conv2d=function(t,e,n){return wo("conv2d")},t.prototype.conv2dDerInput=function(t,e,n){return wo("conv2dDerInput")},t.prototype.conv2dDerFilter=function(t,e,n){return wo("conv2dDerFilter")},t.prototype.fusedDepthwiseConv2D=function(t){t.input,t.filter,t.convInfo,t.bias,t.activation,t.preluActivationWeights;return wo("fusedDepthwiseConv2D")},t.prototype.depthwiseConv2D=function(t,e,n){return wo("depthwiseConv2D")},t.prototype.depthwiseConv2DDerInput=function(t,e,n){return wo("depthwiseConv2DDerInput")},t.prototype.depthwiseConv2DDerFilter=function(t,e,n){return wo("depthwiseConv2DDerFilter")},t.prototype.conv3d=function(t,e,n){return wo("conv3d")},t.prototype.conv3dDerInput=function(t,e,n){return wo("conv3dDerInput")},t.prototype.conv3dDerFilter=function(t,e,n){return wo("conv3dDerFilter")},t.prototype.maxPool=function(t,e){return wo("maxPool")},t.prototype.maxPoolBackprop=function(t,e,n,r){return wo("maxPoolBackprop")},t.prototype.avgPool=function(t,e){return wo("avgPool")},t.prototype.avgPoolBackprop=function(t,e,n){return wo("avgPoolBackprop")},t.prototype.avgPool3d=function(t,e){return wo("avgPool3d")},t.prototype.avgPool3dBackprop=function(t,e,n){return wo("avgPool3dBackprop")},t.prototype.maxPool3d=function(t,e){return wo("maxPool3d")},t.prototype.maxPool3dBackprop=function(t,e,n,r){return wo("maxPool3dBackprop")},t.prototype.reshape=function(t,e){return wo("reshape")},t.prototype.cast=function(t,e){return wo("cast")},t.prototype.tile=function(t,e){return wo("tile")},t.prototype.pad=function(t,e,n){return wo("pad")},t.prototype.transpose=function(t,e){return wo("transpose")},t.prototype.gather=function(t,e,n){return wo("gather")},t.prototype.gatherND=function(t,e){return wo("gatherND")},t.prototype.scatterND=function(t,e,n){return wo("scatterND")},t.prototype.batchToSpaceND=function(t,e,n){return wo("batchToSpaceND")},t.prototype.spaceToBatchND=function(t,e,n){return wo("spaceToBatchND")},t.prototype.resizeBilinear=function(t,e,n,r){return wo("resizeBilinear")},t.prototype.resizeBilinearBackprop=function(t,e,n){return wo("resizeBilinearBackprop")},t.prototype.resizeNearestNeighbor=function(t,e,n,r){return wo("resizeNearestNeighbor")},t.prototype.resizeNearestNeighborBackprop=function(t,e,n){return wo("resizeNearestNeighborBackprop")},t.prototype.batchNormalization=function(t,e,n,r,o,a){return wo("batchNormalization")},t.prototype.localResponseNormalization4D=function(t,e,n,r,o){return wo("localResponseNormalization4D")},t.prototype.LRNGrad=function(t,e,n,r,o,a,i){return wo("LRNGrad")},t.prototype.multinomial=function(t,e,n,r){return wo("multinomial")},t.prototype.oneHot=function(t,e,n,r){return wo("oneHot")},t.prototype.cumsum=function(t,e,n,r){return wo("cumsum")},t.prototype.nonMaxSuppression=function(t,e,n,r,o){return wo("nonMaxSuppression")},t.prototype.fft=function(t){return wo("fft")},t.prototype.ifft=function(t){return wo("ifft")},t.prototype.complex=function(t,e){return wo("complex")},t.prototype.real=function(t){return wo("real")},t.prototype.imag=function(t){return wo("imag")},t.prototype.cropAndResize=function(t,e,n,r,o,a){return wo("cropAndResize")},t.prototype.depthToSpace=function(t,e,n){return wo("depthToSpace")},t.prototype.split=function(t,e,n){return wo("split")},t.prototype.sparseToDense=function(t,e,n,r){return wo("sparseToDense")},t.prototype.diag=function(t){return wo("diag")},t.prototype.fill=function(t,e,n){return wo("fill")},t.prototype.onesLike=function(t){return wo("onesLike")},t.prototype.zerosLike=function(t){return wo("zerosLike")},t.prototype.linspace=function(t,e,n){return wo("linspace")},t.prototype.dispose=function(){return wo("dispose")},t}();function wo(t){throw new Error("'"+t+"' not yet implemented or not found in the registry. Did you forget to import the kernel?")}function Co(t,e){for(var n=t.length,r=[],o=0;o<n;o++){var a=n-1-o,i=t[a]||1;(e[e.length-1-o]||1)>1&&1===i&&r.unshift(a)}return r}function Eo(t,e){for(var n=[],r=0;r<e.length;r++){var o=t[t.length-r-1],a=e.length-r-1,i=e[a];(null==o||1===o&&i>1)&&n.unshift(a)}return n}function Ro(t,e){for(var n=[],r=Math.max(t.length,e.length),o=0;o<r;o++){var a=t[t.length-o-1];null==a&&(a=1);var i=e[e.length-o-1];if(null==i&&(i=1),1===a)n.unshift(i);else if(1===i)n.unshift(a);else{if(a!==i)throw Error("Operands could not be broadcast together with shapes "+t+" and "+e+".");n.unshift(a)}}return n}function Io(t,e,n,r,o,a,i){void 0===i&&(i="channelsLast");var s,u=To(e),c=u[0],l=u[1];if("channelsLast"===i)s=[c,l,t[3],t[3]];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);s=[c,l,t[1],t[1]]}return So(t,s,n,r,o,a,!1,i)}function ko(t,e,n,r,o,a,i){void 0===i&&(i="NDHWC");var s,u,c=No(e),l=c[0],h=c[1],f=c[2];if("NDHWC"===i)u="channelsLast",s=[l,h,f,t[4],t[4]];else{if("NCDHW"!==i)throw new Error("Unknown dataFormat "+i);u="channelsFirst",s=[l,h,f,t[1],t[1]]}return Ao(t,s,n,r,o,!1,u,a)}function So(t,e,n,r,o,a,i,s){void 0===i&&(i=!1),void 0===s&&(s="channelsLast");var u=[-1,-1,-1,-1],c=u[0],l=u[1],h=u[2],f=u[3];if("channelsLast"===s)c=t[0],l=t[1],h=t[2],f=t[3];else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat "+s);c=t[0],f=t[1],l=t[2],h=t[3]}var d,p=e[0],v=e[1],m=e[3],g=To(n),y=g[0],x=g[1],b=To(r),w=b[0],E=b[1],R=Fo(p,w),I=Fo(v,E),k=function(t,e,n,r,o,a,i,s){var u,c,l;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};var h=function(t,e,n,r,o){null==r&&(r=Do(t,e,n));var a=t[0],i=t[1],s=_o((a-e+2*r)/n+1,o);C(A(s),(function(){return"The output # of rows ("+s+") must be an integer. Change the stride and/or zero pad parameters"}));var u=_o((i-e+2*r)/n+1,o);return C(A(u),(function(){return"The output # of columns ("+u+") must be an integer. Change the stride and/or zero pad parameters"})),[s,u]}([e,n],a,r,t,s);c=h[0],l=h[1]}else if("same"===t){c=Math.ceil(e/r),l=Math.ceil(n/o);var f=Math.max(0,(c-1)*r+a-e),d=Math.max(0,(l-1)*o+i-n),p=Math.floor(f/2),v=f-p,m=Math.floor(d/2);u={top:p,bottom:v,left:m,right:d-m,type:"SAME"}}else{if("valid"!==t)throw Error("Unknown padding parameter: "+t);u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-a+1)/r),l=Math.ceil((n-i+1)/o)}return{padInfo:u,outHeight:c,outWidth:l}}(o,l,h,y,x,R,I,a),S=k.padInfo,D=k.outHeight,T=k.outWidth,N=i?m*f:m;return"channelsFirst"===s?d=[c,N,D,T]:"channelsLast"===s&&(d=[c,D,T,N]),{batchSize:c,dataFormat:s,inHeight:l,inWidth:h,inChannels:f,outHeight:D,outWidth:T,outChannels:N,padInfo:S,strideHeight:y,strideWidth:x,filterHeight:p,filterWidth:v,effectiveFilterHeight:R,effectiveFilterWidth:I,dilationHeight:w,dilationWidth:E,inShape:t,outShape:d,filterShape:e}}function Ao(t,e,n,r,o,a,i,s){void 0===a&&(a=!1),void 0===i&&(i="channelsLast");var u=[-1,-1,-1,-1,-1],c=u[0],l=u[1],h=u[2],f=u[3],d=u[4];if("channelsLast"===i)c=t[0],l=t[1],h=t[2],f=t[3],d=t[4];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);c=t[0],d=t[1],l=t[2],h=t[3],f=t[4]}var p,v=e[0],m=e[1],g=e[2],y=e[4],x=No(n),b=x[0],w=x[1],E=x[2],R=No(r),I=R[0],k=R[1],S=R[2],D=Fo(v,I),T=Fo(m,k),N=Fo(g,S),F=function(t,e,n,r,o,a,i,s,u,c,l){var h,f,d,p;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};var v=function(t,e,n,r,o,a){null==o&&(o=Do(t,e,r));var i=t[0],s=t[1],u=t[2],c=_o((i-e+2*o)/r+1,a);C(A(c),(function(){return"The output # of depths ("+c+") must be an integer. Change the stride and/or zero pad parameters"}));var l=_o((s-e+2*o)/r+1,a);C(A(l),(function(){return"The output # of rows ("+l+") must be an integer. Change the stride and/or zero pad parameters"}));var h=_o((u-e+2*o)/r+1,a);return C(A(h),(function(){return"The output # of columns ("+h+") must be an integer. Change the stride and/or zero pad parameters"})),[c,l,h,n]}([e,n,r,1],s,1,o,t,l);f=v[0],d=v[1],p=v[2]}else if("same"===t){f=Math.ceil(e/o),d=Math.ceil(n/a),p=Math.ceil(r/i);var m=(f-1)*o+s-e,g=(d-1)*a+u-n,y=(p-1)*i+c-r,x=Math.floor(m/2),b=m-x,w=Math.floor(g/2),E=g-w,R=Math.floor(y/2);h={top:w,bottom:E,left:R,right:y-R,front:x,back:b,type:"SAME"}}else{if("valid"!==t)throw Error("Unknown padding parameter: "+t);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},f=Math.ceil((e-s+1)/o),d=Math.ceil((n-u+1)/a),p=Math.ceil((r-c+1)/i)}return{padInfo:h,outDepth:f,outHeight:d,outWidth:p}}(o,l,h,f,b,w,E,D,T,N,s),_=F.padInfo,O=F.outDepth,M=F.outHeight,B=F.outWidth,P=a?y*d:y;return"channelsFirst"===i?p=[c,P,O,M,B]:"channelsLast"===i&&(p=[c,O,M,B,P]),{batchSize:c,dataFormat:i,inDepth:l,inHeight:h,inWidth:f,inChannels:d,outDepth:O,outHeight:M,outWidth:B,outChannels:P,padInfo:_,strideDepth:b,strideHeight:w,strideWidth:E,filterDepth:v,filterHeight:m,filterWidth:g,effectiveFilterDepth:D,effectiveFilterHeight:T,effectiveFilterWidth:N,dilationDepth:I,dilationHeight:k,dilationWidth:S,inShape:t,outShape:p,filterShape:e}}function Do(t,e,n,r){void 0===r&&(r=1);var o=Fo(e,r);return Math.floor((t[0]*(n-1)-n+o)/2)}function To(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function No(t){return"number"==typeof t?[t,t,t]:t}function Fo(t,e){return e<=1?t:t+(t-1)*(e-1)}function _o(t,e){if(!e)return t;switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error("Unknown roundingMode "+e)}}function Oo(t){var e=To(t),n=e[0],r=e[1],o=e[2];return 1===n&&1===r&&1===o}function Mo(t,e){return Oo(t)||Oo(e)}function Bo(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error("Unknown dataFormat "+t)}function Po(t,e,n){if("complex64"===e){if("complex64"===t.dtype)return t.clone();var r=Gn(t.shape),o=t.toFloat(),a=n.complex(o,r);return r.dispose(),o.dispose(),a}if(!U(t.dtype,e))return Lt.makeTensorFromDataId(t.dataId,t.shape,e);if("complex64"===t.dtype){var i=n.real(t);a=i.cast(e);return i.dispose(),a}if("int32"===e)return n.int(t);if("bool"===e){var s=On(0,t.dtype);a=n.notEqual(t,s);return s.dispose(),a}throw new Error("Error in Cast: failed to cast "+t.dtype+" to "+e)}function Lo(t,e){return Lt.makeTensorFromDataId(t.dataId,e,t.dtype)}function Wo(t,e,n){var r=(e-t)/(n-1),o=tt(n,"float32");o[0]=t;for(var a=1;a<o.length;a++)o[a]=o[a-1]+r;return Mn(o,"float32")}var Uo=Object.freeze({castTensor:Po,reshapeTensor:Lo,linspaceImpl:Wo,upcastType:Dt,axesAreInnerMostDims:yn,combineLocations:xn,computeOutAndReduceShapes:bn,expandShapeToKeepDim:wn,assertAxesAreInnerMostDims:Cn,getAxesPermutation:En,getUndoAxesPermutation:Rn,getInnerMostAxes:In,getBroadcastDims:Co,getReductionAxes:Eo,assertAndGetBroadcastShape:Ro,assertParamsConsistent:kn,computeOutShape:Sn,computePool2DInfo:Io,computePool3DInfo:ko,computeConv2DInfo:So,computeConv3DInfo:Ao,computeDefaultPad:Do,tupleValuesAreOne:Oo,eitherStridesOrDilationsAreOne:Mo,convertConv2DDataFormat:Bo,PARALLELIZE_THRESHOLD:Yr,computeOptimalWindowSize:$r});function Vo(t,e){if(t.length!==e.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+t.length+", imag: "+e.length+".");for(var n=new Float32Array(2*t.length),r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function zo(t,e){return{real:t[2*e],imag:t[2*e+1]}}function Go(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function Ho(t,e,n){var r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}function qo(t,e,n){var r=function(t,e,n){return function(t,e,n){var r=0,o=t.length,a=0,i=!1;for(;r<o;){var s=n(e,t[a=r+(o-r>>>1)]);s>0?r=a+1:(o=a,i=!s)}return i?r:-r-1}(t,e,n||Ko)}(t,e,n),o=r<0?-(r+1):r;t.splice(o,0,e)}function Ko(t,e){return t>e?1:t<e?-1:0}function jo(t,e,n,r,o){return Yo(t,e,n,r,o,0).selectedIndices}function Xo(t,e,n,r,o,a){var i=Yo(t,e,n,r,o,a,!0);return i.numValidOutputs.dispose(),{selectedIndices:i.selectedIndices,selectedScores:i.selectedScores}}function Yo(t,e,n,r,o,a,i,s){void 0===i&&(i=!1),void 0===s&&(s=!1);for(var u=Array.from(e).map((function(t,e){return{score:t,boxIndex:e,suppressBeginIndex:0}})).filter((function(t){return t.score>o})).sort(Jo),c=a>0?-.5/a:0,l=[],h=[];l.length<n&&u.length>0;){var f=u.pop(),d=f.score,p=f.boxIndex,v=f.suppressBeginIndex;if(d<o)break;for(var m=!1,g=l.length-1;g>=v;--g){var y=$o(t,p,l[g]);if(y>=r){m=!0;break}if(f.score=f.score*Qo(r,c,y),f.score<=o)break}f.suppressBeginIndex=l.length,m||(f.score===d?(l.push(p),h.push(f.score)):f.score>o&&qo(u,f,Jo))}var x=l.length;return s&&(l.fill(0,x),h.fill(0,x)),{selectedIndices:Mn(l,"int32"),selectedScores:Mn(h,"float32"),numValidOutputs:On(x,"int32")}}function $o(t,e,n){var r=t.subarray(4*e,4*e+4),o=t.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),s=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),c=Math.min(o[0],o[2]),l=Math.min(o[1],o[3]),h=Math.max(o[0],o[2]),f=Math.max(o[1],o[3]),d=(s-a)*(u-i),p=(h-c)*(f-l);if(d<=0||p<=0)return 0;var v=Math.max(a,c),m=Math.max(i,l),g=Math.min(s,h),y=Math.min(u,f),x=Math.max(g-v,0)*Math.max(y-m,0);return x/(d+p-x)}function Qo(t,e,n){var r=Math.exp(e*n*n);return n<=t?r:0}function Jo(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}function Zo(t,e,n){var r=new Array(t.rank).fill(0),o=t.shape.slice();return e.map((function(e){o[n]=e;var a=t.slice(r,o);return r[n]+=e,a}))}function ta(t,e){for(var n=new Array(t.rank),r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];var o=dr(n,t.dtype);for(r=0;r<o.values.length;++r){for(var a=o.indexToLoc(r),i=new Array(t.rank),s=0;s<i.length;s++)i[s]=a[s]%t.shape[s];var u=t.locToIndex(i);o.values[r]=t.values[u]}return o.toTensor()}function ea(t,e,n,r,o){for(var a=e[e.length-1],i=[t.length/a,a],s=i[0],u=i[1],c=B(n,s*r),l=B("int32",s*r),h=0;h<s;h++){for(var f=h*u,d=t.subarray(f,f+u),p=[],v=0;v<d.length;v++)p.push({value:d[v],index:v});p.sort((function(t,e){return e.value-t.value}));var m=h*r,g=c.subarray(m,m+r),y=l.subarray(m,m+r);for(v=0;v<r;v++)g[v]=p[v].value,y[v]=p[v].index}var x=e.slice();return x[x.length-1]=r,[Fn(c,x,n),Fn(l,x,"int32")]}function na(t,e){for(var n=[],r=0;r<e.length;r++)e[r]&&n.push(r);var o=dr(t,"int32"),a=dr([n.length,t.length],"int32");for(r=0;r<n.length;r++){var i=o.indexToLoc(n[r]),s=r*t.length;a.values.set(i,s)}return a.toTensor()}var ra=function(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((function(t,e){return"T"+e}));var n=[];this.variableNames.forEach((function(t){n.push("float v"+t+" = get"+t+"AtOutCoords();")}));var r=this.variableNames.map((function(t){return"v"+t})).join(" + ");this.userCode="\n      void main() {\n        "+n.join("\n        ")+"\n\n        float result = "+r+";\n        setOutput(result);\n      }\n    "},oa=function(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((function(t,e){return"T"+e}));var n=[];this.variableNames.forEach((function(t){n.push("vec4 v"+t+" = get"+t+"AtOutCoords();")}));var r=this.variableNames.map((function(t){return"v"+t})).join(" + ");this.userCode="\n      void main() {\n        "+n.join("\n        ")+"\n\n        vec4 result = "+r+";\n        setOutput(result);\n      }\n    "},aa=function(t,e,n){this.variableNames=["A"];var r=t.windowSize,o=t.batchSize,a=t.inSize,i=Math.ceil(a/r);n||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];var s="max"===e?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+r+";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < "+r+"; i++) {\n          int inIdx = "+u+";\n          float candidate = getA(batch, inIdx);\n          if (candidate "+s+" bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "};function ia(t,e){return["x","y","z","w","u","v"].slice(0,e).map((function(e){return t+"."+e}))}function sa(t,e){return 1===e?[t]:ia(t,e)}function ua(){var t,e,n,r,o,a,s,u,c,l;return 2===i().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",o="texture",a="outputColor",s="out vec4 outputColor;",u="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",c="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",o="texture2D",a="gl_FragColor",s="",u="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",c="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:o,output:a,defineOutput:s,defineSpecialNaN:u,defineSpecialInf:c,defineRound:l}}function ca(t,e,n){void 0===n&&(n="index");var r=$(e);return r.map((function(e,o){return"int "+t[o]+" = "+n+" / "+e+"; "+(o===r.length-1?"int "+t[o+1]+" = "+n+" - "+t[o]+" * "+e:"index -= "+t[o]+" * "+e)+";"})).join("")}function la(t){var e=$(t).map((function(t){return t.toString()}));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * "+e[0]+" + coords.y * "+e[1]+" + coords.z;\n  }\n"}var ha="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";function fa(t,e,n,r){var o=[];t.forEach((function(t){var e=k(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?o.push("uniform float "+t.name+(e>1?"["+e+"]":"")+";"):(o.push("uniform sampler2D "+t.name+";"),o.push("uniform int offset"+t.name+";"))}));var a,i,s=o.join("\n"),u=t.map((function(t){return function(t,e,n){void 0===n&&(n=!1);var r="";r+=n?pa(t):da(t);var o=t.shapeInfo.logicalShape,a=e.logicalShape;o.length<=a.length&&(r+=n?function(t,e){var n,r=t.name,o=r.charAt(0).toUpperCase()+r.slice(1),a="get"+o+"AtOutCoords",i=t.shapeInfo.logicalShape.length,s=e.logicalShape.length,u=Co(t.shapeInfo.logicalShape,e.logicalShape),c=wa(s),l=s-i,h=["x","y","z","w","u","v"];n=0===i?"":s<2&&u.length>=1?"coords = 0;":u.map((function(t){return"coords."+h[t+l]+" = 0;"})).join("\n");var f="";f=s<2&&i>0?"coords":t.shapeInfo.logicalShape.map((function(t,e){return"coords."+h[e+l]})).join(", ");var d="return outputValue;",p=1===k(t.shapeInfo.logicalShape),v=1===k(e.logicalShape);if(1!==i||p||v){if(p&&!v)d=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(u.length){var m=i-2,g=i-1;u.indexOf(m)>-1&&u.indexOf(g)>-1?d="return vec4(outputValue.x);":u.indexOf(m)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(g)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}}else d="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 "+a+"() {\n      "+c+" coords = getOutputCoords();\n      "+n+"\n      vec4 outputValue = get"+o+"("+f+");\n      "+d+"\n    }\n  "}(t,e):function(t,e){var n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),o="get"+r+"AtOutCoords",a=e.texShape,i=t.shapeInfo.texShape,s=t.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!t.shapeInfo.isUniform&&s===u&&null==t.shapeInfo.flatOffset&&S(i,a))return"\n      float "+o+"() {\n        return sampleTexture("+n+", resultUV);\n      }\n    ";var c,l=wa(u),h=Co(t.shapeInfo.logicalShape,e.logicalShape),f=u-s,d=["x","y","z","w","u","v"];c=0===s?"":u<2&&h.length>=1?"coords = 0;":h.map((function(t){return"coords."+d[t+f]+" = 0;"})).join("\n");var p="";p=u<2&&s>0?"coords":t.shapeInfo.logicalShape.map((function(t,e){return"coords."+d[e+f]})).join(", ");return"\n    float "+o+"() {\n      "+l+" coords = getOutputCoords();\n      "+c+"\n      return get"+r+"("+p+");\n    }\n  "}(t,e));return r}(t,e,r)})).join("\n"),c=e.texShape,l=ua(),h=function(t){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return "+t.texture2D+"(textureSampler, uv).r;\n    }\n  "}(l),f=function(t){return t.version+"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    "+t.varyingFs+" vec2 resultUV;\n    "+t.defineOutput+"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    "+t.defineSpecialNaN+"\n    "+t.defineSpecialInf+"\n    "+t.defineRound+"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    "+va+"\n    "+ma+"\n    "+ga+"\n  "}(l);return e.isPacked?(a=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(1===n[0])return"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * "+n[1]+".0);\n      }\n    ";if(1===n[1])return"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * "+n[0]+".0);\n      }\n    ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      return 2 * (resTexRC.x * "+n[1]+" + resTexRC.y);\n    }\n  "}(0,e);case 2:return function(t,e){var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(S(t,e))return"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2("+n[0]+", "+n[1]+"));\n      }\n    ";var r=Math.ceil(t[1]/2);return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      int r = 2 * (index / "+r+");\n      int c = imod(index, "+r+") * 2;\n\n      return ivec2(r, c);\n    }\n  "}(t,e);case 3:return n=t,r=e,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],a=Math.ceil(n[2]/2),i=a*Math.ceil(n[1]/2),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+o[0]+", "+o[1]+"));\n      int index = resTexRC.x * "+o[1]+" + resTexRC.y;\n\n      int b = index / "+i+";\n      index -= b * "+i+";\n\n      int r = 2 * (index / "+a+");\n      int c = imod(index, "+a+") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";default:return function(t,e){for(var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),o=r*Math.ceil(t[t.length-2]/2),a=o,i="",s="b, r, c",u=2;u<t.length-1;u++)a*=t[t.length-u-1],i="\n      int b"+u+" = index / "+a+";\n      index -= b"+u+" * "+a+";\n    "+i,s="b"+u+", "+s;return"\n    ivec"+t.length+" getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n\n      "+i+"\n\n      int b = index / "+o+";\n      index -= b * "+o+";\n\n      int r = 2 * (index / "+r+");\n      int c = imod(index, "+r+") * 2;\n\n      return ivec"+t.length+"("+s+");\n    }\n  "}(t,e)}var n,r,o,a,i}(e.logicalShape,c),i=function(t){return"\n    void setOutput(vec4 val) {\n      "+t.output+" = val;\n    }\n  "}(l)):(a=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){if(1===e[0])return"\n      int getOutputCoords() {\n        return int(resultUV.x * "+e[1]+".0);\n      }\n    ";if(1===e[1])return"\n      int getOutputCoords() {\n        return int(resultUV.y * "+e[0]+".0);\n      }\n    ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      return resTexRC.x * "+e[1]+" + resTexRC.y;\n    }\n  "}(0,e);case 2:return function(t,e){if(S(t,e))return"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+e[0]+", "+e[1]+"));\n      }\n    ";if(1===t[1])return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+e[0]+", "+e[1]+"));\n        int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";if(1===t[0])return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+e[0]+", "+e[1]+"));\n        int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n      int r = index / "+t[1]+";\n      int c = index - r * "+t[1]+";\n      return ivec2(r, c);\n    }\n  "}(t,e);case 3:return n=e,r=ca(["r","c","d"],t),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      "+r+"\n      return ivec3(r, c, d);\n    }\n  ";case 4:return function(t,e){var n=ca(["r","c","d","d2"],t);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n      "+n+"\n      return ivec4(r, c, d, d2);\n    }\n  "}(t,e);case 5:return function(t,e){var n=ca(["r","c","d","d2","d3"],t);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2("+e[0]+",\n                             "+e[1]+"));\n\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n\n      "+n+"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "}(t,e);case 6:return function(t,e){var n=ca(["r","c","d","d2","d3","d4"],t);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n\n      "+n+"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "}(t,e);default:throw new Error(t.length+"-D output sampling is not yet supported")}var n,r}(e.logicalShape,c),i=function(t){return"\n    void setOutput(float val) {\n      "+t.output+" = vec4(val, 0, 0, 0);\n    }\n  "}(l)),r&&(f+=ya),[f,h,i,s,a,u,n].join("\n")}function da(t){var e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return"float "+n+"() {return "+e+";}";var r=t.shapeInfo.texShape,o=r[0],a=r[1];if(1===o&&1===a)return"\n      float "+n+"() {\n        return sampleTexture("+e+", halfCR);\n      }\n    ";var i=t.shapeInfo.texShape,s=i[0],u=i[1],c=xa(e);return"\n    float "+n+"() {\n      vec2 uv = uvFromFlat("+s+", "+u+", "+c+");\n      return sampleTexture("+e+", uv);\n    }\n  "}(t);case 1:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return"\n      float "+n+"(int index) {\n        "+ba(t)+"\n      }\n    ";var r=t.shapeInfo.texShape,o=r[0],a=r[1];if(1===a&&1===o)return"\n      float "+n+"(int index) {\n        return sampleTexture("+e+", halfCR);\n      }\n    ";var i=xa(e);if(1===a)return"\n      float "+n+"(int index) {\n        vec2 uv = vec2(0.5, (float(index + "+i+") + 0.5) / "+o+".0);\n        return sampleTexture("+e+", uv);\n      }\n    ";if(1===o)return"\n      float "+n+"(int index) {\n        vec2 uv = vec2((float(index + "+i+") + 0.5) / "+a+".0, 0.5);\n        return sampleTexture("+e+", uv);\n      }\n    ";return"\n    float "+n+"(int index) {\n      vec2 uv = uvFromFlat("+o+", "+a+", index + "+i+");\n      return sampleTexture("+e+", uv);\n    }\n  "}(t);case 2:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape;if(null!=o&&S(e,o)){var a=o[0],i=o[1];return"\n    float "+r+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+i+".0, "+a+".0);\n      return sampleTexture("+n+", uv);\n    }\n  "}var s=M(e),u=s.newShape,c=s.keptDims,l=u;if(l.length<e.length){var h=Ca(t,l);return"\n      "+da(h)+"\n      float "+r+"(int row, int col) {\n        return "+r+"("+Ea(["row","col"],c)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2("+e[1]+", 1)));\n        "+ba(t)+"\n      }\n    ";var f=o[0],d=o[1],p=xa(n);if(1===d)return"\n    float "+r+"(int row, int col) {\n      float index = dot(vec3(row, col, "+p+"), vec3("+e[1]+", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / "+f+".0);\n      return sampleTexture("+n+", uv);\n    }\n  ";if(1===f)return"\n    float "+r+"(int row, int col) {\n      float index = dot(vec3(row, col, "+p+"), vec3("+e[1]+", 1, 1));\n      vec2 uv = vec2((index + 0.5) / "+d+".0, 0.5);\n      return sampleTexture("+n+", uv);\n    }\n  ";return"\n  float "+r+"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * "+e[1]+" + col + "+p+";\n    vec2 uv = uvFromFlat("+f+", "+d+", index);\n    return sampleTexture("+n+", uv);\n  }\n"}(t);case 3:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[1]*e[2],a=e[2],i=M(e),s=i.newShape,u=i.keptDims,c=s;if(c.length<e.length){var l=Ca(t,c);return"\n        "+da(l)+"\n        float "+r+"(int row, int col, int depth) {\n          return "+r+"("+Ea(["row","col","depth"],u)+");\n        }\n      "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3("+o+", "+a+", 1)));\n        "+ba(t)+"\n      }\n    ";var h=t.shapeInfo.texShape,f=h[0],d=h[1],p=t.shapeInfo.flatOffset;if(d===o&&null==p)return"\n        float "+r+"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2("+a+", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2("+d+".0, "+f+".0);\n          return sampleTexture("+n+", uv);\n        }\n      ";if(d===a&&null==p)return"\n    float "+r+"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2("+e[1]+", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+d+".0, "+f+".0);\n      return sampleTexture("+n+", uv);\n    }\n  ";var v=xa(n);return"\n      float "+r+"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * "+o+" + col * "+a+" + depth + "+v+";\n        vec2 uv = uvFromFlat("+f+", "+d+", index);\n        return sampleTexture("+n+", uv);\n      }\n  "}(t);case 4:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[3],a=e[2]*o,i=e[1]*a,s=M(e),u=s.newShape,c=s.keptDims;if(u.length<e.length){var l=Ca(t,u);return"\n      "+da(l)+"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        return "+r+"("+Ea(["row","col","depth","depth2"],c)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4("+i+", "+a+", "+o+", 1)));\n        "+ba(t)+"\n      }\n    ";var h=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,d=f[0],p=f[1];if(p===i&&null==h)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3("+a+", "+o+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+p+".0, "+d+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(p===o&&null==h)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3("+e[1]*e[2]+", "+e[2]+", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+p+".0, "+d+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var v=xa(n);return"\n    float "+r+"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+i+" + col * "+a+" +\n          depth * "+o+" + depth2;\n      vec2 uv = uvFromFlat("+d+", "+p+", index + "+v+");\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);case 5:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[4],a=e[3]*o,i=e[2]*a,s=e[1]*i,u=M(e),c=u.newShape,l=u.keptDims;if(c.length<e.length){var h=Ca(t,c);return"\n      "+da(h)+"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        return "+r+"("+Ea(["row","col","depth","depth2","depth3"],l)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+s+", "+i+", "+a+", "+o+")) +\n          depth3;\n        "+ba(t)+"\n      }\n    ";var f=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],v=d[1];if(v===s&&null==f)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4("+i+", "+a+", "+o+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+v+".0, "+p+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(v===o&&null==f)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+e[1]*e[2]*e[3]+",\n               "+e[2]*e[3]+", "+e[3]+", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+v+".0, "+p+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var m=xa(n);return"\n    float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+s+" + col * "+i+" + depth * "+a+" +\n          depth2 * "+o+" + depth3 + "+m+";\n      vec2 uv = uvFromFlat("+p+", "+v+", index);\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);case 6:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=M(e),a=o.newShape,i=o.keptDims;if(a.length<e.length){var s=Ca(t,a);return"\n      "+da(s)+"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return "+r+"("+Ea(["row","col","depth","depth2","depth3","depth4"],i)+");\n      }\n    "}var u=e[5],c=e[4]*u,l=e[3]*c,h=e[2]*l,f=e[1]*h;if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4("+f+", "+h+", "+l+", "+c+")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2("+u+", 1)));\n        "+ba(t)+"\n      }\n    ";var d=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,v=p[0],m=p[1];if(m===f&&null==d)return"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4("+h+", "+l+", "+c+", "+u+")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+m+".0, "+v+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(m===u&&null==d)return"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4("+e[1]*e[2]*e[3]*e[4]+",\n               "+e[2]*e[3]*e[4]+",\n               "+e[3]*e[4]+",\n               "+e[4]+")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+m+".0, "+v+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var g=xa(n);return"\n    float "+r+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+f+" + col * "+h+" + depth * "+l+" +\n          depth2 * "+c+" + depth3 * "+u+" + depth4 + "+g+";\n      vec2 uv = uvFromFlat("+v+", "+m+", index);\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);default:throw new Error(e.length+"-D input sampling is not yet supported")}}function pa(t){var e,n,r;switch(t.shapeInfo.logicalShape.length){case 0:return e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=ua(),"\n    vec4 "+n+"() {\n      return "+r.texture2D+"("+e+", halfCR);\n    }\n  ";case 1:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],a=ua();return"\n    vec4 "+n+"(int index) {\n      vec2 uv = packedUVfrom1D(\n        "+o[0]+", "+o[1]+", index);\n      return "+a.texture2D+"("+e+", uv);\n    }\n  "}(t);case 2:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape,a=o[0],i=o[1],s=ua();if(null!=o&&S(e,o))return"\n      vec4 "+r+"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2("+i+".0, "+a+".0);\n\n        return "+s.texture2D+"("+n+", uv);\n      }\n    ";var u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=Math.ceil(e[1]/2);return"\n    vec4 "+r+"(int row, int col) {\n      vec2 uv = packedUVfrom2D("+c+", "+u[0]+", "+u[1]+", row, col);\n      return "+s.texture2D+"("+n+", uv);\n    }\n  "}(t);case 3:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){var i=e.slice(1),s=Ca(t,i);return"\n        "+pa(s)+"\n        vec4 "+r+"(int b, int row, int col) {\n          return "+r+"("+Ea(["b","row","col"],[1,2])+");\n        }\n      "}var u=a[0],c=a[1],l=Math.ceil(e[2]/2),h=l*Math.ceil(e[1]/2),f=ua();return"\n    vec4 "+r+"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        "+u+", "+c+", "+h+", "+l+", b, row, col);\n      return "+f.texture2D+"("+n+", uv);\n    }\n  "}(t);default:return function(t){for(var e=t.shapeInfo.logicalShape,n=e.length,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],s=i[0],u=i[1],c=Math.ceil(e[n-1]/2),l=c*Math.ceil(e[n-2]/2),h="int b, int row, int col",f="b * "+l+" + (row / 2) * "+c+" + (col / 2)",d=2;d<n-1;d++)h="int b"+d+", "+h,l*=e[n-d-1],f="b"+d+" * "+l+" + "+f;var p=ua();return"\n    vec4 "+o+"("+h+") {\n      int index = "+f+";\n      int texR = index / "+u+";\n      int texC = index - texR * "+u+";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+u+", "+s+");\n      return "+p.texture2D+"("+r+", uv);\n    }\n  "}(t)}}var va="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ma="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ga="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ya="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function xa(t){return"offset"+t}function ba(t){var e=t.name,n=k(t.shapeInfo.logicalShape);return n<2?"return "+e+";":"\n    for (int i = 0; i < "+n+"; i++) {\n      if (i == index) {\n        return "+e+"[i];\n      }\n    }\n  "}function wa(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error("GPU for rank "+t+" is not yet supported")}function Ca(t,e){var n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function Ea(t,e){return e.map((function(e){return t[e]})).join(", ")}var Ra=function(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,C(t.length>2,(function(){return"Packed arg"+(n.charAt(0).toUpperCase()+n.slice(1))+" supports only inputs with rank above 2."}));var o=t[t.length-1],a=Math.ceil(o/e);this.outputShape=t.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");var i,s,u=this.outputShape,c=u.length,l=wa(c),h=sa("coords",c);if(1===a){var f=wa(s=c+1);i="\n        "+f+" sourceLocR = "+f+"("+h.join()+", 0);\n        ++"+h[c-1]+";\n        "+f+" sourceLocG = "+f+"("+h.join()+", 0);\n        ++"+h[c-2]+";\n        "+f+" sourceLocA = "+f+"("+h.join()+", 0);\n        --"+h[c-1]+";\n        "+f+" sourceLocB = "+f+"("+h.join()+", 0);\n        --"+h[c-2]+";"}else s=c,i="\n        "+l+" sourceLocR = coords;\n        ++"+h[c-1]+";\n        "+l+" sourceLocG = coords;\n        ++"+h[c-2]+";\n        "+l+" sourceLocA = coords;\n        --"+h[c-1]+";\n        "+l+" sourceLocB = coords;\n        --"+h[c-2]+";";var d=["x","y","z","w","u","v"].slice(0,s),p="."+d[s-1],v=d.map((function(t){return"int "+t})),m=sa("sourceLocR",s-1).concat("inIdx.r"),g=sa("sourceLocG",s-1).concat("inIdx.g"),y=sa("sourceLocB",s-1).concat("inIdx.b"),x=sa("sourceLocA",s-1).concat("inIdx.a"),b="max"===n?"greaterThan":"lessThan",w=r?"":"\n          inIdx = round(vec4(getBestIndicesAChannel("+m.join()+"),\n                             getBestIndicesAChannel("+g.join()+"),\n                             getBestIndicesAChannel("+y.join()+"),\n                             getBestIndicesAChannel("+x.join()+")));",E="vec4(\n            getAChannel("+m.join()+"),\n            hasNextCol ? getAChannel("+g.join()+") : 0.,\n            hasNextRow ? getAChannel("+y.join()+") : 0.,\n            hasNextRow && hasNextCol ? getAChannel("+x.join()+") : 0.)",R=r?"":"\n      float getBestIndicesAChannel("+v.join()+") {\n        return getChannel(getBestIndicesA("+d.join()+"),\n                                          vec2("+d.slice(-2).join()+"));\n      }";this.userCode="\n      float getAChannel("+v.join()+") {\n        return getChannel(getA("+d.join()+"),\n                               vec2("+d.slice(-2).join()+"));\n      }\n      "+R+"\n      void main() {\n        "+l+" coords = getOutputCoords();\n        bool hasNextCol = "+h[c-1]+" < "+(u[c-1]-1)+";\n        bool hasNextRow = "+h[c-2]+" < "+(u[c-2]-1)+";\n        "+i+"\n        ivec4 srcIdx = ivec4(sourceLocR"+p+", sourceLocG"+p+",\n          sourceLocB"+p+", sourceLocA"+p+") * "+e+";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = "+E+";\n\n        for (int i = 0; i < "+e+"; i++) {\n          inIdx = srcIdx;\n          "+w+"\n          vec4 candidate = "+E+";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4("+b+"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "},Ia=function(t){this.variableNames=["dy"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,s=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=s-1-t.padInfo.top,l=u-1-t.padInfo.left,h=1/(e*n);this.userCode="\n      const ivec2 pads = ivec2("+c+", "+l+");\n      const float avgMultiplier = float("+h+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+s+";\n            wR += "+a+") {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+u+";\n            wC+= "+i+") {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},ka=function(t){this.variableNames=["dy"],this.outputShape=t.inShape;var e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth,d=l-1-t.padInfo.front,p=h-1-t.padInfo.top,v=f-1-t.padInfo.left,m=1/(e*n*r);this.userCode="\n      const ivec3 pads = ivec3("+d+", "+p+", "+v+");\n      const float avgMultiplier = float("+m+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+l+";\n            wD += "+s+") {\n          float dyD = float(dyDCorner + wD) / "+o+".0;\n\n          if (dyD < 0.0 || dyD >= "+t.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+h+";\n              wR += "+u+") {\n            float dyR = float(dyRCorner + wR) / "+a+".0;\n\n            if (dyR < 0.0 || dyR >= "+t.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+f+";\n                wC += "+c+") {\n              float dyC = float(dyCCorner + wC) / "+i+".0;\n\n              if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Sa=function(t,e,n,r,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Ro(t,e),Ro(t,n);var i="0.0";null!=r&&(Ro(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");var s="1.0";null!=o&&(Ro(t,o),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+i+";\n        float scale = "+s+";\n        float inv = scale * inversesqrt(variance + float("+a+"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "},Aa=function(t,e,n,r,o,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ro(t,e),Ro(t,n);var i="vec4(0.0)";null!=r&&(Ro(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");var s="vec4(1.0)";null!=o&&(Ro(t,o),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        vec4 offset = "+i+";\n        vec4 scale = "+s+";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4("+a+"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "},Da="return areal * breal - aimag * bimag;",Ta="return areal * bimag + aimag * breal;",Na=function(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ro(e,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+t+"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "},Fa="return a + b;",_a="return a - b;",Oa="return a * b;",Ma="return (a < 0.) ? b * a : a;",Ba=function(t,e,n){this.variableNames=["A","B"],this.outputShape=Ro(e,n),this.userCode="\n      float binaryOperation(float a, float b) {\n        "+t+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "},Pa="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",La=function(t,e,n,r){void 0===r&&(r=!1),this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ro(e,n);var o=this.outputShape.length,a="";if(r)if(0===o||1===k(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a="\n          "+wa(o)+" coords = getOutputCoords();\n        ",1===o)a+="\n            result.y = (coords + 1) >= "+this.outputShape[0]+" ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";else{var i=sa("coords",o);a+="\n            bool nextRowOutOfBounds =\n              ("+i[o-2]+" + 1) >= "+this.outputShape[o-2]+";\n            bool nextColOutOfBounds =\n              ("+i[o-1]+" + 1) >= "+this.outputShape[o-1]+";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        "+t+"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        "+a+"\n\n        setOutput(result);\n      }\n    "},Wa=function(){function t(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t,e){var n=this;return function(r,o){null==n.minLoc&&(n.minLoc=r.getUniformLocationNoThrow(o,"minVal"),n.maxLoc=r.getUniformLocationNoThrow(o,"maxVal")),r.gl.uniform1f(n.minLoc,t),r.gl.uniform1f(n.maxLoc,e)}},t}(),Ua=function(){function t(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t,e){var n=this;return function(r,o){null==n.minLoc&&(n.minLoc=r.getUniformLocationNoThrow(o,"minVal"),n.maxLoc=r.getUniformLocationNoThrow(o,"maxVal")),r.gl.uniform1f(n.minLoc,t),r.gl.uniform1f(n.maxLoc,e)}},t}(),Va=function(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "},za=function(t){this.outputShape=[],this.outputShape=Sn(t,1),this.variableNames=t.map((function(t,e){return"T"+e}));var e=new Array(t.length-1);e[0]=t[0][1];for(var n=1;n<e.length;n++)e[n]=e[n-1]+t[n][1];var r=["if (yC < "+e[0]+") setOutput(getT0(yR, yC));"];for(n=1;n<e.length;n++){var o=e[n-1];r.push("else if (yC < "+e[n]+") setOutput(getT"+n+"(yR, yC-"+o+"));")}var a=e.length,i=e[e.length-1];r.push("else setOutput(getT"+a+"(yR, yC-"+i+"));"),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        "+r.join("\n        ")+"\n      }\n    "},Ga=function(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Sn(t,e);var n=this.outputShape,r=n.length,o=wa(r),a=sa("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((function(t,e){return"T"+e}));var s=new Array(t.length-1);s[0]=t[0][e];for(var u=1;u<s.length;u++)s[u]=s[u-1]+t[u][e];var c=i[e],l=i.slice(-2),h=i.join(),f="if ("+c+" < "+s[0]+") {\n        return getChannel(\n            getT0("+h+"), vec2("+l.join()+"));\n        }";for(u=1;u<s.length;u++){var d=s[u-1];f+="\n        if ("+c+" < "+s[u]+"  && "+c+" >= "+s[u-1]+") {\n          return getChannel(\n            getT"+u+"("+Ha(i,c,d)+"),\n            vec2("+Ha(l,c,d)+"));\n        }"}var p=s.length,v=s[s.length-1];f+="\n        return getChannel(\n          getT"+p+"("+Ha(i,c,v)+"),\n          vec2("+Ha(l,c,v)+"));",this.userCode="\n      float getValue("+i.map((function(t){return"int "+t}))+") {\n        "+f+"\n      }\n\n      void main() {\n        "+o+" coords = getOutputCoords();\n        vec4 result = vec4(getValue("+a+"), 0., 0., 0.);\n\n        "+a[r-1]+" = "+a[r-1]+" + 1;\n        if ("+a[r-1]+" < "+n[r-1]+") {\n          result.g = getValue("+a+");\n        }\n\n        "+a[r-2]+" = "+a[r-2]+" + 1;\n        if ("+a[r-2]+" < "+n[r-2]+") {\n          result.a = getValue("+a+");\n        }\n\n        "+a[r-1]+" = "+a[r-1]+" - 1;\n        if ("+a[r-2]+" < "+n[r-2]+" &&\n            "+a[r-1]+" < "+n[r-1]+") {\n          result.b = getValue("+a+");\n        }\n        setOutput(result);\n      }\n    "};function Ha(t,e,n){var r=t.indexOf(e);return t.map((function(t,e){return e===r?t+" - "+n:t})).join()}var qa=function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left,a="channelsLast"===t.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n            int xR = wR + yR * "+e+" - "+r+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n              int xC = wC + yC * "+n+" - "+o+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              if ("+a+") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Ka=function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a="channelsLast"===t.dataFormat,i=e-1-t.padInfo.top,s=n-1-t.padInfo.left,u=a?1:2,c=a?2:3,l=a?3:1;this.userCode="\n      const ivec2 pads = ivec2("+i+", "+s+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords["+l+"];\n\n        ivec2 dyCorner = ivec2(coords["+u+"], coords["+c+"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+e+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+e+" - 1 - wR;\n\n          for (int wC = 0; wC < "+n+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+n+" - 1 - wC;\n\n            for (int d2 = 0; d2 < "+t.outChannels+"; d2++) {\n\n              if ("+a+") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},ja=function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,o=t.padInfo.front,a=t.padInfo.top,i=t.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yF = 0; yF < "+t.outDepth+"; yF++) {\n            int xF = wF + yF * "+e+" - "+o+";\n\n            if (xF < 0 || xF >= "+t.inDepth+") {\n              continue;\n            }\n\n            for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n              int xR = wR + yR * "+n+" - "+a+";\n\n              if (xR < 0 || xR >= "+t.inHeight+") {\n                continue;\n              }\n\n              for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n                int xC = wC + yC * "+r+" - "+i+";\n\n                if (xC < 0 || xC >= "+t.inWidth+") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Xa=function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=e-1-t.padInfo.front,u=n-1-t.padInfo.top,c=r-1-t.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+s+", "+u+", "+c+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+e+"; wF++) {\n          float dyF = float(dyFCorner + wF) / "+o+".0;\n\n          if (dyF < 0.0 || dyF >= "+t.outDepth+".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = "+e+" - 1 - wF;\n\n          for (int wR = 0; wR < "+n+"; wR++) {\n            float dyR = float(dyRCorner + wR) / "+a+".0;\n\n            if (dyR < 0.0 || dyR >= "+t.outHeight+".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = "+n+" - 1 - wR;\n\n            for (int wC = 0; wC < "+r+"; wC++) {\n              float dyC = float(dyCCorner + wC) / "+i+".0;\n\n              if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = "+r+" - 1 - wC;\n\n              for (int d2 = 0; d2 < "+t.outChannels+"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Ya=function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * "+a+" + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n            int xR = wR + yR * "+e+" - "+r+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n              int xC = wC + yC * "+n+" - "+o+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},$a=function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=e-1-t.padInfo.top,i=n-1-t.padInfo.left,s=t.outChannels/t.inChannels;this.userCode="\n      const ivec2 pads = ivec2("+a+", "+i+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < "+e+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+e+" - 1 - wR;\n\n          for (int wC = 0; wC < "+n+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+n+" - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < "+s+"; dm++) {\n              int d2 = d1 * "+s+" + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Qa=function(t,e,n,r){void 0===e&&(e=!1),void 0===n&&(n=null),void 0===r&&(r=!1),this.variableNames=["x","W"],this.outputShape=t.outShape;var o=t.padInfo.top,a=t.padInfo.left,i=t.strideHeight,s=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,l=t.filterHeight,h=t.filterWidth,f=4*Math.floor(t.inChannels/4),d=t.inChannels%4,p="channelsLast"===t.dataFormat,v=p?1:2,m=p?2:3,g=p?3:1,y="",x="";n&&(y=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          "+n+"\n        }":"\n          float activation(float x) {\n            "+n+"\n          }\n        ",x="result = activation(result);");var b=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+y+"\n\n      const ivec2 strides = ivec2("+i+", "+s+");\n      const ivec2 pads = ivec2("+o+", "+a+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords["+g+"];\n\n        ivec2 xRCCorner =\n            ivec2(coords["+v+"], coords["+m+"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+l+"; wR++) {\n          int xR = xRCorner + wR * "+u+";\n\n          if (xR < 0 || xR >= "+t.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+h+"; wC++) {\n            int xC = xCCorner + wC * "+c+";\n\n            if (xC < 0 || xC >= "+t.inWidth+") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < "+f+"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if ("+p+") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if ("+(1===d)+") {\n\n              if ("+p+") {\n                dotProd +=\n                    getX(batch, xR, xC, "+f+") *\n                    getW(wR, wC, "+f+", d2);\n              } else {\n                dotProd +=\n                    getX(batch, "+f+", xR, xC) *\n                    getW(wR, wC, "+f+", d2);\n              }\n\n            } else if ("+(2===d)+") {\n              vec2 wValues = vec2(\n                getW(wR, wC, "+f+", d2),\n                getW(wR, wC, "+f+" + 1, d2)\n              );\n\n              if ("+p+") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, "+f+"),\n                  getX(batch, xR, xC, "+f+" + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, "+f+", xR, xC),\n                  getX(batch, "+f+" + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if ("+(3===d)+") {\n              vec3 wValues = vec3(\n                getW(wR, wC, "+f+", d2),\n                getW(wR, wC, "+f+" + 1, d2),\n                getW(wR, wC, "+f+" + 2, d2)\n              );\n\n              if ("+p+") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, "+f+"),\n                  getX(batch, xR, xC, "+f+" + 1),\n                  getX(batch, xR, xC, "+f+" + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, "+f+", xR, xC),\n                  getX(batch, "+f+" + 1, xR, xC),\n                  getX(batch, "+f+" + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        "+b+"\n        "+x+"\n        setOutput(result);\n      }\n    "},Ja=function(t){this.variableNames=["x","W"],this.outputShape=t.outShape;var e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,l=t.filterDepth,h=t.filterHeight,f=t.filterWidth,d=4*Math.floor(t.inChannels/4),p=t.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3("+o+", "+a+", "+i+");\n      const ivec3 pads = ivec3("+e+", "+n+", "+r+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+l+"; wF++) {\n          int xF = xFCorner + wF * "+s+";\n\n          if (xF < 0 || xF >= "+t.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+h+"; wR++) {\n            int xR = xRCorner + wR * "+u+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+f+"; wC++) {\n              int xC = xCCorner + wC * "+c+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < "+d+"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if ("+(1===p)+") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, "+d+") *\n                  getW(wF, wR, wC, "+d+", d2);\n              } else if ("+(2===p)+") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, "+d+"),\n                  getX(batch, xF, xR, xC, "+d+" + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, "+d+", d2),\n                  getW(wF, wR, wC, "+d+" + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if ("+(3===p)+") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, "+d+"),\n                  getX(batch, xF, xR, xC, "+d+" + 1),\n                  getX(batch, xF, xR, xC, "+d+" + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, "+d+", d2),\n                  getW(wF, wR, wC, "+d+" + 1, d2),\n                  getW(wF, wR, wC, "+d+" + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Za=function(t,e,n,r){void 0===e&&(e=!1),void 0===n&&(n=null),void 0===r&&(r=!1),this.variableNames=["x","W"],this.outputShape=t.outShape;var o=t.inHeight,a=t.inWidth,i=t.padInfo.top,s=t.padInfo.left,u=t.strideHeight,c=t.strideWidth,l=t.dilationHeight,h=t.dilationWidth,f=t.filterHeight,d=t.filterWidth,p=t.outChannels/t.inChannels,v="",m="";n&&(v=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          "+n+"\n        }":"\n          float activation(float x) {\n            "+n+"\n          }\n        ",m="result = activation(result);");var g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+v+"\n\n      const ivec2 strides = ivec2("+u+", "+c+");\n      const ivec2 pads = ivec2("+i+", "+s+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / "+p+";\n        int q = d2 - d1 * "+p+";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < "+f+"; wR++) {\n          int xR = xRCorner + wR * "+l+";\n\n          if (xR < 0 || xR >= "+o+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+d+"; wC++) {\n            int xC = xCCorner + wC * "+h+";\n\n            if (xC < 0 || xC >= "+a+") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        "+g+"\n        "+m+"\n        setOutput(result);\n      }\n    "},ti=function(t,e,n,r){void 0===e&&(e=!1),void 0===n&&(n=null),void 0===r&&(r=!1),this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;for(var o=t.inHeight,a=t.inWidth,i=t.padInfo.top,s=t.padInfo.left,u=t.strideHeight,c=t.strideWidth,l=t.dilationHeight,h=t.dilationWidth,f=t.filterHeight,d=t.filterWidth,p=d,v="int xR; int xC; int xCOffset;",m=0;m<f;m++)for(var g=0;g<d;g++)v+="\n          vec4 xTexelR"+m+"C"+2*g+" = vec4(0.);\n          vec4 wR"+m+"C"+g+" = vec4(0.);\n          vec4 xR"+m+"C"+g+" = vec4(0.);";for(m=0;m<f;m++)for(var y=0;y<p;y++){if(v+="\n          xR = xRCorner + "+m*l+";\n          xC = xCCorner + "+(g=2*y)*h+";\n        ",1===c){if(g<d&&(v+=s%2==1?"\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < "+o+" && xCOffset >= 0 && xCOffset < "+a+") {\n                  xTexelR"+m+"C"+g+" = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= "+a+") {\n                    xTexelR"+m+"C"+g+".zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR"+m+"C"+g+" = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < "+o+" && xCOffset >= 0 && xCOffset < "+a+") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= "+a+") {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR"+m+"C"+g+" = vec4(previous.zw, xTexelR"+m+"C"+g+".xy);\n                } else {\n                  xR"+m+"C"+g+" = vec4(0, 0, xTexelR"+m+"C"+g+".xy);\n                }\n              ":"\n                if(xR >= 0 && xR < "+o+" && xC >= 0 && xC < "+a+") {\n                  xTexelR"+m+"C"+g+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+m+"C"+g+" = vec4(0.);\n                }\n\n                xR"+m+"C"+g+" = xTexelR"+m+"C"+g+";\n              ",g+1<d)){var x=s%2==0?b(h):h;h%2==0&&s%2==1||h%2!=0&&s%2!=1?(v+="\n                  xCOffset = xC + "+s%2+" + "+x+";\n\n                  if(xR >= 0 && xR < "+o+" &&\n                    xCOffset >= 0 && xCOffset < "+a+") {\n                    xTexelR"+m+"C"+(g+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n                ",h>1&&(v+="\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < "+o+" &&\n                      xCOffset >= 0 && xCOffset < "+a+") {\n                      xTexelR"+m+"C"+g+" = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR"+m+"C"+g+" = vec4(0.);\n                    }\n                  "),v+="\n                  xR"+m+"C"+(g+1)+" = vec4(\n                    xTexelR"+m+"C"+g+".zw, xTexelR"+m+"C"+(g+2)+".xy);\n                "):v+="\n                  xCOffset = xC + "+x+";\n\n                  if(xR >= 0 && xR < "+o+" &&\n                    xCOffset >= 0 && xCOffset < "+a+") {\n                    xTexelR"+m+"C"+(g+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR"+m+"C"+(g+1)+" = xTexelR"+m+"C"+(g+2)+";\n                "}}else g<d&&(v+="\n              if(xR >= 0 && xR < "+o+") {\n            ",s%2==1?(v+="\n                xCOffset = xC + 1 - "+c+";\n                if(xCOffset >= 0 && xCOffset < "+a+") {\n                  xTexelR"+m+"C"+g+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+m+"C"+g+" = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < "+a+") {\n                  xTexelR"+m+"C"+(g+2)+" = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR"+m+"C"+(g+2)+" = vec4(0.);\n                }\n\n                xR"+m+"C"+g+" = vec4(\n                  xTexelR"+m+"C"+g+".zw, xTexelR"+m+"C"+(g+2)+".zw);\n              ",g+1<d&&(v+="\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + "+c+";\n                  if(xCOffset >= 0 && xCOffset < "+a+") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR"+m+"C"+(g+1)+" = vec4(xTexelR"+m+"C"+(g+2)+".xy, final.xy);\n                ")):(v+="\n                if(xC >= 0 && xC < "+a+") {\n                  xTexelR"+m+"C"+g+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+m+"C"+g+" = vec4(0.);\n                }\n\n                xCOffset = xC + "+c+";\n                if(xCOffset >= 0 && xCOffset < "+a+") {\n                  xTexelR"+m+"C"+(g+2)+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+m+"C"+(g+2)+" = vec4(0.);\n                }\n\n                xR"+m+"C"+g+" = vec4(\n                  xTexelR"+m+"C"+g+".xy, xTexelR"+m+"C"+(g+2)+".xy);\n              ",g+1<d&&(v+="\n                  xR"+m+"C"+(g+1)+" = vec4(\n                    xTexelR"+m+"C"+g+".zw, xTexelR"+m+"C"+(g+2)+".zw);\n                ")),v+="}");g<d&&(v+="\n            vec4 wTexelR"+m+"C"+g+" = getW("+m+", "+g+", d1, q);\n            wR"+m+"C"+g+" = vec4(wTexelR"+m+"C"+g+".xz, wTexelR"+m+"C"+g+".xz);\n          ",g+1<d&&(v+="\n              vec4 wTexelR"+m+"C"+(g+1)+" = getW("+m+", "+(g+1)+", d1, q);\n              wR"+m+"C"+(g+1)+" =\n                vec4(wTexelR"+m+"C"+(g+1)+".xz, wTexelR"+m+"C"+(g+1)+".xz);"))}for(m=0;m<f;m++)for(g=0;g<d;g++)v+="dotProd += xR"+m+"C"+g+" * wR"+m+"C"+g+";";var w="",C="";n&&(w=r?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          "+n+"\n        }":"vec4 activation(vec4 x) {\n          "+n+"\n        }",C="result = activation(result);");var E=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+w+"\n\n      const ivec2 strides = ivec2("+u+", "+c+");\n      const ivec2 pads = ivec2("+i+", "+s+");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        "+v+"\n\n        vec4 result = dotProd;\n        "+E+"\n        "+C+"\n        setOutput(result);\n      }\n    "},ei=function(t,e,n,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var a=t[0],i=t[1],s=t[2],u=t[3],c=e[0],l=n[0],h=n[1];this.outputShape=[c,l,h,u];var f="bilinear"===r?1:0,d=[i-1+".0",s-1+".0"],p=d[0],v=d[1],m=l>1?[""+(i-1)/(l-1),"(y2-y1) * height_ratio","y1*"+p+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+p],g=m[0],y=m[1],x=m[2],b=h>1?[""+(s-1)/(h-1),"(x2-x1) * width_ratio","x1*"+v+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+v],w=b[0],C=b[1],E=b[2];this.userCode="\n      const float height_ratio = float("+g+");\n      const float width_ratio = float("+w+");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= "+a+") {\n          return;\n        }\n\n        float height_scale = "+y+";\n        float width_scale = "+C+";\n\n        float in_y = "+x+";\n        if( in_y < 0.0 || in_y > "+p+" ) {\n          setOutput(float("+o+"));\n          return;\n        }\n        float in_x = "+E+";\n        if( in_x < 0.0 || in_x > "+v+" ) {\n          setOutput(float("+o+"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if("+f+" == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "},ni=function(t,e,n){this.variableNames=["x"],this.outputShape=t;var r=t.length,o=t[t.length-1],a=n?"<":">";this.userCode="\n      int getIndex(int i) {\n        "+(n?"return "+o+" -i - 1;":"return i;")+"\n      }\n\n      void main() {\n        "+wa(r)+" coords = getOutputCoords();\n        int end = "+ri(r,"coords")+";\n        float val = 0.0;\n        for (int i = "+o+" - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx "+a+" end) {\n            continue;\n          }\n          if (idx == end && "+e+") {\n            continue;\n          }\n          "+ri(r,"coords")+" = idx;\n          val += getX("+function(t,e){if(1===t)return""+e;if(2===t)return e+".x, "+e+".y";if(3===t)return e+".x, "+e+".y, "+e+".z";if(4===t)return e+".x, "+e+".y, "+e+".z, "+e+".w";throw Error("Cumulative sum for rank "+t+" is not yet supported")}(r,"coords")+");\n        }\n        setOutput(val);\n      }\n    "};function ri(t,e){if(1===t)return""+e;if(2===t)return e+".y";if(3===t)return e+".z";if(4===t)return e+".w";throw Error("Cumulative sum for rank "+t+" is not yet supported")}var oi=function(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Vt.DENSE;var e=Yt(t),n=ua();this.outputShape=t,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+ca(["r","c","d"],t)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+e[0]+", "+e[1]+"));\n        int index = 4 * (resTexRC.x * "+e[1]+" + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        "+n.output+" = result;\n      }\n    "},ai=function(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Vt.DENSE;var e=Yt(t),n=ua();this.outputShape=t,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+ca(["r","c","d"],t)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+e[0]+", "+e[1]+"));\n        int index = 4 * (resTexRC.x * "+e[1]+" + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        "+n.output+" = result;\n      }\n    "},ii=function(){function t(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = "+this.getHeightCoordString()+";\n      int w = "+this.getWidthCoordString()+";\n      int d = "+this.getDepthCoordString()+";\n\n      int in_h = h / "+e+";\n      int offset_h = imod(h, "+e+");\n      int in_w = w / "+e+";\n      int offset_w = imod(w, "+e+");\n      int offset_d = (offset_h * "+e+" + offset_w) *\n        "+this.getOutputDepthSize()+";\n      int in_d = d + offset_d;\n\n      float result = "+this.getInputSamplingString()+";\n      setOutput(result);\n    }\n  "}return t.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},t.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},t.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},t.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]},t.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},t}(),si=function(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "},ui=function(t){this.variableNames=["A"],this.outTexUsage=zt.DOWNLOAD;var e=ua();this.outputShape=t,this.userCode="\n      "+ha+"\n\n      void main() {\n        float x = getAAtOutCoords();\n        "+e.output+" = encode_float(x);\n      }\n    "},ci=function(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=zt.DOWNLOAD;var e=ua();this.outputShape=t,this.userCode="\n      "+ha+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        "+e.output+" = encode_float(x);\n      }\n    "},li=function(t,e,n){void 0===n&&(n=!1),this.variableNames=["A"];var r=ua(),o=e[0],a=e[1];this.outputShape=t;var i="result";n&&(i="floor(result * 255. + 0.5)"),this.userCode="\n      "+la(t)+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / "+a+";\n        int c = imod(flatIndex, "+a+");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2("+a+".0, "+o+".0);\n        vec4 values = "+r.texture2D+"(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        "+r.output+" = vec4("+i+", 0., 0., 0.);\n      }\n    "},hi=function(t,e,n){void 0===n&&(n=!1),this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var r=ua(),o=e[0],a=e[1];this.outputShape=t;var i="",s="result";n&&(s="floor(result * 255. + 0.5)");for(var u=0;u<=1;u++)for(var c=0;c<=1;c++){var l=2*u+c;i+="\n          localCoords = coords;\n          if(localCoords[2] + "+c+" < "+t[2]+") {\n            localCoords[2] += "+c+";\n            if(localCoords[1] + "+u+" < "+t[1]+") {\n              localCoords[1] += "+u+";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / "+a+";\n              c = imod(flatIndex, "+a+");\n              uv = (vec2(c, r) + halfCR) / vec2("+a+".0, "+o+".0);\n              values = "+r.texture2D+"(A, uv);\n\n              if(offset == 0) {\n                result["+l+"] = values[0];\n              } else if(offset == 1) {\n                result["+l+"] = values[1];\n              } else if(offset == 2) {\n                result["+l+"] = values[2];\n              } else {\n                result["+l+"] = values[3];\n              }\n            }\n          }\n        "}this.userCode="\n      "+la(t)+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        "+i+"\n\n        "+r.output+" = "+s+";\n      }\n    "},fi="return real * expR - imag * expI;",di="return real * expI + imag * expR;",pi=function(t,e,n){this.variableNames=["real","imag"];var r=e[1];this.outputShape=e;var o=n?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,a=n?r+".0":"1.0";this.userCode="\n      const float exponentMultiplier = "+o+";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        "+t+"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float("+r+");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < "+r+"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / "+a+";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "},vi=function(){function t(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;return function(n,r){null==e.valueLoc&&(e.valueLoc=n.getUniformLocationNoThrow(r,"value")),n.gl.uniform1f(e.valueLoc,t)}},t}(),mi=function(t,e,n){this.variableNames=["A","indices"];var r=t.slice();r[n]=e,this.outputShape=r,this.rank=r.length;var o=wa(this.rank),a=function(t,e){var n=t.length;if(n>4)throw Error("Gather for rank "+n+" is not yet supported");if(1===n)return"int(getIndices(resRC))";for(var r=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],a=0;a<t.length;a++)a===e?o.push("int(getIndices("+r[a]+"))"):o.push(""+r[a]);return o.join()}(t,n);this.userCode="\n      void main() {\n        "+o+" resRC = getOutputCoords();\n        setOutput(getA("+a+"));\n      }\n    "};var gi=function(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;var r=wa(e.length),o=wa(n.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode="\n        "+r+" strides = "+r+"("+this.strides+");\n         void main() {\n          "+o+" coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < "+this.sliceDim+"; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * "+a+";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "};function yi(t,e){var n=ua();return oe(t,e,n.version+"\n    precision highp float;\n    "+n.attribute+" vec3 clipSpacePos;\n    "+n.attribute+" vec2 uv;\n    "+n.varyingVs+" vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")}function xi(t,e){return fe(t,e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function bi(t,e){return de(t,e,new Uint16Array([0,1,2,2,1,3]))}function wi(t,e,n,r,o,a,i){ve(n,r);var s=pe(t,e),u=t.TEXTURE_2D;return Jt(t,e,(function(){return t.bindTexture(u,s)})),Jt(t,e,(function(){return t.texParameteri(u,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)})),Jt(t,e,(function(){return t.texParameteri(u,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)})),Jt(t,e,(function(){return t.texParameteri(u,t.TEXTURE_MIN_FILTER,t.NEAREST)})),Jt(t,e,(function(){return t.texParameteri(u,t.TEXTURE_MAG_FILTER,t.NEAREST)})),Jt(t,e,(function(){return t.texImage2D(u,0,o,n,r,0,a,i,null)})),Jt(t,e,(function(){return t.bindTexture(t.TEXTURE_2D,null)})),s}function Ci(t,e,n,r,o){var a=Xt(n,r);return wi(t,e,a[0],a[1],o.internalFormatFloat,o.textureFormatFloat,t.FLOAT)}function Ei(t,e,n,r,o){var a=Xt(n,r);return wi(t,e,a[0],a[1],o.internalFormatHalfFloat,o.textureFormatFloat,o.textureTypeHalfFloat)}function Ri(t,e,n,r,o){var a=Xt(n,r);return wi(t,e,a[0],a[1],t.RGBA,t.RGBA,t.UNSIGNED_BYTE)}function Ii(t,e,n,r,o){var a=$t(n,r);return wi(t,e,a[0],a[1],o.internalFormatPackedFloat,t.RGBA,t.FLOAT)}function ki(t,e,n,r,o){var a=$t(n,r);return wi(t,e,a[0],a[1],o.internalFormatPackedHalfFloat,t.RGBA,o.textureTypeHalfFloat)}function Si(t,e,n,r){return Jt(t,e,(function(){return t.bindBuffer(t.ARRAY_BUFFER,r)})),ge(t,e,n,"clipSpacePos",r,3,20,0)&&ge(t,e,n,"uv",r,2,20,12)}function Ai(t,e,n,r,o,a,i){var s,u,c;Jt(t,e,(function(){return t.bindTexture(t.TEXTURE_2D,n)})),a instanceof Uint8Array?(s=new Uint8Array(r*o*4),u=t.UNSIGNED_BYTE,c=t.RGBA):(s=new Float32Array(r*o*4),u=t.FLOAT,c=i.internalFormatPackedFloat),s.set(a),Jt(t,e,(function(){return t.texImage2D(t.TEXTURE_2D,0,c,r,o,0,t.RGBA,u,s)})),Jt(t,e,(function(){return t.bindTexture(t.TEXTURE_2D,null)}))}function Di(t,e,n,r){Jt(t,e,(function(){return t.bindTexture(t.TEXTURE_2D,n)})),r.data instanceof Uint8Array?Jt(t,e,(function(){return t.texImage2D(t.TEXTURE_2D,0,t.RGBA,r.width,r.height,0,t.RGBA,t.UNSIGNED_BYTE,r.data)})):Jt(t,e,(function(){return t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,r)})),Jt(t,e,(function(){return t.bindTexture(t.TEXTURE_2D,null)}))}function Ti(t,e,n,r,o){var a=t.createBuffer();Jt(t,e,(function(){return t.bindBuffer(t.PIXEL_PACK_BUFFER,a)}));var i=16*n*r;return Jt(t,e,(function(){return t.bufferData(t.PIXEL_PACK_BUFFER,i,t.STREAM_READ)})),Jt(t,e,(function(){return t.readPixels(0,0,r,n,t.RGBA,t.FLOAT,0)})),Jt(t,e,(function(){return t.bindBuffer(t.PIXEL_PACK_BUFFER,null)})),a}function Ni(t,e,n){var r=t,o=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}function Fi(t,e,n,r,o){var a=Xt(n,r),i=a[0],s=a[1],u=new Uint8Array(n*r*4);return Jt(t,e,(function(){return t.readPixels(0,0,i,s,o.downloadTextureFormat,t.UNSIGNED_BYTE,u)})),new Float32Array(u.buffer)}function _i(t,e,n,r,o,a,i,s){var u=t,c=new Float32Array(function(t,e){var n=$t(t,e);return n[0]*n[1]*4}(a,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}function Oi(t,e,n,r){var o=new Float32Array(n*r*4);return Jt(t,e,(function(){return t.readPixels(0,0,r,n,t.RGBA,t.FLOAT,o)})),o}var Mi=Object.freeze({createVertexShader:yi,createVertexBuffer:xi,createIndexBuffer:bi,createFloat32MatrixTexture:Ci,createFloat16MatrixTexture:Ei,createUnsignedBytesMatrixTexture:Ri,createPackedMatrixTexture:Ii,createFloat16PackedMatrixTexture:ki,bindVertexProgramAttributeStreams:Si,uploadDenseMatrixToTexture:Ai,uploadPixelDataToTexture:Di,createBufferFromOutputTexture:Ti,downloadFloat32MatrixFromBuffer:Ni,downloadByteEncodedFloatMatrixFromOutputTexture:Fi,downloadPackedMatrixFromBuffer:_i,downloadMatrixFromPackedOutputTexture:Oi}),Bi=function(){function t(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];var e=i().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,Kt(e,t)):this.gl=jt(e);var n="WEBGL_color_buffer_float";if(1===i().getNumber("WEBGL_VERSION")){if(this.textureFloatExtension=re(this.gl,this.debug,"OES_texture_float"),Pe(this.gl,"OES_texture_half_float"))this.textureHalfFloatExtension=re(this.gl,this.debug,"OES_texture_half_float");else if(i().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Pe(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=re(this.gl,this.debug,"EXT_color_buffer_half_float");else if(i().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Pe(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!Pe(this.gl,"EXT_color_buffer_half_float"))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=xi(this.gl,this.debug),this.indexBuffer=bi(this.gl,this.debug),this.framebuffer=me(this.gl,this.debug),this.textureConfig=Qt(this.gl,this.textureHalfFloatExtension)}return Object.defineProperty(t.prototype,"debug",{get:function(){return i().getBool("DEBUG")},enumerable:!0,configurable:!0}),t.prototype.dispose=function(){var t=this;if(!this.disposed){null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");var e=this.gl;Jt(e,this.debug,(function(){return e.finish()})),Jt(e,this.debug,(function(){return e.bindFramebuffer(e.FRAMEBUFFER,null)})),Jt(e,this.debug,(function(){return e.deleteFramebuffer(t.framebuffer)})),Jt(e,this.debug,(function(){return e.bindBuffer(e.ARRAY_BUFFER,null)})),Jt(e,this.debug,(function(){return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)})),Jt(e,this.debug,(function(){return e.deleteBuffer(t.indexBuffer)})),this.disposed=!0}},t.prototype.createFloat32MatrixTexture=function(t,e){return this.throwIfDisposed(),Ci(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createFloat16MatrixTexture=function(t,e){return this.throwIfDisposed(),Ei(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createUnsignedBytesMatrixTexture=function(t,e){return this.throwIfDisposed(),Ri(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.uploadPixelDataToTexture=function(t,e){this.throwIfDisposed(),Di(this.gl,this.debug,t,e)},t.prototype.uploadDenseMatrixToTexture=function(t,e,n,r){this.throwIfDisposed(),Ai(this.gl,this.debug,t,e,n,r,this.textureConfig)},t.prototype.createFloat16PackedMatrixTexture=function(t,e){return this.throwIfDisposed(),ki(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createPackedMatrixTexture=function(t,e){return this.throwIfDisposed(),Ii(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.deleteMatrixTexture=function(t){var e=this;this.throwIfDisposed(),this.outputTexture===t&&(Ee(this.gl,this.debug,this.framebuffer),this.outputTexture=null),Jt(this.gl,this.debug,(function(){return e.gl.deleteTexture(t)}))},t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(t,e,n){var r=this;return this.downloadMatrixDriver(t,(function(){return Fi(r.gl,r.debug,e,n,r.textureConfig)}))},t.prototype.downloadPackedMatrixFromBuffer=function(t,e,n,r,o,a){return _i(this.gl,t,0,0,0,o,a,this.textureConfig)},t.prototype.downloadFloat32MatrixFromBuffer=function(t,e){return Ni(this.gl,t,e)},t.prototype.createBufferFromTexture=function(t,e,n){this.bindTextureToFrameBuffer(t);var r=Ti(this.gl,this.debug,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r},t.prototype.createAndWaitForFence=function(){var t=this.createFence(this.gl);return this.pollFence(t)},t.prototype.createFence=function(t){var e,n,r=this;if(i().getBool("WEBGL_FENCE_API_ENABLED")){var o=t,a=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=function(){var t=o.clientWaitSync(a,0,0);return t===o.ALREADY_SIGNALED||t===o.CONDITION_SATISFIED},e=a}else i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=function(){return r.isQueryAvailable(e,i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):n=function(){return!0};return{query:e,isFencePassed:n}},t.prototype.downloadMatrixFromPackedTexture=function(t,e,n){var r=this;return this.downloadMatrixDriver(t,(function(){return Oi(r.gl,r.debug,e,n)}))},t.prototype.createProgram=function(t){this.throwIfDisposed();var e=this.gl,n=ae(e,this.debug,t),r=yi(e,this.debug),o=ce(e,this.debug);return Jt(e,this.debug,(function(){return e.attachShader(o,r)})),Jt(e,this.debug,(function(){return e.attachShader(o,n)})),le(e,this.debug,o),this.debug&&he(e,this.debug,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=Si(e,this.debug,this.program,this.vertexBuffer)),o},t.prototype.deleteProgram=function(t){var e=this;this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&Jt(this.gl,this.debug,(function(){return e.gl.deleteProgram(t)}))},t.prototype.setProgram=function(t){var e=this;this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&he(this.gl,this.debug,this.program),Jt(this.gl,this.debug,(function(){return e.gl.useProgram(t)}))},t.prototype.getUniformLocation=function(t,e,n){return void 0===n&&(n=!0),this.throwIfDisposed(),n?xe(this.gl,this.debug,t,e):be(this.gl,t,e)},t.prototype.getAttributeLocation=function(t,e){var n=this;return this.throwIfDisposed(),Jt(this.gl,this.debug,(function(){return n.gl.getAttribLocation(t,e)}))},t.prototype.getUniformLocationNoThrow=function(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)},t.prototype.setInputMatrixTexture=function(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),we(this.gl,this.debug,this.program,t,e,n)},t.prototype.setOutputMatrixTexture=function(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)},t.prototype.setOutputPackedMatrixTexture=function(t,e,n){this.throwIfDisposed();var r=$t(e,n),o=r[0],a=r[1];this.setOutputMatrixTextureDriver(t,o,a)},t.prototype.setOutputMatrixWriteRegion=function(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)},t.prototype.setOutputPackedMatrixWriteRegion=function(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")},t.prototype.debugValidate=function(){null!=this.program&&he(this.gl,this.debug,this.program),Re(this.gl)},t.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var t=this.gl;this.debug&&this.debugValidate(),Jt(t,this.debug,(function(){return t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)}))},t.prototype.blockUntilAllProgramsCompleted=function(){var t=this;this.throwIfDisposed(),Jt(this.gl,this.debug,(function(){return t.gl.finish()}))},t.prototype.getQueryTimerExtension=function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=re(this.gl,this.debug,2===i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension},t.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},t.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},t.prototype.beginQuery=function(){if(2===i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}var r=this.getQueryTimerExtensionWebGL1(),o=r.createQueryEXT();return r.beginQueryEXT(r.TIME_ELAPSED_EXT,o),o},t.prototype.endQuery=function(){if(2!==i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}else{var e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT)}},t.prototype.waitForQueryAndGetTime=function(t){return n(this,void 0,void 0,(function(){var e=this;return r(this,(function(n){switch(n.label){case 0:return[4,F((function(){return e.disposed||e.isQueryAvailable(t,i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}))];case 1:return n.sent(),[2,this.getQueryTime(t,i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}}))}))},t.prototype.getQueryTime=function(t,e){if(0===e)return null;if(2===e){var n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}var r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6},t.prototype.isQueryAvailable=function(t,e){if(0===e)return!0;if(2===e){var n=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}o=(r=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint},t.prototype.pollFence=function(t){var e=this;return new Promise((function(n){e.addItemToPoll((function(){return t.isFencePassed()}),(function(){return n()}))}))},t.prototype.pollItems=function(){for(var t=function(t){for(var e=0;e<t.length;++e){if(!t[e]())break}return e-1}(this.itemsToPoll.map((function(t){return t.isDoneFn}))),e=0;e<=t;++e){(0,this.itemsToPoll[e].resolveFn)()}this.itemsToPoll=this.itemsToPoll.slice(t+1)},t.prototype.addItemToPoll=function(t,e){var n=this;this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||F((function(){return n.pollItems(),0===n.itemsToPoll.length}))},t.prototype.bindTextureToFrameBuffer=function(t){this.throwIfDisposed(),Ce(this.gl,this.debug,t,this.framebuffer),this.debug&&Re(this.gl)},t.prototype.unbindTextureToFrameBuffer=function(){null!=this.outputTexture?(Ce(this.gl,this.debug,this.outputTexture,this.framebuffer),this.debug&&Re(this.gl)):Ee(this.gl,this.debug,this.framebuffer)},t.prototype.downloadMatrixDriver=function(t,e){this.bindTextureToFrameBuffer(t);var n=e();return this.unbindTextureToFrameBuffer(),n},t.prototype.setOutputMatrixTextureDriver=function(t,e,n){this.throwIfDisposed();var r=this.gl;Ce(r,this.debug,t,this.framebuffer),this.debug&&Re(r),this.outputTexture=t,Jt(r,this.debug,(function(){return r.viewport(0,0,e,n)})),Jt(r,this.debug,(function(){return r.scissor(0,0,e,n)}))},t.prototype.setOutputMatrixWriteRegionDriver=function(t,e,n,r){var o=this;this.throwIfDisposed(),Jt(this.gl,this.debug,(function(){return o.gl.scissor(t,e,n,r)}))},t.prototype.throwIfDisposed=function(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")},t.prototype.throwIfNoProgram=function(){if(null==this.program)throw new Error("No GPU program is currently set.")},t}();function Pi(t,e){if(t.length!==e.length)throw Error("Binary was compiled with "+t.length+" inputs, but was executed with "+e.length+" inputs");t.forEach((function(t,n){var r=t.logicalShape,o=e[n],a=o.shape;if(!S(r,a))throw Error("Binary was compiled with different shapes than the current args. Shapes "+r+" and "+a+" must match");if(!t.isUniform||!o.isUniform){var i=t.texShape,s=o.isUniform?null:o.texData.texShape;if(!S(i,s))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+i+" and "+s+" must match")}}))}var Li=function(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;for(var r=n.filterWidth,o=n.inChannels,a=n.strideWidth,i=n.strideHeight,s=n.padInfo,u=n.outWidth,c=n.dilationWidth,l=n.dilationHeight,h=n.dataFormat,f=s.left,d=s.top,p=o*r,v=ua(),m="channelsLast"===h,g=m?0:1,y=m?1:2,x="",b=0;b<=1;b++)for(var w=0;w<=1;w++)x+="\n          blockIndex = rc.y + "+w+";\n          pos = rc.x + "+b+";\n\n          if(blockIndex < "+t[1]+" && pos < "+t[0]+") {\n            offsetY = int(blockIndex / ("+u+")) * "+i+" - "+d+";\n            d0 = offsetY + "+l+" * (pos / "+p+");\n\n            if(d0 < "+e[g]+" && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), "+u+".) * "+a+". - "+f+".);\n              d1 = offsetX + "+c+" * (int(mod(float(pos), "+p+".) / "+o+".));\n\n              if(d1 < "+e[y]+" && d1 >= 0) {\n\n                ch = int(mod(float(pos), "+o+".));\n\n                if ("+m+") {\n                  innerDims = vec2(d1, ch);\n                  result["+(2*b+w)+"] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result["+(2*b+w)+"] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";this.userCode="\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        "+x+"\n\n        "+v.output+" = result;\n      }\n    "},Wi=function(t,e,n,r,o){this.variableNames=["x"],this.outputShape=[];var a,i=e,s=t[3]-1;this.outputShape=t;var u="float("+n+") + float("+r+") * sum";a=.5===o?"inversesqrt("+u+")":1===o?"1.0/("+u+")":"exp(log("+u+") * float(-"+o+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -"+i+"; j <= "+i+"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  "+s+") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * "+a+";\n        setOutput(val);\n      }\n    "},Ui=function(t,e,n,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=o,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < "+this.depth+"; ++d) {\n          int depthBegin = int(max(0.0, float(d - "+e+")));\n          int depthEnd = int(min(float("+this.depth+"),\n              float(d + "+e+" + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = "+this.depth+";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float("+r+") * norm + float("+n+");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float("+r+")\n                * float("+o+")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * "+o+");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "},Vi=function(t,e,n,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;var a,i=e,s=t[3]-1;this.outputShape=t;var u="float("+n+") + float("+r+") * sum";a=.5===o?"inversesqrt("+u+")":1===o?"1.0/("+u+")":"exp(log("+u+") * float(-"+o+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < "+this.outputShape[3]+";\n        bool hasNextRow = c < "+this.outputShape[2]+";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - "+i+";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - "+i+"; j <= "+i+"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2("+s+"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * "+a+";\n        setOutput(result);\n      }\n    "},zi=function(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;var e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,o=t.effectiveFilterHeight,a=t.effectiveFilterWidth,i=o-1-t.padInfo.top,s=a-1-t.padInfo.left,u=o*a-1;this.userCode="\n      const ivec2 pads = ivec2("+i+", "+s+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+o+";\n          wR += "+r+") {\n          float dyR = float(dyRCorner + wR) / "+e+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+a+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+n+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = "+u+" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * "+a+" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Gi=function(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;var e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,i=t.dilationWidth,s=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,l=s-1-t.padInfo.front,h=u-1-t.padInfo.top,f=c-1-t.padInfo.left,d=s*u*c-1;this.userCode="\n      const ivec3 pads = ivec3("+l+", "+h+", "+f+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+s+";\n           wD += "+o+") {\n          float dyD = float(dyDCorner + wD) / "+e+".0;\n\n          if (dyD < 0.0 || dyD >= "+t.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+u+";\n              wR += "+a+") {\n            float dyR = float(dyRCorner + wR) / "+n+".0;\n\n            if (dyR < 0.0 || dyR >= "+t.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+c+";\n                wC += "+i+") {\n              float dyC = float(dyCCorner + wC) / "+r+".0;\n\n              if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = "+d+" -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * "+u+" * "+c+" +\n                  wR * "+c+" + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Hi=function(t,e,n,r,o,a,i){void 0===n&&(n=!1),void 0===r&&(r=!1),void 0===o&&(o=!1),void 0===a&&(a=null),void 0===i&&(i=!1),this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;var s=n?t[1]:t[2],u=Math.ceil(s/2),c=n?"i * 2, rc.y":"rc.y, i * 2",l=r?"rc.z, i * 2":"i * 2, rc.z",h=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],d="",p="";a&&(d=i?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          "+a+"\n        }":"vec4 activation(vec4 x) {\n          "+a+"\n        }",p="result = activation(result);");var v=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+d+"\n\n      const float sharedDimension = "+u+".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < "+u+"; i++) {\n          vec4 a = getMatrixA(rc.x, "+c+");\n          vec4 b = getMatrixB(rc.x, "+l+");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += ("+h[0]+" * "+f[0]+");\n          result += ("+h[1]+" * "+f[1]+");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        "+v+"\n\n        "+p+"\n\n        setOutput(result);\n      }\n    "},qi=function(){function t(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < "+(e-1)+"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+(e-1)+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;return function(n,r){null==e.seedLoc&&(e.seedLoc=n.getUniformLocation(r,"seed")),n.gl.uniform1f(e.seedLoc,t)}},t}(),Ki=function(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float("+r+"), float("+n+"),\n                      float(index == coords.y)));\n      }\n    "},ji=function(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;var e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{var n=sa("rc",e),r=wa(e),o=function(t,e,n){if(1===t)return"rc > "+e[0];for(var r="",o=t-2;o<t;o++)r+=n[o]+" >= "+e[o],o<t-1&&(r+="||");return r}(e,t,n),a=function(t,e,n,r){if(1===t)return"";var o=r.slice(-2);return"\n    int r = "+o[0]+";\n    int c = "+o[1]+";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= "+e+";\n    bool rEdge = rp1 >= "+n+";\n  "}(e,t[t.length-1],t[t.length-2],n),i=function(t,e){var n=t.length,r=function(t,e){for(var n=[],r=0;r<=1;r++)for(var o=0;o<=1;o++){for(var a=(0===r?"r":"rp1")+", "+(0===o?"c":"cp1"),i=2;i<t;i++)a=e[e.length-1-i]+","+a;n.push(a)}return n}(n,e);return 1===n?"getA(rc),\n            rc + 1 >= "+t[0]+" ? 0. : getA(rc + 1),\n            0, 0":"getA("+r[0]+"),\n          cEdge ? 0. : getA("+r[1]+"),\n          rEdge ? 0. : getA("+r[2]+"),\n          rEdge || cEdge ? 0. : getA("+r[3]+")"}(t,n);this.userCode="\n        void main() {\n          "+r+" rc = getOutputCoords();\n\n          if("+o+") {\n            setOutput(vec4(0));\n          } else {\n            "+a+"\n\n            setOutput(vec4("+i+"));\n          }\n        }\n      "}};var Xi=function(t,e,n){this.variableNames=["x"],this.outputShape=e.map((function(e,n){return e[0]+t[n]+e[1]}));var r=t.length,o=wa(r),a=e.map((function(t){return t[0]})).join(","),i=e.map((function(e,n){return e[0]+t[n]})).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?"\n      "+o+" start = "+o+"("+a+");\n      "+o+" end = "+o+"("+i+");\n\n      void main() {\n        "+o+" outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float("+n+"));\n        } else {\n          "+o+" coords = outC - start;\n          setOutput(getX("+s+"));\n        }\n      }\n    ":"\n        int start = "+a+";\n        int end = "+i+";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float("+n+"));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      "},Yi=function(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((function(e,n){return e[0]+t[n]+e[1]}));for(var r=t.length,o=wa(r),a=e.map((function(t){return t[0]})).join(","),i=e.map((function(e,n){return e[0]+t[n]})).join(","),s=sa("rc",r),u=sa("source",r),c=s[r-1]+" < "+this.outputShape[r-1],l=1===r?"source":"vec2("+u.slice(-2).join()+")",h=[o+" rc = outputLoc;",s[r-1]+" += 1;\n       if("+c+") {\n      ",1===r?"":"}\n       rc = outputLoc;\n       "+s[r-2]+" += 1;\n       if("+s[r-2]+" < "+this.outputShape[r-2]+") {",1===r?"":"  "+s[r-1]+" += 1;\n         if("+c+") {"],f=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",d="",p=0,v=1===r?2:4;p<v;p++)d+="\n        "+h[p]+"\n        if ("+f+") {\n          result["+p+"] = float("+n+");\n        } else {\n          "+o+" source = rc - start;\n          result["+p+"] = getChannel(getX("+u.join()+"), "+l+");\n        }\n      ";d+=1===r?"} ":"}}",this.userCode="\n      const "+o+" start = "+o+"("+a+");\n      const "+o+" end = "+o+"("+i+");\n\n      void main() {\n        "+o+" outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        "+d+"\n        setOutput(result);\n      }\n    "},$i=function(t,e,n){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");var r=t.filterWidth,o=t.strideHeight,a=t.strideWidth,i=t.dilationHeight,s=t.dilationWidth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,l=t.padInfo.top,h=t.padInfo.left;this.outputShape=t.outShape;var f="avg"===e,d="0.0";if(f||(d="-1.0 / 1e-20"),n)this.userCode="\n        const ivec2 strides = ivec2("+o+", "+a+");\n        const ivec2 pads = ivec2("+l+", "+h+");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+u+";\n              wR += "+i+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+c+";\n                wC += "+s+") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * "+c+" + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var p=e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(p="avgValue / count");var v=4*Math.floor(r/4),m=r%4,g="\n      if ("+f+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec2 strides = ivec2("+o+", "+a+");\n      const ivec2 pads = ivec2("+l+", "+h+");\n      const float initializationValue = "+d+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+t.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+d+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < "+u+";\n            wR += "+i+") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+t.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+v+"; wC += 4) {\n            int xC = xCCorner + wC * "+s+";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              getValue(batch, xR, xC + 2 * "+s+", d),\n              getValue(batch, xR, xC + 3 * "+s+", d)\n            );\n\n            "+g+"\n          }\n\n          int xC = xCCorner + "+v+";\n          if ("+(1===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            "+g+"\n          } else if ("+(2===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+g+"\n          } else if ("+(3===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              getValue(batch, xR, xC + 2 * "+s+", d),\n              initializationValue\n            );\n\n            "+g+"\n          }\n        }\n        setOutput("+p+");\n      }\n    "}},Qi=function(t,e,n){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");var r=t.filterWidth,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,v=t.padInfo.left;this.outputShape=t.outShape;var m="avg"===e,g="0.0";if(m||(g="-1.0 / 1e-20"),n)this.userCode="\n        const ivec3 strides =\n            ivec3("+o+", "+a+", "+i+");\n        const ivec3 pads = ivec3("+d+", "+p+", "+v+");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < "+l+";\n              wD += "+s+") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= "+t.inDepth+") {\n              continue;\n            }\n\n            for (int wR = 0; wR < "+h+";\n                wR += "+u+") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= "+t.inHeight+") {\n                continue;\n              }\n\n              for (int wC = 0; wC < "+f+";\n                  wC += "+c+") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= "+t.inWidth+") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * "+h+" * "+f+" +\n                      wR * "+f+" + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var y=e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(y="avgValue / count");var x=4*Math.floor(r/4),b=r%4,w="\n      if ("+m+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec3 strides =\n        ivec3("+o+", "+a+", "+i+");\n      const ivec3 pads = ivec3("+d+", "+p+", "+v+");\n      const float initializationValue = "+g+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= "+t.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+g+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < "+l+";\n            wD += "+s+") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= "+t.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+h+";\n            wR += "+u+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+x+"; wC += 4) {\n              int xC = xCCorner + wC * "+c+";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+c+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+c+", ch),\n                getValue(batch, xD, xR, xC + 3 * "+c+", ch)\n              );\n\n              "+w+"\n            }\n\n            int xC = xCCorner + "+x+";\n            if ("+(1===b)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              "+w+"\n            } else if ("+(2===b)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+c+", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              "+w+"\n            } else if ("+(3===b)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+c+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+c+", ch),\n                initializationValue\n              );\n\n              "+w+"\n            }\n          }\n          setOutput("+y+");\n        }\n      }\n    "}},Ji=function(t,e){this.variableNames=["x"];var n=t.windowSize,r=t.batchSize,o=t.inSize,a=Math.ceil(o/n);this.outputShape=[r,a];var i="0.0",s="";"prod"===e?i="1.0":"min"===e?(i="1.0 / 1e-20",s="min"):"max"===e&&(i="-1.0 / 1e-20",s="max");var u=e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");var c=4*Math.floor(n/4),l=n%4,h="\n      if ("+("sum"===e)+") {\n        sumValue += dot(values, ones);\n      } else if ("+("prod"===e)+") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = "+s+"(values, minMaxValue);\n      }\n    ",f="vec4";"all"===e?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===e&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");var d="";o%n>0&&(d="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return initializationValue;\n        }\n      "),this.userCode="\n      const float initializationValue = "+i+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+d+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+n+";\n\n        vec4 minMaxValue = vec4("+i+");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < "+c+"; i += 4) {\n          int inIdx = inOffset + i;\n          "+f+" values = "+f+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+h+"\n        }\n\n        int inIdx = inOffset + "+c+";\n        if ("+(1===l)+") {\n          "+f+" values = "+f+"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          "+h+"\n        } else if ("+(2===l)+") {\n          "+f+" values = "+f+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          "+h+"\n        } else if ("+(3===l)+") {\n          "+f+" values = "+f+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          "+h+"\n        }\n        setOutput("+u+");\n      }\n    "},Zi=function(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;for(var n="",r=0;r<4;r++){var o="thisRC = rc;";r%2==1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),n+="\n        "+o+"\n        "+(r>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+"\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result["+r+"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        "+(r>0?"}":"")+"\n      "}this.userCode="\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      "+ca(["r","c","d"],e)+"\n      return ivec3(r, c, d);\n    }\n  \n      "+la(t)+"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = "+t[1]+";\n        int cols = "+t[2]+";\n\n        "+n+"\n\n        setOutput(result);\n      }\n    "};var ts=function(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;var r=e.shape,o=r[1],a=r[2],i=t.shape,s=i[1],u=i[2],c=[n&&s>1?o-1:o,n&&u>1?a-1:a],l=[n&&s>1?s-1:s,n&&u>1?u-1:u],h=c[0]/l[0],f=c[1]/l[1],d=1/h,p=1/f,v=2*Math.ceil(d)+2,m=2*Math.ceil(p)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+h+");\n        const float widthScale = float("+f+");\n\n        const float invHeightScale = float("+d+");\n        const float invWidthScale = float("+p+");\n\n        const int winHeight = int("+v+");\n        const int winWidth = int("+m+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+s+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+u+") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), "+(o-1)+".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), "+(a-1)+".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "},es=function(t,e,n,r){this.variableNames=["A"],this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],c=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+u[0]/c[0]+",\n          "+u[1]/c[1]+");\n      const vec2 inputShapeRC = vec2("+a+".0, "+i+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "},ns=function(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],c=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          "+u[0]/c[0]+",\n          "+u[1]/c[1]+",\n          "+u[1]/c[1]+");\n      const vec3 inputShapeRC = vec3("+a+".0, "+i+".0,\n                                     "+i+".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < "+(s-1)+";\n        bool hasNextRow = coords.z < "+(n-1)+";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "},rs=function(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;var r=e.shape,o=r[1],a=r[2],i=t.shape,s=i[1],u=i[2],c=[n&&s>1?o-1:o,n&&u>1?a-1:a],l=[n&&s>1?s-1:s,n&&u>1?u-1:u],h=c[0]/l[0],f=c[1]/l[1],d=1/h,p=1/f,v=2*Math.ceil(d)+2,m=2*Math.ceil(p)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+h+");\n        const float widthScale = float("+f+");\n\n        const float invHeightScale = float("+d+");\n        const float invWidthScale = float("+p+");\n\n        const int winHeight = int("+v+");\n        const int winWidth = int("+m+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+s+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+u+") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float("+c[0]+") *\n                (float(dyR) / float("+l[0]+"));\n\n            float sourceFracCol =\n                float("+c[1]+") *\n                  (float(dyC) / float("+l[1]+"));\n\n            int sourceNearestRow = int(min(\n                float(int("+o+") - 1),\n                "+n+" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int("+a+") - 1),\n                "+n+" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "},os=function(t,e,n,r){this.variableNames=["A"],this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],c=[r&&e>1?e-1:e,r&&n>1?n-1:n],l=r?"0.5":"0.0";this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+u[0]/c[0]+",\n          "+u[1]/c[1]+");\n      const vec2 inputShapeRC = vec2("+a+".0, "+i+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+l+")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "},as=function(t,e){this.variableNames=["x"];var n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-"+n+" tensor is not yet supported");if(this.outputShape=t,1!==n){var r=t.map((function(n,r){return function(n){return-1!==e.indexOf(n)&&1!==t[n]?t[n]+" - coords["+n+"] - 1":"coords["+n+"]"}(r)})).join(","),o=wa(n);this.userCode="\n      void main() {\n        "+o+" coords = getOutputCoords();\n        setOutput(getX("+r+"));\n      }\n    "}else this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX("+t[0]+" - coord - 1));\n        }\n      "},is=function(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;var n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-"+n+" tensor is not yet supported");this.outputShape=t;var r=sa("rc",n),o=r[n-1]+" + 1 < "+this.outputShape[n-1],a=r[n-2]+" + 1 < "+this.outputShape[n-2],i=wa(n);function s(n){var r=t.map((function(r,o){return function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?t[n]+" - "+r[n]+" - 1":""+r[n]}(o,n)}));return"getChannel(getX("+r.join(",")+"), vec2("+r.slice(-2).join(",")+"))"}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX("+t[0]+" - rc - 1),\n            "+t[0]+" - rc - 1);\n          if("+o+"){\n              result.g = getChannel(getX("+t[0]+" - (rc  + 1) - 1),\n                "+t[0]+" - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ":"\n        void main() {\n          "+i+" rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = "+function(t){return s(t)}(r.slice())+";\n          if("+o+"){\n            result.g = "+function(t){return t[n-1]="("+t[n-1]+" + 1)",s(t)}(r.slice())+";\n          }\n          if("+a+") {\n            result.b = "+function(t){return t[n-2]="("+t[n-2]+" + 1)",s(t)}(r.slice())+";\n            if("+o+") {\n              result.a = "+function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",s(t)}(r.slice())+";\n            }\n          }\n          setOutput(result);\n        }\n    "},ss=function(t,e,n,r,o,a,i){void 0===i&&(i=!0),this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;var s=wa(o.length),u=wa(a.length),c="";1===n?c="i":2===n&&(c="i, j");var l="getIndices("+c+")",h="";1===r?h="i":2===r&&(h="i, coords[1]");var f="getUpdates("+h+")",d=e>1?"strides[j]":"strides";this.userCode="\n        "+s+" strides = "+s+"("+o+");\n\n        void main() {\n          "+u+" coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < "+t+"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < "+e+"; j++) {\n              int index = round("+l+");\n              flattenedIndex += index * "+d+";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += "+f+";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "},us=function(t,e){this.variableNames=["x","segmentIds"];var n=t.windowSize,r=t.batchSize,o=t.inSize,a=t.numSegments,i=a*Math.ceil(o/n);this.outputShape=[r,i];var s=4*Math.floor(n/4),u=n%4,c="\n        sumValue += dot(values, segFilter);\n    ",l="";o%n>0&&(l="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return initializationValue;\n        }\n      ");var h="";o%n>0&&(h="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return -1.0;\n        }\n      "),this.userCode="\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        "+l+"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        "+h+"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          "+a+")) * float("+n+"));\n        int currentSeg = int(mod(float(outIdx), float("+a+")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < "+s+"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          "+c+"\n        }\n\n        int inIdx = inOffset + "+s+";\n        if ("+(1===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          "+c+"\n        } else if ("+(2===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          "+c+"\n        } else if ("+(3===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          "+c+"\n        }\n        setOutput(sumValue);\n      }\n    "},cs=function(t,e,n){var r,o;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error("Where for rank "+n+" is not yet supported");if(1===n)o="resRC",r="resRC";else{for(var a=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],s=[],u=0;u<e.length;u++)s.push(""+a[u]),u<t&&i.push(""+a[u]);r=i.join(),o=s.join()}var c=wa(n);this.userCode="\n      void main() {\n        "+c+" resRC = getOutputCoords();\n        float cVal = getC("+r+");\n        if (cVal >= 1.0) {\n          setOutput(getA("+o+"));\n        } else {\n          setOutput(getB("+o+"));\n        }\n      }\n    "},ls=function(){function t(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;var e,n=wa(this.rank),r="uniform int start["+this.rank+"];",o=function(t){if(1===t)return"sourceLoc";if(t<=6)return hs.slice(0,t).map((function(t){return"sourceLoc."+t})).join(",");throw Error("Slicing for rank "+t+" is not yet supported")}(this.rank);e="\n        "+n+" sourceLoc;\n        "+n+" coords = getOutputCoords();\n        "+t.map((function(t,e){return"sourceLoc."+hs[e]+" = start["+e+"] + coords."+hs[e]+";"})).join("\n")+"\n      ",this.userCode="\n      "+r+"\n      void main() {\n        "+e+"\n        setOutput(getSource("+o+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;if(t.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+t.length+")");return function(n,r){null==e.startLoc&&(e.startLoc=n.getUniformLocationNoThrow(r,"start"),null==e.startLoc)||n.gl.uniform1iv(e.startLoc,t)}},t}(),hs=["x","y","z","w","u","v"];var fs=function(){function t(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;var e=wa(this.rank),n=sa("coords",this.rank),r=sa("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":"vec2("+r.slice(-2).join()+")",a="getChannel(getSource("+r.join()+"), "+o+")",i="\n      result.x = "+a+";\n      if (++"+n[this.rank-1]+" < "+t[this.rank-1]+") {\n        ++"+r[this.rank-1]+";\n        result.y = "+a+";\n        --"+r[this.rank-1]+";\n      }\n    ",s=1===this.rank?"":"\n      --"+n[this.rank-1]+";\n      if (++"+n[this.rank-2]+" < "+t[this.rank-2]+") {\n        ++"+r[this.rank-2]+";\n        result.z = "+a+";\n        if (++"+n[this.rank-1]+" < "+t[this.rank-1]+") {\n          ++"+r[this.rank-1]+";\n          result.w = "+a+";\n        }\n      }\n    ",u=this.rank<=4?"sourceLoc = coords +\n            "+e+"("+t.map((function(t,e){return"start["+e+"]"})).join()+");":t.map((function(t,e){return r[e]+" = "+n[e]+" + start["+e+"];"})).join("\n");this.userCode="\n      uniform int start["+this.rank+"];\n      void main() {\n        "+e+" coords = getOutputCoords();\n        "+e+" sourceLoc;\n        "+u+"\n        vec4 result = vec4(0.);\n        "+i+"\n        "+s+"\n        setOutput(result);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;if(t.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+t.length+")");return function(n,r){null==e.startLoc&&(e.startLoc=n.getUniformLocationNoThrow(r,"start"),null==e.startLoc)||n.gl.uniform1iv(e.startLoc,t)}},t}(),ds=function(t,e,n){this.variableNames=["x"],this.outputShape=n;var r=n.length,o=wa(n.length),a=wa(n.length),i="";if(1===r)i="coords * strides + begin";else{var s=0;i=n.map((function(t,e){return s++,1===n.length?"coords * strides["+e+"] + begin["+e+"]":"coords["+(s-1)+"] * strides["+e+"] + begin["+e+"]"})).join(",")}this.userCode="\n      "+o+" begin = "+o+"("+t+");\n      "+o+" strides = "+o+"("+e+");\n\n      void main() {\n        "+a+" coords = getOutputCoords();\n        setOutput(getX("+i+"));\n      }\n    "},ps=function(){function t(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}return t.prototype.acquireTexture=function(t,e,n){var r,o=vs(e,n),a=ms(t,o,n);if(a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]),this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this.log();var i=this.freeTextures[a].shift();return this.usedTextures[a].push(i),i}return this.numUsedTextures++,this.log(),o===Gt.PACKED_2X2_FLOAT32?r=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):o===Gt.PACKED_2X2_FLOAT16?r=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):o===Gt.UNPACKED_FLOAT32?r=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):o===Gt.UNPACKED_FLOAT16?r=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):o===Gt.PACKED_4X1_UNSIGNED_BYTE&&(r=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(r),r},t.prototype.releaseTexture=function(t,e,n,r){if(null!=this.freeTextures){var o=ms(e,vs(n,r),r);o in this.freeTextures||(this.freeTextures[o]=[]),this.freeTextures[o].push(t),this.numFreeTextures++,this.numUsedTextures--;var a=this.usedTextures[o],i=a.indexOf(t);if(i<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(i,1),this.log()}},t.prototype.log=function(){if(this.logEnabled){var t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+t+")")}},t.prototype.getNumUsedTextures=function(){return this.numUsedTextures},t.prototype.getNumFreeTextures=function(){return this.numFreeTextures},t.prototype.dispose=function(){var t=this;if(null!=this.freeTextures){for(var e in this.freeTextures)this.freeTextures[e].forEach((function(e){t.gpgpu.deleteMatrixTexture(e)}));for(var e in this.usedTextures)this.usedTextures[e].forEach((function(e){t.gpgpu.deleteMatrixTexture(e)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0}},t}();function vs(t,e){if(t===zt.UPLOAD)return Gt.PACKED_2X2_FLOAT32;if(t===zt.RENDER||null==t)return function(t){return i().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?Gt.PACKED_2X2_FLOAT32:Gt.UNPACKED_FLOAT32:t?Gt.PACKED_2X2_FLOAT16:Gt.UNPACKED_FLOAT16}(e);if(t===zt.DOWNLOAD||t===zt.PIXELS)return Gt.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+t)}function ms(t,e,n){return t[0]+"_"+t[1]+"_"+e+"_"+n}var gs=function(t,e){this.variableNames=["A"];for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[r]*e[r];this.outputShape=n,this.rank=n.length;var o=wa(this.rank),a=function(t){var e=t.length;if(e>5)throw Error("Tile for rank "+e+" is not yet supported");if(1===e)return"imod(resRC, "+t[0]+")";for(var n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[],o=0;o<t.length;o++)r.push("imod("+n[o]+", "+t[o]+")");return r.join()}(t);this.userCode="\n      void main() {\n        "+o+" resRC = getOutputCoords();\n        setOutput(getA("+a+"));\n      }\n    "};var ys=function(t,e){this.variableNames=["A"];for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[e[r]];this.outputShape=n,this.rank=n.length;var o=wa(this.rank),a=function(t){var e=t.length;if(e>6)throw Error("Transpose for rank "+e+" is not yet supported");for(var n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e),o=0;o<t.length;o++)r[t[o]]=n[o];return r.join()}(e);this.userCode="\n    void main() {\n      "+o+" resRC = getOutputCoords();\n      setOutput(getA("+a+"));\n    }\n    "};var xs=function(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[e[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");var o=wa(this.rank),a=ia("rc",this.rank),i=new Array(this.rank);for(r=0;r<e.length;r++)i[e[r]]=a[r];var s="vec2("+i.slice(-2).join()+")",u="++"+a[this.rank-1]+" < "+n[this.rank-1],c="getChannel(getA("+i.join()+"), "+s+")";this.userCode="\n    void main() {\n      "+o+" rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = "+c+";\n      if("+u+") {\n        result[1] = "+c+";\n      }\n      --"+a[this.rank-1]+";\n      if(++"+a[this.rank-2]+" < "+n[this.rank-2]+") {\n        result[2] = "+c+";\n        if("+u+") {\n          result[3] = "+c+";\n        }\n      }\n      setOutput(result);\n    }\n    "},bs=1.7580993408473768,ws=1.0507009873554805,Cs=function(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      float unaryOperation(float x) {\n        "+e+"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "},Es="if (isnan(x)) return x;",Rs="return x;",Is="return abs(x);",ks=Es+"\n  return (x < 0.0) ? 0.0 : x;\n",Ss=Es+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",As="return (x >= 0.0) ? x : (exp(x) - 1.0);",Ds="\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = "+bs+";\n  float scale = "+ws+";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";var Ts="return -x;",Ns="return ceil(x);",Fs="return floor(x);",_s="return exp(x);",Os="return exp(x) - 1.0;",Ms=Es+"\n  return sin(x);\n",Bs=Es+"\n  return cos(x);\n",Ps=Es+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",Ls=Es+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",Ws=Es+"\n  return atan(x);\n",Us=Es+"return log(x + sqrt(x * x + 1.0));",Vs=Es+"\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",zs=Es+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",Gs="return x;",Hs="return x;",qs="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Ks="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",js="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Xs=function(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        "+e+"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "},Ys=function(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;var e=t.length,n=sa("rc",e),r=wa(e),o=function(t,e){if(1===t)return"rc";for(var n="",r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),a=n.slice(-2),i=e<=1?"rc":"vec2("+a.join(",")+")";this.userCode="\n      void main() {\n        "+r+" rc = getOutputCoords();\n        vec4 packedInput = getA("+o+");\n\n        setOutput(getChannel(packedInput, "+i+"));\n      }\n    "},$s={};function Qs(t,e){if(void 0===e&&(e=!1),"linear"===t)return e?Hs:Rs;if("relu"===t)return e?qs:ks;if("elu"===t)return e?js:As;if("relu6"===t)return e?Ks:Ss;if("prelu"===t)return e?Pa:Ma;throw new Error("Activation "+t+" has not been implemented for the WebGL backend.")}var Js=600;var Zs=function(t){function o(e){var n,r=t.call(this)||this;if(r.pendingRead=new WeakMap,r.pendingDisposal=new WeakSet,r.dataRefCount=new WeakMap,r.numBytesInGPU=0,r.uploadWaitMs=0,r.downloadWaitMs=0,r.warnedAboutMemory=!1,r.pendingDeletes=0,r.disposed=!1,!i().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){var o=jt(i().getNumber("WEBGL_VERSION"));r.binaryCache=(n=i().getNumber("WEBGL_VERSION"))in $s?$s[n]:($s[n]={},$s[n]),r.gpgpu=new Bi(o),r.canvas=o.canvas,r.gpgpuCreatedLocally=!0}else r.gpgpu=e,r.binaryCache={},r.gpgpuCreatedLocally=!1,r.canvas=e.gl.canvas;return r.textureManager=new ps(r.gpgpu),r.numMBBeforeWarning=null==i().global.screen?1024:i().global.screen.height*i().global.screen.width*window.devicePixelRatio*Js/1024/1024,r.texData=new xo(r,Lt),r}return e(o,t),o.prototype.numDataIds=function(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes},o.prototype.write=function(t,e,n){if(i().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var r={};return this.texData.set(r,{shape:e,dtype:n,values:t,usage:zt.UPLOAD}),r},o.prototype.move=function(t,e,n,r){if(i().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:e,usage:zt.UPLOAD})},o.prototype.readSync=function(t){var e=this.texData.get(t),n=e.values,r=e.dtype,o=e.complexTensors,a=e.slice,i=e.shape,s=e.isPacked;if(null!=a){var u=void 0;u=s?new Xs(i,Gs):new Cs(i,Gs);var c=this.runWebGLProgram(u,[{dataId:t,shape:i,dtype:r}],r),l=this.readSync(c.dataId);return this.disposeData(c.dataId),l}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;var h,f,d=null!=this.activeTimers;(d&&(h=et()),"complex64"===r)?f=Vo(o.real.dataSync(),o.imag.dataSync()):f=this.getValuesFromTexture(t);return d&&(this.downloadWaitMs+=et()-h),this.convertAndCacheOnCPU(t,f)},o.prototype.read=function(t){return n(this,void 0,void 0,(function(){var e,n,o,a,s,u,c,l,h,f,d,p,v,m,g,y,x,b,w,C,E,R;return r(this,(function(r){switch(r.label){case 0:if(this.pendingRead.has(t))return e=this.pendingRead.get(t),[2,new Promise((function(t){return e.push(t)}))];if(n=this.texData.get(t),o=n.values,a=n.shape,s=n.slice,u=n.dtype,c=n.complexTensors,l=n.isPacked,null!=s)return h=void 0,h=l?new Xs(a,Gs):new Cs(a,Gs),f=this.runWebGLProgram(h,[{dataId:t,shape:a,dtype:u}],u),d=this.read(f.dataId),this.disposeData(f.dataId),[2,d];if(null!=o)return[2,this.convertAndCacheOnCPU(t)];if(!i().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===i().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");return p=null,"complex64"!==u&&i().get("WEBGL_BUFFER_SUPPORTED")&&(v=this.decode(t),m=this.texData.get(v.dataId),p=(R=this.gpgpu).createBufferFromTexture.apply(R,[m.texture].concat(Yt(a)))),this.pendingRead.set(t,[]),"complex64"===u?[3,2]:[4,this.gpgpu.createAndWaitForFence()];case 1:r.sent(),r.label=2;case 2:return"complex64"!==u?[3,4]:[4,Promise.all([c.real.data(),c.imag.data()])];case 3:return y=r.sent(),x=y[0],b=y[1],g=Vo(x,b),[3,5];case 4:null==p?g=this.getValuesFromTexture(t):(w=k(a),g=this.gpgpu.downloadFloat32MatrixFromBuffer(p,w)),r.label=5;case 5:return null!=v&&this.disposeData(v.dataId),C=this.convertAndCacheOnCPU(t,g),E=this.pendingRead.get(t),this.pendingRead.delete(t),E.forEach((function(t){return t(C)})),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t),this.pendingDeletes--),[2,C]}}))}))},o.prototype.checkNumericalProblems=function(t){if(null!=t)for(var e=0;e<t.length;e++){var n=t[e];if(!ee(n)){if(i().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value "+n+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value "+n+" cannot be represented on this device.")}}},o.prototype.getValuesFromTexture=function(t){var e,n=this.texData.get(t),r=n.shape,o=n.dtype,a=n.isPacked,s=k(r);if(i().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){var u=this.decode(t),c=this.texData.get(u.dataId),l=(e=this.gpgpu).downloadMatrixFromPackedTexture.apply(e,[c.texture].concat(Yt(r))).subarray(0,s);return this.disposeData(u.dataId),l}var h=i().getBool("WEBGL_PACK")&&!0===a,f=h?Te(r):r,d=h?new ci(f):new ui(f),p=this.runWebGLProgram(d,[{shape:f,dtype:o,dataId:t}],"float32"),v=this.texData.get(p.dataId),m=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v.texture,v.texShape[0],v.texShape[1]).subarray(0,s);return this.disposeData(p.dataId),m},o.prototype.time=function(t){return n(this,void 0,void 0,(function(){var e,n,o,a,s,u,c;return r(this,(function(r){switch(r.label){case 0:return e=this.activeTimers,n=[],o=!1,null==this.programTimersStack?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,t(),a=I(this.activeTimers.map((function(t){return t.query}))).filter((function(t){return null!=t})),s=I(this.activeTimers.map((function(t){return t.name}))).filter((function(t){return null!=t})),this.activeTimers=e,o&&(this.programTimersStack=null),u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[4,Promise.all(a)]:[3,2];case 1:return c=r.sent(),u.kernelMs=w(c),u.getExtraProfileInfo=function(){return c.map((function(t,e){return{name:s[e],ms:t}})).map((function(t){return t.name+": "+t.ms})).join(", ")},[3,3];case 2:u.kernelMs={error:"WebGL query timers are not supported in this environment."},r.label=3;case 3:return this.uploadWaitMs=0,this.downloadWaitMs=0,[2,u]}}))}))},o.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU}},o.prototype.startTimer=function(){return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:et(),endMs:null}},o.prototype.endTimer=function(t){return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=et(),t)},o.prototype.getQueryTime=function(t){return n(this,void 0,void 0,(function(){var e;return r(this,(function(n){return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[2,this.gpgpu.waitForQueryAndGetTime(t)]:[2,(e=t).endMs-e.startMs]}))}))},o.prototype.disposeData=function(t){if(!this.pendingDisposal.has(t)){if(this.pendingRead.has(t))return this.pendingDisposal.add(t),void this.pendingDeletes++;if(this.texData.has(t)){this.releaseGPUData(t);var e=this.texData.get(t).complexTensors;null!=e&&(e.real.dispose(),e.imag.dispose()),this.texData.delete(t)}}},o.prototype.releaseGPUData=function(t){var e=this.texData.get(t),n=e.texture,r=e.dtype,o=e.texShape,a=e.usage,i=e.isPacked,s=e.slice,u=s&&s.origDataId||t,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),null!=n&&(this.numBytesInGPU-=this.computeBytes(o,r),this.textureManager.releaseTexture(n,o,a,i)));var l=this.texData.get(t);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null},o.prototype.getTexture=function(t){return this.uploadToGPU(t),this.texData.get(t).texture},o.prototype.getDataInfo=function(t){return this.texData.get(t)},o.prototype.getCPUBackend=function(){return i().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=Lt.findBackend("cpu")),this.cpuBackend):null},o.prototype.shouldExecuteOnCPU=function(t,e){var n=this;return void 0===e&&(e=128),null!=this.getCPUBackend()&&t.every((function(t){return null==n.texData.get(t.dataId).texture&&t.size<e}))},o.prototype.getGPGPUContext=function(){return this.gpgpu},o.prototype.complex=function(t,e){var n=this.makeOutput(t.shape,"complex64");return this.texData.get(n.dataId).complexTensors={real:Lt.keep(t.clone()),imag:Lt.keep(e.clone())},n},o.prototype.real=function(t){return this.texData.get(t.dataId).complexTensors.real.clone()},o.prototype.imag=function(t){return this.texData.get(t.dataId).complexTensors.imag.clone()},o.prototype.slice=function(t,e,n){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.slice(t,e,n);if(0===k(n))return Fn([],n,t.dtype);var r=this.texData.get(t.dataId).isPacked,o=io(t.shape,e,n);if(r||!o){var a=i().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fs(n):new ls(n),s=a.getCustomSetupFunc(e);return this.compileAndRun(a,[t],null,s)}return this.uploadToGPU(t.dataId),this.shallowSlice(t,e,n)},o.prototype.shallowSlice=function(t,e,n){var r=this.texData.get(t.dataId),o=this.makeOutput(n,t.dtype),a=this.texData.get(o.dataId);Object.assign(a,r),a.shape=n,a.dtype=t.dtype;var i=so(e,t.strides);r.slice&&(i+=r.slice.flatOffset),a.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||t.dataId};var s=this.dataRefCount.get(a.slice.origDataId)||1;return this.dataRefCount.set(a.slice.origDataId,s+1),o},o.prototype.stridedSlice=function(t,e,n,r){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.stridedSlice(t,e,n,r);var o=ro(e,n,r);if(o.some((function(t){return 0===t})))return Fn([],o);var a=new ds(e,r,o);return this.compileAndRun(a,[t])},o.prototype.reverse=function(t,e){var n=i().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new is(t.shape,e):new as(t.shape,e);return this.compileAndRun(n,[t])},o.prototype.concat=function(t,e){if("complex64"===t[0].dtype){var n=t.map((function(t){return Tn(t)})),r=t.map((function(t){return Nn(t)}));return Dn(this.concat(n,e),this.concat(r,e))}if(this.shouldExecuteOnCPU(t))return this.cpuBackend.concat(t,e);if(1===t.length)return t[0];if(t.length>i().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){var o=Math.floor(t.length/2),a=this.concat(t.slice(0,o),e),s=this.concat(t.slice(o),e);return this.concat([a,s],e)}if(i().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].rank>1){var u=new Ga(t.map((function(t){return t.shape})),e);return this.compileAndRun(u,t)}var c=Sn(t.map((function(t){return t.shape})),e),l=t.map((function(t){return t.as2D(-1,k(t.shape.slice(e)))})),h=new za(l.map((function(t){return t.shape})));return this.compileAndRun(h,l).reshape(c)},o.prototype.neg=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.neg(t);if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Ts,t.dtype);var e=new Cs(t.shape,Ts);return this.compileAndRun(e,[t])},o.prototype.batchMatMul=function(t,e,n,r){var o=n?t.shape[2]:t.shape[1],a=r?e.shape[1]:e.shape[2],i=n?t.shape[1]:t.shape[2],s=t.shape[0];if((1===o||1===a)&&i>1e3){n&&(t=t.transpose([0,2,1])),r&&(e=e.transpose([0,2,1]));var u=1===a?t:t.as3D(s,i,1),c=1===a?2:1,l=1===a?e.as3D(s,1,i):e;return this.multiply(u,l).sum(c,!0)}var h=Dt(t.dtype,e.dtype),f=new Hi(t.shape,[s,o,a],n,r);return this.compileAndRun(f,[t,e],h)},o.prototype.fusedBatchMatMul=function(t){var e=t.a,n=t.b,r=t.transposeA,o=t.transposeB,a=t.bias,i=t.activation,s=t.preluActivationWeights,u=r?e.shape[2]:e.shape[1],c=o?n.shape[1]:n.shape[2],l=e.shape[0],h=Dt(e.dtype,n.dtype),f=null!=a,d=null!=s,p=i?Qs(i,!0):null,v=new Hi(e.shape,[l,u,c],r,o,f,p,d),m=[e,n];return a&&m.push(a),s&&m.push(s),this.compileAndRun(v,m,h)},o.prototype.multiply=function(t,e){if("complex64"===t.dtype){var n=this.texData.get(t.dataId),r=this.texData.get(e.dataId),o=new Na(Da,t.shape,e.shape),a=new Na(Ta,t.shape,e.shape),s=[this.makeComplexComponentTensorInfo(t,n.complexTensors.real),this.makeComplexComponentTensorInfo(t,n.complexTensors.imag),this.makeComplexComponentTensorInfo(e,r.complexTensors.real),this.makeComplexComponentTensorInfo(e,r.complexTensors.imag)],u=this.compileAndRun(o,s),c=this.compileAndRun(a,s),l=this.complex(u,c);return u.dispose(),c.dispose(),l}if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.multiply(t,e);if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,Oa,t.dtype);var h=new Ba(Oa,t.shape,e.shape);return this.compileAndRun(h,[t,e],t.dtype)},o.prototype.batchNormalization=function(t,e,n,r,o,a){var s=[t,e,n],u=null;null!=a&&(u=a.shape,s.push(a));var c=null;if(null!=o&&(c=o.shape,s.push(o)),i().getBool("WEBGL_PACK_NORMALIZATION")){var l=new Aa(t.shape,e.shape,n.shape,u,c,r);return this.compileAndRun(l,s)}var h=new Sa(t.shape,e.shape,n.shape,u,c,r);return this.compileAndRun(h,s)},o.prototype.localResponseNormalization4D=function(t,e,n,r,o){var a=i().getBool("WEBGL_PACK_NORMALIZATION")?new Vi(t.shape,e,n,r,o):new Wi(t.shape,e,n,r,o);return this.compileAndRun(a,[t])},o.prototype.LRNGrad=function(t,e,n,r,o,a,i){var s=new Ui(e.shape,r,o,a,i);return this.compileAndRun(s,[e,n,t])},o.prototype.tile=function(t,e){if("string"===t.dtype){var n=this.readSync(t.dataId).map((function(t){return ot(t)}));return ta(dr(t.shape,t.dtype,n),e)}var r=new gs(t.shape,e);return this.compileAndRun(r,[t])},o.prototype.pad=function(t,e,n){var r=i().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Yi(t.shape,e,n):new Xi(t.shape,e,n);return this.compileAndRun(r,[t])},o.prototype.transpose=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.transpose(t,e);var n=i().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xs(t.shape,e):new ys(t.shape,e);return this.compileAndRun(n,[t])},o.prototype.gather=function(t,e,n){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.gather(t,e,n);var r=new mi(t.shape,e.size,n);return this.compileAndRun(r,[t,e])},o.prototype.batchToSpaceND=function(t,e,n){C(t.rank<=4,(function(){return"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"}));var r=e.reduce((function(t,e){return t*e})),o=zr(t.shape,e,r),a=Gr(o.length,e.length),i=Hr(t.shape,e,r),s=qr(n,e.length),u=Kr(i,n,e.length);return t.reshape(o).transpose(a).reshape(i).slice(s,u)},o.prototype.spaceToBatchND=function(t,e,n){C(t.rank<=4,(function(){return"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"}));var r=e.reduce((function(t,e){return t*e})),o=[[0,0]];o.push.apply(o,n);for(var a=1+e.length;a<t.shape.length;++a)o.push([0,0]);var i=t.pad(o),s=zr(i.shape,e,r,!1),u=Gr(s.length,e.length,!1),c=Hr(i.shape,e,r,!1);return i.reshape(s).transpose(u).reshape(c)},o.prototype.reduce=function(t,e,n){var r=t.shape[0],o=t.shape[1],a=$r(o),i=new Ji({windowSize:a,inSize:o,batchSize:r},e),s=this.compileAndRun(i,[t],n);return 1===s.shape[1]?s:this.reduce(s,e,n)},o.prototype.argReduce=function(t,e,n){void 0===n&&(n=null);var r=t.shape[0],o=t.shape[1];null!=n&&(r=n.shape[0],o=n.shape[1]);var a=$r(o),i=new aa({windowSize:a,inSize:o,batchSize:r},e,null==n),s=[t];null!=n&&s.push(n);var u=this.compileAndRun(i,s,"int32");return 1===u.shape[1]?u:this.argReduce(t,e,u)},o.prototype.argReducePacked=function(t,e,n){void 0===n&&(n=null);var r=null!=n?n.shape:t.shape,o=$r(r[r.length-1]),a=new Ra(r,o,e,null==n),i=null==n?[t]:[t,n],s=this.compileAndRun(a,i,"int32");return s.rank===t.rank?this.argReducePacked(t,e,s):s},o.prototype.sum=function(t,e){Cn("sum",e,t.rank);var n=bn(t.shape,e),r=n[0],o=k(n[1]),a=t.as2D(-1,o),i=Tt(t.dtype);return this.reduce(a,"sum",i).reshape(r)},o.prototype.prod=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.prod(t,e);var n=bn(t.shape,e),r=n[0],o=k(n[1]),a=t.as2D(-1,o),i=Tt(t.dtype);return this.reduce(a,"prod",i).reshape(r)},o.prototype.unsortedSegmentSum=function(t,e,n){var r=0,o=En([r],t.rank),a=t;null!=o&&(a=t.transpose(o),r=In(1,t.rank)[0]);var i=function(t,e,n){for(var r=[],o=t.length,a=0;a<o;a++)a!==e?r.push(t[a]):r.push(n);return r}(a.shape,r,n),s=k([a.shape[r]]),u=a.as2D(-1,s),c=Tt(t.dtype),l=this.segOpCompute(u,"unsortedSegmentSum",e,c,n).reshape(i);return null!=o&&(l=l.transpose(Rn(o))),l},o.prototype.segOpCompute=function(t,e,n,r,o){var a=t.shape[0],i=t.shape[1],s=function(t,e){var n,r=!1;for(t<=Yr?(n=t,r=!0):n=Y(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=Y(t,n+1);return n}(i,o),u=new us({windowSize:s,inSize:i,batchSize:a,numSegments:o},e),c=this.compileAndRun(u,[t,n],r);return c.shape[1]===o?c:(n=Kn(0,o).tile([i/s]),this.segOpCompute(c,e,n,r,o))},o.prototype.argMinMaxReduce=function(t,e,n){var r=[e];if(Cn("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,t.rank),!i().getBool("WEBGL_PACK_REDUCE")||t.rank<=2){var o=bn(t.shape,r),a=o[0],s=k(o[1]),u=t.as2D(-1,s);return this.argReduce(u,n).reshape(a)}return this.argReducePacked(t,n)},o.prototype.argMin=function(t,e){return this.argMinMaxReduce(t,e,"min")},o.prototype.argMax=function(t,e){return this.argMinMaxReduce(t,e,"max")},o.prototype.cumsum=function(t,e,n,r){if(e!==t.rank-1)throw new Error("WebGL cumsum shader expects an inner-most axis="+(t.rank-1)+" but got axis="+e);var o=new ni(t.shape,n,r);return this.compileAndRun(o,[t])},o.prototype.equal=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(equal(a, b));\n","bool");var n=new Ba("return float(a == b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.notEqual=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(notEqual(a, b));\n","bool");var n=new Ba("return float(a != b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.less=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.less(t,e);if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThan(a, b));\n","bool");var n=new Ba("return float(a < b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.lessEqual=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThanEqual(a, b));\n","bool");var n=new Ba("return float(a <= b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.greater=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.greater(t,e);if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThan(a, b));\n","bool");var n=new Ba("return float(a > b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.greaterEqual=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThanEqual(a, b));\n","bool");var n=new Ba("return float(a >= b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.logicalNot=function(t){var e=new Cs(t.shape,"return float(!(x >= 1.0));");return this.compileAndRun(e,[t])},o.prototype.logicalAnd=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");var n=new Ba("return float(a >= 1.0 && b >= 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.logicalOr=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");var n=new Ba("return float(a >= 1.0 || b >= 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")},o.prototype.select=function(t,e,n){var r=new cs(t.rank,e.shape,e.rank);return this.compileAndRun(r,[t,e,n],Dt(e.dtype,n.dtype))},o.prototype.where=function(t){dn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var e=t.dataSync();return na(t.shape,e)},o.prototype.topk=function(t,e,n){return ea(t.dataSync(),t.shape,t.dtype,e)},o.prototype.min=function(t,e){Cn("min",e,t.rank);var n=bn(t.shape,e),r=n[0],o=k(n[1]),a=t.as2D(-1,o);return this.reduce(a,"min",a.dtype).reshape(r)},o.prototype.minimum=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.minimum(t,e);var n=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},o.prototype.mod=function(t,e){var n=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Ba("if (b == 0.0) return NAN;\n  return mod(a, b);",t.shape,e.shape);return this.compileAndRun(n,[t,e])},o.prototype.max=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.max(t,e);Cn("max",e,t.rank);var n=bn(t.shape,e),r=n[0],o=k(n[1]),a=t.as2D(-1,o);return this.reduce(a,"max",a.dtype).reshape(r)},o.prototype.maximum=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.maximum(t,e);var n=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},o.prototype.all=function(t,e){Cn("all",e,t.rank);var n=bn(t.shape,e),r=n[0],o=k(n[1]),a=t.as2D(-1,o);return this.reduce(a,"all",a.dtype).reshape(r)},o.prototype.any=function(t,e){Cn("any",e,t.rank);var n=bn(t.shape,e),r=n[0],o=k(n[1]),a=t.as2D(-1,o);return this.reduce(a,"any",a.dtype).reshape(r)},o.prototype.realDivide=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS")){return this.packedBinaryOp(t,e,"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n","float32",!0)}var n=new Ba("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",t.shape,e.shape);return this.compileAndRun(n,[t,e],"float32")},o.prototype.floorDiv=function(t,e){if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n","int32");var n=new Ba("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",t.shape,e.shape);return this.compileAndRun(n,[t,e],"int32")},o.prototype.add=function(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,Fa);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.add(t,e);var n=Dt(t.dtype,e.dtype);if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,Fa,n);var r=new Ba(Fa,t.shape,e.shape);return this.compileAndRun(r,[t,e],n)},o.prototype.packedUnaryOp=function(t,e,n){var r=new Xs(t.shape,e);return this.compileAndRun(r,[t],n)},o.prototype.packedBinaryOp=function(t,e,n,r,o){void 0===o&&(o=!1);var a=new La(n,t.shape,e.shape,o);return this.compileAndRun(a,[t,e],r)},o.prototype.complexSeparableBinaryOp=function(t,e,n){var r=this,o=this.texData.get(t.dataId),a=this.texData.get(e.dataId),i=[[o.complexTensors.real,a.complexTensors.real],[o.complexTensors.imag,a.complexTensors.imag]].map((function(o){var a=o[0],i=o[1],s=r.makeComplexComponentTensorInfo(t,a),u=r.makeComplexComponentTensorInfo(e,i),c=new Ba(n,t.shape,e.shape);return r.compileAndRun(c,[s,u],Dt(a.dtype,i.dtype))})),s=i[0],u=i[1],c=this.complex(s,u);return s.dispose(),u.dispose(),c},o.prototype.makeComplexComponentTensorInfo=function(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}},o.prototype.addN=function(t){if(1===t.length)return t[0];if(t.length>i().get("WEBGL_MAX_TEXTURES_IN_SHADER")){var e=Math.floor(t.length/2),n=this.addN(t.slice(0,e)),r=this.addN(t.slice(e));return this.addN([n,r])}var o=t.map((function(t){return t.dtype})).reduce((function(t,e){return Dt(t,e)})),a=t.map((function(t){return t.shape})),s=i().getBool("WEBGL_PACK")?new oa(t[0].shape,a):new ra(t[0].shape,a);return this.compileAndRun(s,t,o)},o.prototype.subtract=function(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,_a);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.subtract(t,e);var n=Dt(t.dtype,e.dtype);if(i().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,_a,t.dtype);var r=new Ba(_a,t.shape,e.shape);return this.compileAndRun(r,[t,e],n)},o.prototype.pow=function(t,e){var n=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Ba("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",t.shape,e.shape),r=Dt(t.dtype,e.dtype);return this.compileAndRun(n,[t,e],r)},o.prototype.ceil=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.ceil(t);if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Ns,t.dtype);var e=new Cs(t.shape,Ns);return this.compileAndRun(e,[t])},o.prototype.floor=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.floor(t);if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Fs,t.dtype);var e=new Cs(t.shape,Fs);return this.compileAndRun(e,[t])},o.prototype.sign=function(t){var e=new Cs(t.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(e,[t])},o.prototype.isNaN=function(t){var e=new Cs(t.shape,"return float(isnan(x));");return this.compileAndRun(e,[t],"bool")},o.prototype.isInf=function(t){var e=new Cs(t.shape,"return float(isinf(x));");return this.compileAndRun(e,[t],"bool")},o.prototype.isFinite=function(t){var e=new Cs(t.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(e,[t],"bool")},o.prototype.round=function(t){var e=new Cs(t.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(e,[t])},o.prototype.exp=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.exp(t);if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,_s,t.dtype);var e=new Cs(t.shape,_s);return this.compileAndRun(e,[t])},o.prototype.expm1=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.expm1(t);if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Os,t.dtype);var e=new Cs(t.shape,Os);return this.compileAndRun(e,[t])},o.prototype.softmax=function(t,e){var n=O([e],t.shape),r=this.max(t,n),o=wn(r.shape,n),a=this.subtract(t,r.reshape(o)),i=this.exp(a),s=this.sum(i,n).reshape(o);return this.realDivide(i,s)},o.prototype.log=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.log(t);if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",t.dtype);var e=new Cs(t.shape,"if (x < 0.0) return NAN;\n  return log(x);");return this.compileAndRun(e,[t])},o.prototype.log1p=function(t){var e=new Cs(t.shape,"return log(1.0 + x);");return this.compileAndRun(e,[t])},o.prototype.sqrt=function(t){var e=new Cs(t.shape,"return sqrt(x);");return this.compileAndRun(e,[t])},o.prototype.rsqrt=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.rsqrt(t);var e=new Cs(t.shape,"return inversesqrt(x);");return this.compileAndRun(e,[t])},o.prototype.reciprocal=function(t){var e=new Cs(t.shape,"return 1.0 / x;");return this.compileAndRun(e,[t])},o.prototype.relu=function(t){var e;return e=i().getBool("WEBGL_PACK")?new Xs(t.shape,qs):new Cs(t.shape,ks),this.compileAndRun(e,[t])},o.prototype.relu6=function(t){var e;return e=i().getBool("WEBGL_PACK")?new Xs(t.shape,Ks):new Cs(t.shape,Ss),this.compileAndRun(e,[t])},o.prototype.prelu=function(t,e){var n=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La(Pa,t.shape,e.shape):new Ba(Ma,t.shape,e.shape);return this.compileAndRun(n,[t,e])},o.prototype.elu=function(t){if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,js,t.dtype);var e=new Cs(t.shape,As);return this.compileAndRun(e,[t])},o.prototype.eluDer=function(t,e){var n=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",t.shape,e.shape):new Ba("return (b >= 1.0) ? a : a * (b + 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e])},o.prototype.selu=function(t){var e=new Cs(t.shape,Ds);return this.compileAndRun(e,[t])},o.prototype.int=function(t){var e=new Cs(t.shape,"return float(int(x));");return this.compileAndRun(e,[t],"int32")},o.prototype.clip=function(t,e,n){var r,o=(r=i().getBool("WEBGL_PACK_CLIP")?new Ua(t.shape):new Wa(t.shape)).getCustomSetupFunc(e,n);return this.compileAndRun(r,[t],null,o)},o.prototype.abs=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.abs(t);if(i().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Is,t.dtype);var e=new Cs(t.shape,Is);return this.compileAndRun(e,[t])},o.prototype.complexAbs=function(t){var e=this.texData.get(t.dataId),n=new Va(t.shape),r=[this.makeComplexComponentTensorInfo(t,e.complexTensors.real),this.makeComplexComponentTensorInfo(t,e.complexTensors.imag)];return this.compileAndRun(n,r)},o.prototype.sigmoid=function(t){var e=new Cs(t.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(e,[t])},o.prototype.softplus=function(t){var e=new Cs(t.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(e,[t])},o.prototype.sin=function(t){var e=new Cs(t.shape,Ms);return this.compileAndRun(e,[t])},o.prototype.cos=function(t){var e=new Cs(t.shape,Bs);return this.compileAndRun(e,[t])},o.prototype.tan=function(t){var e=new Cs(t.shape,"return tan(x);");return this.compileAndRun(e,[t])},o.prototype.asin=function(t){var e=new Cs(t.shape,Ps);return this.compileAndRun(e,[t])},o.prototype.acos=function(t){var e=new Cs(t.shape,Ls);return this.compileAndRun(e,[t])},o.prototype.atan=function(t){var e=new Cs(t.shape,Ws);return this.compileAndRun(e,[t])},o.prototype.atan2=function(t,e){var n=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},o.prototype.sinh=function(t){var e=new Cs(t.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])},o.prototype.cosh=function(t){var e=new Cs(t.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])},o.prototype.tanh=function(t){var e=new Cs(t.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(e,[t])},o.prototype.asinh=function(t){var e=new Cs(t.shape,Us);return this.compileAndRun(e,[t])},o.prototype.acosh=function(t){var e=new Cs(t.shape,Vs);return this.compileAndRun(e,[t])},o.prototype.atanh=function(t){var e=new Cs(t.shape,zs);return this.compileAndRun(e,[t])},o.prototype.erf=function(t){var e=new Cs(t.shape,'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');return this.compileAndRun(e,[t])},o.prototype.step=function(t,e){var n=new Cs(t.shape,function(t){return void 0===t&&(t=0),Es+"\n    return x > 0.0 ? 1.0 : float("+t+");\n  "}(e));return this.compileAndRun(n,[t])},o.prototype.conv2dByMatMul=function(t,e,n,r,o,a){var s=t.shape,u=this.texData.get(t.dataId),c=n.inChannels,l=s[0]*s[1]*s[2],h=n.outChannels,f="channelsLast"===n.dataFormat,d=(1===l||1===h)&&c>1e3,p=s[2]%2!=0&&!!u.isPacked;if(d||!i().getBool("WEBGL_LAZILY_UNPACK")||!i().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!p){var v=f?s[0]*s[1]*s[2]:s[0]*s[2]*s[3],m=this.reshape(t,[1,v,n.inChannels]),g=this.reshape(e,[1,n.inChannels,n.outChannels]);return this.reshape(this.fusedBatchMatMul({a:m,b:g,transposeA:!1,transposeB:!1,bias:r,activation:o,preluActivationWeights:a}),n.outShape)}var y=f?s[0]*s[1]*(s[2]+1):s[0]*s[2]*(s[3]+1),x={dataId:t.dataId,shape:[1,y,n.inChannels],dtype:t.dtype},b=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,C(_e(u.shape,x.shape),(function(){return"packed reshape "+u.shape+" to "+x.shape+" isn't free"}));var w=this.reshape(e,[1,n.inChannels,n.outChannels]),E=this.fusedBatchMatMul({a:x,b:w,transposeA:!1,transposeB:!1,bias:r,activation:o,preluActivationWeights:a}),R=this.texData.get(E.dataId);return C(R.isPacked,(function(){return"batchMatMul result is expected to be packed"})),u.shape=b,R.shape=n.outShape,Lt.makeTensorFromDataId(E.dataId,n.outShape,E.dtype)},o.prototype.conv2dWithIm2Row=function(t,e,n,r,o,a){var i=n.filterWidth,s=n.filterHeight,u=n.inChannels,c=n.outWidth,l=n.outHeight,h="channelsLast"===n.dataFormat,f=i*s*u,d=l*c,p=[f,d],v=t.squeeze([0]),m=e.reshape([1,f,-1]),g=new Li(p,v.shape,n),y=this.compileAndRun(g,[v]).reshape([1,p[0],p[1]]),x=null!=r,b=null!=a,w=o?Qs(o,!0):null,C=new Hi(y.shape,[1,d,n.outChannels],!0,!1,x,w,b),E=[y,m];r&&E.push(r),b&&E.push(a);var R=this.compileAndRun(C,E);return h?R.reshape([1,l,c,n.outChannels]):R.reshape([1,n.outChannels,l,c])},o.prototype.fusedConv2d=function(t){var e=t.input,n=t.filter,r=t.convInfo,o=t.bias,a=t.activation,s=t.preluActivationWeights;if(1===r.filterHeight&&1===r.filterWidth&&1===r.dilationHeight&&1===r.dilationWidth&&1===r.strideHeight&&1===r.strideWidth&&("SAME"===r.padInfo.type||"VALID"===r.padInfo.type))return this.conv2dByMatMul(e,n,r,o,a,s);if(i().getBool("WEBGL_CONV_IM2COL")&&1===e.shape[0])return this.conv2dWithIm2Row(e,n,r,o,a,s);var u=null!=o,c=null!=s,l=a?Qs(a,!1):null,h=new Qa(r,u,l,c),f=[e,n];return o&&f.push(o),s&&f.push(s),this.compileAndRun(h,f)},o.prototype.conv2d=function(t,e,n){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n);if(i().getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n);var r=new Qa(n);return this.compileAndRun(r,[t,e])},o.prototype.conv2dDerInput=function(t,e,n){var r=new Ka(n);return this.compileAndRun(r,[t,e])},o.prototype.conv2dDerFilter=function(t,e,n){var r=new qa(n);return this.compileAndRun(r,[t,e])},o.prototype.fusedDepthwiseConv2D=function(t){var e,n=t.input,r=t.filter,o=t.convInfo,a=t.bias,s=t.activation,u=t.preluActivationWeights,c=i().getBool("WEBGL_PACK_DEPTHWISECONV")&&o.strideWidth<=2&&o.outChannels/o.inChannels==1,l=s?Qs(s,c):null,h=[n,r],f=null!=a,d=null!=u;return f&&h.push(a),d&&h.push(u),c?(e=new ti(o,f,l,d),this.compileAndRun(e,h)):(e=new Za(o,f,l,d),this.compileAndRun(e,h))},o.prototype.depthwiseConv2D=function(t,e,n){var r;return i().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1?(r=new ti(n),this.compileAndRun(r,[t,e])):(r=new Za(n),this.compileAndRun(r,[t,e]))},o.prototype.depthwiseConv2DDerInput=function(t,e,n){var r=new $a(n);return this.compileAndRun(r,[t,e])},o.prototype.depthwiseConv2DDerFilter=function(t,e,n){var r=new Ya(n);return this.compileAndRun(r,[t,e])},o.prototype.conv3d=function(t,e,n){var r=new Ja(n);return this.compileAndRun(r,[t,e])},o.prototype.conv3dDerInput=function(t,e,n){var r=new Xa(n);return this.compileAndRun(r,[t,e])},o.prototype.conv3dDerFilter=function(t,e,n){var r=new ja(n);return this.compileAndRun(r,[t,e])},o.prototype.maxPool=function(t,e){var n=new $i(e,"max",!1);return this.compileAndRun(n,[t])},o.prototype.avgPool=function(t,e){var n=new $i(e,"avg",!1);return this.compileAndRun(n,[t],"float32")},o.prototype.maxPoolBackprop=function(t,e,n,r){var o=new $i(r,"max",!0),a=this.compileAndRun(o,[e]),i=new zi(r),s=this.compileAndRun(i,[t,a],e.dtype);return a.dispose(),s},o.prototype.avgPoolBackprop=function(t,e,n){var r=new Ia(n);return this.compileAndRun(r,[t],e.dtype)},o.prototype.cast=function(t,e){return Po(t,e,this)},o.prototype.unstack=function(t,e){for(var n=t.shape[e],r=new Array(t.rank-1),o=0,a=0;a<t.rank;a++)a!==e&&(r[o++]=t.shape[a]);var i=new Array(t.rank).fill(0),s=t.shape.slice();s[e]=1;var u=new Array(n);for(a=0;a<u.length;a++)i[e]=a,u[a]=this.slice(t,i,s).reshape(r);return u},o.prototype.avgPool3d=function(t,e){var n=new Qi(e,"avg",!1);return this.compileAndRun(n,[t],"float32")},o.prototype.avgPool3dBackprop=function(t,e,n){var r=new ka(n);return this.compileAndRun(r,[t],e.dtype)},o.prototype.maxPool3d=function(t,e){var n=new Qi(e,"max",!1);return this.compileAndRun(n,[t],"float32")},o.prototype.maxPool3dBackprop=function(t,e,n,r){var o=new Qi(r,"max",!0),a=this.compileAndRun(o,[e]),i=new Gi(r),s=this.compileAndRun(i,[t,a],e.dtype);return a.dispose(),s},o.prototype.reshape=function(t,e){var n=this.texData.get(t.dataId);if(n.isPacked&&!_e(t.shape,e)&&(null===n.texture||!_e(n.shape,e))){var r=this.packedReshape(t,e);return Lt.makeTensorFromDataId(r.dataId,r.shape,r.dtype)}return Lo(t,e)},o.prototype.resizeBilinear=function(t,e,n,r){var o=i().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ns(t.shape,e,n,r):new es(t.shape,e,n,r);return this.compileAndRun(o,[t],"float32")},o.prototype.resizeBilinearBackprop=function(t,e,n){var r=new ts(t,e,n);return this.compileAndRun(r,[t])},o.prototype.resizeNearestNeighbor=function(t,e,n,r){var o=new os(t.shape,e,n,r);return this.compileAndRun(o,[t])},o.prototype.resizeNearestNeighborBackprop=function(t,e,n){var r=new rs(t,e,n);return this.compileAndRun(r,[t])},o.prototype.multinomial=function(t,e,n,r){var o=e?t:go(t),a=o.shape[0],i=o.shape[1],s=new qi(a,i,n),u=s.getCustomSetupFunc(r);return this.compileAndRun(s,[o],"int32",u)},o.prototype.oneHot=function(t,e,n,r){var o=new Ki(t.size,e,n,r);return this.compileAndRun(o,[t])},o.prototype.diag=function(t){var e=new si(t.size);return this.compileAndRun(e,[t])},o.prototype.nonMaxSuppression=function(t,e,n,r,o){return dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"),jo(t.dataSync(),e.dataSync(),n,r,o)},o.prototype.cropAndResize=function(t,e,n,r,o,a){var i=new ei(t.shape,e.shape,r,o,a);return this.compileAndRun(i,[t,e,n],"float32")},o.prototype.depthToSpace=function(t,e,n){C(e>1,(function(){return"blockSize should be > 1 for depthToSpace, but was: "+e}));var r=t.shape[0],o="NHWC"===n?t.shape[1]:t.shape[2],a="NHWC"===n?t.shape[2]:t.shape[3],i="NHWC"===n?t.shape[3]:t.shape[1],s=o*e,u=a*e,c=i/(e*e),l=new ii("NHWC"===n?[r,s,u,c]:[r,c,s,u],e,n);return this.compileAndRun(l,[t])},o.prototype.split=function(t,e,n){return Zo(t,e,n)},o.prototype.scatterND=function(t,e,n){var r=Zr(0,t,n),o=r.sliceRank,a=r.numUpdates,i=r.sliceSize,s=r.strides,u=r.outputSize,c=[u/i,i],l=t.reshape([a,o]),h=e.reshape([a,i]);if(0===u)return Lo(Fn([]),n);var f=On(0),d=new ss(a,o,l.rank,h.rank,s,c);return this.compileAndRun(d,[h,l,f]).reshape(n)},o.prototype.sparseToDense=function(t,e,n,r){var o=Zr(0,t,n),a=o.sliceRank,i=o.numUpdates,s=o.strides,u=o.outputSize,c=new ss(i,a,t.rank,e.rank,s,[u,1],!1);return this.compileAndRun(c,[e,t,r]).reshape(n)},o.prototype.fft=function(t){return this.fftImpl(t,!1)},o.prototype.ifft=function(t){return this.fftImpl(t,!0)},o.prototype.fftImpl=function(t,e){var n=this.texData.get(t.dataId),r=new pi(fi,t.shape,e),o=new pi(di,t.shape,e),a=[this.makeComplexComponentTensorInfo(t,n.complexTensors.real),this.makeComplexComponentTensorInfo(t,n.complexTensors.imag)],i=this.compileAndRun(r,a),s=this.compileAndRun(o,a),u=this.complex(i,s).as2D(t.shape[0],t.shape[1]);return i.dispose(),s.dispose(),u},o.prototype.gatherND=function(t,e){var n=e.shape,r=n[n.length-1],o=jr(t,e),a=o[0],i=o[1],s=o[2],u=o[3],c=e.reshape([i,r]),l=t.reshape([t.size/s,s]),h=new gi(r,u,[i,s]);return this.compileAndRun(h,[l,c]).reshape(a)},o.prototype.fill=function(t,e,n){if("string"===(n=n||j(e))){var r=P(n,k(t));return r.fill(e),Lt.makeTensor(r,t,n,this)}var o=new vi(t,e),a=o.getCustomSetupFunc(e);return this.compileAndRun(o,[],n,a)},o.prototype.onesLike=function(t){if("string"===t.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(t.shape,1,t.dtype)},o.prototype.zerosLike=function(t){return this.fill(t.shape,"string"===t.dtype?"":0,t.dtype)},o.prototype.linspace=function(t,e,n){return Wo(t,e,n)},o.prototype.makeTensorInfo=function(t,e){var n=this.write(null,t,e);return this.texData.get(n).usage=null,{dataId:n,shape:t,dtype:e}},o.prototype.makeOutput=function(t,e){var n=this.makeTensorInfo(t,e).dataId;return Lt.makeTensorFromDataId(n,t,e,this)},o.prototype.unpackTensor=function(t){var e=new Ys(t.shape);return this.runWebGLProgram(e,[t],t.dtype)},o.prototype.packTensor=function(t){var e=new ji(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)},o.prototype.packedReshape=function(t,e){var n=[Ae(t.shape)].concat(De(t.shape)),r={dtype:t.dtype,shape:n,dataId:t.dataId},o=[Ae(e)].concat(De(e)),a=new Zi(o,n),i=this.runWebGLProgram(a,[r],t.dtype,null,!0);return{dataId:i.dataId,shape:e,dtype:i.dtype}},o.prototype.decode=function(t){var e,n=this.texData.get(t),r=n.isPacked,o=n.shape,a=n.dtype,i=Te(o);e=r?new ai(i):new oi(i);return{dtype:a,shape:o,dataId:this.runWebGLProgram(e,[{shape:i,dtype:a,dataId:t}],a,null,!0).dataId}},o.prototype.runWebGLProgram=function(t,e,n,r,o){var a=this;void 0===o&&(o=!1);var s=this.makeTensorInfo(t.outputShape,n),u=this.texData.get(s.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===Vt.DENSE){var c=Yt(t.outputShape);u.texShape=c.map((function(t){return 2*t}))}if(null!=t.outTexUsage&&(u.usage=t.outTexUsage),0===k(s.shape))return u.values=B(s.dtype,0),s;var l=[],h=e.map((function(e){if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var n=a.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&k(e.shape)<=i().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.packedInputs)e=n.isPacked?a.unpackTensor(e):a.packTensor(e),l.push(e),n=a.texData.get(e.dataId);else if(n.isPacked&&!_e(n.shape,e.shape)){var r=e,o=e.shape;e.shape=n.shape,e=a.packedReshape(e,o),l.push(e),n=a.texData.get(e.dataId),r.shape=o}return a.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}}));this.uploadToGPU(s.dataId);var f,d={shape:s.shape,texData:u,isUniform:!1},p=function(t,e,n){var r="";e.concat(n).forEach((function(t){var e=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0,n=t.isUniform?"uniform":t.texData.texShape;r+=t.shape+"_"+n+"_"+e}));var o=t.userCode,a=t.constructor.name;return a+="_"+r+"_"+o}(t,h,d),v=this.getAndSaveBinary(p,(function(){return function(t,e,n,r){var o=e.userCode,a=n.map((function(t,n){var r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}})),s=a.map((function(t){return t.shapeInfo})),u={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},c=fa(a,u,o,e.packedInputs),l=t.createProgram(c),h=null,f=t.getUniformLocation(l,"NAN",!1);1===i().getNumber("WEBGL_VERSION")&&(h=t.getUniformLocation(l,"INFINITY",!1));for(var d={},p=0;p<e.variableNames.length;p++){var v=e.variableNames[p];d[v]=t.getUniformLocation(l,v,!1),d["offset"+v]=t.getUniformLocation(l,"offset"+v,!1)}return{program:e,source:c,webGLProgram:l,uniformLocations:d,inShapeInfos:s,outShapeInfo:u,infLoc:h,nanLoc:f}}(a.gpgpu,t,h,d)})),m=null!=this.activeTimers;if(m&&(f=this.startTimer()),function(t,e,n,r,o){Pi(e.inShapeInfos,n),Pi([e.outShapeInfo],[r]);var a=r.texData.texture,s=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(a,s[0],s[1]):t.setOutputMatrixTexture(a,s[0],s[1]),t.setProgram(e.webGLProgram),1===i().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach((function(n,r){var o=e.program.variableNames[r],a=e.uniformLocations[o],i=e.uniformLocations["offset"+o];if(null!=a)if(n.isUniform)if(k(n.shape)<2)t.gl.uniform1f(a,n.uniformValues[0]);else{var s=n.uniformValues;s instanceof Float32Array||(s=new Float32Array(s)),t.gl.uniform1fv(a,s)}else null!=n.texData.slice&&null!=i&&t.gl.uniform1i(i,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,a,r)})),null!=o&&o(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,v,h,d,r),l.forEach((function(t){return a.disposeData(t.dataId)})),m&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)})),!i().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===o){var g=this.unpackTensor(s);return this.disposeData(s.dataId),g}return s},o.prototype.compileAndRun=function(t,e,n,r,o){void 0===o&&(o=!1),n=n||e[0].dtype;var a=this.runWebGLProgram(t,e,n,r,o);return Lt.makeTensorFromDataId(a.dataId,a.shape,a.dtype)},o.prototype.getAndSaveBinary=function(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]},o.prototype.getTextureManager=function(){return this.textureManager},o.prototype.dispose=function(){var t=this;if(!this.disposed){if(!i().getBool("IS_TEST"))Object.keys(this.binaryCache).forEach((function(e){t.gpgpu.deleteProgram(t.binaryCache[e].webGLProgram),delete t.binaryCache[e]}));this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}},o.prototype.floatPrecision=function(){var t=this;return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Ze((function(){if(!i().get("WEBGL_RENDER_FLOAT32_ENABLED")){var e=i().getBool("DEBUG");i().set("DEBUG",!1);var n=t.abs(On(1e-8)).dataSync()[0];if(i().set("DEBUG",e),n>0)return 32}return 16}))),this.floatPrecisionValue},o.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},o.prototype.uploadToGPU=function(t){var e,n=this.texData.get(t),r=n.shape,o=n.dtype,a=n.values,i=n.texture,s=n.usage,u=n.isPacked;if(null==i){var c,l=null!=this.activeTimers;l&&(c=et());var h=n.texShape;if(null==h&&(h=Ne(r,u),n.texShape=h),null!=a){var f=Te(r),d=void 0,p=h[1],v=h[0],m=a instanceof Uint8Array;u?(p=(e=$t(h[0],h[1]))[0],v=e[1],d=new hi(f,[v,p],m)):d=new li(f,[v,p],m);var g=this.makeTensorInfo([v,p],o);this.texData.get(g.dataId).usage=m?zt.PIXELS:zt.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId),p,v,a);var y=this.runWebGLProgram(d,[g],o,null,!0),x=this.texData.get(y.dataId);n.texture=x.texture,n.texShape=x.texShape,n.isPacked=x.isPacked,n.usage=x.usage,this.disposeData(g.dataId),this.texData.delete(y.dataId),n.values=null,l&&(this.uploadWaitMs+=et()-c)}else{var b=this.acquireTexture(h,s,o,u);n.texture=b}}},o.prototype.convertAndCacheOnCPU=function(t,e){var n=this.texData.get(t),r=n.dtype;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){for(var n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length),r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}throw new Error("Unknown dtype "+e)}(e,r)),n.values},o.prototype.acquireTexture=function(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){var o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+o+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(t,e,r)},o.prototype.computeBytes=function(t,e){return t[0]*t[1]*z(e)},o}(bo);Wt()&&Lt.registerBackend("webgl",(function(){return new Zs}),2);var tu=An({square_:function(t){var e=mn(t,"x","square"),n=[e];return Lt.runKernelFunc((function(t,n){return n([e]),t.square(e)}),{x:e},null,"Square",{},n,[])}}),eu="SquaredDifference";var nu=An({squaredDifference_:function(t,e){var n,r=mn(t,"a","squaredDifference"),o=mn(e,"b","squaredDifference");n=Nt(r,o),r=n[0],o=n[1],Ro(r.shape,o.shape);var a={a:r,b:o},i=[r,o];return Lt.runKernelFunc((function(t,e){var n=t.squaredDifference(r,o);return e([r,o]),n}),a,(function(t,e){var n=e[0],r=e[1],o=On(2);return{a:function(){return t.mul(n.sub(r).mul(o))},b:function(){return t.mul(r.sub(n).mul(o))}}}),eu,{},i,[])}});var ru=An({abs_:function(t){var e=mn(t,"x","abs");return"complex64"===e.dtype?Lt.runKernelFunc((function(t){return t.complexAbs(e)}),{$x:e}):Lt.runKernelFunc((function(t,n){var r=t.abs(e);return n([e]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return t.mul(n.toFloat().step(-1))}}}),"Abs")}}),ou=An({acos_:function(t){var e=mn(t,"x","acos");return Lt.runKernelFunc((function(t,n){var r=t.acos(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.divStrict(On(1).sub(n.toFloat().square()).sqrt()).neg()}}}))}}),au=An({acosh_:function(t){var e=mn(t,"x","acosh");return Lt.runKernelFunc((function(t,n){var r=t.acosh(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.divStrict(n.toFloat().square().sub(1).sqrt())}}}))}}),iu=An({asin_:function(t){var e=mn(t,"x","asin");return Lt.runKernelFunc((function(t,n){var r=t.asin(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.divStrict(On(1).sub(n.toFloat().square()).sqrt())}}}))}}),su=An({asinh_:function(t){var e=mn(t,"x","asinh");return Lt.runKernelFunc((function(t,n){var r=t.asinh(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.divStrict(On(1).add(n.toFloat().square()).sqrt())}}}))}}),uu=An({atan_:function(t){var e=mn(t,"x","atan");return Lt.runKernelFunc((function(t,n){var r=t.atan(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.div(n.toFloat().square().add(1))}}}))}}),cu=An({atanh_:function(t){var e=mn(t,"x","atanh");return Lt.runKernelFunc((function(t,n){var r=t.atanh(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.div(On(1).sub(n.toFloat().square()))}}}))}}),lu=An({ceil_:function(t){var e=mn(t,"x","ceil");return Lt.runKernelFunc((function(t){return t.ceil(e)}),{$x:e},(function(t){return{$x:function(){return Xn(t)}}}))}}),hu=An({clipByValue_:function(t,e,n){var r=mn(t,"x","clipByValue");C(e<=n,(function(){return"Error in clip: min ("+e+") must be less than or equal to max ("+n+")."}));var o=[r],a={min:e,max:n};return Lt.runKernelFunc((function(t,o){var a=t.clip(r,e,n);return o([r]),a}),{x:r},(function(t,r){var o=r[0];return{x:function(){return t.where(o.greaterEqual(e).logicalAnd(o.lessEqual(n)),Xn(t))}}}),"ClipByValue",a,o)}}),fu=An({cos_:function(t){var e=mn(t,"x","cos"),n=[e];return Lt.runKernelFunc((function(t,n){var r=t.cos(e);return n([e]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return n.toFloat().sin().neg().mul(t)}}}),"Cos",{},n)}}),du=An({cosh_:function(t){var e=mn(t,"x","cosh");return Lt.runKernelFunc((function(t,n){var r=t.cosh(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return n.toFloat().sinh().mulStrict(t)}}}))}}),pu=An({erf_:function(t){var e=mn(t,"x","erf");return C("int32"===e.dtype||"float32"===e.dtype,(function(){return"Input dtype must be `int32` or `float32`."})),"int32"===e.dtype&&(e=e.toFloat()),Lt.runKernelFunc((function(t,n){var r=t.erf(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.mul(n.square().neg().exp().mul(2/Math.sqrt(Math.PI)))}}}))}}),vu=An({exp_:function(t){var e=mn(t,"x","exp");return Lt.runKernelFunc((function(t,n){var r=t.exp(e);return n([r]),r}),{x:e},(function(t,e){return{x:function(){return t.mulStrict(e[0])}}}),"Exp",{},[],[!0])}}),mu=An({expm1_:function(t){var e=mn(t,"x","expm1");return Lt.runKernelFunc((function(t,n){var r=t.expm1(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.mul(n.exp())}}}))}}),gu=An({floor_:function(t){var e=mn(t,"x","floor");return Lt.runKernelFunc((function(t){return t.floor(e)}),{$x:e},(function(t){return{$x:function(){return Xn(t)}}}))}}),yu=An({log_:function(t){var e=mn(t,"x","log"),n=[e];return Lt.runKernelFunc((function(t,n){var r=t.log(e);return n([e]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return t.div(n.toFloat())}}}),"Log",{},n)}}),xu=An({log1p_:function(t){var e=mn(t,"x","log1p");return Lt.runKernelFunc((function(t,n){var r=t.log1p(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.div(n.add(1))}}}))}}),bu=An({logSigmoid_:function(t){var e=mn(t,"x","logSigmoid");return Lt.runKernelFunc((function(t,n){var r=t.softplus(e.neg()).neg();return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.mul(n.neg().sigmoid())}}}))}}),wu=An({neg_:function(t){var e=mn(t,"x","neg"),n=[e];return Lt.runKernelFunc((function(t){return t.neg(e)}),{x:e},(function(t){return{x:function(){return t.neg()}}}),"Neg",{},n)}}),Cu=An({reciprocal_:function(t){var e=mn(t,"x","reciprocal");return Lt.runKernelFunc((function(t,n){var r=t.reciprocal(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.div(n.square().neg())}}}))}}),Eu=An({round_:function(t){var e=mn(t,"x","round");return Lt.runKernelFunc((function(t){return t.round(e)}),{$x:e},(function(t){return{$x:function(){return Xn(t)}}}))}}),Ru=An({rsqrt_:function(t){var e=mn(t,"x","rsqrt"),n=[e];return Lt.runKernelFunc((function(t,n){var r=t.rsqrt(e);return n([e]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return t.div(n.pow(1.5).mul(2)).neg()}}}),"Rsqrt",{},n)}}),Iu=An({sigmoid_:function(t){var e=mn(t,"x","sigmoid");return Lt.runKernelFunc((function(t,n){var r=t.sigmoid(e);return n([r]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return t.mul(n.mul(On(1).sub(n)))}}}),"Sigmoid")}}),ku=An({sign_:function(t){var e=mn(t,"x","sign");return Lt.runKernelFunc((function(t){return t.sign(e)}),{$x:e},(function(t){return{$x:function(){return Xn(t)}}}))}}),Su=An({isNaN_:function(t){var e=mn(t,"x","isNaN");return Lt.runKernelFunc((function(t){return t.isNaN(e)}),{$x:e},(function(t){return{$x:function(){return Xn(t)}}}))}}),Au=An({isInf_:function(t){var e=mn(t,"x","isInf");return Lt.runKernelFunc((function(t){return t.isInf(e)}),{$x:e},(function(t){return{$x:function(){return Xn(t)}}}))}}),Du=An({isFinite_:function(t){var e=mn(t,"x","isFinite");return Lt.runKernelFunc((function(t){return t.isFinite(e)}),{$x:e},(function(t){return{$x:function(){return Xn(t)}}}))}}),Tu=An({sin_:function(t){var e=mn(t,"x","sin"),n=[e];return Lt.runKernelFunc((function(t,n){var r=t.sin(e);return n([e]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return n.toFloat().cos().mul(t)}}}),"Sin",{},n)}}),Nu=An({sinh_:function(t){var e=mn(t,"x","sinh");return Lt.runKernelFunc((function(t,n){var r=t.sinh(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return n.toFloat().cosh().mulStrict(t)}}}))}}),Fu=An({softplus_:function(t){var e=mn(t,"x","softplus");return Lt.runKernelFunc((function(t,n){var r=t.softplus(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.mul(n.sigmoid())}}}))}}),_u=An({sqrt_:function(t){var e=mn(t,"x","sqrt");return Lt.runKernelFunc((function(t,n){var r=t.sqrt(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.div(n.toFloat().sqrt().mul(2))}}}))}}),Ou=An({step_:function(t,e){void 0===e&&(e=0);var n=mn(t,"x","step");return Lt.runKernelFunc((function(t){return t.step(n,e)}),{$x:n},(function(t){return{$x:function(){return Xn(t)}}}))}}),Mu=An({tan_:function(t){var e=mn(t,"x","tan");return Lt.runKernelFunc((function(t,n){var r=t.tan(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return t.div(n.cos().square())}}}))}}),Bu=An({tanh_:function(t){var e=mn(t,"x","tanh");return Lt.runKernelFunc((function(t,n){var r=t.tanh(e);return n([r]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return On(1).sub(n.square()).mulStrict(t)}}}),"Tanh",{},null,[!0])}});function Pu(t,e,n,r,o,a){var i,s,u=mn(t,"x","batchNorm"),c=mn(e,"mean","batchNorm"),l=mn(n,"variance","batchNorm");return null!=o&&(i=mn(o,"scale","batchNorm")),null!=r&&(s=mn(r,"offset","batchNorm")),C(2===u.rank,(function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+u.rank+"."})),C(2===c.rank||1===c.rank,(function(){return"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank "+c.rank+"."})),C(2===l.rank||1===l.rank,(function(){return"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank "+l.rank+"."})),null!=i&&C(2===i.rank||1===i.rank,(function(){return"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank "+i.rank+"."})),null!=s&&C(2===s.rank||1===s.rank,(function(){return"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank "+s.rank+"."})),Uu(u,c,l,s,i,a)}function Lu(t,e,n,r,o,a){var i,s,u=mn(t,"x","batchNorm"),c=mn(e,"mean","batchNorm"),l=mn(n,"variance","batchNorm");return null!=o&&(i=mn(o,"scale","batchNorm")),null!=r&&(s=mn(r,"offset","batchNorm")),C(3===u.rank,(function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+u.rank+"."})),C(3===c.rank||1===c.rank,(function(){return"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank "+c.rank+"."})),C(3===l.rank||1===l.rank,(function(){return"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank "+l.rank+"."})),null!=i&&C(3===i.rank||1===i.rank,(function(){return"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank "+i.rank+"."})),null!=s&&C(3===s.rank||1===s.rank,(function(){return"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank "+s.rank+"."})),Uu(u,c,l,s,i,a)}function Wu(t,e,n,r,o,a){var i,s,u=mn(t,"x","batchNorm"),c=mn(e,"mean","batchNorm"),l=mn(n,"variance","batchNorm");return null!=o&&(i=mn(o,"scale","batchNorm")),null!=r&&(s=mn(r,"offset","batchNorm")),C(4===u.rank,(function(){return"Error in batchNorm4D: x must be rank 4 but got rank "+u.rank+"."})),C(4===c.rank||1===c.rank,(function(){return"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank "+c.rank+"."})),C(4===l.rank||1===l.rank,(function(){return"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank "+l.rank+"."})),null!=i&&C(4===i.rank||1===i.rank,(function(){return"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank "+i.rank+"."})),null!=s&&C(4===s.rank||1===s.rank,(function(){return"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank "+s.rank+"."})),Uu(u,c,l,s,i,a)}function Uu(t,e,n,r,o,a){null==a&&(a=.001);var i,s,u,c=mn(t,"x","batchNorm"),l=mn(e,"mean","batchNorm"),h=mn(n,"variance","batchNorm");null!=o&&(i=mn(o,"scale","batchNorm")),null!=r&&(s=mn(r,"offset","batchNorm")),C(l.rank===h.rank,(function(){return"Batch normalization gradient requires mean and variance to have equal ranks."})),C(null==s||l.rank===s.rank,(function(){return"Batch normalization gradient requires mean and offset to have equal ranks."})),C(null==i||l.rank===i.rank,(function(){return"Batch normalization gradient requires mean and scale to have equal ranks."})),u=0===c.rank||1===c.rank?c.as4D(1,1,1,c.size):2===c.rank?c.as4D(1,1,c.shape[0],c.shape[1]):3===c.rank?c.as4D(1,c.shape[0],c.shape[1],c.shape[2]):c;var f=[c,l,h,i];return Lt.runKernelFunc((function(t,e){var n=t.batchNormalization(u,Vu(l),Vu(h),a,Vu(i),Vu(s));return e([c,l,h,i]),n}),{x:c,mean:l,variance:h,scale:i,offset:s},(function(t,e){var n=e,r=n[0],o=n[1],i=n[2],s=n[3],c=null==s?On(1):s,l=Eo(o.shape,u.shape),h=[];if(1===o.rank){for(var f=0;f<u.shape.length-1;++f)h.push(u.shape[f]);h.push(1)}var d=r.sub(o),p=t.mul(c),v=Ru(i.add(On(a))),m=v.mul(v).mul(v).mul(On(-.5));return{x:function(){return 1===o.rank?t.mul(Lr(v.as4D(1,1,1,o.shape[0]),h)).mul(c).reshape(r.shape):t.mul(v).mul(c).reshape(r.shape)},mean:function(){var t=v.mul(On(-1)).mul(p);return 1===o.rank&&(t=t.sum(l)),t.reshape(o.shape)},variance:function(){var t=m.mul(d).mul(p);return 1===o.rank&&(t=t.sum(l)),t.reshape(o.shape)},scale:function(){var e=d.mul(v),n=t.mul(e);return 1===o.rank&&(n=n.sum(l)),n.reshape(o.shape)},offset:function(){var e=t;return 1===o.rank&&(e=e.sum(l)),e.reshape(o.shape)}}}),"BatchNormalization",{varianceEpsilon:a},f).reshape(c.shape)}function Vu(t){return null==t?null:0===t.rank?t.as1D():1===t.rank?t:2===t.rank?t.as4D(1,1,t.shape[0],t.shape[1]):3===t.rank?t.as4D(1,t.shape[0],t.shape[1],t.shape[2]):t}function zu(){Xe("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon")}var Gu=An({batchNormalization2d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),zu(),Pu(t,e,n,a,o,r)}}),Hu=An({batchNormalization3d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),zu(),Lu(t,e,n,a,o,r)}}),qu=An({batchNormalization4d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),zu(),Wu(t,e,n,a,o,r)}}),Ku=An({batchNormalization_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),zu(),Uu(t,e,n,a,o,r)}}),ju=An({batchNorm_:Uu}),Xu=An({batchNorm2d_:Pu}),Yu=An({batchNorm3d_:Lu}),$u=An({batchNorm4d_:Wu});var Qu=An({logicalAnd_:function(t,e){var n=mn(t,"a","logicalAnd","bool"),r=mn(e,"b","logicalAnd","bool");return Ro(n.shape,r.shape),Lt.runKernelFunc((function(t){return t.logicalAnd(n,r)}),{a:n,b:r},null,"LogicalAnd")}}),Ju=An({logicalNot_:function(t){var e=mn(t,"x","logicalNot","bool");return Lt.runKernelFunc((function(t){return t.logicalNot(e)}),{$x:e})}}),Zu=An({logicalOr_:function(t,e){var n=mn(t,"a","logicalOr","bool"),r=mn(e,"b","logicalOr","bool");return Ro(n.shape,r.shape),Lt.runKernelFunc((function(t){return t.logicalOr(n,r)}),{$a:n,$b:r})}}),tc=An({logicalXor_:function(t,e){var n=mn(t,"a","logicalXor","bool"),r=mn(e,"b","logicalXor","bool");return Ro(n.shape,r.shape),Zu(t,e).logicalAnd(Qu(t,e).logicalNot())}}),ec=An({where_:function(t,e,n){var r=mn(e,"a","where"),o=mn(n,"b","where"),a=mn(t,"condition","where","bool");return E(r.shape,o.shape,"Error in where: "),1===a.rank?C(a.shape[0]===r.shape[0],(function(){return"The first dimension of `a` must match the size of `condition`."})):E(a.shape,o.shape,"Error in where: "),Lt.runKernelFunc((function(t,e){var n=t.select(a,r,o);return e([a]),n}),{$condition:a,$a:r,$b:o},(function(t,e){var n=e[0];return{$condition:function(){return Xn(n).toFloat()},$a:function(){return t.mul(n.cast(t.dtype))},$b:function(){return t.mul(n.logicalNot().cast(t.dtype))}}}))}}),nc=function(t){return n(this,void 0,void 0,(function(){var e,n,o;return r(this,(function(r){switch(r.label){case 0:return[4,(e=mn(t,"condition","whereAsync","bool")).data()];case 1:return n=r.sent(),o=na(e.shape,n),t!==e&&e.dispose(),[2,o]}}))}))};var rc=An({add_:function(t,e){var n,r=mn(t,"a","add"),o=mn(e,"b","add");n=Nt(r,o),r=n[0],o=n[1];var a=Ro(r.shape,o.shape);return Lt.runKernelFunc((function(t){return t.add(r,o)}),{a:r,b:o},(function(t){return{a:function(){var e=t,n=Eo(r.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(r.shape)},b:function(){var e=t,n=Eo(o.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(o.shape)}}}),"Add")}}),oc=An({addN_:function(t){C(Array.isArray(t),(function(){return"The argument passed to tf.addN() must be a list of tensors"})),C(t.length>=1,(function(){return"Must pass at least one tensor to tf.addN(), but got "+t.length}));var e=t.map((function(t,e){return mn(t,"tensors"+e,"addN")})),n=e[0];e.forEach((function(t){if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),e.forEach((function(t){if(!S(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));var r=e;return Lt.runKernelFunc((function(t){return t.addN(e)}),r,(function(t){var n={};return e.forEach((function(e,r){n[r]=function(){return t.clone()}})),n}),"AddN")}}),ac=An({addStrict_:function(t,e){var n=mn(t,"a","addStrict"),r=mn(e,"b","addStrict");return E(n.shape,r.shape,"Error in addStrict: "),n.add(r)}}),ic=An({atan2_:function(t,e){var n,r=mn(t,"a","atan2"),o=mn(e,"b","atan2");n=Nt(r,o),r=n[0],o=n[1];var a=Ro(r.shape,o.shape);return Lt.runKernelFunc((function(t,e){var n=t.atan2(r,o);return e([r,o]),n}),{$a:r,$b:o},(function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=rc(n.square(),r.square()),o=t.mul(r.div(e)),i=Eo(n.shape,a);return i.length>0&&(o=o.sum(i)),o.reshape(n.shape)},$b:function(){var e=rc(n.square(),r.square()),o=wu(t.mul(n.div(e))),i=Eo(r.shape,a);return i.length>0&&(o=o.sum(i)),o.reshape(r.shape)}}}))}}),sc=An({div_:function(t,e){var n,r=mn(t,"a","div"),o=mn(e,"b","div");if(n=Nt(r,o),r=n[0],o=n[1],"int32"===r.dtype&&"int32"===o.dtype)return lc(r,o);var a=Ro(r.shape,o.shape);return Lt.runKernelFunc((function(t,e){var n=t.realDivide(r,o);return e([r,o]),n}),{a:r,b:o},(function(t,e){var n=e[0],r=e[1];return{a:function(){var e=t.div(r.toFloat()),o=Eo(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},b:function(){var e=t.mul(n.toFloat()),o=Eo(r.shape,a);o.length>0&&(e=e.sum(o).reshape(r.shape));var i=r.square();return e.div(i.toFloat()).neg()}}}),"Div")}}),uc=An({divNoNan_:function(t,e){var n,r=mn(t,"a","div"),o=mn(e,"b","div");r=(n=Nt(r,o))[0],o=n[1];var a=sc(r,o),i=Xn(a),s=o.equal(i);return ec(s,i,a)}}),cc=An({divStrict_:function(t,e){var n=mn(t,"a","div"),r=mn(e,"b","div");return E(n.shape,r.shape,"Error in divideStrict: "),n.div(r)}}),lc=An({floorDiv_:function(t,e){var n,r=mn(t,"a","floorDiv"),o=mn(e,"b","floorDiv");n=Nt(r,o),r=n[0],o=n[1];var a=Ro(r.shape,o.shape);return Lt.runKernelFunc((function(t,e){var n=t.floorDiv(r,o);return e([r,o]),n}),{a:r,b:o},(function(t,e){var n=e[0],r=e[1];return{a:function(){var e=t.div(r.toFloat()),o=Eo(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},b:function(){var e=t.mul(n.toFloat()),o=Eo(r.shape,a);o.length>0&&(e=e.sum(o).reshape(r.shape));var i=r.square();return e.div(i.toFloat()).neg()}}}),"FloorDiv")}}),hc=An({maximum_:function(t,e){var n,r=mn(t,"a","maximum"),o=mn(e,"b","maximum");return n=Nt(r,o),r=n[0],o=n[1],"bool"===r.dtype&&(r=r.toInt(),o=o.toInt()),Ro(r.shape,o.shape),Lt.runKernelFunc((function(t,e){var n=t.maximum(r,o);return e([r,o]),n}),{a:r,b:o},(function(t,e){var n=e[0],r=e[1];return{a:function(){return t.mul(n.greaterEqual(r).toFloat())},b:function(){return t.mul(n.less(r).toFloat())}}}),"Maximum")}}),fc=An({maximumStrict_:function(t,e){var n=mn(t,"a","maximumStrict"),r=mn(e,"b","maximumStrict");return E(n.shape,r.shape,"Error in maximumStrict: "),n.maximum(r)}}),dc=An({minimum_:function(t,e){var n,r=mn(t,"a","minimum"),o=mn(e,"b","minimum");return n=Nt(r,o),r=n[0],o=n[1],"bool"===r.dtype&&(r=r.toInt(),o=o.toInt()),Ro(r.shape,o.shape),Lt.runKernelFunc((function(t,e){var n=t.minimum(r,o);return e([r,o]),n}),{a:r,b:o},(function(t,e){var n=e[0],r=e[1];return{a:function(){return t.mul(n.lessEqual(r).toFloat())},b:function(){return t.mul(n.greater(r).toFloat())}}}),"Minimum")}}),pc=An({minimumStrict_:function(t,e){var n=mn(t,"a","minimumStrict"),r=mn(e,"b","minimumStrict");return E(n.shape,r.shape,"Error in minimumStrict: "),n.minimum(r)}}),vc=An({mod_:function(t,e){var n,r=mn(t,"a","mod"),o=mn(e,"b","mod");n=Nt(r,o),r=n[0],o=n[1];var a=Ro(r.shape,o.shape);return Lt.runKernelFunc((function(t,e){var n=t.mod(r,o);return e([r,o]),n}),{$a:r,$b:o},(function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=Eo(n.shape,a);return e.length>0?t.sum(e).reshape(n.shape):t},$b:function(){var e=t.mul(n.div(r).floor().neg()),o=Eo(r.shape,a);return o.length>0?e.sum(o).reshape(r.shape):e}}}))}}),mc=An({modStrict_:function(t,e){var n=mn(t,"a","modStrict"),r=mn(e,"b","modStrict");return E(n.shape,r.shape,"Error in modStrict: "),n.mod(r)}}),gc=An({mul_:function(t,e){var n,r=mn(t,"a","mul"),o=mn(e,"b","mul");n=Nt(r,o),r=n[0],o=n[1];var a=Ro(r.shape,o.shape);return Lt.runKernelFunc((function(t,e){var n=t.multiply(r,o);return e([r,o]),n}),{a:r,b:o},(function(t,e){var n=e[0],r=e[1];return{a:function(){var e=t.mul(r.toFloat()),o=Eo(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},b:function(){var e=t.mul(n.toFloat()),o=Eo(r.shape,a);return o.length>0?e.sum(o).reshape(r.shape):e}}}),"Mul")}}),yc=An({mulStrict_:function(t,e){var n=mn(t,"a","mul"),r=mn(e,"b","mul");return E(n.shape,r.shape,"Error in multiplyStrict: "),n.mul(r)}}),xc=An({pow_:function(t,e){var n,r=mn(t,"base","pow"),o=mn(e,"exp","pow");n=Nt(r,o),r=n[0],o=n[1];var a=Ro(r.shape,o.shape),i=[r,o];return Lt.runKernelFunc((function(t,e){var n=t.pow(r,o);return e([r,o,n]),n}),{a:r,b:o},(function(t,e){var n=e[0],r=e[1],o=e[2];return{a:function(){var e=r.toFloat(),o=t.mul(e.mul(n.pow(e.sub(On(1))))),i=Eo(n.shape,a);return i.length>0&&(o=o.sum(i)),o.reshape(n.shape)},b:function(){var e=n.greater(0),i=n.log().where(e,Xn(n)),s=t.mul(o.mul(i)),u=Eo(r.shape,a);return u.length>0&&(s=s.sum(u)),s.reshape(r.shape)}}}),"Pow",{},i,[!0])}}),bc=An({powStrict_:function(t,e){return E(t.shape,e.shape,"Error in powStrict: "),t.pow(e)}}),wc=An({squaredDifferenceStrict_:function(t,e){var n=mn(t,"a","squaredDifferenceStrict"),r=mn(e,"b","squaredDifferenceStrict");return E(n.shape,r.shape,"Error in squaredDifferenceStrict: "),n.squaredDifference(r)}}),Cc=An({sub_:function(t,e){var n,r=mn(t,"a","sub"),o=mn(e,"b","sub");n=Nt(r,o),r=n[0],o=n[1];var a=Ro(r.shape,o.shape);return Lt.runKernelFunc((function(t){return t.subtract(r,o)}),{a:r,b:o},(function(t){return{a:function(){var e=t,n=Eo(r.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(r.shape)},b:function(){var e=t,n=Eo(o.shape,a);return n.length>0&&(e=e.sum(n)),e.neg().reshape(o.shape)}}}),"Sub")}}),Ec=An({subStrict_:function(t,e){var n=mn(t,"a","subStrict"),r=mn(e,"b","subStrict");return E(n.shape,r.shape,"Error in subStrict: "),n.sub(r)}});var Rc=An({equal_:function(t,e){var n,r=mn(t,"a","equal"),o=mn(e,"b","equal");return n=Nt(r,o),r=n[0],o=n[1],Ro(r.shape,o.shape),Lt.runKernelFunc((function(t){return t.equal(r,o)}),{$a:r,$b:o})}}),Ic=An({equalStrict_:function(t,e){var n=mn(t,"a","equalStrict"),r=mn(e,"b","equalStrict");return E(n.shape,r.shape,"Error in equalStrict: "),n.equal(r)}}),kc=An({greater_:function(t,e){var n,r=mn(t,"a","greater"),o=mn(e,"b","greater");return n=Nt(r,o),r=n[0],o=n[1],Ro(r.shape,o.shape),Lt.runKernelFunc((function(t){return t.greater(r,o)}),{a:r,b:o},null,"Greater")}}),Sc=An({greaterEqual_:function(t,e){var n,r=mn(t,"a","greaterEqual"),o=mn(e,"b","greaterEqual");return n=Nt(r,o),r=n[0],o=n[1],Ro(r.shape,o.shape),Lt.runKernelFunc((function(t,e){var n=t.greaterEqual(r,o);return e([r,o]),n}),{a:r,b:o},(function(t,e){var n=e[0],r=e[1];return{a:function(){return Xn(n)},b:function(){return Xn(r)}}}),"GreaterEqual")}}),Ac=An({greaterEqualStrict_:function(t,e){var n=mn(t,"a","greaterEqualStrict"),r=mn(e,"b","greaterEqualStrict");return E(n.shape,r.shape,"Error in greaterEqualStrict: "),n.greaterEqual(r)}}),Dc=An({greaterStrict_:function(t,e){var n=mn(t,"a","greaterStrict"),r=mn(e,"b","greaterStrict");return E(n.shape,r.shape,"Error in greaterStrict: "),n.greater(r)}}),Tc=An({less_:function(t,e){var n,r=mn(t,"a","less"),o=mn(e,"b","less");return n=Nt(r,o),r=n[0],o=n[1],Ro(r.shape,o.shape),Lt.runKernelFunc((function(t){return t.less(r,o)}),{a:r,b:o},null,"Less")}}),Nc=An({lessEqual_:function(t,e){var n,r=mn(t,"a","lessEqual"),o=mn(e,"b","lessEqual");return n=Nt(r,o),r=n[0],o=n[1],Ro(r.shape,o.shape),Lt.runKernelFunc((function(t,e){var n=t.lessEqual(r,o);return e([r,o]),n}),{a:r,b:o},null,"LessEqual")}}),Fc=An({lessEqualStrict_:function(t,e){var n=mn(t,"a","lessEqualStrict"),r=mn(e,"b","lessEqualStrict");return E(n.shape,r.shape,"Error in lessEqualStrict: "),n.lessEqual(r)}}),_c=An({lessStrict_:function(t,e){var n=mn(t,"a","lessStrict"),r=mn(e,"b","lessStrict");return E(n.shape,r.shape,"Error in lessStrict: "),n.less(r)}}),Oc=An({notEqual_:function(t,e){var n,r=mn(t,"a","notEqual"),o=mn(e,"b","notEqual");return n=Nt(r,o),r=n[0],o=n[1],Ro(r.shape,o.shape),Lt.runKernelFunc((function(t){return t.notEqual(r,o)}),{a:r,b:o},null,"NotEqual")}}),Mc=An({notEqualStrict_:function(t,e){var n=mn(t,"a","notEqualStrict"),r=mn(e,"b","notEqualStrict");return E(n.shape,r.shape,"Error in notEqualStrict: "),n.notEqual(r)}});function Bc(t,e){for(var n=[],r=t;r<e;++r)n.push(r);return n}function Pc(t){for(var e=[],n=0;n<t.length;++n)for(var r=0;r<t[n].length;++r)e.push(t[n][r]);return e}var Lc=An({gather_:function(t,e,n){void 0===n&&(n=0);var r=mn(t,"x","gather"),o=mn(e,"indices","gather","int32");n=O(n,r.shape)[0];var a=function(t,e,n){for(var r=t.shape[n],o=[],a=1,i=1,s=0;s<n;s++)o.push(t.shape[s]),a*=t.shape[s];for(s=0;s<e.rank;s++)o.push(e.shape[s]);for(s=n+1;s<t.rank;s++)o.push(t.shape[s]),i*=t.shape[s];return{batchSize:a,sliceSize:i,dimSize:r,outputShape:o}}(r,o,n);return Lt.runKernelFunc((function(t,e){var a=t.gather(r,o.flatten(),n);return e([o]),a}),{x:r,indices:o},(function(t,e){var o=e[0];return{x:function(){var e=r.shape,a=o.size,i=e.slice(0,n),s=i.length,u=e.slice(n,e.length).slice(1),c=u.length,l=Bc(0,s),h=Bc(s+1,s+1+c),f=Pc([i,[a],u]),d=t.reshape(f),p=o.reshape([a]),v=Pc([[s],l,h]),m=d.transpose(v),g=Wc(m,p,r.shape[n]),y=Rn(v);return g=g.transpose(y)},indices:function(){return o}}}),"Gather",{axis:n}).reshape(a.outputShape)}}),Wc=An({unsortedSegmentSum_:function(t,e,n){var r=mn(t,"x","unsortedSegmentSum"),o=mn(e,"segmentIds","unsortedSegmentSum","int32");return C(A(n),(function(){return"numSegments must be of dtype int"})),Lt.runKernelFunc((function(t,e){var a=t.unsortedSegmentSum(r,o,n);return e([o]),a}),{$x:r},(function(t,e){var n=e[0];return{$x:function(){return function(t,e){for(var n=hc(e,Xn(e)),r=Lc(t,n),o=Sc(e,On(0,"int32")),a=r.rank-o.rank,i=0;i<a;++i)o=wr(o,i+1);o=Qu(o,zn(r.shape,"bool"));var s=Xn(r);return ec(o,r,s)}(t,n)}}}))}});var Uc=function(t,e,o){return n(this,void 0,void 0,(function(){var n,a,i,s,u,c,l,h,f,d,p,v,m;return r(this,(function(r){switch(r.label){case 0:for(n=mn(t,"tensor","boolMask"),a=mn(e,"mask","boolMask","bool"),i=null==o?0:o,s=a.rank,u=n.shape,C(s>0,(function(){return"mask cannot be scalar"})),E(u.slice(i,i+s),a.shape,"mask's shape must match the first K dimensions of tensor's shape,"),c=1,l=i;l<i+s;l++)c*=u[l];return h=u.slice(0,i).concat([c],u.slice(i+s)),f=n.reshape(h),d=a.reshape([-1]),[4,nc(d)];case 1:return p=r.sent(),v=p.squeeze([1]),m=Lc(f,v,i),t!==n&&n.dispose(),e!==a&&a.dispose(),v.dispose(),f.dispose(),d.dispose(),p.dispose(),[2,m]}}))}))};function Vc(t,e,n,r,o,a,i){void 0===a&&(a="NHWC"),C(t.length===e.rank,(function(){return"Length of inShape ("+t.length+") and rank of dy ("+e.rank+") must match"}));var s=t,u=e,c=!1;3===e.rank&&(c=!0,u=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]),s=[1,t[0],t[1],t[2]]),C(4===s.length,(function(){return"Error in conv2dDerInput: inShape must be length 4, but got length "+s.length+"."})),C(4===u.rank,(function(){return"Error in conv2dDerInput: dy must be rank 4, but got rank "+u.rank})),C(4===n.rank,(function(){return"Error in conv2dDerInput: filter must be rank 4, but got rank "+n.rank}));var l="NHWC"===a?s[3]:s[1],h="NHWC"===a?u.shape[3]:u.shape[1];C(l===n.shape[2],(function(){return"Error in conv2dDerInput: depth of input ("+l+") must match input depth for filter "+n.shape[2]+"."})),C(h===n.shape[3],(function(){return"Error in conv2dDerInput: depth of output ("+h+") must match output depth for filter "+n.shape[3]+"."})),null!=i&&C(A(o),(function(){return"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+o+"."}));var f=Bo(a),d=So(s,n.shape,r,1,o,i,!1,f),p=Lt.runKernelFunc((function(t,e){var r=t.conv2dDerInput(u,n,d);return e([n,u]),r}),{dy4D:u,filter:n},(function(t,e){var n=e[0],s=e[1];return{dy4D:function(){return qc(t,n,r,o,a,1,i)},filter:function(){return jc(t,s,n.shape,r,o,a,i)}}}));return c?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}function zc(t){var e=function(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}(t),n=e[0],r=e[1],o=e[2];return 1===n&&1===r&&1===o}function Gc(t,e,n,r,o){C(t.length===e.rank,(function(){return"Length of inShape ("+t.length+") and rank of dy ("+e.rank+") must match"}));var a=t,i=e,s=!1;4===e.rank&&(s=!0,i=e.as5D(1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]),a=[1,t[0],t[1],t[2],t[3]]);var u=a[4],c=i.shape[4];C(5===a.length,(function(){return"Error in conv3dDerInput: inShape must be length 5, but got length "+a.length+"."})),C(5===i.rank,(function(){return"Error in conv3dDerInput: dy must be rank 5, but got rank "+i.rank})),C(5===n.rank,(function(){return"Error in conv3dDerInput: filter must be rank 5, but got rank "+n.rank})),C(u===n.shape[3],(function(){return"Error in conv3dDerInput: depth of input ("+u+") must match input depth for filter "+n.shape[3]+"."})),C(c===n.shape[4],(function(){return"Error in conv3dDerInput: depth of output ("+c+") must match output depth for filter "+n.shape[4]+"."}));var l=Ao(a,n.shape,r,1,o),h=Lt.runKernelFunc((function(t){return t.conv3dDerInput(i,n,l)}),{dy5D:i});return s?h.as4D(h.shape[1],h.shape[2],h.shape[3],h.shape[4]):h}var Hc=An({conv1d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NWC"),void 0===a&&(a=1);var s=mn(t,"x","conv1d"),u=mn(e,"filter","conv1d"),c=s,l=!1;2===s.rank&&(l=!0,c=s.as3D(1,s.shape[0],s.shape[1])),C(3===c.rank,(function(){return"Error in conv1d: input must be rank 3, but got rank "+c.rank+"."})),C(3===u.rank,(function(){return"Error in conv1d: filter must be rank 3, but got rank "+u.rank+"."})),null!=i&&C(A(r),(function(){return"Error in conv1d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."})),C(c.shape[2]===u.shape[1],(function(){return"Error in conv1d: depth of input ("+c.shape[2]+") must match input depth for filter "+u.shape[1]+"."})),C(Mo(n,a),(function(){return"Error in conv1D: Either stride or dilation must be 1. Got stride "+n+" and dilation '"+a+"'"})),C("NWC"===o,(function(){return"Error in conv1d: got dataFormat of "+o+" but only NWC is currently supported."}));var h=u.as4D(1,u.shape[0],u.shape[1],u.shape[2]),f=c.as4D(c.shape[0],1,c.shape[1],c.shape[2]),d=qc(f,h,[1,n],r,"NHWC",[1,a],i);return l?d.as2D(d.shape[2],d.shape[3]):d.as3D(d.shape[0],d.shape[2],d.shape[3])}}),qc=An({conv2d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NHWC"),void 0===a&&(a=[1,1]);var s=mn(t,"x","conv2d"),u=mn(e,"filter","conv2d"),c=s,l=!1;3===s.rank&&(l=!0,c=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),C(4===c.rank,(function(){return"Error in conv2d: input must be rank 4, but got rank "+c.rank+"."})),C(4===u.rank,(function(){return"Error in conv2d: filter must be rank 4, but got rank "+u.rank+"."})),null!=i&&C(A(r),(function(){return"Error in conv2d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."}));var h="NHWC"===o?c.shape[3]:c.shape[1];C(h===u.shape[2],(function(){return"Error in conv2d: depth of input ("+h+") must match input depth for filter "+u.shape[2]+"."})),C(Mo(n,a),(function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"}));var f=Bo(o),d=So(c.shape,u.shape,n,a,r,i,!1,f),p=[u,c],v=Lt.runKernelFunc((function(t,e){var n=t.conv2d(c,u,d);return e([u,c]),n}),{x:c,filter:u},(function(t,e){var i=e,s=i[0],u=i[1];return C(Oo(a),(function(){return"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+a+"'"})),{x:function(){return Xc(u.shape,t,s,n,r,o)},filter:function(){return jc(u,t,s.shape,n,r,o)}}}),"Conv2D",d,p);return l?v.as3D(v.shape[1],v.shape[2],v.shape[3]):v}}),Kc=An({conv3d_:function(t,e,n,r,o,a){void 0===o&&(o="NDHWC"),void 0===a&&(a=[1,1,1]);var i=mn(t,"x","conv3d"),s=mn(e,"filter","conv3d"),u=i,c=!1;4===i.rank&&(c=!0,u=i.as5D(1,i.shape[0],i.shape[1],i.shape[2],i.shape[3])),C(5===u.rank,(function(){return"Error in conv3d: input must be rank 5, but got rank "+u.rank+"."})),C(5===s.rank,(function(){return"Error in conv3d: filter must be rank 5, but got rank "+s.rank+"."})),C(u.shape[4]===s.shape[3],(function(){return"Error in conv3d: depth of input ("+u.shape[4]+") must match input depth for filter "+s.shape[3]+"."})),C(function(t,e){return zc(t)||zc(e)}(n,a),(function(){return"Error in conv3D: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"})),C("NDHWC"===o,(function(){return"Error in conv3d: got dataFormat of "+o+" but only NDHWC is currently supported."}));var l=Ao(u.shape,s.shape,n,a,r),h=Lt.runKernelFunc((function(t,e){var n=t.conv3d(u,s,l);return e([u,s]),n}),{x:u,$filter:s},(function(t,e){C(zc(a),(function(){return"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+a+"'"}));var o=e[0],i=e[1];return{x:function(){return Gc(o.shape,t,i,n,r)},$filter:function(){return function(t,e,n,r,o){var a=t;4===t.rank&&(a=t.as5D(1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]));var i=e;4===i.rank&&(i=e.as5D(1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]));C(5===a.rank,(function(){return"Error in conv3dDerFilter: input must be rank 5, but got shape "+a.shape+"."})),C(5===i.rank,(function(){return"Error in conv3dDerFilter: dy must be rank 5, but got shape "+i.shape+"."})),C(5===n.length,(function(){return"Error in conv3dDerFilter: filterShape must be length 5, but got "+n+"."})),C(a.shape[4]===n[3],(function(){return"Error in conv3dDerFilter: depth of input "+a.shape[4]+") must match input depth in filter ("+n[3]+"."})),C(i.shape[4]===n[4],(function(){return"Error in conv3dDerFilter: depth of dy ("+i.shape[4]+") must match output depth for filter ("+n[4]+")."}));var s=Ao(a.shape,n,r,1,o);return Lt.runKernelFunc((function(t){return t.conv3dDerFilter(a,i,s)}),{x5D:a,dy5D:i})}(o,t,i.shape,n,r)}}}));return c?h.as4D(h.shape[1],h.shape[2],h.shape[3],h.shape[4]):h}}),jc=An({conv2dDerFilter_:function(t,e,n,r,o,a,i){void 0===a&&(a="NHWC");var s=t;3===t.rank&&(s=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var u=e;3===u.rank&&(u=e.as4D(1,e.shape[0],e.shape[1],e.shape[2])),C(4===s.rank,(function(){return"Error in conv2dDerFilter: input must be rank 4, but got shape "+s.shape+"."})),C(4===u.rank,(function(){return"Error in conv2dDerFilter: dy must be rank 4, but got shape "+u.shape+"."})),C(4===n.length,(function(){return"Error in conv2dDerFilter: filterShape must be length 4, but got "+n+"."}));var c="NHWC"===a?s.shape[3]:s.shape[1],l="NHWC"===a?u.shape[3]:u.shape[1];C(c===n[2],(function(){return"Error in conv2dDerFilter: depth of input "+c+") must match input depth in filter ("+n[2]+"."})),C(l===n[3],(function(){return"Error in conv2dDerFilter: depth of dy ("+l+") must match output depth for filter ("+n[3]+")."})),null!=i&&C(A(o),(function(){return"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+o+"."}));var h=Bo(a),f=So(s.shape,n,r,1,o,i,!1,h);return Lt.runKernelFunc((function(t){return t.conv2dDerFilter(s,u,f)}),{x4D:s,dy4D:u})}}),Xc=An({conv2dDerInput_:Vc}),Yc=An({depthwiseConv2d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NHWC"),void 0===a&&(a=[1,1]);var s=mn(t,"x","depthwiseConv2d"),u=mn(e,"filter","depthwiseConv2d"),c=s,l=!1;3===s.rank&&(l=!0,c=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),C(4===c.rank,(function(){return"Error in depthwiseConv2d: input must be rank 4, but got rank "+c.rank+"."})),C(4===u.rank,(function(){return"Error in depthwiseConv2d: filter must be rank 4, but got rank "+u.rank+"."})),C(c.shape[3]===u.shape[2],(function(){return"Error in depthwiseConv2d: number of input channels ("+c.shape[3]+") must match the inChannels dimension in filter "+u.shape[2]+"."})),null==a&&(a=[1,1]),C(Mo(n,a),(function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"})),null!=i&&C(A(r),(function(){return"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."}));var h=So(c.shape,u.shape,n,a,r,i,!0),f=[c,u],d=Lt.runKernelFunc((function(t,e){var n=t.depthwiseConv2D(c,u,h);return e([c,u]),n}),{x:c,filter:u},(function(t,e){C(Oo(a),(function(){return"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+a+"'"}));var n=e[0],r=e[1];return{x:function(){return $c(n.shape,t,r,h)},filter:function(){return Qc(n,t,r.shape,h)}}}),"DepthwiseConv2dNative",h,f);return l?d.as3D(d.shape[1],d.shape[2],d.shape[3]):d}}),$c=An({depthwiseConv2dDerInput_:function(t,e,n,r){var o=e,a=!1;3===e.rank&&(a=!0,o=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]));var i=Lt.runKernelFunc((function(t){return t.depthwiseConv2DDerInput(o,n,r)}),{dy4D:o});return a?i.as3D(i.shape[1],i.shape[2],i.shape[3]):i}}),Qc=An({depthwiseConv2dDerFilter_:function(t,e,n,r){var o=t;3===t.rank&&(o=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var a=e;return 3===a.rank&&(a=e.as4D(1,e.shape[0],e.shape[1],e.shape[2])),Lt.runKernelFunc((function(t){return t.depthwiseConv2DDerFilter(o,a,r)}),{x4D:o,dy4D:a})}}),Jc=An({separableConv2d_:function(t,e,n,r,o,a,i){void 0===a&&(a=[1,1]),void 0===i&&(i="NHWC");var s=mn(t,"x","separableConv2d"),u=mn(e,"depthwiseFilter","separableConv2d"),c=mn(n,"pointwiseFilter","separableConv2d"),l=s,h=!1;if(3===s.rank&&(h=!0,l=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");C(4===l.rank,(function(){return"Error in separableConv2d: input must be rank 4, but got rank "+l.rank+"."})),C(4===u.rank,(function(){return"Error in separableConv2d: depthwise filter must be rank 4, but got rank "+u.rank+"."})),C(4===c.rank,(function(){return"Error in separableConv2d: pointwise filter must be rank 4, but got rank "+u.rank+"."})),C(1===c.shape[0],(function(){return"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got "+c.shape[0]+"."})),C(1===c.shape[1],(function(){return"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got "+c.shape[1]+"."}));var f=u.shape[2],d=u.shape[3];C(c.shape[2]===f*d,(function(){return"Error in separableConv2d: the third dimension of pointwise filter must be "+f*d+", but got "+c.shape[2]+"."}));var p=Yc(l,u,r,o,i,a),v=qc(p,c,1,"valid",i);return h?v.as3D(v.shape[1],v.shape[2],v.shape[3]):v}}),Zc=An({conv2dTranspose_:function(t,e,n,r,o,a){return Vc(n,mn(t,"x","conv2dTranspose"),mn(e,"filter","conv2dTranspose"),r,o,"NHWC",a)}}),tl=An({conv3dTranspose_:function(t,e,n,r,o){return Gc(n,mn(t,"x","conv3dTranspose"),mn(e,"filter","conv3dTranspose"),r,o)}});var el=An({matMul_:function(t,e,n,r){var o;void 0===n&&(n=!1),void 0===r&&(r=!1);var a=mn(t,"a","matMul"),i=mn(e,"b","matMul");o=Nt(a,i),a=o[0],i=o[1];var s=n?a.shape[a.rank-2]:a.shape[a.rank-1],u=r?i.shape[i.rank-1]:i.shape[i.rank-2],c=n?a.shape[a.rank-1]:a.shape[a.rank-2],l=r?i.shape[i.rank-2]:i.shape[i.rank-1],h=a.shape.slice(0,-2),f=i.shape.slice(0,-2),d=k(h),p=k(f);C(a.rank>=2&&i.rank>=2&&a.rank===i.rank,(function(){return"Error in matMul: inputs must have the same rank of at least 2, got ranks "+a.rank+" and "+i.rank+"."})),C(S(h,f),(function(){return"Error in matMul: outer dimensions ("+h+") and ("+f+") of Tensors with shapes "+a.shape+" and "+i.shape+" must match."})),C(s===u,(function(){return"Error in matMul: inner shapes ("+s+") and ("+u+") of Tensors with shapes "+a.shape+" and "+i.shape+" and transposeA="+n+" and transposeB="+r+" must match."}));var v=a.shape.slice(0,-2).concat([c,l]),m=n?a.as3D(d,s,c):a.as3D(d,c,s),g=r?i.as3D(p,l,u):i.as3D(p,u,l),y={transposeA:n,transposeB:r};return Lt.runKernelFunc((function(t,e){var o=t.batchMatMul(m,g,n,r);return e([m,g]),o}),{a:m,b:g},(function(t,e){var o=e,a=o[0],i=o[1];return n||r?!n&&r?{a:function(){return t.matMul(i,!1,!1)},b:function(){return t.matMul(a,!0,!1)}}:n&&!r?{a:function(){return i.matMul(t,!1,!0)},b:function(){return a.matMul(t,!1,!1)}}:{a:function(){return i.matMul(t,!0,!0)},b:function(){return t.matMul(a,!0,!0)}}:{a:function(){return t.matMul(i,!1,!0)},b:function(){return a.matMul(t,!0,!1)}}}),"BatchMatMul",y).reshape(v)}}),nl=An({dot_:function(t,e){var n=mn(t,"t1","dot"),r=mn(e,"t2","dot");C(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(function(){return"Error in dot: inputs must all be rank 1 or 2, but got ranks "+n.rank+" and "+r.rank+"."}));var o=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];return C(o===a,(function(){return"Error in dot: inner dimensions of inputs must match, but got "+o+" and "+a+"."})),1===n.rank&&1===r.rank?n.as2D(1,-1).matMul(r.as2D(-1,1)).asScalar():1===n.rank&&2===r.rank?n.as2D(1,-1).matMul(r.as2D(r.shape[0],r.shape[1])).as1D():2===n.rank&&1===r.rank?n.matMul(r.as2D(-1,1)).as1D():n.matMul(r.as2D(r.shape[0],r.shape[1]))}}),rl=An({outerProduct_:function(t,e){var n=mn(t,"v1","outerProduct"),r=mn(e,"v2","outerProduct");return C(1===n.rank&&1===r.rank,(function(){return"Error in outerProduct: inputs must be rank 1, but got ranks "+n.rank+" and "+r.rank+"."})),n.as2D(-1,1).matMul(r.as2D(1,-1))}});var ol=An({reverse_:function(t,e){var n=mn(t,"x","reverse");if(0===n.rank)return n.clone();var r=O(e,n.shape);return Lt.runKernelFunc((function(t){return t.reverse(n,r)}),{$x:n},(function(t){return{$x:function(){return t.reverse(r)}}})).reshapeAs(n)}}),al=An({reverse1d_:function(t){var e=mn(t,"x","reverse");return C(1===e.rank,(function(){return"Error in reverse1D: x must be rank 1 but got rank "+e.rank+"."})),ol(e,0)}}),il=An({reverse2d_:function(t,e){var n=mn(t,"x","reverse");return C(2===n.rank,(function(){return"Error in reverse2D: x must be rank 2 but got rank "+n.rank+"."})),ol(n,e)}}),sl=An({reverse3d_:function(t,e){var n=mn(t,"x","reverse");return C(3===n.rank,(function(){return"Error in reverse3D: x must be rank 3 but got rank "+n.rank+"."})),ol(n,e)}}),ul=An({reverse4d_:function(t,e){var n=mn(t,"x","reverse");return C(4===n.rank,(function(){return"Error in reverse4D: x must be rank 4 but got rank "+n.rank+"."})),ol(n,e)}});function cl(t,e,n,r,o,a){var i=mn(t,"x","maxPool"),s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),null==r&&(r=[1,1]),C(4===s.rank,(function(){return"Error in maxPool: input must be rank 4 but got rank "+s.rank+"."})),C(Mo(n,r),(function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+r+"'"})),null!=a&&C(A(o),(function(){return"Error in maxPool: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."}));var c=Io(s.shape,e,n,r,o,a);if(1===c.filterWidth&&1===c.filterHeight&&S(c.inShape,c.outShape))return i.clone();var l=[s],h=Lt.runKernelFunc((function(t,e){var n=t.maxPool(s,c);return e([s,n]),n}),{x:s},(function(t,a){var i=a[0],s=a[1];return{x:function(){return function(t,e,n,r,o,a,i,s){var u=mn(t,"dy","maxPoolBackprop"),c=mn(e,"input","maxPoolBackprop"),l=mn(n,"output","maxPoolBackprop");C(c.rank===u.rank,(function(){return"Rank of input ("+c.rank+") does not match rank of dy ("+u.rank+")"})),null==a&&(a=[1,1]);C(Mo(o,a),(function(){return"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+a+"'"})),C(4===u.rank,(function(){return"Error in maxPoolBackprop: dy must be rank 4 but got rank "+u.rank+"."})),C(4===c.rank,(function(){return"Error in maxPoolBackprop: input must be rank 4 but got rank "+c.rank+"."})),null!=s&&C(A(i),(function(){return"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode "+s+" but got pad "+i+"."}));var h=Io(c.shape,r,o,a,i,s);return Lt.runKernelFunc((function(t){return t.maxPoolBackprop(u,c,l,h)}),{$dy:u,$input:c})}(t,i,s,e,n,r,o)}}}),"MaxPool",c,l);return u?h.as3D(h.shape[1],h.shape[2],h.shape[3]):h}function ll(t,e,n,r,o,a){var i=mn(t,"x","avgPool","float32");null==r&&(r=[1,1]),C(Mo(n,r),(function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+r+"'"}));var s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),C(4===s.rank,(function(){return"Error in avgPool: x must be rank 4 but got rank "+s.rank+"."})),null!=a&&C(A(o),(function(){return"Error in avgPool: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."}));var c=Io(s.shape,e,n,r,o,a);if(1===c.filterWidth&&1===c.filterHeight&&S(c.inShape,c.outShape))return i.clone();var l=Lt.runKernelFunc((function(t){return t.avgPool(s,c)}),{x:s},(function(t){return{x:function(){return function(t,e,n,r,o,a){var i=mn(t,"dy","avgPoolBackprop"),s=mn(e,"input","avgPoolBackprop");C(s.rank===i.rank,(function(){return"Rank of input ("+s.rank+") does not match rank of dy ("+i.rank+")"})),null==o&&(o=[1,1]);C(Mo(r,o),(function(){return"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+o+"'"}));var u=s,c=i,l=!1;3===s.rank&&(l=!0,u=s.as4D(1,s.shape[0],s.shape[1],s.shape[2]),c=i.as4D(1,i.shape[0],i.shape[1],i.shape[2]));C(4===c.rank,(function(){return"Error in avgPoolBackprop: dy must be rank 4 but got rank "+c.rank+"."})),C(4===u.rank,(function(){return"Error in avgPoolBackprop: input must be rank 4 but got rank "+u.rank+"."}));var h=Io(u.shape,n,r,o,a),f=Lt.runKernelFunc((function(t){return t.avgPoolBackprop(c,u,h)}),{dy4D:c,input4D:u});if(l)return f.as3D(f.shape[1],f.shape[2],f.shape[3]);return f}(t,s,e,n,r,o)}}}),"AvgPool",c);return l=l.cast(i.dtype),u?l.as3D(l.shape[1],l.shape[2],l.shape[3]):l}var hl=An({maxPool_:function(t,e,n,r,o){return cl(t,e,n,1,r,o)}}),fl=An({avgPool_:function(t,e,n,r,o){return ll(t,e,n,1,r,o)}}),dl=An({pool_:function(t,e,n,r,o,a){null==o&&(o=[1,1]),null==a&&(a=1),0===r&&(r="valid");var i=mn(t,"x","maxPool"),s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),C(Mo(a,o),(function(){return"Error in pool: Either strides or dilations must be 1. Got strides "+a+" and dilations '"+o+"'"}));var c,l=Io(s.shape,e,a,o,r),h=[l.dilationHeight,l.dilationWidth];c="same"===r?function(t,e){var n=t.map((function(t,n){return t+(t-1)*(e[n]-1)})).map((function(t){return t-1})),r=n.map((function(t){return Math.floor(t/2)})),o=n.map((function(t,e){return t-r[e]}));return n.map((function(t,e){return[r[e],o[e]]}))}([l.filterHeight,l.filterWidth],h):[[0,0],[0,0]];var f=1===h[0]&&1===h[1],d=function(t,e,n){var r=n.map((function(t){return t[0]})),o=n.map((function(t){return t[1]})),a=t.concat(r,o),i=e.map((function(t,e){return(t-a[e]%t)%t})),s=o.map((function(t,e){return t+i[e]})),u=e.map((function(t,e){return[r[e],s[e]]})),c=e.map((function(t,e){return[0,i[e]]}));return[u,c]}([l.inHeight,l.inWidth],h,c),p=d[0],v=d[1],m=f?r:"valid",g=f?s:Mr(s,h,p),y=("avg"===n?function(){return ll(g,e,a,1,m)}:function(){return cl(g,e,a,1,m)})(),x=f?y:vr(y,h,v);return u?x.as3D(x.shape[1],x.shape[2],x.shape[3]):x}}),pl=An({maxPool3d_:function(t,e,n,r,o,a,i){void 0===a&&(a="NDHWC");var s=mn(t,"x","maxPool3d"),u=s,c=!1;4===s.rank&&(c=!0,u=s.as5D(1,s.shape[0],s.shape[1],s.shape[2],s.shape[3])),null==i&&(i=[1,1,1]),C(5===u.rank,(function(){return"Error in maxPool3d: x must be rank 5 but got rank "+u.rank+"."})),C("NDHWC"===a,(function(){return"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of "+a})),C(Mo(n,i),(function(){return"Error in maxPool3d: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+i+"'"})),null!=o&&C(A(r),(function(){return"Error in maxPool3d: pad must be an integer when using, dimRoundingMode "+o+" but got pad "+r+"."}));var l=ko(u.shape,e,n,i,r,o,a),h=Lt.runKernelFunc((function(t,e){var n=t.maxPool3d(u,l);return e([u,n]),n}),{x:u},(function(t,a){var s=a[0],u=a[1];return{x:function(){return function(t,e,n,r,o,a,i,s){var u=mn(t,"dy","maxPool3dBackprop"),c=mn(e,"input","maxPool3dBackprop"),l=mn(n,"output","maxPool3dBackprop"),h=u,f=c,d=l,p=!1;4===c.rank&&(p=!0,h=u.as5D(1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]),f=c.as5D(1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]),d=l.as5D(1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]));C(5===h.rank,(function(){return"Error in maxPool3dBackprop: dy must be rank 5 but got rank "+h.rank+"."})),C(5===f.rank,(function(){return"Error in maxPool3dBackprop: input must be rank 5 but got rank "+f.rank+"."})),C(5===d.rank,(function(){return"Error in maxPool3dBackprop: output must be rank 5 but got rank "+d.rank+"."})),null==a&&(a=[1,1,1]);C(Mo(o,a),(function(){return"Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+a+"'"})),null!=s&&C(A(i),(function(){return"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode "+s+" but got pad "+i+"."}));var v=ko(f.shape,r,o,a,i,s),m=Lt.runKernelFunc((function(t){return t.maxPool3dBackprop(h,f,d,v)}),{dy5D:h,input5D:f});if(p)return m.as4D(m.shape[1],m.shape[2],m.shape[3],m.shape[4]);return m}(t,s,u,e,n,i,r,o)}}}));return c?h.as4D(h.shape[1],h.shape[2],h.shape[3],h.shape[4]):h}}),vl=An({avgPool3d_:function(t,e,n,r,o,a,i){void 0===a&&(a="NDHWC");var s=mn(t,"x","avgPool3d","float32"),u=s,c=!1;4===s.rank&&(c=!0,u=s.as5D(1,s.shape[0],s.shape[1],s.shape[2],s.shape[3])),null==i&&(i=[1,1,1]),C(5===u.rank,(function(){return"Error in avgPool3d: x must be rank 5 but got rank "+u.rank+"."})),C("NDHWC"===a,(function(){return"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of "+a})),C(Mo(n,i),(function(){return"Error in avgPool3d: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+i+"'"})),null!=o&&C(A(r),(function(){return"Error in avgPool3d: pad must be an integer when using, dimRoundingMode "+o+" but got pad "+r+"."}));var l=ko(u.shape,e,n,i,r,o,a),h=Lt.runKernelFunc((function(t){return t.avgPool3d(u,l)}),{x:u},(function(t){return{x:function(){return function(t,e,n,r,o,a,i){var s=mn(t,"dy","avgPool3dBackprop"),u=mn(e,"input","avgPool3dBackprop"),c=s,l=u,h=!1;4===u.rank&&(h=!0,c=s.as5D(1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]),l=u.as5D(1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]));C(5===c.rank,(function(){return"Error in avgPool3dBackprop: dy must be rank 5 but got rank "+c.rank+"."})),C(5===l.rank,(function(){return"Error in avgPool3dBackprop: input must be rank 5 but got rank "+l.rank+"."})),null==o&&(o=[1,1,1]);C(Mo(r,o),(function(){return"Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+o+"'"})),null!=i&&C(A(a),(function(){return"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+a+"."}));var f=ko(l.shape,n,r,o,a,i),d=Lt.runKernelFunc((function(t){return t.avgPool3dBackprop(c,l,f)}),{dy5D:c,input5D:l});if(h)return d.as4D(d.shape[1],d.shape[2],d.shape[3],d.shape[4]);return d}(t,u,e,n,i,r,o)}}}));return h=h.cast(u.dtype),c?h.as4D(h.shape[1],h.shape[2],h.shape[3],h.shape[4]):h}});var ml=An({slice_:function(t,e,n){var r,o,a=mn(t,"x","slice");if(0===a.rank)throw new Error("Slicing scalar is not possible");(r="number"==typeof e?[e].concat(new Array(a.rank-1).fill(0)):e.length<a.rank?e.concat(new Array(a.rank-e.length).fill(0)):e.slice()).forEach((function(t){C(-1!==t,(function(){return"slice() does not support negative begin indexing."}))})),o=(o=null==n?new Array(a.rank).fill(-1):"number"==typeof n?[n].concat(new Array(a.rank-1).fill(-1)):n.length<a.rank?n.concat(new Array(a.rank-n.length).fill(-1)):n).map((function(t,e){return t>=0?t:(C(-1===t,(function(){return"Negative size values should be exactly -1 but got "+t+" for the slice() size at index "+e+"."})),a.shape[e]-r[e])})),eo(a,r,o);var i=a.shape,s={begin:r,size:o};return Lt.runKernelFunc((function(t){return t.slice(a,r,o)}),{x:a},(function(t){for(var e=[],n=0;n<t.rank;n++)e.push([r[n],i[n]-r[n]-o[n]]);return{x:function(){return t.pad(e)}}}),"Slice",s)}}),gl=An({slice1d_:function(t,e,n){var r=mn(t,"x","slice1d");return C(1===r.rank,(function(){return"slice1d expects a rank-1 tensor, but got a rank-"+r.rank+" tensor"})),ml(r,[e],[n])}}),yl=An({slice2d_:function(t,e,n){var r=mn(t,"x","slice2d");return C(2===r.rank,(function(){return"slice2d expects a rank-2 tensor, but got a rank-"+r.rank+" tensor"})),ml(r,e,n)}}),xl=An({slice3d_:function(t,e,n){var r=mn(t,"x","slice3d");return C(3===r.rank,(function(){return"slice3d expects a rank-3 tensor, but got a rank-"+r.rank+" tensor"})),ml(r,e,n)}}),bl=An({slice4d_:function(t,e,n){var r=mn(t,"x","slice4d");return C(4===r.rank,(function(){return"slice4d expects a rank-4 tensor, but got a rank-"+r.rank+" tensor"})),ml(r,e,n)}});function wl(t,e,n,r,o){return e.rank<n.rank&&(e=e.reshape(wn(e.shape,r))),t.rank<n.rank&&(t=t.reshape(wn(t.shape,r))),{x:function(){var r=t.mul(n.equal(e).cast(t.dtype));return null==o?r:r.transpose(o)}}}var Cl=An({all_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","all","bool"),o=O(e,r.shape),a=o,i=En(a,r.rank);null!=i&&(r=r.transpose(i),a=In(a.length,r.rank));var s=Lt.runKernelFunc((function(t){return t.all(r,a)}),{$x:r});if(n){var u=wn(s.shape,o);return s.reshape(u)}return s}}),El=An({any_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","any","bool"),o=O(e,r.shape),a=o,i=En(a,r.rank);null!=i&&(r=r.transpose(i),a=In(a.length,r.rank));var s=Lt.runKernelFunc((function(t){return t.any(r,a)}),{$x:r});if(n){var u=wn(s.shape,o);return s.reshape(u)}return s}}),Rl=An({argMax_:function(t,e){void 0===e&&(e=0);var n=mn(t,"x","argMax");null==e&&(e=0);var r=O(e,n.shape),o=En(r,n.rank);null!=o&&(n=n.transpose(o),r=In(r.length,n.rank));var a={axis:r[0]},i=[n];return Lt.runKernelFunc((function(t,e){var o=t.argMax(n,r[0]);return e([n]),o}),{x:n},(function(t,e){var n=e[0];return{x:function(){return Xn(n)}}}),"ArgMax",a,i)}}),Il=An({argMin_:function(t,e){void 0===e&&(e=0);var n=mn(t,"x","argMin");null==e&&(e=0);var r=O(e,n.shape),o=En(r,n.rank);return null!=o&&(n=n.transpose(o),r=In(r.length,n.rank)),Lt.runKernelFunc((function(t,e){var o=t.argMin(n,r[0]);return e([n]),o}),{$x:n},(function(t,e){var n=e[0];return{$x:function(){return Xn(n)}}}))}}),kl=An({logSumExp_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","logSumExp"),o=O(e,r.shape),a=r.max(o,!0),i=r.sub(a).exp().sum(o).log(),s=a.reshape(i.shape).add(i);if(n){var u=wn(s.shape,o);return s.reshape(u)}return s}}),Sl=An({max_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","max"),o=r,a=O(e,r.shape),i=a,s=En(i,r.rank);null!=s&&(r=r.transpose(s),i=In(i.length,r.rank));var u=[r],c=Lt.runKernelFunc((function(t,e){var n=t.max(r,i);return e([o,n]),n}),{x:r},(function(t,e){return wl(t,e[1],e[0],a,s)}),"Max",{axes:i},u,[!0]);if(n){var l=wn(c.shape,a);c=c.reshape(l)}return c}}),Al=An({mean_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","mean"),o=O(e,r.shape),a=k(bn(r.shape,o)[1]);return vo((function(t){var r=On(a);return{value:(r.dtype===t.dtype?t:t.cast(r.dtype)).div(r).sum(e,n),gradFunc:function(e){var n=t.shape.slice();return o.forEach((function(t){n[t]=1})),e.reshape(n).mul(zn(t.shape,"float32")).div(a)}}}))(r)}}),Dl=An({min_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","min"),o=r,a=O(e,r.shape),i=a,s=En(i,r.rank);null!=s&&(r=r.transpose(s),i=In(i.length,r.rank));var u=[r],c=Lt.runKernelFunc((function(t,e){var n=t.min(r,i);return e([o,n]),n}),{x:r},(function(t,e){return wl(t,e[1],e[0],a,s)}),"Min",{axes:i},u,[!0]);if(n){var l=wn(c.shape,a);c=c.reshape(l)}return c}}),Tl=An({moments_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=O(e,(t=mn(t,"x","moments")).shape),o=t.mean(r,n),a=o.shape;n||(a=wn(o.shape,r));var i=t.toFloat().sub(o.reshape(a)).square();return{mean:o,variance:i.mean(r,n)}}}),Nl=An({sum_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","sum");"bool"===r.dtype&&(r=r.toInt());var o=O(e,r.shape);return vo((function(t){var e=En(o,t.rank),r=o,a=t;null!=e&&(a=t.transpose(e),r=In(r.length,t.rank));var i=function(e){var n=t.shape.slice();return o.forEach((function(t){n[t]=1})),e.reshape(n).mul(zn(t.shape,"float32"))},s={axes:r},u=Lt.runKernelFunc((function(t){return t.sum(a,r)}),{x:a},(function(t){return{x:function(){return i(t)}}}),"Sum",s);if(n){var c=wn(u.shape,o);u=u.reshape(c)}return{value:u,gradFunc:i}}))(r)}}),Fl=An({prod_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=mn(t,"x","prod");"bool"===r.dtype&&(r=r.toInt());var o=O(e,r.shape),a=En(o,r.rank),i=o,s=r;null!=a&&(s=r.transpose(a),i=In(i.length,r.rank));var u=Lt.runKernelFunc((function(t){return t.prod(s,i)}),{permutedX:s});if(n){var c=wn(u.shape,o);u=u.reshape(c)}return u}});var _l=An({elu_:function(t){var e=mn(t,"x","elu");return Lt.runKernelFunc((function(t,n){var r=t.elu(e);return n([r]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){return Lt.runKernelFunc((function(e){return e.eluDer(t,n)}),{dy:t,y:n})}}}))}}),Ol=An({leakyRelu_:function(t,e){void 0===e&&(e=.2);var n=mn(t,"x","leakyRelu");return hc(On(e).mul(n),n)}}),Ml=An({prelu_:function(t,e){var n=mn(t,"x","prelu"),r=mn(e,"alpha","prelu");return Lt.runKernelFunc((function(t,e){var o=t.prelu(n,r);return e([n,r]),o}),{x:n,alpha:r},(function(t,e){var n=e[0],r=e[1],o=n.greater(0);return{x:function(){return ec(o,t,t.mul(r))},alpha:function(){var e=ec(o,Xn(t),t.mul(n)),a=Eo(r.shape,t.shape);return a.length>0&&(e=e.sum(a)),e.reshape(r.shape)}}}),"Prelu")}}),Bl=An({relu_:function(t){var e=mn(t,"x","relu");return"bool"===e.dtype?e.toInt():Lt.runKernelFunc((function(t,n){var r=t.relu(e);return n([e]),r}),{x:e},(function(t,e){var n=e[0];return{x:function(){return t.mulStrict(n.step().toFloat())}}}),"Relu")}}),Pl=An({relu6_:function(t){var e=mn(t,"x","relu6");return"bool"===e.dtype?e.toInt():Lt.runKernelFunc((function(t,n){var r=t.relu6(e);return n([e]),r}),{x:e},(function(t,e){var n=e[0],r=n.lessEqual(6).mul(n.step());return{x:function(){return t.mulStrict(r.toFloat())}}}),"Relu6")}}),Ll=An({selu_:function(t){var e=mn(t,"x","selu");return Lt.runKernelFunc((function(t,n){var r=t.selu(e);return n([e]),r}),{$x:e},(function(t,e){var n=e[0];return{$x:function(){var e=n.greater(On(0)),r=On(bs),o=On(ws),a=t.mul(o),i=t.mul(r).mul(n.toFloat().exp());return ec(e,a,i)}}}))}});var Wl=An({transpose_:function(t,e){var n=mn(t,"x","transpose");if(null==e&&(e=n.shape.map((function(t,e){return e})).reverse()),C(n.rank===e.length,(function(){return"Error in transpose: rank of input "+n.rank+" must match length of perm "+e+"."})),e.forEach((function(t){C(t>=0&&t<n.rank,(function(){return"All entries in 'perm' must be between 0 and "+(n.rank-1)+" but got "+e}))})),n.rank<=1)return n.clone();var r={perm:e};return Lt.runKernelFunc((function(t){return t.transpose(n,e)}),{x:n},(function(t){var n=Rn(e);return{x:function(){return t.transpose(n)}}}),"Transpose",r)}});var Ul=An({localResponseNormalization_:function(t,e,n,r,o){void 0===e&&(e=5),void 0===n&&(n=1),void 0===r&&(r=1),void 0===o&&(o=.5);var a=mn(t,"x","localResponseNormalization");C(4===a.rank||3===a.rank,(function(){return"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank "+a.rank+"."})),C(A(e),(function(){return"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius "+e+"."}));var i=a,s=!1;3===a.rank&&(s=!0,i=a.as4D(1,a.shape[0],a.shape[1],a.shape[2]));var u=Lt.runKernelFunc((function(t,a){var s=t.localResponseNormalization4D(i,e,n,r,o);return a([i,s]),s}),{x4D:i},(function(t,a){var i=a[0],s=a[1];return{x4D:function(){return Lt.runKernelFunc((function(a){return a.LRNGrad(t,i,s,e,n,r,o)}),{})}}}));return s?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}});var Vl=An({norm_:function(t,e,n,r){void 0===e&&(e="euclidean"),void 0===n&&(n=null),void 0===r&&(r=!1);var o=function t(e,n,r){void 0===r&&(r=null);if(0===e.rank)return e.abs();if(1!==e.rank&&null===r)return t(e.reshape([-1]),n,r);if(1===e.rank||"number"==typeof r||Array.isArray(r)&&1===r.length){if(1===n)return e.abs().sum(r);if(n===1/0)return e.abs().max(r);if(n===-1/0)return e.abs().min(r);if("euclidean"===n||2===n)return e.abs().pow(On(2,"int32")).sum(r).sqrt();throw new Error("Error in norm: invalid ord value: "+n)}if(Array.isArray(r)&&2===r.length){if(1===n)return e.abs().sum(r[0]).max(r[1]-1);if(n===1/0)return e.abs().sum(r[1]).max(r[0]);if(n===-1/0)return e.abs().sum(r[1]).min(r[0]);if("fro"===n||"euclidean"===n)return e.square().sum(r).sqrt();throw new Error("Error in norm: invalid ord value: "+n)}throw new Error("Error in norm: invalid axis: "+r)}(t=mn(t,"x","norm"),e,n),a=o.shape;if(r){var i=O(n,t.shape);a=wn(o.shape,i)}return o.reshape(a)}});var zl=An({basicLSTMCell_:function(t,e,n,r,o,a){var i=mn(t,"forgetBias","basicLSTMCell"),s=mn(e,"lstmKernel","basicLSTMCell"),u=mn(n,"lstmBias","basicLSTMCell"),c=mn(r,"data","basicLSTMCell"),l=mn(o,"c","basicLSTMCell"),h=mn(a,"h","basicLSTMCell"),f=c.concat(h,1).matMul(s).add(u),d=f.shape[0],p=f.shape[1]/4,v=[d,p],m=f.slice([0,0],v),g=f.slice([0,p],v),y=f.slice([0,2*p],v),x=f.slice([0,3*p],v),b=m.sigmoid().mulStrict(g.tanh()).addStrict(l.mulStrict(i.add(y).sigmoid())),w=b.tanh().mulStrict(x.sigmoid());return[b,w]}}),Gl=An({multiRNNCell_:function(t,e,n,r){for(var o=mn(e,"data","multiRNNCell"),a=gn(n,"c","multiRNNCell"),i=gn(r,"h","multiRNNCell"),s=o,u=[],c=0;c<t.length;c++){var l=t[c](s,a[c],i[c]);u.push(l[0]),u.push(l[1]),s=l[1]}var h=[],f=[];for(c=0;c<u.length;c+=2)h.push(u[c]),f.push(u[c+1]);return[h,f]}});var Hl=An({movingAverage_:function(t,e,n,r,o){void 0===o&&(o=!0);var a=mn(t,"v","movingAverage"),i=mn(e,"x","movingAverage"),s=mn(n,"decay","movingAverage");Ft(a,i),C(S(a.shape,i.shape),(function(){return"Shape mismatch in v and x"}));var u=On(1),c=u.sub(s),l=i.sub(a).mul(c);if(o){C(null!=r,(function(){return"When using zeroDebias: true, step is required."}));var h=mn(r,"step","movingAverage");l=l.div(u.sub(xc(s,h)))}return a.add(l)}});var ql=An({stridedSlice_:function(t,e,n,r,o,a,i,s,u){if(void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),void 0===u&&(u=0),null==r&&(r=new Array(e.length)),0!==i)throw new Error("ellipsis mask is not yet supported");var c=mn(t,"x","stridedSlice"),l=no(s),h=c.shape.slice();l.forEach((function(t){e[t]=0,n[t]=1,h.splice(t,0,1)})),c=c.reshape(h);for(var f=0;f<c.rank;f++)e[f]=oo(o,e,r,c.shape,f),n[f]=ao(a,n,r,c.shape,f),r[f]=r[f]||1;var d=no(u);d.forEach((function(t){n[t]=e[t]+1,r[t]=1}));var p=ro(e,n,r),v=p.filter((function(t,e){return-1===d.indexOf(e)}));return r.every((function(t){return 1===t}))?ml(c,e,p).reshape(v):Lt.runKernelFunc((function(t){return t.stridedSlice(c,e,n,r)}),{$x:c}).reshape(v)}});var Kl=An({topk_:function(t,e,n){void 0===e&&(e=1),void 0===n&&(n=!0);var r=mn(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");var o=r.shape[r.shape.length-1];if(e>o)throw new Error("'k' passed to topk() must be <= the last dimension ("+o+") but got "+e);var a=Lt.runKernelFunc((function(t){return t.topk(r,e,n)}),{$x:r});return{values:a[0],indices:a[1]}}});var jl=An({scatterND_:function(t,e,n){var r=mn(t,"indices","scatterND","int32"),o=mn(e,"updates","scatterND");return Jr(o,r,n),Lt.runKernelFunc((function(t){return t.scatterND(r,o,n)}),{indices:r,updates:o},null,"ScatterNd",{shape:n})}});var Xl=An({fft_:function(t){C("complex64"===t.dtype,(function(){return"The dtype for tf.spectral.fft() must be complex64 but got "+t.dtype+"."}));var e=t.shape[t.shape.length-1],n=t.size/e,r=t.as2D(n,e);return Lt.runKernelFunc((function(t){return t.fft(r)}),{input:t}).reshape(t.shape)}}),Yl=An({ifft_:function(t){C("complex64"===t.dtype,(function(){return"The dtype for tf.spectral.ifft() must be complex64 but got "+t.dtype+"."}));var e=t.shape[t.shape.length-1],n=t.size/e,r=t.as2D(n,e);return Lt.runKernelFunc((function(t){return t.ifft(r)}),{input:t}).reshape(t.shape)}}),$l=An({rfft_:function(t,e){C("float32"===t.dtype,(function(){return"The dtype for rfft() must be real value but got "+t.dtype}));var n,r=t.shape[t.shape.length-1],o=t.size/r;if(null!=e&&e<r){var a=t.shape.map((function(t){return 0})),i=t.shape.map((function(t){return t}));i[t.shape.length-1]=e,n=t.slice(a,i),r=e}else if(null!=e&&e>r){var s=t.shape.map((function(t){return t}));s[t.shape.length-1]=e-r,n=t.concat(Gn(s),t.shape.length-1),r=e}else n=t;var u=n.zerosLike(),c=Dn(n,u).as2D(o,r),l=Xl(c),h=Math.floor(r/2)+1,f=Tn(l),d=Nn(l),p=f.split([h,r-h],f.shape.length-1),v=d.split([h,r-h],d.shape.length-1),m=n.shape.slice();return m[n.shape.length-1]=h,Dn(p[0],v[0]).reshape(m)}}),Ql=An({irfft_:function(t){var e=t.shape[t.shape.length-1],n=t.size/e;if(e<=2){var r=t.as2D(n,e),o=Yl(r);return Tn(o)}var a=[n,2*(e-1)],i=Tn(t).as2D(n,e),s=Nn(t).as2D(n,e),u=i.slice([0,1],[n,e-2]).reverse(1),c=s.slice([0,1],[n,e-2]).reverse(1).mul(On(-1)),l=i.concat(u,1),h=s.concat(c,1);return r=Dn(l,h).as2D(a[0],a[1]),o=Yl(r),Tn(o)}}),Jl=Object.freeze({fft:Xl,ifft:Yl,rfft:$l,irfft:Ql});var Zl=An({sparseToDense_:function(t,e,n,r){void 0===r&&(r=0);var o=mn(t,"sparseIndices","sparseToDense","int32"),a=mn(e,"sparseValues","sparseToDense"),i=mn(r,"defaultValue","sparseToDense",a.dtype);return function(t,e,n,r){if("int32"!==t.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was "+t.dtype+".");if(t.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape "+t.shape+".");var o=t.rank>0?t.shape[0]:1,a=t.rank>1?t.shape[1]:1;if(n.length!==a)throw new Error("outputShape has incorrect number of elements:, "+n.length+", should be: "+a+".");var i=e.size;if(0!==e.rank&&(1!==e.rank||i!==o))throw new Error("sparseValues has incorrect shape "+e.shape+", should be [] or ["+o+"]");if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(o,a,n,i),Lt.runKernelFunc((function(t){return t.sparseToDense(o,a,n,i)}),{$sparseIndices:o,$sparseValues:a,$defaultValue:i})}});var th=An({gatherND_:function(t,e){var n=mn(e,"indices","gatherND","int32"),r=mn(t,"x","gatherND");return Lt.runKernelFunc((function(t){return t.gatherND(r,n)}),{x:r,indices:n},null,"GatherNd")}});var eh=An({diag_:function(t){var e=mn(t,"x","diag").flatten(),n=t.shape.concat(t.shape);return Lt.runKernelFunc((function(t){return t.diag(e)}),{$x:e}).reshape(n)}});var nh=An({dropout_:function(t,e,n,r){var o=mn(t,"x","dropout");if(C("float32"===o.dtype,(function(){return"x has to be a floating point tensor since it's going to be scaled, but got a "+o.dtype+" tensor instead."})),C(e>=0&&e<1,(function(){return"rate must be a float in the range [0, 1), but got "+e+"."})),0===e)return t instanceof wt?o.clone():o;var a=function(t,e){if(null==e)return t.shape.slice();if(S(t.shape,e))return e;if(t.shape.length===e.length){for(var n=[],r=0;r<t.shape.length;r++)null==e[r]&&null!=t.shape[r]?n.push(t.shape[r]):n.push(e[r]);return n}return e}(o,n),i=1-e,s=_r(a,0,1,"float32",r).add(i).floor().div(i);return o.mul(s)}});function rh(t,e,n){for(var r=1-t%2,o=new Float32Array(t),a=0;a<t;++a){var i=2*Math.PI*a/(t+r-1);o[a]=e-n*Math.cos(i)}return Mn(o,"float32")}var oh=An({hannWindow_:function(t){return rh(t,.5,.5)}}),ah=An({hammingWindow_:function(t){return rh(t,.54,.46)}}),ih=An({frame_:function(t,e,n,r,o){void 0===r&&(r=!1),void 0===o&&(o=0);for(var a=0,i=[];a+e<=t.size;)i.push(ml(t,a,e)),a+=n;if(r)for(;a<t.size;){var s=a+e-t.size,u=Yn([ml(t,a,e-s),Hn([s],o)]);i.push(u),a+=n}return 0===i.length?Bn([],[0,e]):Yn(i).as2D(i.length,e)}}),sh=An({stft_:function(t,e,n,r,o){var a;void 0===o&&(o=oh),null==r&&(a=e,r=Math.floor(Math.pow(2,Math.ceil(Math.log(a)/Math.log(2)))));for(var i=ih(t,e,n),s=gc(i,o(e)),u=[],c=0;c<i.shape[0];c++)u.push($l(s.slice([c,0],[1,e]),r));return Yn(u)}}),uh=Object.freeze({hannWindow:oh,hammingWindow:ah,frame:ih,stft:sh});var ch,lh=function(t,e,o){return void 0===o&&(o=1),n(this,void 0,void 0,(function(){var n,a,i,s,u,c,l,h,f,d,p,v,m,g;return r(this,(function(r){switch(r.label){case 0:return n=mn(t,"predictions","inTopK"),a=mn(e,"targets","inTopK"),C(n.rank>1,(function(){return"inTopK() expects the predictions to be of rank 2 or higher, but got "+n.rank})),C(n.rank-1===a.rank,(function(){return"predictions rank should be 1 larger than targets rank, but got predictions rank "+n.rank+" and targets rank "+a.rank})),E(n.shape.slice(0,n.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension."),i=n.shape[n.shape.length-1],C(o>0&&o<=i,(function(){return"'k' passed to inTopK() must be > 0 && <= the predictions last dimension ("+i+"), but got "+o})),[4,n.data()];case 1:return s=r.sent(),[4,a.data()];case 2:for(u=r.sent(),c=[s.length/i,i],h=c[1],f=B("bool",l=c[0]),d=0;d<l;d++){for(p=d*h,v=s.subarray(p,p+h),m=[],g=0;g<v.length;g++)m.push({value:v[g],index:g});for(m.sort((function(t,e){return e.value-t.value})),f[d]=0,g=0;g<o;g++)if(m[g].index===u[d]){f[d]=1;break}}return t!==n&&n.dispose(),e!==a&&a.dispose(),[2,Fn(f,a.shape,"bool")]}}))}))};!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(ch||(ch={}));var hh=An({absoluteDifference_:function(t,e,n,r){void 0===r&&(r=ch.SUM_BY_NONZERO_WEIGHTS);var o=mn(t,"labels","absoluteDifference"),a=mn(e,"predictions","absoluteDifference"),i=null;null!=n&&(i=mn(n,"weights","absoluteDifference")),E(o.shape,a.shape,"Error in absoluteDifference: ");var s=o.sub(a).abs();return fh(s,i,r)}}),fh=An({computeWeightedLoss_:function(t,e,n){void 0===n&&(n=ch.SUM_BY_NONZERO_WEIGHTS);var r=mn(t,"losses","computeWeightedLoss"),o=null;null!=e&&(o=mn(e,"weights","computeWeightedLoss"));var a=null==o?r:r.mul(o);if(n===ch.NONE)return a;if(n===ch.SUM)return a.sum();if(n===ch.MEAN){if(null==o)return a.mean();var i=r.size/o.size,s=a.sum().div(o.sum());return i>1?s.div(On(i)):s}if(n===ch.SUM_BY_NONZERO_WEIGHTS){if(null==o)return a.sum().div(On(r.size));var u=o.mul(zn(r.shape)).notEqual(On(0)).sum().toFloat();return a.sum().div(u)}throw Error("Unknown reduction: "+n)}}),dh=An({cosineDistance_:function(t,e,n,r,o){void 0===o&&(o=ch.SUM_BY_NONZERO_WEIGHTS);var a=mn(t,"labels","cosineDistance"),i=mn(e,"predictions","cosineDistance"),s=null;null!=r&&(s=mn(r,"weights","cosineDistance")),E(a.shape,i.shape,"Error in cosineDistance: ");var u=On(1).sub(a.mul(i).sum(n,!0));return fh(u,s,o)}}),ph=An({hingeLoss_:function(t,e,n,r){void 0===r&&(r=ch.SUM_BY_NONZERO_WEIGHTS);var o=mn(t,"labels","hingeLoss"),a=mn(e,"predictions","hingeLoss"),i=null;null!=n&&(i=mn(n,"weights","hingeLoss")),E(o.shape,a.shape,"Error in hingeLoss: ");var s=On(1);o=On(2).mul(o).sub(s);var u=s.sub(o.mul(a)).relu();return fh(u,i,r)}}),vh=An({huberLoss_:function(t,e,n,r,o){void 0===r&&(r=1),void 0===o&&(o=ch.SUM_BY_NONZERO_WEIGHTS);var a=mn(t,"labels","huberLoss"),i=mn(e,"predictions","huberLoss"),s=null;null!=n&&(s=mn(n,"weights","huberLoss")),E(a.shape,i.shape,"Error in huberLoss: ");var u=On(r),c=i.sub(a).abs(),l=dc(c,u),h=c.sub(l),f=On(.5).mul(l.square()).add(u.mul(h));return fh(f,s,o)}}),mh=An({logLoss_:function(t,e,n,r,o){void 0===r&&(r=1e-7),void 0===o&&(o=ch.SUM_BY_NONZERO_WEIGHTS);var a=mn(t,"labels","logLoss"),i=mn(e,"predictions","logLoss"),s=null;null!=n&&(s=mn(n,"weights","logLoss")),E(a.shape,i.shape,"Error in logLoss: ");var u=On(1),c=On(r),l=a.mul(i.add(c).log()).neg().sub(u.sub(a).mul(u.sub(i).add(c).log()));return fh(l,s,o)}}),gh=An({meanSquaredError_:function(t,e,n,r){void 0===r&&(r=ch.SUM_BY_NONZERO_WEIGHTS);var o=mn(t,"labels","meanSquaredError"),a=mn(e,"predictions","meanSquaredError"),i=null;null!=n&&(i=mn(n,"weights","meanSquaredError")),E(o.shape,a.shape,"Error in meanSquaredError: ");var s=o.squaredDifference(a);return fh(s,i,r)}}),yh=An({sigmoidCrossEntropy_:function(t,e,n,r,o){void 0===r&&(r=0),void 0===o&&(o=ch.SUM_BY_NONZERO_WEIGHTS);var a=mn(t,"multiClassLabels","sigmoidCrossEntropy"),i=mn(e,"logits","sigmoidCrossEntropy"),s=null;if(null!=n&&(s=mn(n,"weights","sigmoidCrossEntropy")),E(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){var u=On(r),c=On(1),l=On(.5);a=a.mul(c.sub(u)).add(l.mul(u))}var h=function(t,e){var n=mn(t,"labels","sigmoidCrossEntropyWithLogits"),r=mn(e,"logits","sigmoidCrossEntropyWithLogits");E(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");var o=r.relu(),a=r.mul(n),i=r.abs().neg().exp().log1p();return o.sub(a).add(i)}(a,i);return fh(h,s,o)}}),xh=An({softmaxCrossEntropy_:function(t,e,n,r,o){void 0===r&&(r=0),void 0===o&&(o=ch.SUM_BY_NONZERO_WEIGHTS);var a=mn(t,"onehotLabels","softmaxCrossEntropy"),i=mn(e,"logits","softmaxCrossEntropy"),s=null;if(null!=n&&(s=mn(n,"weights","softmaxCrossEntropy")),E(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){var u=On(r),c=On(1),l=On(a.shape[1]);a=a.mul(c.sub(u)).add(u.div(l))}var h=function(t,e,n){if(void 0===n&&(n=-1),-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank "+e.rank+" and dim was "+n);return vo((function(t,e,r){var o=e.logSumExp([n],!0),a=e.toFloat().sub(o);r([t,a]);return{value:a.mul(t).neg().sum([n]),gradFunc:function(t,e){var r=e[0],o=e[1],a=wn(t.shape,[n]);return[t.reshape(a).mul(r.toFloat().sub(o.exp())),t.reshape(a).mul(o.exp().sub(r.toFloat()))]}}}))(t,e)}(a,i);return fh(h,s,o)}}),bh=Object.freeze({get Reduction(){return ch},absoluteDifference:hh,computeWeightedLoss:fh,cosineDistance:dh,hingeLoss:ph,huberLoss:vh,logLoss:mh,meanSquaredError:gh,sigmoidCrossEntropy:yh,softmaxCrossEntropy:xh});function wh(t,e){return void 0===e&&(e=!1),Lt.tidy((function(){if(2!==t.shape.length)throw new Error("qr2d() requires a 2D Tensor, but got a "+t.shape.length+"D Tensor.");for(var n=t.shape[0],r=t.shape[1],o=Cr(n),a=t.clone(),i=Bn([[1]],[1,1]),s=i.clone(),u=n>=r?r:n,c=function(t){var e,u=a,c=s,l=o;e=Lt.tidy((function(){var e=a.slice([t,t],[n-t,1]),u=e.norm(),c=a.slice([t,t],[1,1]),l=Bn([[-1]]).where(c.greater(0),Bn([[1]])),h=c.sub(l.mul(u)),f=e.div(h);s=1===f.shape[0]?i.clone():i.concat(f.slice([1,0],[f.shape[0]-1,f.shape[1]]),0);var d=l.matMul(h).div(u).neg(),p=a.slice([t,0],[n-t,r]),v=d.mul(s);if(0===t)a=p.sub(v.matMul(s.transpose().matMul(p)));else{var m=p.sub(v.matMul(s.transpose().matMul(p)));a=a.slice([0,0],[t,r]).concat(m,0)}var g=o.slice([0,t],[n,o.shape[1]-t]);if(0===t)o=g.sub(g.matMul(s).matMul(v.transpose()));else{var y=g.sub(g.matMul(s).matMul(v.transpose()));o=o.slice([0,0],[n,t]).concat(y,1)}return[s,a,o]})),s=e[0],a=e[1],o=e[2],tn([u,c,l])},l=0;l<u;++l)c(l);return!e&&n>r&&(o=o.slice([0,0],[n,r]),a=a.slice([0,0],[r,r])),[o,a]}))}var Ch=An({bandPart_:function(t,e,n){if(e%1!=0)throw new Error("bandPart(): numLower must be an integer, got "+e+".");if(n%1!=0)throw new Error("bandPart(): numUpper must be an integer, got "+n+".");var r=mn(t,"a","bandPart");if(r.rank<2)throw new Error("bandPart(): Rank must be at least 2, got "+r.rank+".");var o=r.shape,a=r.shape.slice(-2),i=a[0],s=a[1];if(!(e<=i))throw new Error("bandPart(): numLower ("+e+") must not be greater than the number of rows ("+i+").");if(!(n<=s))throw new Error("bandPart(): numUpper ("+n+") must not be greater than the number of columns ("+s+").");e<0&&(e=i),n<0&&(n=s);var u=Kn(0,i,1,"int32").reshape([-1,1]),c=Kn(0,s,1,"int32"),l=Cc(u,c),h=Qu(l.lessEqual(On(+e,"int32")),l.greaterEqual(On(-n,"int32"))),f=Gn([i,s],r.dtype);return Pr(Ur(r.reshape([-1,i,s])).map((function(t){return ec(h,t,f)}))).reshape(o)}}),Eh=An({gramSchmidt_:function(t){var e;if(Array.isArray(t)){e=!1,C(null!=t&&t.length>0,(function(){return"Gram-Schmidt process: input must not be null, undefined, or empty"}));for(var n=t[0].shape[0],r=function(e){C(t[e].shape[0]===n,(function(){return"Gram-Schmidt: Non-unique lengths found in the input vectors: ("+t[e].shape[0]+" vs. "+n+")"}))},o=1;o<t.length;++o)r(o)}else e=!0,t=tr(t,t.shape[0],0).map((function(t){return Br(t,[0])}));C(t.length<=t[0].shape[0],(function(){return"Gram-Schmidt: Number of vectors ("+t.length+") exceeds number of dimensions ("+t[0].shape[0]+")."}));var a=[],i=t,s=function(t){a.push(Lt.tidy((function(){var e=i[t];if(t>0)for(var n=0;n<t;++n){var r=Nl(a[n].mulStrict(e)).mul(a[n]);e=e.sub(r)}return e.div(Vl(e,"euclidean"))})))};for(o=0;o<t.length;++o)s(o);return e?Pr(a,0):a}}),Rh=An({qr_:function(t,e){if(void 0===e&&(e=!1),t.rank<2)throw new Error("qr() requires input tensor to have a rank >= 2, but got rank "+t.rank);if(2===t.rank)return wh(t,e);var n=t.shape.slice(0,t.shape.length-2).reduce((function(t,e){return t*e})),r=Ur(t.reshape([n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),o=[],a=[];return r.forEach((function(t){var n=wh(t,e),r=n[0],i=n[1];o.push(r),a.push(i)})),[Pr(o,0).reshape(t.shape),Pr(a,0).reshape(t.shape)]}}),Ih=Object.freeze({bandPart:Ch,gramSchmidt:Eh,qr:Rh});function kh(t,e,n,r,o,a){null==r&&(r=.5),null==o&&(o=Number.NEGATIVE_INFINITY),null==a&&(a=0);var i=t.shape[0];return n=Math.min(n,i),C(0<=r&&r<=1,(function(){return"iouThreshold must be in [0, 1], but was '"+r+"'"})),C(2===t.rank,(function(){return"boxes must be a 2D tensor, but was of rank '"+t.rank+"'"})),C(4===t.shape[1],(function(){return"boxes must have 4 columns, but 2nd dimension was "+t.shape[1]})),C(1===e.rank,(function(){return"scores must be a 1D tensor"})),C(e.shape[0]===i,(function(){return"scores has incompatible shape with boxes. Expected "+i+", but was "+e.shape[0]})),C(0<=a&&a<=1,(function(){return"softNmsSigma must be in [0, 1], but was '"+a+"'"})),{maxOutputSize:n,iouThreshold:r,scoreThreshold:o,softNmsSigma:a}}var Sh=An({resizeBilinear_:function(t,e,n){void 0===n&&(n=!1);var r=mn(t,"images","resizeBilinear");C(3===r.rank||4===r.rank,(function(){return"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+r.rank+"."})),C(2===e.length,(function(){return"Error in resizeBilinear: new shape must 2D, but got shape "+e+"."}));var o=r,a=!1;3===r.rank&&(a=!0,o=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));var i=e[0],s=e[1],u=Lt.runKernelFunc((function(t,e){return e([o]),t.resizeBilinear(o,i,s,n)}),{x:o},(function(t,e){return{x:function(){return Lt.runKernelFunc((function(r){return r.resizeBilinearBackprop(t,e[0],n)}),{})}}}),"ResizeBilinear",{alignCorners:n,newHeight:i,newWidth:s});return a?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}}),Ah=An({resizeNearestNeighbor_:function(t,e,n){void 0===n&&(n=!1);var r=mn(t,"images","resizeNearestNeighbor");C(3===r.rank||4===r.rank,(function(){return"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+r.rank+"."})),C(2===e.length,(function(){return"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+e+"."})),C("float32"===r.dtype||"int32"===r.dtype,(function(){return"`images` must have `int32` or `float32` as dtype"}));var o=r,a=!1;3===r.rank&&(a=!0,o=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));var i=e[0],s=e[1],u=Lt.runKernelFunc((function(t,e){return e([o]),t.resizeNearestNeighbor(o,i,s,n)}),{batchImages:o},(function(t,e){return{batchImages:function(){return Lt.runKernelFunc((function(r){return r.resizeNearestNeighborBackprop(t,e[0],n)}),{})}}}));return a?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}}),Dh=An({nonMaxSuppression_:function(t,e,n,r,o){void 0===r&&(r=.5),void 0===o&&(o=Number.NEGATIVE_INFINITY);var a=mn(t,"boxes","nonMaxSuppression"),i=mn(e,"scores","nonMaxSuppression"),s=kh(a,i,n,r,o);n=s.maxOutputSize,r=s.iouThreshold,o=s.scoreThreshold;var u={maxOutputSize:n,iouThreshold:r,scoreThreshold:o};return Lt.runKernelFunc((function(t){return t.nonMaxSuppression(a,i,n,r,o)}),{boxes:a,scores:i},null,"NonMaxSuppressionV3",u)}}),Th=function(t,e,o,a,i){return void 0===a&&(a=.5),void 0===i&&(i=Number.NEGATIVE_INFINITY),n(this,void 0,void 0,(function(){var n,s,u,c,l,h,f;return r(this,(function(r){switch(r.label){case 0:return n=mn(t,"boxes","nonMaxSuppressionAsync"),s=mn(e,"scores","nonMaxSuppressionAsync"),u=kh(n,s,o,a,i),o=u.maxOutputSize,a=u.iouThreshold,i=u.scoreThreshold,[4,Promise.all([n.data(),s.data()])];case 1:return c=r.sent(),l=c[0],h=c[1],f=jo(l,h,o,a,i),n!==t&&n.dispose(),s!==e&&s.dispose(),[2,f]}}))}))},Nh=An({nonMaxSuppressionWithScore_:function(t,e,n,r,o,a){void 0===r&&(r=.5),void 0===o&&(o=Number.NEGATIVE_INFINITY),void 0===a&&(a=0);var i=mn(t,"boxes","nonMaxSuppression"),s=mn(e,"scores","nonMaxSuppression"),u=kh(i,s,n,r,o,a),c={maxOutputSize:n=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:o=u.scoreThreshold,softNmsSigma:a=u.softNmsSigma},l=Lt.runKernel("NonMaxSuppressionV5",{boxes:i,scores:s},c);return{selectedIndices:l[0],selectedScores:l[1]}}}),Fh=function(t,e,o,a,i,s){return void 0===a&&(a=.5),void 0===i&&(i=Number.NEGATIVE_INFINITY),void 0===s&&(s=0),n(this,void 0,void 0,(function(){var n,u,c,l,h,f,d;return r(this,(function(r){switch(r.label){case 0:return n=mn(t,"boxes","nonMaxSuppressionAsync"),u=mn(e,"scores","nonMaxSuppressionAsync"),c=kh(n,u,o,a,i,s),o=c.maxOutputSize,a=c.iouThreshold,i=c.scoreThreshold,s=c.softNmsSigma,[4,Promise.all([n.data(),u.data()])];case 1:return l=r.sent(),h=l[0],f=l[1],d=Xo(h,f,o,a,i,s),n!==t&&n.dispose(),u!==e&&u.dispose(),[2,d]}}))}))},_h=An({cropAndResize_:function(t,e,n,r,o,a){var i=mn(t,"image","cropAndResize"),s=mn(e,"boxes","cropAndResize","float32"),u=mn(n,"boxInd","cropAndResize","int32");o=o||"bilinear",a=a||0;var c=s.shape[0];return C(4===i.rank,(function(){return"Error in cropAndResize: image must be rank 4,but got rank "+i.rank+"."})),C(2===s.rank&&4===s.shape[1],(function(){return"Error in cropAndResize: boxes must be have size ["+c+",4] but had shape "+s.shape+"."})),C(1===u.rank&&u.shape[0]===c,(function(){return"Error in cropAndResize: boxInd must be have size ["+c+"] but had shape "+s.shape+"."})),C(2===r.length,(function(){return"Error in cropAndResize: cropSize must be of length 2, but got length "+r.length+"."})),C(r[0]>=1&&r[1]>=1,(function(){return"cropSize must be atleast [1,1], but was "+r})),C("bilinear"===o||"nearest"===o,(function(){return"method must be bilinear or nearest, but was "+o})),Lt.runKernelFunc((function(t,e){return t.cropAndResize(i,s,u,r,o,a)}),{images:i,boxes:s,boxInd:u},null,"CropAndResize",{method:o,extrapolationValue:a,cropSize:r})}}),Oh=Object.freeze({resizeBilinear:Sh,resizeNearestNeighbor:Ah,nonMaxSuppression:Dh,nonMaxSuppressionAsync:Th,nonMaxSuppressionWithScore:Nh,nonMaxSuppressionWithScoreAsync:Fh,cropAndResize:_h}),Mh=function(t,e){return!(t>0)||"linear"===e},Bh=function(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return t.mul(e.step());throw new Error("Gradient for activation "+n+" has not been implemented yet.")},Ph=function(t,e){var n=e,r=Eo(t.shape,e.shape);return r.length>0&&(n=n.sum(r)),n.reshape(t.shape)},Lh=function(t,e,n){if("linear"===e)return t;if("relu"===e)return Bl(t);if("elu"===e)return _l(t);if("relu6"===e)return Pl(t);if("prelu"===e)return Ml(t,n);throw new Error("Unknown fused activation "+e+".")};var Wh=An({fusedMatMul_:function(t){var e,n=t.a,r=t.b,o=t.transposeA,a=void 0!==o&&o,i=t.transposeB,s=void 0!==i&&i,u=t.bias,c=t.activation,l=void 0===c?"linear":c,h=t.preluActivationWeights;if(!1===Mh(Lt.state.gradientDepth,l)){var f=el(n,r,a,s);return null!=u&&(f=rc(f,u)),Lh(f,l,h)}var d=mn(n,"a","fused matMul"),p=mn(r,"b","fused matMul");e=Nt(d,p),d=e[0],p=e[1];var v=a?d.shape[d.rank-2]:d.shape[d.rank-1],m=s?p.shape[p.rank-1]:p.shape[p.rank-2],g=a?d.shape[d.rank-1]:d.shape[d.rank-2],y=s?p.shape[p.rank-2]:p.shape[p.rank-1],x=d.shape.slice(0,-2),b=p.shape.slice(0,-2),w=k(x),E=k(b);C(d.rank>=2&&p.rank>=2&&d.rank===p.rank,(function(){return"Error in fused matMul: inputs must have the same rank of at least 2, got ranks "+d.rank+" and "+p.rank+"."})),C(S(x,b),(function(){return"Error in fused matMul: outer dimensions ("+x+") and ("+b+") of Tensors with shapes "+d.shape+" and "+p.shape+" must match."})),C(v===m,(function(){return"Error in fused matMul: inner shapes ("+v+") and ("+m+") of Tensors with shapes "+d.shape+" and "+p.shape+" and transposeA="+a+" and transposeB="+s+" must match."}));var R,I,A=d.shape.slice(0,-2).concat([g,y]),D=a?d.as3D(w,v,g):d.as3D(w,g,v),T=s?p.as3D(E,y,m):p.as3D(E,m,y);null!=u&&Ro(A,(R=Nt(R=mn(u,"bias","fused matMul"),d)[0]).shape),null!=h&&(I=mn(h,"prelu weights","fused matMul"));var N={a:D,b:T};null!=u&&(N.bias=R),null!=h&&(N.preluActivationWeights=I);var F=[D,T];return Lt.runKernelFunc((function(t,e){var n=t.fusedBatchMatMul({a:D,b:T,transposeA:a,transposeB:s,bias:R,activation:l,preluActivationWeights:I});return e([D,T,n]),n}),N,(function(t,e){var n=e[0],r=e[1],o=e[2],i=Bh(t,o,l),c={};return null!=u&&(c={bias:function(){return Ph(R,i)}}),a||s?!a&&s?Object.assign({a:function(){return i.matMul(r,!1,!1)},b:function(){return i.matMul(n,!0,!1)}},c):a&&!s?Object.assign({a:function(){return r.matMul(i,!1,!0)},b:function(){return n.matMul(i,!1,!1)}},c):Object.assign({a:function(){return r.matMul(i,!0,!0)},b:function(){return i.matMul(n,!0,!0)}},c):Object.assign({a:function(){return i.matMul(r,!1,!0)},b:function(){return n.matMul(i,!0,!1)}},c)}),"_FusedMatMul",{transposeA:a,transposeB:s,activation:l},F,[!0]).reshape(A)}}),Uh=An({fusedConv2d_:function(t){var e=t.x,n=t.filter,r=t.strides,o=t.pad,a=t.dataFormat,i=void 0===a?"NHWC":a,s=t.dilations,u=void 0===s?[1,1]:s,c=t.dimRoundingMode,l=t.bias,h=t.activation,f=void 0===h?"linear":h,d=t.preluActivationWeights;if(f=f||"linear",!1===Mh(Lt.state.gradientDepth,f)){var p=qc(e,n,r,o,i,u,c);return null!=l&&(p=rc(p,l)),Lh(p,f,d)}var v=mn(e,"x","conv2d"),m=mn(n,"filter","conv2d"),g=v,y=!1;3===v.rank&&(y=!0,g=v.as4D(1,v.shape[0],v.shape[1],v.shape[2])),C(4===g.rank,(function(){return"Error in fused conv2d: input must be rank 4, but got rank "+g.rank+"."})),C(4===m.rank,(function(){return"Error in fused conv2d: filter must be rank 4, but got rank "+m.rank+"."})),null!=c&&C(A(o),(function(){return"Error in fused conv2d: pad must be an integer when using, dimRoundingMode "+c+" but got pad "+o+"."})),C(g.shape[3]===m.shape[2],(function(){return"Error in conv2d: depth of input ("+g.shape[3]+") must match input depth for filter "+m.shape[2]+"."})),C(Mo(r,u),(function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+u+"'"})),C("NHWC"===i,(function(){return"Error in conv2d: got dataFormat of "+i+" but only NHWC is currently supported."}));var x,b,w=So(g.shape,m.shape,r,u,o,c);null!=l&&(x=Nt(x=mn(l,"bias","fused conv2d"),v)[0],Ro(w.outShape,x.shape)),null!=d&&(b=mn(d,"prelu weights","fused conv2d"));var E={x:g,filter:m};null!=l&&(E.bias=x),null!=d&&(E.preluActivationWeights=b);var R=[m,g],I=Lt.runKernelFunc((function(t,e){var n=t.fusedConv2d({input:g,filter:m,convInfo:w,bias:x,activation:f,preluActivationWeights:b});return e([m,g,n]),n}),E,(function(t,e){var n=e,a=n[0],i=n[1],s=n[2],c=Bh(t,s,f);C(Oo(u),(function(){return"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+u+"'"}));var h={};return null!=l&&(h={bias:function(){return Ph(x,c)}}),Object.assign({x:function(){return Xc(i.shape,c,a,r,o)},filter:function(){return jc(i,c,a.shape,r,o)}},h)}),"FusedConv2D",{convInfo:w,activation:f},R,[!0]);return y?I.as3D(I.shape[1],I.shape[2],I.shape[3]):I}}),Vh=An({fusedDepthwiseConv2d_:function(t){var e=t.x,n=t.filter,r=t.strides,o=t.pad,a=t.dataFormat,i=void 0===a?"NHWC":a,s=t.dilations,u=void 0===s?[1,1]:s,c=t.dimRoundingMode,l=t.bias,h=t.activation,f=void 0===h?"linear":h,d=t.preluActivationWeights;if(!1===Mh(Lt.state.gradientDepth,f)){var p=Yc(e,n,r,o,i,u,c);return null!=l&&(p=rc(p,l)),Lh(p,f,d)}var v=mn(e,"x","depthwiseConv2d"),m=mn(n,"filter","depthwiseConv2d"),g=v,y=!1;3===v.rank&&(y=!0,g=v.as4D(1,v.shape[0],v.shape[1],v.shape[2])),C(4===g.rank,(function(){return"Error in fused depthwiseConv2d: input must be rank 4, but got rank "+g.rank+"."})),C(4===m.rank,(function(){return"Error in fused depthwiseConv2d: filter must be rank 4, but got rank "+m.rank+"."})),C(g.shape[3]===m.shape[2],(function(){return"Error in fused depthwiseConv2d: number of input channels ("+g.shape[3]+") must match the inChannels dimension in filter "+m.shape[2]+"."})),null==u&&(u=[1,1]),C(Mo(r,u),(function(){return"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+u+"'"})),null!=c&&C(A(o),(function(){return"Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode "+c+" but got pad "+o+"."}));var x,b,w=So(g.shape,m.shape,r,u,o,c,!0);null!=l&&(x=Nt(x=mn(l,"bias","fused conv2d"),v)[0],Ro(w.outShape,x.shape)),null!=d&&(b=mn(d,"prelu weights","fused depthwiseConv2d"));var E={x:g,filter:m};null!=l&&(E.bias=x),null!=d&&(E.preluActivationWeights=b);var R=[m,g],I=Lt.runKernelFunc((function(t,e){var n=t.fusedDepthwiseConv2D({input:g,filter:m,convInfo:w,bias:x,activation:f,preluActivationWeights:b});return e([m,g,n]),n}),E,(function(t,e){C(Oo(u),(function(){return"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+u+"'"}));var n=e[0],r=e[1],o=e[2],a=Bh(t,o,f),i={};return null!=l&&(i={bias:function(){return Ph(x,a)}}),Object.assign({x:function(){return $c(r.shape,a,n,w)},filter:function(){return Qc(r,a,n.shape,w)}},i)}),"FusedDepthwiseConv2D",{convInfo:w,activation:f},R,[!0]);return y?I.as3D(I.shape[1],I.shape[2],I.shape[3]):I}}),zh=Object.freeze({matMul:Wh,conv2d:Uh,depthwiseConv2d:Vh}),Gh=Object.freeze({image:Oh,linalg:Ih,losses:bh,spectral:Jl,fused:zh,signal:uh,square:tu,squaredDifference:nu,conv1d:Hc,conv2d:qc,conv3d:Kc,depthwiseConv2d:Yc,separableConv2d:Jc,conv2dTranspose:Zc,conv3dTranspose:tl,op:An,batchNormalization2d:Gu,batchNormalization3d:Hu,batchNormalization4d:qu,batchNormalization:Ku,batchNorm:ju,batchNorm2d:Xu,batchNorm3d:Yu,batchNorm4d:$u,booleanMaskAsync:Uc,complex:Dn,real:Tn,imag:Nn,concat:Yn,concat1d:$n,concat2d:Qn,concat3d:Jn,concat4d:Zn,split:tr,matMul:el,dot:nl,outerProduct:rl,reverse:ol,reverse1d:al,reverse2d:il,reverse3d:sl,reverse4d:ul,maxPool:hl,avgPool:fl,pool:dl,maxPool3d:pl,avgPool3d:vl,slice:ml,slice1d:gl,slice2d:yl,slice3d:xl,slice4d:bl,abs:ru,acos:ou,acosh:au,asin:iu,asinh:su,atan:uu,atanh:cu,ceil:lu,clipByValue:hu,cos:fu,cosh:du,erf:pu,exp:vu,expm1:mu,floor:gu,log:yu,log1p:xu,logSigmoid:bu,neg:wu,reciprocal:Cu,round:Eu,rsqrt:Ru,sigmoid:Iu,sign:ku,isNaN:Su,isInf:Au,isFinite:Du,sin:Tu,sinh:Nu,softplus:Fu,sqrt:_u,step:Ou,tan:Mu,tanh:Bu,all:Cl,any:El,argMax:Rl,argMin:Il,logSumExp:kl,max:Sl,mean:Al,min:Dl,moments:Tl,sum:Nl,prod:Fl,equal:Rc,equalStrict:Ic,greater:kc,greaterEqual:Sc,greaterEqualStrict:Ac,greaterStrict:Dc,less:Tc,lessEqual:Nc,lessEqualStrict:Fc,lessStrict:_c,notEqual:Oc,notEqualStrict:Mc,add:rc,addN:oc,addStrict:ac,atan2:ic,div:sc,divNoNan:uc,divStrict:cc,floorDiv:lc,maximum:hc,maximumStrict:fc,minimum:dc,minimumStrict:pc,mod:vc,modStrict:mc,mul:gc,mulStrict:yc,pow:xc,powStrict:bc,squaredDifferenceStrict:wc,sub:Cc,subStrict:Ec,elu:_l,leakyRelu:Ol,prelu:Ml,relu:Bl,relu6:Pl,selu:Ll,logicalAnd:Qu,logicalNot:Ju,logicalOr:Zu,logicalXor:tc,where:ec,whereAsync:nc,buffer:dr,print:pr,batchToSpaceND:vr,broadcastTo:mr,cast:gr,clone:yr,cumsum:xr,depthToSpace:br,expandDims:wr,eye:Cr,multinomial:Er,oneHot:Rr,pad:Ir,pad1d:kr,pad2d:Sr,pad3d:Ar,pad4d:Dr,rand:Tr,randomNormal:Nr,randomGamma:Fr,randomUniform:_r,reshape:Or,spaceToBatchND:Mr,squeeze:Br,stack:Pr,tile:Lr,truncatedNormal:Wr,unstack:Ur,setdiff1dAsync:Vr,fill:Hn,linspace:qn,ones:zn,range:Kn,scalar:On,tensor:Fn,tensor1d:Mn,tensor2d:Bn,tensor3d:Pn,tensor4d:Ln,tensor5d:Wn,tensor6d:Un,variable:Vn,zeros:Gn,onesLike:jn,zerosLike:Xn,transpose:Wl,softmax:go,logSoftmax:yo,localResponseNormalization:Ul,norm:Vl,gather:Lc,unsortedSegmentSum:Wc,basicLSTMCell:zl,multiRNNCell:Gl,movingAverage:Hl,stridedSlice:ql,topk:Kl,scatterND:jl,fft:Xl,ifft:Yl,rfft:$l,irfft:Ql,sparseToDense:Zl,gatherND:th,diag:eh,dropout:nh,hannWindow:oh,hammingWindow:ah,frame:ih,stft:sh,inTopKAsync:lh});function Hh(t,e){Array.isArray(t)||(t=[t]),t.forEach((function(t){null!=t&&C("complex64"!==t.dtype,(function(){return e+" does not support complex64 tensors."}))}))}function qh(t,e,n,r){if("linear"===n)return t.linear(e);if("relu"===n)return t.relu(e);if("elu"===n)return t.elu(e);if("relu6"===n)return t.relu6(e);if("prelu"===n)return t.prelu(e,r);throw new Error("Activation "+n+" has not been implemented for the CPU backend.")}var Kh=function(t){function o(){var e=t.call(this)||this;return e.blockSize=48,e.firstUse=!0,e.data=new xo(e,Lt),e}return e(o,t),o.prototype.write=function(t,e,n){this.firstUse&&(this.firstUse=!1,i().get("IS_NODE")&&dn("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));var r={};return this.data.set(r,{values:t,dtype:n}),r},o.prototype.move=function(t,e,n,r){this.data.set(t,{values:e,dtype:r})},o.prototype.numDataIds=function(){return this.data.numDataIds()},o.prototype.read=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(e){return[2,this.readSync(t)]}))}))},o.prototype.readSync=function(t){var e=this.data.get(t),n=e.dtype,r=e.complexTensors;return"complex64"===n?Vo(this.readSync(r.real.dataId),this.readSync(r.imag.dataId)):this.data.get(t).values},o.prototype.bufferSync=function(t){var e=this.readSync(t.dataId),n=e;if("string"===t.dtype)try{n=e.map((function(t){return ot(t)}))}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}return dr(t.shape,t.dtype,n)},o.prototype.makeOutput=function(t,e,n){var r=this.write(t,e,n);return Lt.makeTensorFromDataId(r,e,n,this)},o.prototype.disposeData=function(t){if(this.data.has(t)){var e=this.data.get(t).complexTensors;null!=e&&(e.real.dispose(),e.imag.dispose()),this.data.delete(t)}},o.prototype.time=function(t){return n(this,void 0,void 0,(function(){var e;return r(this,(function(n){return e=et(),t(),[2,{kernelMs:et()-e}]}))}))},o.prototype.memory=function(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}},o.prototype.complex=function(t,e){var n=this.makeOutput(null,t.shape,"complex64");return this.data.get(n.dataId).complexTensors={real:Lt.keep(t.clone()),imag:Lt.keep(e.clone())},n},o.prototype.real=function(t){return this.data.get(t.dataId).complexTensors.real.clone()},o.prototype.imag=function(t){return this.data.get(t.dataId).complexTensors.imag.clone()},o.prototype.slice=function(t,e,n){if(Hh(t,"slice"),io(t.shape,e,n)){var r=so(e,t.strides),o=k(n);return Fn(this.readSync(t.dataId).subarray(r,r+o),n,t.dtype)}for(var a=dr(n,t.dtype),i=this.bufferSync(t),s=0;s<a.size;++s){var u=a.indexToLoc(s).map((function(t,n){return t+e[n]}));a.values[s]=i.get.apply(i,u)}return a.toTensor()},o.prototype.stridedSlice=function(t,e,n,r){Hh(t,"stridedSlice");var o=ro(e,n,r);if(o.some((function(t){return 0===t})))return Fn([],o);for(var a=dr(o,t.dtype),i=this.bufferSync(t),s=0;s<a.size;s++){for(var u=a.indexToLoc(s),c=new Array(u.length),l=0;l<c.length;l++)c[l]=u[l]*r[l]+e[l];a.set.apply(a,[i.get.apply(i,c)].concat(u))}return a.toTensor()},o.prototype.diag=function(t){for(var e=this.readSync(t.dataId),n=dr([t.size,t.size],t.dtype),r=n.values,o=0;o<e.length;o++)r[o*t.size+o]=e[o];return n.toTensor()},o.prototype.unstack=function(t,e){for(var n=t.shape[e],r=new Array(t.rank-1),o=0,a=0;a<t.rank;a++)a!==e&&(r[o++]=t.shape[a]);var i=new Array(t.rank).fill(0),s=t.shape.slice();s[e]=1;var u=new Array(n);for(a=0;a<u.length;a++)i[e]=a,u[a]=this.slice(t,i,s).reshape(r);return u},o.prototype.reverse=function(t,e){Hh(t,"reverse");for(var n=dr(t.shape,t.dtype),r=this.bufferSync(t),o=function(o){var a=n.indexToLoc(o),i=a.slice();e.forEach((function(e){return i[e]=t.shape[e]-1-i[e]})),n.set.apply(n,[r.get.apply(r,i)].concat(a))},a=0;a<n.size;a++)o(a);return n.toTensor()},o.prototype.concat=function(t,e){var n=this;if("complex64"===t[0].dtype){var r=t.map((function(t){return Tn(t)})),o=t.map((function(t){return Nn(t)}));return Dn(this.concat(r,e),this.concat(o,e))}var a=t.map((function(t){var n=k(t.shape.slice(e));return t.as2D(-1,n)})),i=Sn(a.map((function(t){return t.shape})),1),s=dr(i,t[0].dtype).values;if(1===a[0].shape[0]){var u=0;a.forEach((function(t){s.set(n.readSync(t.dataId),u),u+=t.size}))}else{var c=0;a.forEach((function(t){for(var e=n.readSync(t.dataId),r=0,o=0;o<t.shape[0];++o)for(var a=o*i[1]+c,u=0;u<t.shape[1];++u)s[a+u]=e[r++];c+=t.shape[1]}))}var l=Sn(t.map((function(t){return t.shape})),e);return Fn(s,l,t[0].dtype)},o.prototype.neg=function(t){return Hh(t,"neg"),this.multiply(On(-1),t)},o.prototype.add=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(function(t,e,n,r){return{real:t+n,imag:e+r}})):this.broadcastedBinaryOp(t,e,Dt(t.dtype,e.dtype),(function(t,e){return t+e}))},o.prototype.addN=function(t){var e=this;Hh(t,"addN");for(var n=t.map((function(t){return e.readSync(t.dataId)})),r=dr(t[0].shape,t[0].dtype),o=r.values,a=0;a<t.length;a++)for(var i=n[a],s=0;s<o.length;s++)o[s]+=i[s];return r.toTensor()},o.prototype.softmax=function(t,e){var n=O([e],t.shape),r=this.max(t,n),o=wn(r.shape,n),a=this.subtract(t,r.reshape(o)),i=this.exp(a),s=this.sum(i,n).reshape(o);return this.realDivide(i,s)},o.prototype.subtract=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(function(t,e,n,r){return{real:t-n,imag:e-r}})):this.broadcastedBinaryOp(t,e,Dt(t.dtype,e.dtype),(function(t,e){return t-e}))},o.prototype.pow=function(t,e){return Hh([t,e],"pow"),this.broadcastedBinaryOp(t,e,t.dtype,(function(t,e){return Math.pow(t,e)}))},o.prototype.batchMatMul=function(t,e,n,r){Hh([t,e],"matMul");for(var o=n?t.shape[1]:t.shape[2],a=n?t.shape[2]:t.shape[1],i=r?e.shape[1]:e.shape[2],s=t.shape[0],u=this.readSync(t.dataId),c=this.readSync(e.dataId),l=n?[t.strides[0],1,t.strides[1]]:[t.strides[0],t.strides[1],1],h=l[0],f=l[1],d=l[2],p=r?[1,e.strides[1],e.strides[0]]:[e.strides[1],1,e.strides[0]],v=p[0],m=p[1],g=p[2],y=a*i,x=dr([s,a,i],t.dtype),b=x.values,w=this.blockSize,C=0;C<s;C++)for(var E=0;E<a;E+=w)for(var R=0;R<i;R+=w)for(var I=0;I<o;I+=w)for(var k=Math.min(E+w,a),S=Math.min(R+w,i),A=Math.min(I+w,o),D=E;D<k;D++)for(var T=R;T<S;T++){for(var N=0,F=I;F<A;F++)N+=u[C*h+D*f+F*d]*c[F*v+T*m+C*g];b[C*y+(D*i+T)]+=N}return x.toTensor()},o.prototype.fusedBatchMatMul=function(t){var e=t.a,n=t.b,r=t.transposeA,o=t.transposeB,a=t.bias,i=t.activation,s=t.preluActivationWeights,u=this.batchMatMul(e,n,r,o);return a&&(u=this.add(u,a)),i&&(u=qh(this,u,i,s)),u},o.prototype.multiply=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(function(t,e,n,r){return{real:t*n-e*r,imag:t*r+e*n}})):this.broadcastedBinaryOp(t,e,Dt(t.dtype,e.dtype),(function(t,e){return t*e}))},o.prototype.realDivide=function(t,e){Hh([t,e],"realDivide");return this.broadcastedBinaryOp(t,e,"float32",(function(t,e){return t/e}))},o.prototype.floorDiv=function(t,e){Hh([t,e],"floorDiv");return this.broadcastedBinaryOp(t,e,"int32",(function(t,e){return Math.floor(t/e)}))},o.prototype.sum=function(t,e){Hh(t,"sum"),Cn("sum",e,t.rank);for(var n=bn(t.shape,e),r=n[0],o=n[1],a=Gn(r,Dt(t.dtype,"int32")),i=k(o),s=this.readSync(a.dataId),u=this.readSync(t.dataId),c=0;c<s.length;++c){for(var l=c*i,h=0,f=0;f<i;++f)h+=u[l+f];s[c]=h}return a},o.prototype.prod=function(t,e){Hh(t,"sum");for(var n=bn(t.shape,e),r=n[0],o=n[1],a=Gn(r,Dt(t.dtype,"int32")),i=k(o),s=this.readSync(a.dataId),u=this.readSync(t.dataId),c=0;c<s.length;++c){for(var l=c*i,h=1,f=0;f<i;++f)h*=u[l+f];s[c]=h}return a},o.prototype.unsortedSegmentSum=function(t,e,n){Hh(t,"unsortedSegmentSum");for(var r=[],o=t.rank-e.rank,a=0;a<o;++a)e=e.expandDims(a+1);for(a=0;a<n;++a){var i=On(a,"int32"),s=Rc(i,e).asType("float32").mul(t).sum(0);r.push(s)}return Pr(r)},o.prototype.argMin=function(t,e){Hh(t,"argMin");var n=[e];Cn("argMin",n,t.rank);for(var r=bn(t.shape,n),o=r[0],a=r[1],i=Gn(o,"int32"),s=k(a),u=this.readSync(i.dataId),c=this.readSync(t.dataId),l=0;l<u.length;++l){for(var h=l*s,f=c[h],d=0,p=0;p<s;++p){var v=c[h+p];v<f&&(f=v,d=p)}u[l]=d}return i},o.prototype.argMax=function(t,e){Hh(t,"argMax");var n=[e];Cn("argMax",n,t.rank);for(var r=bn(t.shape,n),o=r[0],a=r[1],i=Gn(o,"int32"),s=k(a),u=this.readSync(i.dataId),c=this.readSync(t.dataId),l=0;l<u.length;++l){for(var h=l*s,f=c[h],d=0,p=0;p<s;++p){var v=c[h+p];v>f&&(f=v,d=p)}u[l]=d}return i},o.prototype.cumsum=function(t,e,n,r){if(Hh(t,"cumsum"),e!==t.rank-1)throw new Error("backend.cumsum in CPU expects an inner-most axis="+(t.rank-1)+" but got axis="+e);for(var o=Dt(t.dtype,"int32"),a=Gn(t.shape,o),i=this.readSync(a.dataId),s=this.readSync(t.dataId),u=t.shape[t.rank-1],c=r?function(t,e){return t+u-e-1}:function(t,e){return t+e},l=0;l<s.length;l+=u)for(var h=0;h<u;h++){var f=c(l,h);if(0===h)i[f]=n?0:s[f];else{var d=c(l,h-1);i[f]=n?s[d]+i[d]:s[f]+i[d]}}return a},o.prototype.equal=function(t,e){return Hh([t,e],"equal"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t===e?1:0}))},o.prototype.notEqual=function(t,e){return Hh([t,e],"notEqual"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t!==e?1:0}))},o.prototype.less=function(t,e){return Hh([t,e],"less"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t<e?1:0}))},o.prototype.lessEqual=function(t,e){return Hh([t,e],"lessEqual"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t<=e?1:0}))},o.prototype.greater=function(t,e){return Hh([t,e],"greater"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t>e?1:0}))},o.prototype.greaterEqual=function(t,e){return Hh([t,e],"greaterEqual"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t>=e?1:0}))},o.prototype.logicalNot=function(t){Hh(t,"logicalNot");for(var e=this.readSync(t.dataId),n=new Uint8Array(e.length),r=0;r<e.length;++r)n[r]=e[r]?0:1;return this.makeOutput(n,t.shape,"bool")},o.prototype.logicalAnd=function(t,e){return Hh([t,e],"logicalAnd"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t&&e}))},o.prototype.logicalOr=function(t,e){return Hh([t,e],"logicalOr"),this.broadcastedBinaryOp(t,e,"bool",(function(t,e){return t||e}))},o.prototype.select=function(t,e,n){Hh([t,e,n],"select");for(var r=this.readSync(t.dataId),o=this.readSync(e.dataId),a=this.readSync(n.dataId),i=Gn(e.shape,Dt(e.dtype,n.dtype)),s=this.readSync(i.dataId),u=0,c=0===t.rank||t.rank>1||1===e.rank?1:k(e.shape.slice(1)),l=0;l<r.length;l++)for(var h=0;h<c;h++)1===r[l]?s[u++]=o[l]:s[u++]=a[l];return i},o.prototype.where=function(t){Hh([t],"where");var e=this.readSync(t.dataId);return na(t.shape,e)},o.prototype.topk=function(t,e,n){return Hh(t,"topk"),ea(this.readSync(t.dataId),t.shape,t.dtype,e)},o.prototype.min=function(t,e){Hh(t,"min"),Cn("min",e,t.rank);for(var n=bn(t.shape,e),r=n[0],o=n[1],a=Gn(r,t.dtype),i=k(o),s=this.readSync(a.dataId),u=this.readSync(t.dataId),c=0;c<s.length;++c){for(var l=c*i,h=u[l],f=0;f<i;++f){var d=u[l+f];d<h&&(h=d)}s[c]=h}return a},o.prototype.minimum=function(t,e){return Hh([t,e],"minimum"),this.broadcastedBinaryOp(t,e,t.dtype,(function(t,e){return Math.min(t,e)}))},o.prototype.mod=function(t,e){return Hh([t,e],"mod"),this.broadcastedBinaryOp(t,e,t.dtype,(function(t,e){var n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}))},o.prototype.max=function(t,e){Hh(t,"max"),Cn("max",e,t.rank);for(var n=bn(t.shape,e),r=n[0],o=n[1],a=Gn(r,t.dtype),i=k(o),s=this.readSync(a.dataId),u=this.readSync(t.dataId),c=0;c<s.length;++c){for(var l=c*i,h=u[l],f=0;f<i;++f){var d=u[l+f];d>h&&(h=d)}s[c]=h}return a},o.prototype.maximum=function(t,e){return Hh([t,e],"maximum"),this.broadcastedBinaryOp(t,e,t.dtype,(function(t,e){return Math.max(t,e)}))},o.prototype.all=function(t,e){Hh(t,"all"),Cn("all",e,t.rank);for(var n=bn(t.shape,e),r=n[0],o=n[1],a=Gn(r,t.dtype),i=k(o),s=this.readSync(a.dataId),u=this.readSync(t.dataId),c=0;c<s.length;++c){for(var l=c*i,h=u[l],f=0;f<i;++f){var d=u[l+f];h=h&&d}s[c]=h}return a},o.prototype.any=function(t,e){Hh(t,"any"),Cn("any",e,t.rank);for(var n=bn(t.shape,e),r=n[0],o=n[1],a=Gn(r,t.dtype),i=k(o),s=this.readSync(a.dataId),u=this.readSync(t.dataId),c=0;c<s.length;++c){for(var l=c*i,h=u[l],f=0;f<i;++f){var d=u[l+f];h=h||d}s[c]=h}return a},o.prototype.squaredDifference=function(t,e){return Hh([t,e],"squaredDifference"),this.broadcastedBinaryOp(t,e,t.dtype,(function(t,e){var n=t-e;return n*n}))},o.prototype.ceil=function(t){Hh(t,"ceil");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.ceil(e[r]);return this.makeOutput(n,t.shape,"float32")},o.prototype.floor=function(t){Hh(t,"floor");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.floor(e[r]);return this.makeOutput(n,t.shape,"float32")},o.prototype.sign=function(t){Hh(t,"x");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r)e[r]<0?n[r]=-1:e[r]>0?n[r]=1:n[r]=0;return this.makeOutput(n,t.shape,"float32")},o.prototype.isNaN=function(t){Hh(t,"x");for(var e=this.readSync(t.dataId),n=new Uint8Array(e.length),r=0;r<e.length;++r)Number.isNaN(e[r])&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")},o.prototype.isInf=function(t){Hh(t,"x");for(var e=this.readSync(t.dataId),n=new Uint8Array(e.length),r=0;r<e.length;++r)Math.abs(e[r])===1/0&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")},o.prototype.isFinite=function(t){Hh(t,"x");for(var e=this.readSync(t.dataId),n=new Uint8Array(e.length),r=0;r<e.length;++r)Number.isFinite(e[r])&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")},o.prototype.round=function(t){Hh(t,"round");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=Math.floor(e[r]);e[r]-o<.5?n[r]=Math.floor(e[r]):e[r]-o>.5?n[r]=Math.ceil(e[r]):n[r]=o%2==0?o:o+1}return this.makeOutput(n,t.shape,"float32")},o.prototype.exp=function(t){Hh(t,"exp");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.exp(e[r]);return this.makeOutput(n,t.shape,"float32")},o.prototype.expm1=function(t){Hh(t,"expm1");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.expm1(e[r]);return this.makeOutput(n,t.shape,"float32")},o.prototype.log=function(t){Hh(t,"log");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.log(o)}return this.makeOutput(n,t.shape,"float32")},o.prototype.log1p=function(t){Hh(t,"log1p");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.log1p(o)}return this.makeOutput(n,t.shape,"float32")},o.prototype.sqrt=function(t){Hh(t,"sqrt");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.sqrt(o)}return this.makeOutput(n,t.shape,"float32")},o.prototype.rsqrt=function(t){Hh(t,"rsqrt");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=1/Math.sqrt(o)}return this.makeOutput(n,t.shape,"float32")},o.prototype.reciprocal=function(t){Hh(t,"reciprocal");for(var e=this.readSync(t.dataId),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=1/e[r];return this.makeOutput(n,t.shape,"float32")},o.prototype.linear=function(t){return t},o.prototype.relu=function(t){Hh(t,"relu");for(var e=Gn(t.shape,t.dtype),n=this.readSync(e.dataId),r=this.readSync(t.dataId),o=0;o<r.length;++o)n[o]=Math.max(0,r[o]);return e},o.prototype.relu6=function(t){Hh(t,"relu");for(var e=Gn(t.shape,t.dtype),n=this.readSync(e.dataId),r=this.readSync(t.dataId),o=0;o<r.length;++o)n[o]=Math.min(Math.max(0,r[o]),6);return e},o.prototype.prelu=function(t,e){return Hh([t,e],"prelu"),this.broadcastedBinaryOp(t,e,t.dtype,(function(t,e){return t<0?e*t:t}))},o.prototype.elu=function(t){Hh(t,"elu");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r){var o=n[r];e[r]=o>=0?o:Math.exp(o)-1}return this.makeOutput(e,t.shape,"float32")},o.prototype.eluDer=function(t,e){Hh([t,e],"eluDer");for(var n=new Float32Array(e.size),r=this.readSync(e.dataId),o=this.readSync(t.dataId),a=0;a<r.length;++a){var i=r[a];n[a]=i>=1?o[a]:o[a]*(i+1)}return this.makeOutput(n,e.shape,"float32")},o.prototype.selu=function(t){Hh(t,"selu");for(var e=bs,n=ws,r=new Float32Array(t.size),o=this.readSync(t.dataId),a=0;a<o.length;++a){var i=o[a];r[a]=i>=0?n*i:e*(Math.exp(i)-1)}return this.makeOutput(r,t.shape,"float32")},o.prototype.clip=function(t,e,n){Hh(t,"clip");for(var r=new Float32Array(t.size),o=this.readSync(t.dataId),a=0;a<o.length;++a){var i=o[a];r[a]=i>n?n:i<e?e:i}return this.makeOutput(r,t.shape,"float32")},o.prototype.abs=function(t){for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.abs(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.complexAbs=function(t){for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<t.size;++r){var o=n[2*r],a=n[2*r+1];e[r]=Math.hypot(o,a)}return this.makeOutput(e,t.shape,"float32")},o.prototype.int=function(t){Hh(t,"int");for(var e=new Int32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=n[r];return this.makeOutput(e,t.shape,"int32")},o.prototype.sigmoid=function(t){Hh(t,"sigmoid");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=1/(1+Math.exp(-n[r]));return this.makeOutput(e,t.shape,"float32")},o.prototype.softplus=function(t){Hh(t,"softplus");for(var e=Math.log(1.1920928955078125e-7)+2,n=new Float32Array(t.size),r=this.readSync(t.dataId),o=0;o<r.length;++o){var a=r[o]>-e,i=r[o]<e,s=Math.exp(r[o]),u=void 0;u=i?s:a?r[o]:Math.log(1+s),n[o]=u}return this.makeOutput(n,t.shape,"float32")},o.prototype.sin=function(t){Hh(t,"sin");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.sin(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.cos=function(t){Hh(t,"cos");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.cos(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.tan=function(t){Hh(t,"tan");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.tan(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.asin=function(t){Hh(t,"asin");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.asin(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.acos=function(t){Hh(t,"acos");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.acos(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.atan=function(t){Hh(t,"atan");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.atan(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.atan2=function(t,e){return Hh([t,e],"atan2"),this.broadcastedBinaryOp(t,e,t.dtype,(function(t,e){return Math.atan2(t,e)}))},o.prototype.sinh=function(t){Hh(t,"sinh");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.sinh(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.cosh=function(t){Hh(t,"cosh");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.cosh(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.tanh=function(t){Hh(t,"tanh");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=D(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.asinh=function(t){Hh(t,"asinh");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.asinh(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.acosh=function(t){Hh(t,"acosh");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.acosh(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.atanh=function(t){Hh(t,"atanh");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r)e[r]=Math.atanh(n[r]);return this.makeOutput(e,t.shape,"float32")},o.prototype.erf=function(t){Hh(t,"erf");for(var e=new Float32Array(t.size),n=this.readSync(t.dataId),r=0;r<n.length;++r){var o=Math.sign(n[r]),a=Math.abs(n[r]),i=1/(1+.3275911*a);e[r]=o*(1-((((1.061405429*i-1.453152027)*i+1.421413741)*i-.284496736)*i+.254829592)*i*Math.exp(-a*a))}return this.makeOutput(e,t.shape,"float32")},o.prototype.step=function(t,e){void 0===e&&(e=0),Hh(t,"step");for(var n=new Float32Array(t.size),r=this.readSync(t.dataId),o=0;o<r.length;++o){var a=r[o];isNaN(a)?n[o]=NaN:n[o]=a>0?1:e}return this.makeOutput(n,t.shape,"float32")},o.prototype.fusedConv2d=function(t){var e=t.input,n=t.filter,r=t.convInfo,o=t.bias,a=t.activation,i=t.preluActivationWeights,s=this.conv2d(e,n,r);return o&&(s=this.add(s,o)),a&&(s=qh(this,s,a,i)),s},o.prototype.conv2d=function(t,e,n){Hh([t,e],"conv2d");for(var r=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,i=n.dilationWidth,s=n.padInfo.left,u=n.padInfo.top,c="channelsLast"===n.dataFormat,l=dr(n.outShape,t.dtype),h=t.strides[0],f=c?t.strides[1]:t.strides[2],d=c?t.strides[2]:1,p=c?1:t.strides[1],v=l.strides[0],m=c?l.strides[1]:l.strides[2],g=c?l.strides[2]:1,y=c?1:l.strides[1],x=this.readSync(t.dataId),b=this.readSync(e.dataId),w=l.values,C=0;C<n.batchSize;++C)for(var E=C*h,R=C*v,I=0;I<n.outHeight;++I)for(var k=R+I*m,S=I*n.strideHeight-u,A=0;A<r;A++){var D=S+A*a;if(!(D<0||D>=n.inHeight))for(var T=A*e.strides[0],N=E+D*f,F=0;F<n.outWidth;++F)for(var _=k+F*g,O=F*n.strideWidth-s,M=0;M<o;M++){var B=O+M*i;if(!(B<0||B>=n.inWidth))for(var P=N+B*d,L=T+M*e.strides[1],W=0;W<n.inChannels;++W){for(var U=x[P+W*p],V=0;V<n.outChannels;++V)w[_+V*y]+=U*b[L+V];L+=n.outChannels}}}return l.toTensor()},o.prototype.conv3d=function(t,e,n){for(var r=n.filterDepth,o=n.filterHeight,a=n.filterWidth,i=n.dilationDepth,s=n.dilationHeight,u=n.dilationWidth,c=n.padInfo.front,l=n.padInfo.left,h=n.padInfo.top,f=dr(n.outShape,t.dtype),d=this.readSync(t.dataId),p=this.readSync(e.dataId),v=f.values,m=0;m<n.batchSize;++m)for(var g=m*t.strides[0],y=m*f.strides[0],x=0;x<n.outDepth;++x)for(var b=y+x*f.strides[1],w=x*n.strideDepth-c,C=0;C<r;C++){var E=w+C*i;if(!(E<0||E>=n.inDepth))for(var R=C*e.strides[0],I=g+E*t.strides[1],k=0;k<n.outHeight;++k)for(var S=b+k*f.strides[2],A=k*n.strideHeight-h,D=0;D<o;D++){var T=A+D*s;if(!(T<0||T>=n.inHeight))for(var N=R+D*e.strides[1],F=I+T*t.strides[2],_=0;_<n.outWidth;++_)for(var O=S+_*n.outChannels,M=_*n.strideWidth-l,B=0;B<a;B++){var P=M+B*u;if(!(P<0||P>=n.inWidth))for(var L=N+B*e.strides[2],W=F+P*n.inChannels,U=L,V=0;V<n.inChannels;++V){for(var z=d[W+V],G=0;G<n.outChannels;++G)v[O+G]+=z*p[U+G];U+=n.outChannels}}}}return f.toTensor()},o.prototype.conv2dDerInput=function(t,e,n){Hh([t,e],"conv2dDerInput");for(var r=dr(n.inShape,"float32"),o=r.values,a=this.readSync(t.dataId),i=this.readSync(e.dataId),s=e.strides,u=s[0],c=s[1],l=s[2],h=n.batchSize,f=n.filterHeight,d=n.filterWidth,p=n.inChannels,v=n.inHeight,m=n.inWidth,g=n.outChannels,y=n.outHeight,x=n.outWidth,b=n.strideHeight,w=n.strideWidth,C=n.dataFormat,E=f-1-n.padInfo.top,R=d-1-n.padInfo.left,I="channelsLast"===C,k=r.strides[0],S=I?r.strides[1]:r.strides[2],A=I?r.strides[2]:1,D=I?1:r.strides[1],T=t.strides[0],N=I?t.strides[1]:t.strides[2],F=I?t.strides[2]:1,_=I?1:t.strides[1],O=0;O<h;++O)for(var M=0;M<p;++M)for(var B=0;B<v;++B)for(var P=B-E,L=Math.max(0,Math.ceil(P/b)),W=Math.min(y,(f+P)/b),U=0;U<m;++U){for(var V=U-R,z=Math.max(0,Math.ceil(V/w)),G=Math.min(x,(d+V)/w),H=0,q=L;q<W;++q)for(var K=q*b-P,j=z;j<G;++j)for(var X=T*O+N*q+F*j,Y=u*(f-1-K)+c*(d-1-(j*w-V))+l*M,$=0;$<g;++$){H+=a[X+_*$]*i[Y+$]}o[k*O+S*B+A*U+D*M]=H}return r.toTensor()},o.prototype.conv3dDerInput=function(t,e,n){for(var r=dr(n.inShape,"float32"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],c=a[3],l=this.readSync(t.dataId),h=t.strides,f=h[0],d=h[1],p=h[2],v=h[3],m=this.readSync(e.dataId),g=e.strides,y=g[0],x=g[1],b=g[2],w=g[3],C=n.batchSize,E=n.filterDepth,R=n.filterHeight,I=n.filterWidth,k=n.inChannels,S=n.inDepth,A=n.inHeight,D=n.inWidth,T=n.outChannels,N=n.outDepth,F=n.outHeight,_=n.outWidth,O=n.strideDepth,M=n.strideHeight,B=n.strideWidth,P=E-1-n.padInfo.front,L=R-1-n.padInfo.top,W=I-1-n.padInfo.left,U=0;U<C;++U)for(var V=0;V<k;++V)for(var z=0;z<S;++z)for(var G=z-P,H=Math.max(0,Math.ceil(G/O)),q=Math.min(N,(E+G)/O),K=0;K<A;++K)for(var j=K-L,X=Math.max(0,Math.ceil(j/M)),Y=Math.min(F,(R+j)/M),$=0;$<D;++$){for(var Q=$-W,J=Math.max(0,Math.ceil(Q/B)),Z=Math.min(_,(I+Q)/B),tt=0,et=H;et<q;++et)for(var nt=et*O-G,rt=X;rt<Y;++rt)for(var ot=rt*M-j,at=J;at<Z;++at)for(var it=f*U+d*et+p*rt+v*at,st=y*(E-1-nt)+x*(R-1-ot)+b*(I-1-(at*B-Q))+w*V,ut=0;ut<T;++ut){tt+=l[it+ut]*m[st+ut]}o[i*U+s*z+u*K+c*$+V]=tt}return r.toTensor()},o.prototype.conv2dDerFilter=function(t,e,n){Hh([t,e],"conv2dDerFilter");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s="channelsLast"===n.dataFormat,u=dr(n.filterShape,"float32"),c=n.padInfo.left,l=n.padInfo.top,h=this.bufferSync(t),f=this.bufferSync(e),d=0;d<a;++d)for(var p=Math.max(0,Math.ceil((l-d)/r)),v=Math.min(n.outHeight,(n.inHeight+l-d)/r),m=0;m<i;++m)for(var g=Math.max(0,Math.ceil((c-m)/o)),y=Math.min(n.outWidth,(n.inWidth+c-m)/o),x=0;x<n.inChannels;++x)for(var b=0;b<n.outChannels;++b){for(var w=0,C=0;C<n.batchSize;++C)for(var E=p;E<v;++E)for(var R=d+E*r-l,I=g;I<y;++I){var k=m+I*o-c;w+=s?h.get(C,R,k,x)*f.get(C,E,I,b):h.get(C,x,R,k)*f.get(C,b,E,I)}u.set(w,d,m,x,b)}return u.toTensor()},o.prototype.conv3dDerFilter=function(t,e,n){for(var r=n.strideDepth,o=n.strideHeight,a=n.strideWidth,i=n.filterDepth,s=n.filterHeight,u=n.filterWidth,c=dr(n.filterShape,"float32"),l=c.values,h=c.strides,f=h[0],d=h[1],p=h[2],v=h[3],m=this.readSync(e.dataId),g=e.strides,y=g[0],x=g[1],b=g[2],w=g[3],C=this.readSync(t.dataId),E=t.strides,R=E[0],I=E[1],k=E[2],S=E[3],A=n.padInfo.front,D=n.padInfo.left,T=n.padInfo.top,N=0;N<i;++N)for(var F=Math.max(0,Math.ceil((A-N)/r)),_=Math.min(n.outDepth,(n.inDepth+A-N)/r),O=N*f,M=0;M<s;++M)for(var B=Math.max(0,Math.ceil((T-M)/o)),P=Math.min(n.outHeight,(n.inHeight+T-M)/o),L=M*d+O,W=0;W<u;++W)for(var U=Math.max(0,Math.ceil((D-W)/a)),V=Math.min(n.outWidth,(n.inWidth+D-W)/a),z=W*p+L,G=0;G<n.inChannels;++G)for(var H=G*v+z,q=0;q<n.outChannels;++q){for(var K=0,j=0;j<n.batchSize;++j)for(var X=j*R,Y=j*y,$=F;$<_;++$)for(var Q=(N+$*r-A)*I+X,J=$*x+Y,Z=B;Z<P;++Z)for(var tt=(M+Z*o-T)*k+Q,et=Z*b+J,nt=U;nt<V;++nt){var rt=nt*w+et;K+=C[(W+nt*a-D)*S+tt+G]*m[rt+q]}l[H+q]=K}return c.toTensor()},o.prototype.fusedDepthwiseConv2D=function(t){var e=t.input,n=t.filter,r=t.convInfo,o=t.bias,a=t.activation,i=t.preluActivationWeights,s=this.depthwiseConv2D(e,n,r);return o&&(s=this.add(s,o)),a&&(s=qh(this,s,a,i)),s},o.prototype.depthwiseConv2D=function(t,e,n){Hh([t,e],"depthwiseConv2D");for(var r=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,i=n.dilationWidth,s=n.padInfo.left,u=n.padInfo.top,c=n.outChannels/n.inChannels,l=dr(n.outShape,t.dtype),h=this.readSync(t.dataId),f=this.readSync(e.dataId),d=l.values,p=0;p<n.batchSize;++p)for(var v=p*t.strides[0],m=p*l.strides[0],g=0;g<n.outHeight;++g)for(var y=m+g*l.strides[1],x=g*n.strideHeight-s,b=0;b<r;++b){var w=x+b*a;if(!(w<0||w>=n.inHeight))for(var C=b*e.strides[0],E=v+w*t.strides[1],R=0;R<n.outWidth;++R)for(var I=y+R*l.strides[2],k=R*n.strideWidth-u,S=0;S<o;++S){var A=k+S*i;if(!(A<0||A>=n.inWidth))for(var D=C+S*e.strides[1],T=E+A*n.inChannels,N=I,F=D,_=0;_<n.inChannels;++_){for(var O=h[T+_],M=0;M<c;++M)d[N+M]+=O*f[F+M];N+=c,F+=c}}}return l.toTensor()},o.prototype.depthwiseConv2DDerInput=function(t,e,n){Hh([t,e],"depthwiseConv2DDerInput");for(var r=dr(n.inShape,"float32"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],c=this.readSync(t.dataId),l=t.strides,h=l[0],f=l[1],d=l[2],p=this.readSync(e.dataId),v=e.strides,m=v[0],g=v[1],y=v[2],x=n.batchSize,b=n.filterHeight,w=n.filterWidth,C=n.inChannels,E=n.inHeight,R=n.inWidth,I=n.outChannels,k=n.outHeight,S=n.outWidth,A=n.strideHeight,D=n.strideWidth,T=b-1-n.padInfo.top,N=w-1-n.padInfo.left,F=I/C,_=0;_<x;++_)for(var O=0;O<C;++O)for(var M=0;M<E;++M)for(var B=M-T,P=Math.max(0,Math.ceil(B/A)),L=Math.min(k,(b+B)/A),W=0;W<R;++W){for(var U=W-N,V=Math.max(0,Math.ceil(U/D)),z=Math.min(S,(w+U)/D),G=0,H=P;H<L;++H)for(var q=H*A-B,K=V;K<z;++K)for(var j=h*_+f*H+d*K,X=m*(b-1-q)+g*(w-1-(K*D-U))+y*O,Y=0;Y<F;++Y){G+=c[j+(O*F+Y)]*p[X+Y]}o[i*_+s*M+u*W+O]=G}return r.toTensor()},o.prototype.depthwiseConv2DDerFilter=function(t,e,n){Hh([t,e],"depthwiseConv2DDerFilter");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=dr(n.filterShape,"float32"),u=n.padInfo.left,c=n.padInfo.top,l=n.outChannels/n.inChannels,h=this.bufferSync(t),f=this.bufferSync(e),d=0;d<a;++d)for(var p=Math.max(0,Math.ceil((c-d)/r)),v=Math.min(n.outHeight,(n.inHeight+c-d)/r),m=0;m<i;++m)for(var g=Math.max(0,Math.ceil((u-m)/o)),y=Math.min(n.outWidth,(n.inWidth+u-m)/o),x=0;x<n.outChannels;++x){for(var b=Math.trunc(x/l),w=x%l,C=0,E=0;E<n.batchSize;++E)for(var R=p;R<v;++R)for(var I=d+R*r-c,k=g;k<y;++k){var S=m+k*o-u;C+=h.get(E,I,S,b)*f.get(E,R,k,x)}s.set(C,d,m,b,w)}return s.toTensor()},o.prototype.tile=function(t,e){return Hh(t,"tile"),ta(this.bufferSync(t),e)},o.prototype.pad=function(t,e,n){Hh(t,"pad");var r=e.map((function(e,n){return e[0]+t.shape[n]+e[1]})),o=e.map((function(t){return t[0]})),a=this.bufferSync(t),i=dr(r,t.dtype);0!==n&&i.values.fill(n);for(var s=0;s<t.size;s++){var u=a.indexToLoc(s),c=u.map((function(t,e){return t+o[e]}));i.set.apply(i,[a.get.apply(a,u)].concat(c))}return i.toTensor()},o.prototype.transpose=function(t,e){Hh(t,"transpose");for(var n=new Array(t.rank),r=0;r<n.length;r++)n[r]=t.shape[e[r]];var o=this.readSync(t.dataId),a=dr(n,t.dtype),i=this.bufferSync(t);for(r=0;r<t.size;++r){for(var s=i.indexToLoc(r),u=new Array(s.length),c=0;c<u.length;c++)u[c]=s[e[c]];var l=a.locToIndex(u);a.values[l]=o[r]}return a.toTensor()},o.prototype.gather=function(t,e,n){Hh([t,e],"gather");var r=t.shape.slice(),o=this.readSync(e.dataId);r[n]=o.length;for(var a=dr(r,t.dtype),i=this.bufferSync(t),s=0;s<a.size;++s){var u=a.indexToLoc(s),c=u.slice();c[n]=o[u[n]];var l=i.locToIndex(c);a.values[s]=i.values[l]}return a.toTensor()},o.prototype.batchToSpaceND=function(t,e,n){Hh([t],"batchToSpaceND");var r=e.reduce((function(t,e){return t*e})),o=zr(t.shape,e,r),a=Gr(o.length,e.length),i=Hr(t.shape,e,r),s=qr(n,e.length),u=Kr(i,n,e.length);return t.reshape(o).transpose(a).reshape(i).slice(s,u)},o.prototype.spaceToBatchND=function(t,e,n){Hh([t],"spaceToBatchND");var r=e.reduce((function(t,e){return t*e})),o=[[0,0]];o.push.apply(o,n);for(var a=1+e.length;a<t.shape.length;++a)o.push([0,0]);var i=t.pad(o),s=zr(i.shape,e,r,!1),u=Gr(s.length,e.length,!1),c=Hr(i.shape,e,r,!1);return i.reshape(s).transpose(u).reshape(c)},o.prototype.pool=function(t,e,n){Hh(t,"pool");for(var r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=e.padInfo.top,l=e.padInfo.left,h="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,f=this.readSync(t.dataId),d=dr(e.outShape,t.dtype),p=d.values,v=e.outShape[1]*e.outShape[2]*e.outShape[3],m=e.outShape[2]*e.outShape[3],g=e.outShape[3],y=0;y<e.batchSize;++y)for(var x=y*v,b=y*t.strides[0],w=0;w<e.inChannels;++w)for(var C=0;C<e.outHeight;++C)for(var E=C*r-c,R=Math.max(0,E),I=Math.min(e.inHeight,s+E),k=x+C*m,S=0;S<e.outWidth;++S){for(var A=S*o-l,D=Math.max(0,A),T=Math.min(e.inWidth,u+A),N=h,F=0,_=0,O=R;O<I;O+=a){for(var M=b+O*t.strides[1],B=D;B<T;B+=i){var P=f[M+B*t.strides[2]+w];"max"===n&&P>N?N=P:"avg"===n&&(F+=P,_++)}if(isNaN(N))break}p[k+S*g+w]="avg"===n?F/_:N}return d.toTensor()},o.prototype.maxPool=function(t,e){return this.pool(t,e,"max")},o.prototype.maxPoolPositions=function(t,e){for(var n=dr(e.outShape,"int32"),r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=e.padInfo.top,l=e.padInfo.left,h=this.bufferSync(t),f=0;f<e.batchSize;++f)for(var d=0;d<e.inChannels;++d)for(var p=0;p<e.outHeight;++p){for(var v=p*r-c,m=v;m<0;)m+=a;for(var g=Math.min(e.inHeight,s+v),y=0;y<e.outWidth;++y){for(var x=y*o-l,b=x;b<0;)b+=i;for(var w=Math.min(e.inWidth,u+x),C=Number.NEGATIVE_INFINITY,E=-1,R=m;R<g;R+=a)for(var I=R-v,k=b;k<w;k+=i){var S=k-x,A=h.get(f,R,k,d);A>C&&(C=A,E=I*u+S)}n.set(E,f,p,y,d)}}return n.toTensor()},o.prototype.maxPoolBackprop=function(t,e,n,r){Hh([e,n],"maxPoolBackprop");for(var o=this.maxPoolPositions(e,r),a=r.strideHeight,i=r.strideWidth,s=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,l=r.effectiveFilterWidth,h=l-1-r.padInfo.left,f=c-1-r.padInfo.top,d=dr(e.shape,"float32"),p=this.bufferSync(o),v=this.bufferSync(t),m=0;m<r.batchSize;++m)for(var g=0;g<r.inChannels;++g)for(var y=0;y<r.inHeight;++y)for(var x=0;x<r.inWidth;++x){for(var b=y-f,w=x-h,C=0,E=0;E<c;E+=s){var R=(b+E)/a;if(!(R<0||R>=r.outHeight||Math.floor(R)!==R))for(var I=0;I<l;I+=u){var k=(w+I)/i;if(!(k<0||k>=r.outWidth||Math.floor(k)!==k)){var S=c*l-1-p.get(m,R,k,g)===E*l+I?1:0;if(0!==S)C+=v.get(m,R,k,g)*S}}}d.set(C,m,y,x,g)}return d.toTensor()},o.prototype.avgPoolBackprop=function(t,e,n){Hh([t,e],"avgPoolBackprop");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=n.dilationHeight,u=n.dilationWidth,c=n.effectiveFilterHeight,l=n.effectiveFilterWidth,h=l-1-n.padInfo.left,f=c-1-n.padInfo.top,d=dr(e.shape,"float32"),p=1/(a*i),v=this.bufferSync(t),m=0;m<n.batchSize;++m)for(var g=0;g<n.inChannels;++g)for(var y=0;y<n.inHeight;++y)for(var x=0;x<n.inWidth;++x){for(var b=y-f,w=x-h,C=0,E=0;E<c;E+=s){var R=(b+E)/r;if(!(R<0||R>=n.outHeight||Math.floor(R)!==R))for(var I=0;I<l;I+=u){var k=(w+I)/o;if(!(k<0||k>=n.outWidth||Math.floor(k)!==k))C+=v.get(m,R,k,g)}}d.set(C*p,m,y,x,g)}return d.toTensor()},o.prototype.pool3d=function(t,e,n){Hh(t,"pool3d");for(var r=e.strideDepth,o=e.strideHeight,a=e.strideWidth,i=e.dilationDepth,s=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,l=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=e.padInfo.front,d=e.padInfo.top,p=e.padInfo.left,v="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=this.readSync(t.dataId),g=dr(e.outShape,t.dtype),y=g.values,x=e.outShape[1]*e.outShape[2]*e.outShape[3]*e.outShape[4],b=e.outShape[2]*e.outShape[3]*e.outShape[4],w=e.outShape[3]*e.outShape[4],C=e.outShape[4],E=0;E<e.batchSize;++E)for(var R=E*x,I=E*t.strides[0],k=0;k<e.inChannels;++k)for(var S=0;S<e.outDepth;++S){for(var A=S*r-f,D=A;D<0;)D+=i;for(var T=Math.min(e.inDepth,c+A),N=R+S*b,F=0;F<e.outHeight;++F){for(var _=F*o-d,O=_;O<0;)O+=s;for(var M=Math.min(e.inHeight,l+_),B=N+F*w,P=0;P<e.outWidth;++P){for(var L=P*a-p,W=L;W<0;)W+=u;for(var U=Math.min(e.inWidth,h+L),V=B+P*C,z=v,G=0,H=0,q=D;q<T;q+=i){for(var K=I+q*t.strides[1],j=O;j<M;j+=s){for(var X=K+j*t.strides[2],Y=W;Y<U;Y+=u){var $=m[X+Y*t.strides[3]+k];if("max"===n&&$>z?z=$:"avg"===n&&(G+=$,H++),isNaN(z))break}if(isNaN(z))break}if(isNaN(z))break}y[V+k]="avg"===n?G/H:z}}}return g.toTensor()},o.prototype.avgPool3d=function(t,e){return Hh(t,"avgPool3d"),this.pool3d(t,e,"avg").toFloat()},o.prototype.avgPool3dBackprop=function(t,e,n){Hh([t,e],"avgPool3dBackprop");for(var r=n.strideDepth,o=n.strideHeight,a=n.strideWidth,i=n.filterDepth,s=n.filterHeight,u=n.filterWidth,c=n.dilationDepth,l=n.dilationHeight,h=n.dilationWidth,f=n.effectiveFilterDepth,d=n.effectiveFilterHeight,p=n.effectiveFilterWidth,v=f-1-n.padInfo.front,m=p-1-n.padInfo.left,g=d-1-n.padInfo.top,y=dr(e.shape,"float32"),x=1/(i*s*u),b=this.bufferSync(t),w=0;w<n.batchSize;++w)for(var C=0;C<n.inChannels;++C)for(var E=0;E<n.inDepth;++E)for(var R=0;R<n.inHeight;++R)for(var I=0;I<n.inWidth;++I){for(var k=E-v,S=R-g,A=I-m,D=0,T=0;T<f;T+=c){var N=(k+T)/r;if(!(N<0||N>=n.outDepth||Math.floor(N)!==N))for(var F=0;F<d;F+=l){var _=(S+F)/o;if(!(_<0||_>=n.outHeight||Math.floor(_)!==_))for(var O=0;O<p;O+=h){var M=(A+O)/a;if(!(M<0||M>=n.outWidth||Math.floor(M)!==M))D+=b.get(w,N,_,M,C)}}}y.set(D*x,w,E,R,I,C)}return y.toTensor()},o.prototype.maxPool3d=function(t,e){return Hh(t,"maxPool3d"),this.pool3d(t,e,"max").toFloat()},o.prototype.maxPool3dPositions=function(t,e){for(var n=dr(e.outShape,"int32"),r=e.strideDepth,o=e.strideHeight,a=e.strideWidth,i=e.dilationDepth,s=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,l=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=e.padInfo.front,d=e.padInfo.top,p=e.padInfo.left,v=this.bufferSync(t),m=0;m<e.batchSize;++m)for(var g=0;g<e.inChannels;++g)for(var y=0;y<e.outDepth;++y){for(var x=y*r-f,b=x;b<0;)b+=i;for(var w=Math.min(e.inDepth,c+x),C=0;C<e.outHeight;++C){for(var E=C*o-d,R=E;R<0;)R+=s;for(var I=Math.min(e.inHeight,l+E),k=0;k<e.outWidth;++k){for(var S=k*a-p,A=S;A<0;)A+=u;for(var D=Math.min(e.inWidth,h+S),T=Number.NEGATIVE_INFINITY,N=-1,F=b;F<w;F+=i)for(var _=F-x,O=R;O<I;O+=s)for(var M=O-E,B=A;B<D;B+=u){var P=B-S,L=v.get(m,F,O,B,g);L>=T&&(T=L,N=_*l*h+M*l+P)}n.set(N,m,y,C,k,g)}}}return n.toTensor()},o.prototype.maxPool3dBackprop=function(t,e,n,r){Hh([e,n],"maxPool3dBackprop");for(var o=this.maxPool3dPositions(e,r),a=r.strideDepth,i=r.strideHeight,s=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,l=r.dilationWidth,h=r.effectiveFilterDepth,f=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=h-1-r.padInfo.front,v=d-1-r.padInfo.left,m=f-1-r.padInfo.top,g=dr(e.shape,"float32"),y=this.bufferSync(o),x=this.bufferSync(t),b=0;b<r.batchSize;++b)for(var w=0;w<r.inChannels;++w)for(var C=0;C<r.inDepth;++C)for(var E=0;E<r.inHeight;++E)for(var R=0;R<r.inWidth;++R){for(var I=C-p,k=E-m,S=R-v,A=0,D=0;D<h;D+=u){var T=(I+D)/a;if(!(T<0||T>=r.outDepth||Math.floor(T)!==T))for(var N=0;N<f;N+=c){var F=(k+N)/i;if(!(F<0||F>=r.outHeight||Math.floor(F)!==F))for(var _=0;_<d;_+=l){var O=(S+_)/s;if(!(O<0||O>=r.outWidth||Math.floor(O)!==O)){var M=h*f*d-1-y.get(b,T,F,O,w)===D*f*d+N*d+_?1:0;if(0!==M)A+=x.get(b,T,F,O,w)*M}}}}g.set(A,b,C,E,R,w)}return g.toTensor()},o.prototype.cast=function(t,e){return Po(t,e,this)},o.prototype.reshape=function(t,e){return Lo(t,e)},o.prototype.avgPool=function(t,e){return Hh(t,"avgPool"),this.pool(t,e,"avg").toFloat()},o.prototype.resizeBilinear=function(t,e,n,r){Hh(t,"resizeBilinear");for(var o=t.shape,a=o[0],i=o[1],s=o[2],u=o[3],c=this.readSync(t.dataId),l=new Float32Array(k([a,e,n,u])),h=[r&&e>1?i-1:i,r&&n>1?s-1:s],f=[r&&e>1?e-1:e,r&&n>1?n-1:n],d=0,p=h[0]/f[0],v=h[1]/f[1],m=0;m<a;m++)for(var g=0;g<e;g++)for(var y=p*g,x=Math.floor(y),b=y-x,w=Math.min(i-1,Math.ceil(y)),C=m*t.strides[0]+x*t.strides[1],E=m*t.strides[0]+w*t.strides[1],R=0;R<n;R++)for(var I=v*R,S=Math.floor(I),A=I-S,D=Math.min(s-1,Math.ceil(I)),T=C+S*t.strides[2],N=E+S*t.strides[2],F=C+D*t.strides[2],_=E+D*t.strides[2],O=0;O<u;O++){var M=c[T+O],B=c[N+O],P=M+(c[F+O]-M)*A,L=P+(B+(c[_+O]-B)*A-P)*b;l[d++]=L}return Fn(l,[a,e,n,u])},o.prototype.resizeBilinearBackprop=function(t,e,n){Hh([t,e],"resizeBilinearBackprop");for(var r=e.shape,o=r[0],a=r[1],i=r[2],s=r[3],u=t.shape,c=u[1],l=u[2],h=new Float32Array(o*a*i*s),f=[n&&c>1?a-1:a,n&&l>1?i-1:i],d=[n&&c>1?c-1:c,n&&l>1?l-1:l],p=f[0]/d[0],v=f[1]/d[1],m=this.readSync(t.dataId),g=0,y=0;y<o;y++)for(var x=y*e.strides[0],b=0;b<c;b++)for(var w=b*p,C=Math.floor(w),E=Math.min(Math.ceil(w),a-1),R=x+C*e.strides[1],I=x+E*e.strides[1],k=w-C,S=1-k,A=0;A<l;A++)for(var D=A*v,T=Math.floor(D),N=Math.min(Math.ceil(D),i-1),F=D-T,_=1-F,O=R+T*e.strides[2],M=R+N*e.strides[2],B=I+T*e.strides[2],P=I+N*e.strides[2],L=S*_,W=S*F,U=k*_,V=k*F,z=0;z<s;z++){var G=m[g++];h[O+z]+=G*L,h[M+z]+=G*W,h[B+z]+=G*U,h[P+z]+=G*V}return Ln(h,[o,i,a,s],e.dtype)},o.prototype.resizeNearestNeighbor=function(t,e,n,r){Hh(t,"resizeNearestNeighbor");for(var o=t.shape,a=o[0],i=o[1],s=o[2],u=o[3],c=this.readSync(t.dataId),l=new Float32Array(a*e*n*u),h=[r&&e>1?i-1:i,r&&n>1?s-1:s],f=[r&&e>1?e-1:e,r&&n>1?n-1:n],d=h[0]/f[0],p=h[1]/f[1],v=0,m=0;m<a;m++)for(var g=m*t.strides[0],y=0;y<e;y++)for(var x=d*y,b=g+Math.min(i-1,r?Math.round(x):Math.floor(x))*t.strides[1],w=0;w<n;w++)for(var C=p*w,E=b+Math.min(s-1,r?Math.round(C):Math.floor(C))*t.strides[2],R=0;R<u;R++){var I=c[E+R];l[v++]=I}return Fn(l,[a,e,n,u],t.dtype)},o.prototype.resizeNearestNeighborBackprop=function(t,e,n){Hh([t,e],"resizeNearestNeighborBackprop");for(var r=e.shape,o=r[0],a=r[1],i=r[2],s=r[3],u=t.shape,c=u[1],l=u[2],h=new Float32Array(o*a*i*s),f=this.readSync(t.dataId),d=[n&&c>1?a-1:a,n&&l>1?i-1:i],p=[n&&c>1?c-1:c,n&&l>1?l-1:l],v=d[0]/p[0],m=d[1]/p[1],g=1/v,y=1/m,x=2*Math.ceil(g)+2,b=2*Math.ceil(y)+2,w=0;w<o;w++)for(var C=w*e.strides[0],E=0;E<a;E++)for(var R=C+E*e.strides[1],I=Math.floor(E*g),k=Math.floor(I-x/2),S=0;S<i;S++)for(var A=R+S*e.strides[2],D=Math.floor(S*y),T=Math.floor(D-b/2),N=0;N<s;N++){for(var F=0,_=0;_<x;_++){var O=_+k;if(!(O<0||O>=c)){var M=C+O*t.strides[1],B=O*v;if(E===Math.min(a-1,n?Math.round(B):Math.floor(B)))for(var P=0;P<b;P++){var L=P+T;if(!(L<0||L>=l)){var W=M+L*t.strides[2],U=L*m;S===Math.min(i-1,n?Math.round(U):Math.floor(U))&&(F+=f[W+N])}}}}h[A+N]=F}return Ln(h,e.shape,e.dtype)},o.prototype.batchNormalization=function(t,e,n,r,o,a){Hh([t,e,n,o,a],"batchNorm");for(var i=this.readSync(t.dataId),s=this.readSync(e.dataId),u=this.readSync(n.dataId),c=o?this.readSync(o.dataId):new Float32Array([1]),l=a?this.readSync(a.dataId):new Float32Array([0]),h=new Float32Array(i.length),f=l.length,d=c.length,p=u.length,v=s.length,m=0,g=0,y=0,x=0,b=0;b<i.length;++b)h[b]=l[m++]+(i[b]-s[g++])*c[y++]/Math.sqrt(u[x++]+r),m>=f&&(m=0),g>=v&&(g=0),y>=d&&(y=0),x>=p&&(x=0);return Ln(h,t.shape)},o.prototype.localResponseNormalization4D=function(t,e,n,r,o){Hh(t,"localResponseNormalization4D");var a=t.shape[3],i=a-1,s=this.readSync(t.dataId),u=t.size,c=new Float32Array(u);function l(t){for(var n=t%a,r=t-n+Math.max(0,n-e),o=t-n+Math.min(n+e,i),u=0;r<=o;r++){var c=s[r];u+=c*c}return u}for(var h=0;h<u;h++){var f=l(h),d=s[h]*Math.pow(n+r*f,-o);c[h]=d}return Ln(c,t.shape)},o.prototype.LRNGrad=function(t,e,n,r,o,a,i){Hh(t,"LRNGrad");for(var s=t.shape[3],u=this.readSync(t.dataId),c=this.readSync(e.dataId),l=this.readSync(n.dataId),h=new Float32Array(t.size),f=t.size,d=0;d<f;d++){for(var p=d%s,v=d-p+Math.max(0,p-r),m=d-p+Math.min(s,p+r+1),g=0,y=v;y<m;y++)g+=Math.pow(c[y],2);g=a*g+o;for(y=v;y<m;y++){var x=-2*a*i*c[y]*l[d]/g;d===y&&(x+=Math.pow(g,-i)),x*=u[d],h[y]+=x}}return Ln(h,t.shape)},o.prototype.multinomial=function(t,e,n,r){Hh(t,"multinomial");for(var o=e?t:go(t),a=o.shape[0],i=o.shape[1],s=Gn([a,n],"int32"),u=this.readSync(s.dataId),c=this.readSync(o.dataId),l=0;l<a;++l){var h=l*i,f=new Float32Array(i-1);f[0]=c[h];for(var d=1;d<f.length;++d)f[d]=f[d-1]+c[h+d];for(var p=cr(r.toString()),v=l*n,m=0;m<n;++m){var g=p();u[v+m]=f.length;for(var y=0;y<f.length;y++)if(g<f[y]){u[v+m]=y;break}}}return s},o.prototype.oneHot=function(t,e,n,r){Hh(t,"oneHot");var o=new Float32Array(t.size*e);o.fill(r);for(var a=this.readSync(t.dataId),i=0;i<t.size;++i)a[i]>=0&&a[i]<e&&(o[i*e+a[i]]=n);return Bn(o,[t.size,e],"int32")},o.prototype.nonMaxSuppression=function(t,e,n,r,o){return Hh(t,"nonMaxSuppression"),jo(this.readSync(t.dataId),this.readSync(e.dataId),n,r,o)},o.prototype.fft=function(t){return this.fftBatch(t,!1)},o.prototype.ifft=function(t){return this.fftBatch(t,!0)},o.prototype.fftBatch=function(t,e){for(var n=t.shape[0],r=t.shape[1],o=dr(t.shape,"float32"),a=dr(t.shape,"float32"),i=Tn(t).as2D(n,r),s=Nn(t).as2D(n,r),u=0;u<n;u++)for(var c=i.slice([u,0],[1,r]),l=s.slice([u,0],[1,r]),h=Dn(c,l),f=this.readSync(this.fftImpl(h,e).dataId),d=0;d<r;d++){var p=zo(f,d);o.values[u*r+d]=p.real,a.values[u*r+d]=p.imag}return Dn(o.toTensor(),a.toTensor()).as2D(n,r)},o.prototype.fftImpl=function(t,e){var n=t.as1D(),r=n.size;if(this.isExponentOf2(r)){var o=this.fftRadix2(n,r,e).as2D(t.shape[0],t.shape[1]);return e&&(o=Dn(Tn(o).div(On(r)),Nn(o).div(On(r)))),o}var a=this.readSync(t.dataId),i=function(t){for(var e=new Float32Array(t.length/2),n=new Float32Array(t.length/2),r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}(this.fourierTransformByMatmul(a,r,e));return Dn(i.real,i.imag).as2D(t.shape[0],t.shape[1])},o.prototype.isExponentOf2=function(t){return 0==(t&t-1)},o.prototype.fftRadix2=function(t,e,n){if(1===e)return t;var r=this.readSync(t.dataId),o=e/2,a=function(t){for(var e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e),o=0;o<t.length;o+=4)n[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:n,imag:r}}(r),i=Dn(a.real,a.imag).as1D(),s=function(t){for(var e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e),o=2;o<t.length;o+=4)n[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:n,imag:r}}(r),u=Dn(s.real,s.imag).as1D();i=this.fftRadix2(i,o,n),u=this.fftRadix2(u,o,n);var c=function(t,e){for(var n=new Float32Array(t/2),r=new Float32Array(t/2),o=0;o<Math.ceil(t/2);o++){var a=(e?2:-2)*Math.PI*(o/t);n[o]=Math.cos(a),r[o]=Math.sin(a)}return{real:n,imag:r}}(e,n),l=Dn(c.real,c.imag).mul(u),h=i.add(l),f=i.sub(l),d=Tn(h).concat(Tn(f)),p=Nn(h).concat(Nn(f));return Dn(d,p).as1D()},o.prototype.fourierTransformByMatmul=function(t,e,n){for(var r=new Float32Array(2*e),o=0;o<e;o++){for(var a=0,i=0,s=0;s<e;s++){var u=Ho(o*s,e,n),c=zo(t,s);a+=c.real*u.real-c.imag*u.imag,i+=c.real*u.imag+c.imag*u.real}n&&(a/=e,i/=e),Go(r,a,i,o)}return r},o.prototype.depthToSpace=function(t,e,n){C("NHWC"===n,(function(){return"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+n})),C(e>1,(function(){return"blockSize should be > 1 for depthToSpace, but was: "+e}));for(var r=t.shape[0],o=t.shape[1],a=t.shape[2],i=t.shape[3],s=o*e,u=a*e,c=i/(e*e),l=this.readSync(t.dataId),h=new Float32Array(r*s*u*c),f=0,d=0;d<r;++d)for(var p=0;p<s;++p)for(var v=Math.floor(p/e),m=p%e,g=0;g<u;++g)for(var y=Math.floor(g/e),x=(m*e+g%e)*c,b=0;b<c;++b){var w=b+x+i*(y+a*(v+o*d));h[f++]=l[w]}return Ln(h,[r,s,u,c])},o.prototype.broadcastedBinaryOp=function(t,e,n,r){var o=Ro(t.shape,e.shape),a=dr(o,n),i=this.readSync(t.dataId),s=this.readSync(e.dataId),u=Co(t.shape,o),c=Co(e.shape,o),l=a.values;if(u.length+c.length===0)for(var h=0;h<l.length;++h)l[h]=r(i[h%i.length],s[h%s.length]);else{var f=this.bufferSync(t),d=this.bufferSync(e),p=function(n){var o=a.indexToLoc(n),h=o.slice(-t.rank);u.forEach((function(t){return h[t]=0}));var p=f.locToIndex(h),v=o.slice(-e.rank);c.forEach((function(t){return v[t]=0}));var m=d.locToIndex(v);l[n]=r(i[p],s[m])};for(h=0;h<l.length;++h)p(h)}return a.toTensor()},o.prototype.broadcastedBinaryComplexOp=function(t,e,n){var r=Ro(t.shape,e.shape),o=dr(r,"float32"),a=dr(r,"float32"),i=this.readSync(t.dataId),s=this.readSync(e.dataId),u=Co(t.shape,r),c=Co(e.shape,r),l=o.values,h=a.values;if(u.length+c.length===0)for(var f=0;f<l.length;f++){var d=f%i.length,p=f%s.length,v=n(i[2*d],i[2*d+1],s[2*p],s[2*p+1]);l[f]=v.real,h[f]=v.imag}else{var m=this.bufferSync(this.data.get(t.dataId).complexTensors.real),g=this.bufferSync(this.data.get(e.dataId).complexTensors.real),y=function(r){var a=o.indexToLoc(r),f=a.slice(-t.rank);u.forEach((function(t){return f[t]=0}));var d=m.locToIndex(f),p=a.slice(-e.rank);c.forEach((function(t){return p[t]=0}));var v=g.locToIndex(p),y=n(i[2*d],i[2*d+1],s[2*v],s[2*v+1]);l[r]=y.real,h[r]=y.imag};for(f=0;f<l.length;f++)y(f)}return this.complex(o.toTensor(),a.toTensor())},o.prototype.split=function(t,e,n){return Zo(t,e,n)},o.prototype.dispose=function(){},o.prototype.floatPrecision=function(){return 32},o.prototype.epsilon=function(){return 1e-7},o.prototype.cropAndResize=function(t,e,n,r,o,a){for(var i=t.shape,s=i[0],u=i[1],c=i[2],l=i[3],h=e.shape[0],f=r[0],d=r[1],p=dr([h,f,d,l],"float32"),v=this.readSync(e.dataId),m=this.readSync(n.dataId),g=this.readSync(t.dataId),y=t.strides,x=p.strides,b=0;b<h;b++){var w=4*b,C=v[w],E=v[w+1],R=v[w+2],I=v[w+3],k=m[b];if(!(k>=s))for(var S=f>1?(R-C)*(u-1)/(f-1):0,A=d>1?(I-E)*(c-1)/(d-1):0,D=0;D<f;D++){var T=f>1?C*(u-1)+D*S:.5*(C+R)*(u-1);if(T<0||T>u-1)for(var N=0;N<d;N++)for(var F=0;F<l;F++){var _=F+N*x[2]+D*x[1]+b*x[0];p.values[_]=a}else if("bilinear"===o){var O=Math.floor(T),M=Math.ceil(T),B=T-O;for(N=0;N<d;N++){if((q=d>1?E*(c-1)+N*A:.5*(E+I)*(c-1))<0||q>c-1)for(F=0;F<l;F++){_=F+N*x[2]+D*x[1]+b*x[0];p.values[_]=a}else{var P=Math.floor(q),L=Math.ceil(q),W=q-P;for(F=0;F<l;F++){var U=g[_=F+P*y[2]+O*y[1]+k*y[0]],V=g[_=F+L*y[2]+O*y[1]+k*y[0]],z=g[_=F+P*y[2]+M*y[1]+k*y[0]],G=U+(V-U)*W,H=z+(g[_=F+L*y[2]+M*y[1]+k*y[0]]-z)*W;_=F+N*x[2]+D*x[1]+b*x[0],p.values[_]=G+(H-G)*B}}}}else for(N=0;N<d;++N){var q;if((q=d>1?E*(c-1)+N*A:.5*(E+I)*(c-1))<0||q>c-1)for(F=0;F<l;F++){_=F+N*x[2]+D*x[1]+b*x[0];p.values[_]=a}else{var K=Math.round(q),j=Math.round(T);for(F=0;F<l;F++){var X=F+K*y[2]+j*y[1]+k*y[0],Y=F+N*x[2]+D*x[1]+b*x[0];p.values[Y]=g[X]}}}}}return p.toTensor()},o.prototype.sparseToDense=function(t,e,n,r){var o=Zr(0,t,n),a=o.sliceRank,i=o.numUpdates,s=o.sliceSize,u=o.strides,c=o.outputSize;return this.scatter(t,e,n,c,s,i,a,u,r,!1)},o.prototype.gatherND=function(t,e){var n=e.shape,r=n[n.length-1],o=jr(t,e),a=o[0],i=o[1],s=o[2],u=o[3];if(0===i)return Fn([],a,t.dtype);for(var c=new gt([i,s],t.dtype),l=this.readSync(e.dataId),h=this.readSync(t.dataId),f=0;f<i;f++){for(var d=[],p=0,v=0;v<r;v++){var m=l[f*r+v];p+=m*u[v],d.push(m)}if(p<0||p>=t.size/s)throw new Error("Invalid indices: "+d+" does not index into "+t.shape);for(var g=0;g<s;g++)c.values[f*s+g]=h[p*s+g]}return c.toTensor().reshape(a)},o.prototype.scatterND=function(t,e,n){var r=Zr(0,t,n),o=r.sliceRank,a=r.numUpdates,i=r.sliceSize,s=r.strides,u=r.outputSize,c=On(0);return this.scatter(t,e,n,u,i,a,o,s,c,!0)},o.prototype.fill=function(t,e,n){var r=P(n=n||j(e),k(t));return r.fill(e),Lt.makeTensor(r,t,n,this)},o.prototype.onesLike=function(t){if("string"===t.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(t.shape,1,t.dtype)},o.prototype.zerosLike=function(t){var e=P(t.dtype,k(t.shape));return this.makeOutput(e,t.shape,t.dtype)},o.prototype.linspace=function(t,e,n){return Wo(t,e,n)},o.prototype.scatter=function(t,e,n,r,o,a,i,s,u,c){var l=[r/o,o],h=this.readSync(t.dataId),f=this.readSync(e.dataId);if(0===r)return Fn([],n,e.dtype);var d=new gt(l,e.dtype);d.values.fill(this.readSync(u.dataId)[0]);for(var p=0;p<a;p++){for(var v=[],m=0,g=0;g<i;g++){var y=h[p*i+g];v.push(y),m+=y*s[g]}if(m<0||m>=r/o)throw new Error("Invalid indices: "+v+" does not index into "+n);for(var x=0;x<o;x++)c?d.values[m*o+x]+=f[p*o+x]:d.values[m*o+x]=0===e.rank?f[0]:f[p*o+x]}return d.toTensor().reshape(n)},o}(bo);Lt.registerBackend("cpu",(function(){return new Kh}),1);for(var jh=0,Xh=[{kernelName:"NonMaxSuppressionV5",backendName:"cpu",kernelFunc:function(t){var e=t.inputs,n=t.backend,r=t.attrs,o=e,a=o.boxes,i=o.scores,s=r,u=s.maxOutputSize,c=s.iouThreshold,l=s.scoreThreshold,h=s.softNmsSigma,f=n;Hh(a,"NonMaxSuppressionWithScore");var d=Xo(f.data.get(a.dataId).values,f.data.get(i.dataId).values,u,c,l,h);return[d.selectedIndices,d.selectedScores]}},{kernelName:"Square",backendName:"cpu",kernelFunc:function(t){var e=t.inputs,n=t.backend,r=e.x,o=n;Hh(r,"square");for(var a=o.data.get(r.dataId).values,i=new Float32Array(a.length),s=0;s<a.length;++s){var u=a[s];i[s]=u*u}return{dataId:o.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},{kernelName:eu,backendName:"cpu",kernelFunc:function(t){var e=t.inputs,n=t.backend,r=e,o=r.a,a=r.b,i=n;Hh([o,a],eu);var s=i.data.get(o.dataId).values,u=i.data.get(a.dataId).values,c=function(t,e,n,r,o,a){var i=Ro(t,e),s=i.length,u=$(i),c=B(o,k(i)),l=t.length,h=e.length,f=$(t),d=$(e),p=Co(t,i),v=Co(e,i);if(p.length+v.length===0)for(var m=0;m<c.length;++m)c[m]=a(n[m%n.length],r[m%r.length]);else{var g=function(t){var e=it(t,s,u),o=e.slice(-l);p.forEach((function(t){return o[t]=0}));var i=at(o,l,f),m=e.slice(-h);v.forEach((function(t){return m[t]=0}));var g=at(m,h,d);c[t]=a(n[i],r[g])};for(m=0;m<c.length;++m)g(m)}return[c,i]}(o.shape,a.shape,s,u,o.dtype,(function(t,e){var n=t-e;return n*n})),l=c[0],h=c[1];return{dataId:i.write(l,h,o.dtype),shape:h,dtype:o.dtype}}}];jh<Xh.length;jh++){d(Xh[jh])}var Yh,$h=function(t){this.variableNames=["A"];var e=ua(),n=t[0],r=t[1];this.outputShape=t,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+r+".0, "+n+".0);\n\n        vec4 values = "+e.texture2D+"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "},Qh=function(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var e=ua(),n=t[0],r=t[1];this.outputShape=t,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2("+r+".0, "+n+".0);\n            vec4 values = "+e.texture2D+"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        "+e.output+" = result;\n      }\n    "};for(var Jh=0,Zh=[{kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(t){var e=t.inputs,n=t.backend,r=t.attrs,o=e.pixels,a=r.numChannels,s="undefined"!=typeof HTMLVideoElement&&o instanceof HTMLVideoElement,u="undefined"!=typeof HTMLImageElement&&o instanceof HTMLImageElement,c=s?[o.videoWidth,o.videoHeight]:[o.width,o.height],l=c[0],h=c[1],f=[h,l],d=[h,l,a];(u||s)&&(null==Yh&&(Yh=document.createElement("canvas").getContext("2d")),Yh.canvas.width=l,Yh.canvas.height=h,Yh.drawImage(o,0,0,l,h),o=Yh.canvas);var p=n.makeTensorInfo(f,"int32");n.texData.get(p.dataId).usage=zt.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),o);var v=i().getBool("WEBGL_PACK")?new Qh(d):new $h(d),m=n.runWebGLProgram(v,[p],"int32");return n.disposeData(p.dataId),m}},{kernelName:"NonMaxSuppressionV5",backendName:"webgl",kernelFunc:function(t){var e=t.inputs,n=t.backend,r=t.attrs;dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var o=e,a=o.boxes,i=o.scores,s=r,u=s.maxOutputSize,c=s.iouThreshold,l=s.scoreThreshold,h=s.softNmsSigma,f=n,d=Xo(f.readSync(a.dataId),f.readSync(i.dataId),u,c,l,h);return[d.selectedIndices,d.selectedScores]}},{kernelName:"Square",backendName:"webgl",kernelFunc:function(t){var e=t.inputs,n=t.backend,r=e.x,o=n,a=new Cs(r.shape,"return x * x;");return o.runWebGLProgram(a,[r],r.dtype)}},{kernelName:eu,backendName:"webgl",kernelFunc:function(t){var e=t.inputs,n=t.backend,r=e,o=r.a,a=r.b,s=n,u=i().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La("return (a - b) * (a - b);",o.shape,a.shape):new Ba("return (a - b) * (a - b);",o.shape,a.shape);return s.compileAndRun(u,[o,a])}}];Jh<Zh.length;Jh++){d(Zh[Jh])}for(var tf=0,ef=[{kernelName:"Square",gradFunc:function(t,e){var n=e[0];return{x:function(){return t.mul(n.toFloat().mul(2))}}}},{kernelName:eu,gradFunc:function(t,e){var n=e[0],r=e[1],o=On(2);return{a:function(){return gc(t,gc(o,Cc(n,r)))},b:function(){return gc(t,gc(o,Cc(r,n)))}}}}];tf<ef.length;tf++){p(ef[tf])}var nf=function(){function t(){}return t.prototype.fetch=function(t,e){return fetch(t,e)},t.prototype.now=function(){return performance.now()},t.prototype.encode=function(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Browser's encoder only supports utf-8, but got "+e);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)},t.prototype.decode=function(t,e){return new TextDecoder(e).decode(t)},t}();i().get("IS_BROWSER")&&i().setPlatform("browser",new nf);var rf,of=function(){return __webpack_require__(/*! node-fetch */ 2)},af=function(){function t(){this.util=__webpack_require__(/*! util */ 3),this.textEncoder=new this.util.TextEncoder}return t.prototype.fetch=function(t,e){return null!=i().global.fetch?i().global.fetch(t,e):(null==rf&&(rf=of()),rf(t,e))},t.prototype.now=function(){var t=process.hrtime();return 1e3*t[0]+t[1]/1e6},t.prototype.encode=function(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Node built-in encoder only supports utf-8, but got "+e);return this.textEncoder.encode(t)},t.prototype.decode=function(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)},t}();i().get("IS_NODE")&&i().setPlatform("node",new af);var sf={float32:4,int32:4,uint16:2,uint8:1,bool:1},uf=4;function cf(t,e){for(var n={},r=0,o=function(e){var o=e.name,a=e.dtype,i=e.shape,s=k(i),u=void 0;if("quantization"in e){var c=e.quantization;if("uint8"!==c.dtype&&"uint16"!==c.dtype)throw new Error("Weight "+e.name+" has unknown quantization dtype "+c.dtype+". Supported quantization dtypes are: 'uint8' and 'uint16'.");var l=sf[c.dtype],h=t.slice(r,r+s*l),f="uint8"===c.dtype?new Uint8Array(h):new Uint16Array(h);if("float32"===a)u=Float32Array.from(f,(function(t){return t*c.scale+c.min}));else{if("int32"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);u=Int32Array.from(f,(function(t){return Math.round(t*c.scale+c.min)}))}r+=s*l}else if("string"===a){var d=k(e.shape);u=[];for(var p=0;p<d;p++){var v=new Uint32Array(t.slice(r,r+uf))[0];r+=uf;var m=new Uint8Array(t.slice(r,r+v));u.push(m),r+=v}}else{var g=sf[a];h=t.slice(r,r+s*g);if("float32"===a)u=new Float32Array(h);else if("int32"===a)u=new Int32Array(h);else{if("bool"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);u=new Uint8Array(h)}r+=s*g}n[o]=Fn(u,i,a)},a=0,i=e;a<i.length;a++){o(i[a])}return n}function lf(t){if(null===t)throw new Error("Invalid input value: "+JSON.stringify(t));var e=0,n=[];t.forEach((function(t){if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+t.constructor.name)}));var r=new Uint8Array(e),o=0;return n.forEach((function(t){r.set(new Uint8Array(t.buffer),o),o+=t.byteLength})),r.buffer}var hf="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function ff(t){return hf?Buffer.byteLength(t):new Blob([t]).size}function df(t){var e=0;t.forEach((function(t){e+=t.byteLength}));var n=new Uint8Array(e),r=0;return t.forEach((function(t){n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function pf(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);var e=t.split("/");return e[e.length-1]}function vf(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:ff(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:ff(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}var mf=function(){function t(){this.saveRouters=[],this.loadRouters=[]}return t.getInstance=function(){return null==t.instance&&(t.instance=new t),t.instance},t.registerSaveRouter=function(e){t.getInstance().saveRouters.push(e)},t.registerLoadRouter=function(e){t.getInstance().loadRouters.push(e)},t.getSaveHandlers=function(e){return t.getHandlers(e,"save")},t.getLoadHandlers=function(e,n){return t.getHandlers(e,"load",n)},t.getHandlers=function(e,n,r){var o=[];return("load"===n?t.getInstance().loadRouters:t.getInstance().saveRouters).forEach((function(t){var n=t(e,r);null!==n&&o.push(n)})),o},t}(),gf="://",yf=function(){function t(){this.managers={}}return t.getInstance=function(){return null==t.instance&&(t.instance=new t),t.instance},t.registerManager=function(e,n){C(null!=e,(function(){return"scheme must not be undefined or null."})),e.endsWith(gf)&&(e=e.slice(0,e.indexOf(gf))),C(e.length>0,(function(){return"scheme must not be an empty string."}));var r=t.getInstance();C(null==r.managers[e],(function(){return"A model store manager is already registered for scheme '"+e+"'."})),r.managers[e]=n},t.getManager=function(t){var e=this.getInstance().managers[t];if(null==e)throw new Error("Cannot find model manager for scheme '"+t+"'");return e},t.getSchemes=function(){return Object.keys(this.getInstance().managers)},t}();function xf(t){if(-1===t.indexOf(gf))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+yf.getSchemes().join(","));return{scheme:t.split(gf)[0],path:t.split(gf)[1]}}function bf(t,e,o){return void 0===o&&(o=!1),n(this,void 0,void 0,(function(){var n,a,i,s,u,c,l,h,f;return r(this,(function(r){switch(r.label){case 0:return C(t!==e,(function(){return"Old path and new path are the same: '"+t+"'"})),C((n=mf.getLoadHandlers(t)).length>0,(function(){return"Copying failed because no load handler is found for source URL "+t+"."})),C(n.length<2,(function(){return"Copying failed because more than one ("+n.length+") load handlers for source URL "+t+"."})),a=n[0],C((i=mf.getSaveHandlers(e)).length>0,(function(){return"Copying failed because no save handler is found for destination URL "+e+"."})),C(i.length<2,(function(){return"Copying failed because more than one ("+n.length+") save handlers for destination URL "+e+"."})),s=i[0],u=xf(t).scheme,c=xf(t).path,l=u===xf(t).scheme,[4,a.load()];case 1:return h=r.sent(),o&&l?[4,yf.getManager(u).removeModel(c)]:[3,3];case 2:r.sent(),r.label=3;case 3:return[4,s.save(h)];case 4:return f=r.sent(),!o||l?[3,6]:[4,yf.getManager(u).removeModel(c)];case 5:r.sent(),r.label=6;case 6:return[2,f.modelArtifactsInfo]}}))}))}var wf="models_store",Cf="model_info_store";function Ef(){if(!i().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");var t=window||self,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Rf(t){var e=t.result;e.createObjectStore(wf,{keyPath:"modelPath"}),e.createObjectStore(Cf,{keyPath:"modelPath"})}var If=function(){function t(t){if(this.indexedDB=Ef(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}return t.prototype.save=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(e){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return[2,this.databaseAction(this.modelPath,t)]}))}))},t.prototype.load=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){return[2,this.databaseAction(this.modelPath)]}))}))},t.prototype.databaseAction=function(t,e){var n=this;return new Promise((function(t,r){var o=n.indexedDB.open("tensorflowjs",1);o.onupgradeneeded=function(){return Rf(o)},o.onsuccess=function(){var a=o.result;if(null==e){var i=a.transaction(wf,"readonly"),s=i.objectStore(wf).get(n.modelPath);s.onsuccess=function(){if(null==s.result)return a.close(),r(new Error("Cannot find model with path '"+n.modelPath+"' in IndexedDB."));t(s.result.modelArtifacts)},s.onerror=function(t){return a.close(),r(s.error)},i.oncomplete=function(){return a.close()}}else{var u,c=vf(e),l=a.transaction(Cf,"readwrite"),h=l.objectStore(Cf),f=h.put({modelPath:n.modelPath,modelArtifactsInfo:c});f.onsuccess=function(){var o=(u=a.transaction(wf,"readwrite")).objectStore(wf).put({modelPath:n.modelPath,modelArtifacts:e,modelArtifactsInfo:c});o.onsuccess=function(){return t({modelArtifactsInfo:c})},o.onerror=function(t){var e=(h=l.objectStore(Cf)).delete(n.modelPath);e.onsuccess=function(){return a.close(),r(o.error)},e.onerror=function(t){return a.close(),r(o.error)}}},f.onerror=function(t){return a.close(),r(f.error)},l.oncomplete=function(){null==u?a.close():u.oncomplete=function(){return a.close()}}}},o.onerror=function(t){return r(o.error)}}))},t.URL_SCHEME="indexeddb://",t}(),kf=function(t){return i().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(If.URL_SCHEME)?(e=t.slice(If.URL_SCHEME.length),new If(e)):null;var e};mf.registerSaveRouter(kf),mf.registerLoadRouter(kf);var Sf=function(){function t(){this.indexedDB=Ef()}return t.prototype.listModels=function(){return n(this,void 0,void 0,(function(){var t=this;return r(this,(function(e){return[2,new Promise((function(e,n){var r=t.indexedDB.open("tensorflowjs",1);r.onupgradeneeded=function(){return Rf(r)},r.onsuccess=function(){var t=r.result,o=t.transaction(Cf,"readonly"),a=o.objectStore(Cf).getAll();a.onsuccess=function(){for(var t={},n=0,r=a.result;n<r.length;n++){var o=r[n];t[o.modelPath]=o.modelArtifactsInfo}e(t)},a.onerror=function(e){return t.close(),n(a.error)},o.oncomplete=function(){return t.close()}},r.onerror=function(t){return n(r.error)}}))]}))}))},t.prototype.removeModel=function(t){return n(this,void 0,void 0,(function(){var e=this;return r(this,(function(n){var r;return t=(r=t).startsWith(If.URL_SCHEME)?r.slice(If.URL_SCHEME.length):r,[2,new Promise((function(n,r){var o=e.indexedDB.open("tensorflowjs",1);o.onupgradeneeded=function(){return Rf(o)},o.onsuccess=function(){var e,a=o.result,i=a.transaction(Cf,"readwrite"),s=i.objectStore(Cf),u=s.get(t);u.onsuccess=function(){if(null==u.result)return a.close(),r(new Error("Cannot find model with path '"+t+"' in IndexedDB."));var o=s.delete(t),i=function(){var o=(e=a.transaction(wf,"readwrite")).objectStore(wf).delete(t);o.onsuccess=function(){return n(u.result.modelArtifactsInfo)},o.onerror=function(t){return r(u.error)}};o.onsuccess=i,o.onerror=function(t){return i(),a.close(),r(u.error)}},u.onerror=function(t){return a.close(),r(u.error)},i.oncomplete=function(){null==e?a.close():e.oncomplete=function(){return a.close()}}},o.onerror=function(t){return r(o.error)}}))]}))}))},t}();if(i().getBool("IS_BROWSER"))try{yf.registerManager(If.URL_SCHEME,new Sf)}catch(t){}var Af="/",Df="tensorflowjs_models",Tf="info",Nf="model_topology",Ff="weight_specs",_f="weight_data",Of="model_metadata";function Mf(t){return{info:[Df,t,Tf].join(Af),topology:[Df,t,Nf].join(Af),weightSpecs:[Df,t,Ff].join(Af),weightData:[Df,t,_f].join(Af),modelMetadata:[Df,t,Of].join(Af)}}function Bf(t){var e=t.split(Af);if(e.length<3)throw new Error("Invalid key format: "+t);return e.slice(1,e.length-1).join(Af)}var Pf=function(){function t(t){if(!i().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Mf(this.modelPath)}return t.prototype.save=function(t){return n(this,void 0,void 0,(function(){var e,n,o;return r(this,(function(r){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),o=vf(t);try{return this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(hf)return Buffer.from(t).toString("base64");for(var e=new Uint8Array(t),n="",r=0,o=e.length;r<o;r++)n+=String.fromCharCode(e[r]);return btoa(n)}(t.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata})),[2,{modelArtifactsInfo:o}]}catch(t){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+o.modelTopologyBytes+", weightSpecsBytes="+o.weightSpecsBytes+", weightDataBytes="+o.weightDataBytes+".")}return[2]}))}))},t.prototype.load=function(){return n(this,void 0,void 0,(function(){var t,e,n,o,a,i,s;return r(this,(function(r){if(null==(t=JSON.parse(this.LS.getItem(this.keys.info))))throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");if(e={},null==(n=JSON.parse(this.LS.getItem(this.keys.topology))))throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");if(e.modelTopology=n,null==(o=JSON.parse(this.LS.getItem(this.keys.weightSpecs))))throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");if(e.weightSpecs=o,null!=(a=this.LS.getItem(this.keys.modelMetadata))&&(i=JSON.parse(a),e.format=i.format,e.generatedBy=i.generatedBy,e.convertedBy=i.convertedBy,e.userDefinedMetadata=i.userDefinedMetadata),null==(s=this.LS.getItem(this.keys.weightData)))throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return e.weightData=function(t){if(hf){var e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}for(var n=atob(t),r=new Uint8Array(n.length),o=0;o<n.length;++o)r.set([n.charCodeAt(o)],o);return r.buffer}(s),[2,e]}))}))},t.URL_SCHEME="localstorage://",t}(),Lf=function(t){return i().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Pf.URL_SCHEME)?(e=t.slice(Pf.URL_SCHEME.length),new Pf(e)):null;var e};mf.registerSaveRouter(Lf),mf.registerLoadRouter(Lf);var Wf=function(){function t(){C(i().getBool("IS_BROWSER"),(function(){return"Current environment is not a web browser"})),C("undefined"==typeof window||void 0!==window.localStorage,(function(){return"Current browser does not appear to support localStorage"})),this.LS=window.localStorage}return t.prototype.listModels=function(){return n(this,void 0,void 0,(function(){var t,e,n,o,a,i;return r(this,(function(r){for(t={},e=Df+Af,n=Af+Tf,o=0;o<this.LS.length;++o)(a=this.LS.key(o)).startsWith(e)&&a.endsWith(n)&&(i=Bf(a),t[i]=JSON.parse(this.LS.getItem(a)));return[2,t]}))}))},t.prototype.removeModel=function(t){return n(this,void 0,void 0,(function(){var e,n;return r(this,(function(r){var o;if(t=(o=t).startsWith(Pf.URL_SCHEME)?o.slice(Pf.URL_SCHEME.length):o,e=Mf(t),null==this.LS.getItem(e.info))throw new Error("Cannot find model at path '"+t+"'");return n=JSON.parse(this.LS.getItem(e.info)),this.LS.removeItem(e.info),this.LS.removeItem(e.topology),this.LS.removeItem(e.weightSpecs),this.LS.removeItem(e.weightData),[2,n]}))}))},t}();if(i().getBool("IS_BROWSER"))try{yf.registerManager(Pf.URL_SCHEME,new Wf)}catch(t){}var Uf="model",Vf=".json",zf=".weights.bin";function Gf(t){return new Promise((function(t){return setTimeout(t)})).then(t)}var Hf=function(){function t(e){if(!i().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(t.URL_SCHEME)&&(e=e.slice(t.URL_SCHEME.length)),null!=e&&0!==e.length||(e=Uf),this.modelTopologyFileName=e+Vf,this.weightDataFileName=e+zf}return t.prototype.save=function(t){return n(this,void 0,void 0,(function(){var e,n,o,a,i,s;return r(this,(function(r){switch(r.label){case 0:if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");if(e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"})),!(t.modelTopology instanceof ArrayBuffer))return[3,1];throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");case 1:return n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],o={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n},a=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),(i=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor).download=this.modelTopologyFileName,i.href=a,[4,Gf((function(){return i.dispatchEvent(new MouseEvent("click"))}))];case 2:return r.sent(),null==t.weightData?[3,4]:((s=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor).download=this.weightDataFileName,s.href=e,[4,Gf((function(){return s.dispatchEvent(new MouseEvent("click"))}))]);case 3:r.sent(),r.label=4;case 4:return[2,{modelArtifactsInfo:vf(t)}]}}))}))},t.URL_SCHEME="downloads://",t}(),qf=function(){function t(t){if(null==t||t.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+t);this.files=t}return t.prototype.load=function(){return n(this,void 0,void 0,(function(){var t,e,n=this;return r(this,(function(r){return t=this.files[0],e=this.files.slice(1),[2,new Promise((function(r,o){var a=new FileReader;a.onload=function(a){var i=JSON.parse(a.target.result),s=i.modelTopology;if(null!=s){0===e.length&&r({modelTopology:s});var u=i.weightsManifest;if(null!=u){var c;try{c=n.checkManifestAndWeightFiles(u,e)}catch(t){return void o(t)}var l=[],h=[],f=[];u.forEach((function(t){t.paths.forEach((function(t){h.push(t),f.push(null)})),l.push.apply(l,t.weights)})),u.forEach((function(t){t.paths.forEach((function(t){var e=new FileReader;e.onload=function(e){var n=e.target.result,o=h.indexOf(t);f[o]=n,-1===f.indexOf(null)&&r({modelTopology:s,weightSpecs:l,weightData:df(f),format:i.format,generatedBy:i.generatedBy,convertedBy:i.convertedBy,userDefinedMetadata:i.userDefinedMetadata})},e.onerror=function(e){return o("Failed to weights data from file of path '"+t+"'.")},e.readAsArrayBuffer(c[t])}))}))}else o(new Error("weightManifest field is missing from file "+t.name))}else o(new Error("modelTopology field is missing from file "+t.name))},a.onerror=function(e){return o("Failed to read model topology and weights manifest JSON from file '"+t.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")},a.readAsText(t)}))]}))}))},t.prototype.checkManifestAndWeightFiles=function(t,e){for(var n=[],r=e.map((function(t){return pf(t.name)})),o={},a=0,i=t;a<i.length;a++){i[a].paths.forEach((function(t){var a=pf(t);if(-1!==n.indexOf(a))throw new Error("Duplicate file basename found in weights manifest: '"+a+"'");if(n.push(a),-1===r.indexOf(a))throw new Error("Weight file with basename '"+a+"' is not provided.");o[t]=e[r.indexOf(a)]}))}if(n.length!==e.length)throw new Error("Mismatch in the number of files in weights manifest ("+n.length+") and the number of weight files provided ("+e.length+").");return o},t}();function Kf(t,e,n,r){!function(t){C(null!=t&&Array.isArray(t)&&t.length>0,(function(){return"promises must be a none empty array"}))}(t),function(t,e){C(t>=0&&t<=1,(function(){return"Progress fraction must be in range [0, 1], but got startFraction "+t})),C(e>=0&&e<=1,(function(){return"Progress fraction must be in range [0, 1], but got endFraction "+e})),C(e>=t,(function(){return"startFraction must be no more than endFraction, but got startFraction "+t+" and endFraction "+e}))}(n=null==n?0:n,r=null==r?1:r);var o=0;return Promise.all(t.map((function(a){return a.then((function(a){var i=n+ ++o/t.length*(r-n);return e(i),a})),a})))}function jf(t,e){return n(this,void 0,void 0,(function(){var n,o,a,s,u,c,l,h,f;return r(this,(function(r){switch(r.label){case 0:return null==e&&(e={}),n=null==e.fetchFunc?i().platform.fetch:e.fetchFunc,o=t.map((function(t){return n(t,e.requestInit,{isBinary:!0})})),a=0,s=.5,null!=e.onProgress?[3,2]:[4,Promise.all(o)];case 1:return u=r.sent(),[3,4];case 2:return[4,Kf(o,e.onProgress,a,s)];case 3:u=r.sent(),r.label=4;case 4:return c=u.map((function(t){return t.arrayBuffer()})),l=.5,h=1,null!=e.onProgress?[3,6]:[4,Promise.all(c)];case 5:return f=r.sent(),[3,8];case 6:return[4,Kf(c,e.onProgress,l,h)];case 7:f=r.sent(),r.label=8;case 8:return[2,f]}}))}))}function Xf(t){var e=this;return function(o,a,i){return void 0===a&&(a=""),n(e,void 0,void 0,(function(){var e,n,s,u,c,l,h,f,d,p;return r(this,(function(r){switch(r.label){case 0:if(e=o.map((function(){return!1})),n={},s=null!=i?i.map((function(){return!1})):[],u=[],o.forEach((function(t,r){var o=0;t.weights.forEach((function(t){var a="quantization"in t?t.quantization.dtype:t.dtype,c=sf[a]*k(t.shape),l=function(){e[r]=!0,null==n[r]&&(n[r]=[]),n[r].push({manifestEntry:t,groupOffset:o,sizeBytes:c})};null!=i?i.forEach((function(e,n){e===t.name&&(l(),s[n]=!0)})):l(),u.push(t.name),o+=c}))})),!s.every((function(t){return t})))throw c=i.filter((function(t,e){return!s[e]})),new Error("Could not find weights in manifest with names: "+c.join(", ")+". \nManifest JSON has weights with names: "+u.join(", ")+".");return l=e.reduce((function(t,e,n){return e&&t.push(n),t}),[]),h=[],l.forEach((function(t){o[t].paths.forEach((function(t){var e=a+(a.endsWith("/")?"":"/")+t;h.push(e)}))})),[4,t(h)];case 1:return f=r.sent(),d={},p=0,l.forEach((function(t){for(var e=o[t].paths.length,r=0,a=0;a<e;a++)r+=f[p+a].byteLength;for(var i=new ArrayBuffer(r),s=new Uint8Array(i),u=0,c=0;c<e;c++){var l=new Uint8Array(f[p+c]);s.set(l,u),u+=l.byteLength}n[t].forEach((function(t){var e=cf(i.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(var n in e)d[n]=e[n]})),p+=e})),[2,d]}}))}))}}mf.registerSaveRouter((function(t){return i().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Hf.URL_SCHEME)?function(t){void 0===t&&(t="model");return new Hf(t)}(t.slice(Hf.URL_SCHEME.length)):null}));var Yf=function(){function t(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,null!=e.fetchFunc?(C("function"==typeof e.fetchFunc,(function(){return"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"})),this.fetch=e.fetchFunc):this.fetch=i().platform.fetch,C(null!=t&&t.length>0,(function(){return"URL path for http must not be null, undefined or empty."})),Array.isArray(t)&&C(2===t.length,(function(){return"URL paths for http must have a length of 2, (actual length is "+t.length+")."})),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}return t.prototype.save=function(t){return n(this,void 0,void 0,(function(){var e,n,o,a;return r(this,(function(r){switch(r.label){case 0:if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");return(e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit)).body=new FormData,n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],o={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata,weightsManifest:n},e.body.append("model.json",new Blob([JSON.stringify(o)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin"),[4,this.fetch(this.path,e)];case 1:if((a=r.sent()).ok)return[2,{modelArtifactsInfo:vf(t),responses:[a]}];throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+a.status+".")}}))}))},t.prototype.load=function(){return n(this,void 0,void 0,(function(){var t,e,n,o,a,i,s,u,c,l,h,f;return r(this,(function(r){switch(r.label){case 0:return[4,this.fetch(this.path,this.requestInit)];case 1:if(!(t=r.sent()).ok)throw new Error("Request to "+this.path+" failed with status code "+t.status+". Please verify this URL points to the model JSON of the model to load.");r.label=2;case 2:return r.trys.push([2,4,,5]),[4,t.json()];case 3:return e=r.sent(),[3,5];case 4:throw r.sent(),n="Failed to parse model JSON of response from "+this.path+".",this.path.endsWith(".pb")?n+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":n+=" Please make sure the server is serving valid JSON for this request.",new Error(n);case 5:if(o=e.modelTopology,a=e.weightsManifest,i=e.generatedBy,s=e.convertedBy,u=e.format,c=e.userDefinedMetadata,null==o&&null==a)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return null==a?[3,7]:[4,this.loadWeights(a)];case 6:f=r.sent(),l=f[0],h=f[1],r.label=7;case 7:return[2,{modelTopology:o,weightSpecs:l,weightData:h,userDefinedMetadata:c,generatedBy:i,convertedBy:s,format:u}]}}))}))},t.prototype.loadWeights=function(t){return n(this,void 0,void 0,(function(){var e,n,o,a,i,s,u,c,l,h,f;return r(this,(function(r){switch(r.label){case 0:for(e=Array.isArray(this.path)?this.path[1]:this.path,n=function(t){var e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),o=n>e?t.substring(n):"";return[r+"/",o]}(e),o=n[0],a=n[1],i=this.weightPathPrefix||o,s=[],u=0,c=t;u<c.length;u++)l=c[u],s.push.apply(s,l.weights);return h=[],t.forEach((function(t){t.paths.forEach((function(t){h.push(i+t+a)}))})),[4,jf(h,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})];case 1:return f=r.sent(),[2,[s,df(f)]]}}))}))},t.URL_SCHEME_REGEX=/^https?:\/\//,t}();function $f(t){return null!=t.match(Yf.URL_SCHEME_REGEX)}var Qf=function(t,e){if("undefined"==typeof fetch)return null;return(Array.isArray(t)?t.every((function(t){return $f(t)})):$f(t))?Jf(t,{onProgress:e}):null};function Jf(t,e){return new Yf(t,e)}mf.registerSaveRouter(Qf),mf.registerLoadRouter(Qf);var Zf=function(){function t(t){this.modelArtifacts=t}return t.prototype.load=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){return[2,this.modelArtifacts]}))}))},t}(),td=function(){function t(t){this.saveHandler=t}return t.prototype.save=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(e){return[2,this.saveHandler(t)]}))}))},t}();var ed=Object.freeze({browserFiles:function(t){return new qf(t)},browserHTTPRequest:function(t,e){return Jf(t,e)},concatenateArrayBuffers:df,decodeWeights:cf,encodeWeights:function(t,e){return n(this,void 0,void 0,(function(){var o,a,i,s,u,c=this;return r(this,(function(l){switch(l.label){case 0:for(o=[],a=[],i=Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t),s=function(s){var u=i[s],l=Array.isArray(t)?t[s].tensor:t[u];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype)throw new Error("Unsupported dtype in weight '"+u+"': "+l.dtype);var h={name:u,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){var f=new Promise((function(t){return n(c,void 0,void 0,(function(){var e,n,o,a,i,s,u;return r(this,(function(r){switch(r.label){case 0:return[4,l.bytes()];case 1:for(e=r.sent(),n=e.reduce((function(t,e){return t+e.length}),0)+uf*e.length,o=new Uint8Array(n),a=0,i=0;i<e.length;i++)s=e[i],u=new Uint8Array(new Uint32Array([s.length]).buffer),o.set(u,a),a+=uf,o.set(s,a),a+=s.length;return t(o),[2]}}))}))}));a.push(f)}else a.push(l.data());null!=e&&(h.group=e),o.push(h)},u=0;u<i.length;++u)s(u);return[4,Promise.all(a)];case 1:return[2,{data:lf(l.sent()),specs:o}]}}))}))},fromMemory:function(t,e,n,r){return 1===arguments.length?null!=t.modelTopology||null!=t.weightSpecs?new Zf(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Zf({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Zf({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))},getLoadHandlers:function(t,e){return mf.getLoadHandlers(t,e)},getModelArtifactsInfoForJSON:vf,getSaveHandlers:function(t){return mf.getSaveHandlers(t)},http:Jf,isHTTPScheme:$f,loadWeights:function(t,e,o,a){return void 0===e&&(e=""),n(this,void 0,void 0,(function(){return r(this,(function(n){return[2,Xf((function(t){return jf(t,{requestInit:a})}))(t,e,o)]}))}))},registerLoadRouter:function(t){return mf.registerLoadRouter(t)},registerSaveRouter:function(t){return mf.registerSaveRouter(t)},weightsLoaderFactory:Xf,withSaveHandler:function(t){return new td(t)},copyModel:function(t,e){return n(this,void 0,void 0,(function(){return r(this,(function(n){return!1,[2,bf(t,e,!1)]}))}))},listModels:function(){return n(this,void 0,void 0,(function(){var t,e,n,o,a,i,s;return r(this,(function(r){switch(r.label){case 0:t=yf.getSchemes(),e={},n=0,o=t,r.label=1;case 1:return n<o.length?(a=o[n],[4,yf.getManager(a).listModels()]):[3,4];case 2:for(s in i=r.sent())e[a+gf+s]=i[s];r.label=3;case 3:return n++,[3,1];case 4:return[2,e]}}))}))},moveModel:function(t,e){return n(this,void 0,void 0,(function(){return r(this,(function(n){return!0,[2,bf(t,e,!0)]}))}))},removeModel:function(t){return n(this,void 0,void 0,(function(){var e;return r(this,(function(n){return e=xf(t),[2,yf.getManager(e.scheme).removeModel(e.path)]}))}))}});var nd,rd=An({confusionMatrix_:function(t,e,n){var r=mn(t,"labels","confusionMatrix"),o=mn(e,"predictions","confusionMatrix");C(null==n||n>0&&Number.isInteger(n),(function(){return"If provided, numClasses must be a positive integer, but got "+n})),C(1===r.rank,(function(){return"Expected the rank of labels to be 1, but got "+r.rank})),C(1===o.rank,(function(){return"Expected the rank of predictions to be 1, but got "+o.rank})),C(r.shape[0]===o.shape[0],(function(){return"Mismatch in the number of examples: "+r.shape[0]+" vs. "+o.shape[0]+". Labels and predictions should have the same number of elements."})),C(n>0&&Number.isInteger(n),(function(){return"numClasses is required to be a positive integer, but got "+n}));var a=Rr(r.asType("int32"),n),i=Rr(o.asType("int32"),n);return a.transpose().matMul(i).asType("int32")}}),od=Object.freeze({confusionMatrix:rd});var ad=An({fromPixels_:function(t,e){if(void 0===e&&(e=3),e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");var n=!1,r=!1,o=!1,a=!1,i=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)o=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)a=!0;else{if(null==t.getContext)throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+t.constructor.name);i=!0}if(o){if(o&&t.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=l("FromPixels",Lt.backendName))return Lt.runKernel("FromPixels",{pixels:t},{numChannels:e});var s,u,c=o?[t.videoWidth,t.videoHeight]:[t.width,t.height],h=c[0],f=c[1];if(i?s=t.getContext("2d").getImageData(0,0,h,f).data:r||n?s=t.data:(a||o)&&(null==nd&&(nd=document.createElement("canvas").getContext("2d")),nd.canvas.width=h,nd.canvas.height=f,nd.drawImage(t,0,0,h,f),s=nd.getImageData(0,0,h,f).data),4===e)u=new Int32Array(s);else{var d=h*f;u=new Int32Array(d*e);for(var p=0;p<d;p++)for(var v=0;v<e;++v)u[p*e+v]=s[4*p+v]}return Pn(u,[f,h,e],"int32")}}),id=Object.freeze({toPixels:function(t,e){return n(this,void 0,void 0,(function(){var n,o,a,i,s,u,c,l,h,f,d,p,v,m,g,y,x,b,w,C,E,R,I;return r(this,(function(r){switch(r.label){case 0:if(n=mn(t,"img","toPixels"),t instanceof wt||(n=n.toInt()),2!==n.rank&&3!==n.rank)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank "+n.rank+".");if(o=n.shape.slice(0,2),a=o[0],i=o[1],(s=2===n.rank?1:n.shape[2])>4||2===s)throw new Error("toPixels only supports depth of size 1, 3 or 4 but got "+s);return[4,n.data()];case 1:return u=r.sent(),c=n.min(),l=n.max(),[4,Promise.all([c.data(),l.data()])];case 2:if(h=r.sent(),f=h[0],d=h[1],p=f[0],v=d[0],c.dispose(),l.dispose(),"float32"===n.dtype){if(p<0||v>1)throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range ["+p+" - "+v+"].")}else{if("int32"!==n.dtype)throw new Error("Unsupported type for toPixels: "+n.dtype+". Please use float32 or int32 tensors.");if(p<0||v>255)throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range ["+p+" - "+v+"].")}for(m="float32"===n.dtype?255:1,g=new Uint8ClampedArray(i*a*4),y=0;y<a*i;++y)x=void 0,b=void 0,w=void 0,C=void 0,1===s?(x=u[y]*m,b=u[y]*m,w=u[y]*m,C=255):3===s?(x=u[3*y]*m,b=u[3*y+1]*m,w=u[3*y+2]*m,C=255):4===s&&(x=u[4*y]*m,b=u[4*y+1]*m,w=u[4*y+2]*m,C=u[4*y+3]*m),g[(E=4*y)+0]=Math.round(x),g[E+1]=Math.round(b),g[E+2]=Math.round(w),g[E+3]=Math.round(C);return null!=e&&(e.width=i,e.height=a,R=e.getContext("2d"),I=new ImageData(g,i,a),R.putImageData(I,0,0)),n!==t&&n.dispose(),[2,g]}}))}))},fromPixels:ad}),sd=function(){function t(){}return t.prototype.getClassName=function(){return this.constructor.className},t.fromConfig=function(t,e){return new t(e)},t}(),ud=function(){function t(){this.classNameMap={}}return t.getMap=function(){return null==t.instance&&(t.instance=new t),t.instance},t.register=function(e){t.getMap().classNameMap[e.className]=[e,e.fromConfig]},t}();function cd(t){C(null!=t.className,(function(){return"Class being registered does not have the static className property defined."})),C("string"==typeof t.className,(function(){return"className is required to be a string, but got type "+typeof t.className})),C(t.className.length>0,(function(){return"Class being registered has an empty-string as its className, which is disallowed."})),ud.register(t)}var ld=Object.freeze({Serializable:sd,SerializationMap:ud,registerClass:cd}),hd=.001,fd=.1;function dd(){return 32===Lt.backend.floatPrecision()?hd:fd}function pd(t,e,n){var r=!0;if((V(t)||V(e))&&(r=!1),V(t)&&V(e)&&(r=!0),r){var o=t.constructor.name,a=e.constructor.name;if(o!==a)throw new Error("Arrays are of different type. Actual: "+o+". Expected: "+a)}if(Array.isArray(t)&&Array.isArray(e)){var i=pn(t),s=pn(e);if(!S(i,s))throw new Error("Arrays have different shapes. Actual: ["+i+"]. Expected: ["+s+"]")}var u=V(t)?t:I(t),c=V(e)?e:I(e);if(u.length!==c.length)throw new Error("Arrays have different lengths actual: "+u.length+" vs expected: "+c.length+".\nActual:   "+u+".\nExpected: "+c+".");for(var l=0;l<c.length;++l){var h=u[l],f=c[l];if(!n(h,f))throw new Error("Arrays differ: actual["+l+"] = "+h+", expected["+l+"] = "+f+".\nActual:   "+u+".\nExpected: "+c+".")}}function vd(t,e,n){return!isFinite(t)&&!isFinite(e)||!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}var md=Object.freeze({TEST_EPSILON_FLOAT16:fd,expectArraysClose:function(t,e,n){return null==n&&(n=dd()),pd(t,e,(function(t,e){return vd(t,e,n)}))},testEpsilon:dd,expectPromiseToFail:function(t,e){t().then((function(){return e.fail()}),(function(){return e()}))},expectArraysEqual:function(t,e){var n="string"==typeof e||"number"==typeof e||"boolean"==typeof e?[e]:e;return H(t)||H(t[0])||H(e)||H(e[0])?pd(t,n,(function(t,e){return t==e})):pd(t,e,(function(t,e){return vd(t,e,0)}))},expectNumbersClose:function(t,e,n){if(null==n&&(n=dd()),!vd(t,e,n))throw new Error("Numbers differ: actual === "+t+", expected === "+e)},expectValuesInRange:function(t,e,n){for(var r=0;r<t.length;r++)if(t[r]<e||t[r]>n)throw new Error("Value out of range:"+t[r]+" low: "+e+", high: "+n)},expectArrayBuffersEqual:function(t,e){expect(new Float32Array(t)).toEqual(new Float32Array(e))}}),gd="1.7.0";var yd=Object.freeze({gpgpu_util:Mi,webgl_util:Ge,forceHalfFloat:function(){i().set("WEBGL_FORCE_F16_TEXTURES",!0)},MathBackendWebGL:Zs,setWebGLContext:Kt,GPGPUContext:Bi}),xd=function(t){function o(){return null!==t&&t.apply(this,arguments)||this}return e(o,t),o.prototype.minimize=function(t,e,n){void 0===e&&(e=!1);var r=this.computeGradients(t,n),o=r.value,a=r.grads;if(null!=n){var i=n.map((function(t){return{name:t.name,tensor:a[t.name]}}));this.applyGradients(i)}else this.applyGradients(a);return tn(a),e?o:(o.dispose(),null)},Object.defineProperty(o.prototype,"iterations",{get:function(){return null==this.iterations_&&(this.iterations_=0),this.iterations_},enumerable:!0,configurable:!0}),o.prototype.incrementIterations=function(){this.iterations_=this.iterations+1},o.prototype.computeGradients=function(t,e){return po(t,e)},o.prototype.dispose=function(){null!=this.iterations_&&tn(this.iterations_)},o.prototype.saveIterations=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){return null==this.iterations_&&(this.iterations_=0),[2,{name:"iter",tensor:On(this.iterations_,"int32")}]}))}))},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){throw new Error("getWeights() is not implemented for this optimizer yet.")}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(t){throw new Error("setWeights() is not implemented for this optimizer class "+this.getClassName())}))}))},o.prototype.extractIterations=function(t){return n(this,void 0,void 0,(function(){var e;return r(this,(function(n){switch(n.label){case 0:return e=this,[4,t[0].tensor.data()];case 1:return e.iterations_=n.sent()[0],[2,t.slice(1)]}}))}))},o}(sd);Object.defineProperty(xd,Symbol.hasInstance,{value:function(t){return null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients}});var bd=function(t){function o(e,n,r){void 0===r&&(r=null);var o=t.call(this)||this;return o.learningRate=e,o.rho=n,o.epsilon=r,o.accumulatedGrads=[],o.accumulatedUpdates=[],null==r&&(o.epsilon=Lt.backend.epsilon()),o}return e(o,t),o.prototype.applyGradients=function(t){var e=this;(Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t)).forEach((function(n,r){var o=Lt.registeredVariables[n];null==e.accumulatedGrads[r]&&(e.accumulatedGrads[r]={originalName:n+"/accum_grad",variable:Ze((function(){return Xn(o).variable(!1)}))}),null==e.accumulatedUpdates[r]&&(e.accumulatedUpdates[r]={originalName:n+"/accum_var",variable:Ze((function(){return Xn(o).variable(!1)}))});var a=Array.isArray(t)?t[r].tensor:t[n];if(null!=a){var i=e.accumulatedGrads[r].variable,s=e.accumulatedUpdates[r].variable;Ze((function(){var t=i.mul(e.rho).add(a.square().mul(1-e.rho)),n=s.add(e.epsilon).sqrt().div(i.add(e.epsilon).sqrt()).mul(a),r=s.mul(e.rho).add(n.square().mul(1-e.rho));i.assign(t),s.assign(r);var u=n.mul(-e.learningRate).add(o);o.assign(u)}))}})),this.incrementIterations()},o.prototype.dispose=function(){null!=this.accumulatedUpdates&&(tn(this.accumulatedGrads.map((function(t){return t.variable}))),tn(this.accumulatedUpdates.map((function(t){return t.variable}))))},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){var t;return r(this,(function(e){switch(e.label){case 0:return t=this.accumulatedGrads.concat(this.accumulatedUpdates),[4,this.saveIterations()];case 1:return[2,[e.sent()].concat(t.map((function(t){return{name:t.originalName,tensor:t.variable}})))]}}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){var e;return r(this,(function(n){switch(n.label){case 0:return[4,this.extractIterations(t)];case 1:return t=n.sent(),e=t.length/2,!1,this.accumulatedGrads=t.slice(0,e).map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),this.accumulatedUpdates=t.slice(e,2*e).map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),[2]}}))}))},o.prototype.getConfig=function(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}},o.fromConfig=function(t,e){return new t(e.learningRate,e.rho,e.epsilon)},o.className="Adadelta",o}(xd);cd(bd);var wd=function(t){function o(e,n){void 0===n&&(n=.1);var r=t.call(this)||this;return r.learningRate=e,r.initialAccumulatorValue=n,r.accumulatedGrads=[],r}return e(o,t),o.prototype.applyGradients=function(t){var e=this;(Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t)).forEach((function(n,r){var o=Lt.registeredVariables[n];if(null==e.accumulatedGrads[r]){e.accumulatedGrads[r]={originalName:n+"/accumulator",variable:Ze((function(){return Hn(o.shape,e.initialAccumulatorValue).variable(!1)}))}}var a=Array.isArray(t)?t[r].tensor:t[n];if(null!=a){var i=e.accumulatedGrads[r].variable;Ze((function(){var t=i.add(a.square());i.assign(t);var n=a.div(t.add(Lt.backend.epsilon()).sqrt()).mul(-e.learningRate).add(o);o.assign(n)}))}})),this.incrementIterations()},o.prototype.dispose=function(){null!=this.accumulatedGrads&&tn(this.accumulatedGrads.map((function(t){return t.variable})))},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){switch(t.label){case 0:return[4,this.saveIterations()];case 1:return[2,[t.sent()].concat(this.accumulatedGrads.map((function(t){return{name:t.originalName,tensor:t.variable}})))]}}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(e){switch(e.label){case 0:return[4,this.extractIterations(t)];case 1:return t=e.sent(),!1,this.accumulatedGrads=t.map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),[2]}}))}))},o.prototype.getConfig=function(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}},o.fromConfig=function(t,e){return new t(e.learningRate,e.initialAccumulatorValue)},o.className="Adagrad",o}(xd);cd(wd);var Cd=function(t){function o(e,n,r,o){void 0===o&&(o=null);var a=t.call(this)||this;return a.learningRate=e,a.beta1=n,a.beta2=r,a.epsilon=o,a.accumulatedFirstMoment=[],a.accumulatedSecondMoment=[],Ze((function(){a.accBeta1=On(n).variable(),a.accBeta2=On(r).variable()})),null==o&&(a.epsilon=Lt.backend.epsilon()),a}return e(o,t),o.prototype.applyGradients=function(t){var e=this,n=Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t);Ze((function(){var r=Cc(1,e.accBeta1),o=Cc(1,e.accBeta2);n.forEach((function(n,a){var i=Lt.registeredVariables[n];null==e.accumulatedFirstMoment[a]&&(e.accumulatedFirstMoment[a]={originalName:n+"/m",variable:Ze((function(){return Xn(i).variable(!1)}))}),null==e.accumulatedSecondMoment[a]&&(e.accumulatedSecondMoment[a]={originalName:n+"/v",variable:Ze((function(){return Xn(i).variable(!1)}))});var s=Array.isArray(t)?t[a].tensor:t[n];if(null!=s){var u=e.accumulatedFirstMoment[a].variable,c=e.accumulatedSecondMoment[a].variable,l=u.mul(e.beta1).add(s.mul(1-e.beta1)),h=c.mul(e.beta2).add(s.square().mul(1-e.beta2)),f=l.div(r),d=h.div(o);u.assign(l),c.assign(h);var p=f.div(d.sqrt().add(e.epsilon)).mul(-e.learningRate).add(i);i.assign(p)}})),e.accBeta1.assign(e.accBeta1.mul(e.beta1)),e.accBeta2.assign(e.accBeta2.mul(e.beta2))})),this.incrementIterations()},o.prototype.dispose=function(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&tn(this.accumulatedFirstMoment.map((function(t){return t.variable}))),null!=this.accumulatedSecondMoment&&tn(this.accumulatedSecondMoment.map((function(t){return t.variable})))},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){var t;return r(this,(function(e){switch(e.label){case 0:return t=this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment),[4,this.saveIterations()];case 1:return[2,[e.sent()].concat(t.map((function(t){return{name:t.originalName,tensor:t.variable}})))]}}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){var e,n=this;return r(this,(function(r){switch(r.label){case 0:return[4,this.extractIterations(t)];case 1:return t=r.sent(),Ze((function(){n.accBeta1.assign(xc(n.beta1,n.iterations_+1)),n.accBeta2.assign(xc(n.beta2,n.iterations_+1))})),e=t.length/2,!1,this.accumulatedFirstMoment=t.slice(0,e).map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),this.accumulatedSecondMoment=t.slice(e,2*e).map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),[2]}}))}))},o.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}},o.fromConfig=function(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)},o.className="Adam",o}(xd);cd(Cd);var Ed=function(t){function o(e,n,r,o,a){void 0===o&&(o=null),void 0===a&&(a=0);var i=t.call(this)||this;return i.learningRate=e,i.beta1=n,i.beta2=r,i.epsilon=o,i.decay=a,i.accumulatedFirstMoment=[],i.accumulatedWeightedInfNorm=[],Ze((function(){i.iteration=On(0).variable(),i.accBeta1=On(n).variable()})),null==o&&(i.epsilon=Lt.backend.epsilon()),i}return e(o,t),o.prototype.applyGradients=function(t){var e=this,n=Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t);Ze((function(){var r=Cc(1,e.accBeta1),o=sc(-e.learningRate,e.iteration.mul(e.decay).add(1));n.forEach((function(n,a){var i=Lt.registeredVariables[n];null==e.accumulatedFirstMoment[a]&&(e.accumulatedFirstMoment[a]={originalName:n+"/m",variable:Xn(i).variable(!1)}),null==e.accumulatedWeightedInfNorm[a]&&(e.accumulatedWeightedInfNorm[a]={originalName:n+"/v",variable:Xn(i).variable(!1)});var s=Array.isArray(t)?t[a].tensor:t[n];if(null!=s){var u=e.accumulatedFirstMoment[a].variable,c=e.accumulatedWeightedInfNorm[a].variable,l=u.mul(e.beta1).add(s.mul(1-e.beta1)),h=c.mul(e.beta2),f=s.abs(),d=h.maximum(f);u.assign(l),c.assign(d);var p=o.div(r).mul(l.div(d.add(e.epsilon))).add(i);i.assign(p)}})),e.iteration.assign(e.iteration.add(1)),e.accBeta1.assign(e.accBeta1.mul(e.beta1))})),this.incrementIterations()},o.prototype.dispose=function(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&tn(this.accumulatedFirstMoment.map((function(t){return t.variable}))),null!=this.accumulatedWeightedInfNorm&&tn(this.accumulatedWeightedInfNorm.map((function(t){return t.variable})))},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){throw new Error("getWeights() is not implemented for Adamax yet.")}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(t){throw new Error("setWeights() is not implemented for Adamax yet.")}))}))},o.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}},o.fromConfig=function(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)},o.className="Adamax",o}(xd);cd(Ed);var Rd=function(t){function o(e){var n=t.call(this)||this;return n.learningRate=e,n.setLearningRate(e),n}return e(o,t),o.prototype.applyGradients=function(t){var e=this;(Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t)).forEach((function(n,r){var o=Array.isArray(t)?t[r].tensor:t[n];if(null!=o){var a=Lt.registeredVariables[n];Ze((function(){var t=e.c.mul(o).add(a);a.assign(t)}))}})),this.incrementIterations()},o.prototype.setLearningRate=function(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=en(On(-t))},o.prototype.dispose=function(){this.c.dispose()},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){switch(t.label){case 0:return[4,this.saveIterations()];case 1:return[2,[t.sent()]]}}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(e){switch(e.label){case 0:return[4,this.extractIterations(t)];case 1:if(0!==(t=e.sent()).length)throw new Error("SGD optimizer does not have settable weights.");return[2]}}))}))},o.prototype.getConfig=function(){return{learningRate:this.learningRate}},o.fromConfig=function(t,e){return new t(e.learningRate)},o.className="SGD",o}(xd);cd(Rd);var Id=function(t){function o(e,n,r){void 0===r&&(r=!1);var o=t.call(this,e)||this;return o.learningRate=e,o.momentum=n,o.useNesterov=r,o.accumulations=[],o.m=On(o.momentum),o}return e(o,t),o.prototype.applyGradients=function(t){var e=this;(Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t)).forEach((function(n,r){var o=Lt.registeredVariables[n];if(null==e.accumulations[r]){e.accumulations[r]={originalName:n+"/momentum",variable:Ze((function(){return Xn(o).variable(!1)}))}}var a=e.accumulations[r].variable,i=Array.isArray(t)?t[r].tensor:t[n];null!=i&&Ze((function(){var t,n=e.m.mul(a).add(i);t=e.useNesterov?e.c.mul(i.add(n.mul(e.m))).add(o):e.c.mul(n).add(o),a.assign(n),o.assign(t)}))})),this.incrementIterations()},o.prototype.dispose=function(){this.m.dispose(),null!=this.accumulations&&tn(this.accumulations.map((function(t){return t.variable})))},o.prototype.setMomentum=function(t){this.momentum=t},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){return r(this,(function(t){switch(t.label){case 0:return[4,this.saveIterations()];case 1:return[2,[t.sent()].concat(this.accumulations.map((function(t){return{name:t.originalName,tensor:t.variable}})))]}}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(e){switch(e.label){case 0:return[4,this.extractIterations(t)];case 1:return t=e.sent(),!1,this.accumulations=t.map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),[2]}}))}))},o.prototype.getConfig=function(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}},o.fromConfig=function(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)},o.className="Momentum",o}(Rd);cd(Id);var kd=function(t){function o(e,n,r,o,a){void 0===n&&(n=.9),void 0===r&&(r=0),void 0===o&&(o=null),void 0===a&&(a=!1);var i=t.call(this)||this;if(i.learningRate=e,i.decay=n,i.momentum=r,i.epsilon=o,i.accumulatedMeanSquares=[],i.accumulatedMoments=[],i.accumulatedMeanGrads=[],i.centered=a,null==o&&(i.epsilon=Lt.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.");return i}return e(o,t),o.prototype.applyGradients=function(t){var e=this;(Array.isArray(t)?t.map((function(t){return t.name})):Object.keys(t)).forEach((function(n,r){var o=Lt.registeredVariables[n];null==e.accumulatedMeanSquares[r]&&(e.accumulatedMeanSquares[r]={originalName:n+"/rms",variable:Ze((function(){return Xn(o).variable(!1)}))}),null==e.accumulatedMoments[r]&&(e.accumulatedMoments[r]={originalName:n+"/momentum",variable:Ze((function(){return Xn(o).variable(!1)}))}),null==e.accumulatedMeanGrads[r]&&e.centered&&(e.accumulatedMeanGrads[r]={originalName:n+"/mg",variable:Ze((function(){return Xn(o).variable(!1)}))});var a=Array.isArray(t)?t[r].tensor:t[n];if(null!=a){var i=e.accumulatedMeanSquares[r].variable,s=e.accumulatedMoments[r].variable;Ze((function(){var t=i.mul(e.decay).add(a.square().mul(1-e.decay));if(e.centered){var n=e.accumulatedMeanGrads[r].variable,u=n.mul(e.decay).add(a.mul(1-e.decay)),c=s.mul(e.momentum).add(a.mul(e.learningRate).div(t.sub(u.square().add(e.epsilon)).sqrt()));i.assign(t),n.assign(u),s.assign(c);var l=o.sub(c);o.assign(l)}else{var h=i.mul(e.decay).add(a.square().mul(1-e.decay));c=s.mul(e.momentum).add(a.mul(e.learningRate).div(h.add(e.epsilon).sqrt()));i.assign(h),s.assign(c);l=o.sub(c);o.assign(l)}}))}})),this.incrementIterations()},o.prototype.dispose=function(){null!=this.accumulatedMeanSquares&&tn(this.accumulatedMeanSquares.map((function(t){return t.variable}))),null!=this.accumulatedMeanGrads&&this.centered&&tn(this.accumulatedMeanGrads.map((function(t){return t.variable}))),null!=this.accumulatedMoments&&tn(this.accumulatedMoments.map((function(t){return t.variable})))},o.prototype.getWeights=function(){return n(this,void 0,void 0,(function(){var t;return r(this,(function(e){switch(e.label){case 0:return t=this.accumulatedMeanSquares.concat(this.accumulatedMoments),this.centered&&t.push.apply(t,this.accumulatedMeanGrads),[4,this.saveIterations()];case 1:return[2,[e.sent()].concat(t.map((function(t){return{name:t.originalName,tensor:t.variable}})))]}}))}))},o.prototype.setWeights=function(t){return n(this,void 0,void 0,(function(){var e;return r(this,(function(n){switch(n.label){case 0:return[4,this.extractIterations(t)];case 1:return t=n.sent(),e=this.centered?t.length/3:t.length/2,!1,this.accumulatedMeanSquares=t.slice(0,e).map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),this.accumulatedMoments=t.slice(e,2*e).map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}})),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((function(t){return{originalName:t.name,variable:t.tensor.variable(!1)}}))),[2]}}))}))},o.prototype.getConfig=function(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}},o.fromConfig=function(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)},o.className="RMSProp",o}(xd);cd(kd);var Sd=function(){function t(){}return t.sgd=function(t){return new Rd(t)},t.momentum=function(t,e,n){return void 0===n&&(n=!1),new Id(t,e,n)},t.rmsprop=function(t,e,n,r,o){return void 0===e&&(e=.9),void 0===n&&(n=0),void 0===r&&(r=null),void 0===o&&(o=!1),new kd(t,e,n,r,o)},t.adam=function(t,e,n,r){return void 0===t&&(t=.001),void 0===e&&(e=.9),void 0===n&&(n=.999),void 0===r&&(r=null),new Cd(t,e,n,r)},t.adadelta=function(t,e,n){return void 0===t&&(t=.001),void 0===e&&(e=.95),void 0===n&&(n=null),new bd(t,e,n)},t.adamax=function(t,e,n,r,o){return void 0===t&&(t=.002),void 0===e&&(e=.9),void 0===n&&(n=.999),void 0===r&&(r=null),void 0===o&&(o=0),new Ed(t,e,n,r,o)},t.adagrad=function(t,e){return void 0===e&&(e=.1),new wd(t,e)},t}(),Ad={sgd:Sd.sgd,momentum:Sd.momentum,adadelta:Sd.adadelta,adagrad:Sd.adagrad,rmsprop:Sd.rmsprop,adamax:Sd.adamax,adam:Sd.adam},Dd="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:function(t){return t()};function Td(){return new Promise((function(t){return Dd((function(){return t()}))}))}wt.prototype.squaredDifference=function(t){return nu(this,t)},xt=Gh;
//# sourceMappingURL=tf-core.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../next/dist/compiled/webpack/global.js */ "./node_modules/next/dist/compiled/webpack/global.js"), __webpack_require__(/*! ./../../../../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var assign=Object.assign.bind(Object);module.exports=assign;module.exports.default=module.exports;
//# sourceMappingURL=object-assign.js.map

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=C%3A%5CPersonal%5CProjects%5Csmile%5Cpages%5Cindex.js!./":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=C%3A%5CPersonal%5CProjects%5Csmile%5Cpages%5Cindex.js ***!
  \******************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


    (window.__NEXT_P = window.__NEXT_P || []).push([
      "/",
      function () {
        return __webpack_require__(/*! ./pages/index.js */ "./pages/index.js");
      }
    ]);
  

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
const isOldIE=function isOldIE(){let memo;return function memorize(){if(typeof memo==='undefined'){// Test for IE <= 9 as proposed by Browserhacks
// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
// Tests for existence of standard globals is to allow style-loader
// to operate correctly into non-standard environments
// @see https://github.com/webpack-contrib/style-loader/issues/177
memo=Boolean(window&&document&&document.all&&!window.atob);}return memo;};}();const getTarget=function getTarget(){const memo={};return function memorize(target){if(typeof memo[target]==='undefined'){let styleTarget=document.querySelector(target);// Special case to return head of iframe instead of iframe itself
if(window.HTMLIFrameElement&&styleTarget instanceof window.HTMLIFrameElement){try{// This will throw an exception if access to iframe is blocked
// due to cross-origin restrictions
styleTarget=styleTarget.contentDocument.head;}catch(e){// istanbul ignore next
styleTarget=null;}}memo[target]=styleTarget;}return memo[target];};}();const stylesInDom=[];function getIndexByIdentifier(identifier){let result=-1;for(let i=0;i<stylesInDom.length;i++){if(stylesInDom[i].identifier===identifier){result=i;break;}}return result;}function modulesToDom(list,options){const idCountMap={};const identifiers=[];for(let i=0;i<list.length;i++){const item=list[i];const id=options.base?item[0]+options.base:item[0];const count=idCountMap[id]||0;const identifier=`${id} ${count}`;idCountMap[id]=count+1;const index=getIndexByIdentifier(identifier);const obj={css:item[1],media:item[2],sourceMap:item[3]};if(index!==-1){stylesInDom[index].references++;stylesInDom[index].updater(obj);}else{stylesInDom.push({identifier,updater:addStyle(obj,options),references:1});}identifiers.push(identifier);}return identifiers;}function insertStyleElement(options){const style=document.createElement('style');const attributes=options.attributes||{};if(typeof attributes.nonce==='undefined'){const nonce=// eslint-disable-next-line no-undef
 true?__webpack_require__.nc:undefined;if(nonce){attributes.nonce=nonce;}}Object.keys(attributes).forEach(key=>{style.setAttribute(key,attributes[key]);});if(typeof options.insert==='function'){options.insert(style);}else{const target=getTarget(options.insert||'head');if(!target){throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");}target.appendChild(style);}return style;}function removeStyleElement(style){// istanbul ignore if
if(style.parentNode===null){return false;}style.parentNode.removeChild(style);}/* istanbul ignore next  */const replaceText=function replaceText(){const textStore=[];return function replace(index,replacement){textStore[index]=replacement;return textStore.filter(Boolean).join('\n');};}();function applyToSingletonTag(style,index,remove,obj){const css=remove?'':obj.media?`@media ${obj.media} {${obj.css}}`:obj.css;// For old IE
/* istanbul ignore if  */if(style.styleSheet){style.styleSheet.cssText=replaceText(index,css);}else{const cssNode=document.createTextNode(css);const childNodes=style.childNodes;if(childNodes[index]){style.removeChild(childNodes[index]);}if(childNodes.length){style.insertBefore(cssNode,childNodes[index]);}else{style.appendChild(cssNode);}}}function applyToTag(style,options,obj){let css=obj.css;const media=obj.media;const sourceMap=obj.sourceMap;if(media){style.setAttribute('media',media);}else{style.removeAttribute('media');}if(sourceMap&&typeof btoa!=='undefined'){css+=`\n/*# sourceMappingURL=data:application/json;base64,${btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))))} */`;}// For old IE
/* istanbul ignore if  */if(style.styleSheet){style.styleSheet.cssText=css;}else{while(style.firstChild){style.removeChild(style.firstChild);}style.appendChild(document.createTextNode(css));}}let singleton=null;let singletonCounter=0;function addStyle(obj,options){let style;let update;let remove;if(options.singleton){const styleIndex=singletonCounter++;style=singleton||(singleton=insertStyleElement(options));update=applyToSingletonTag.bind(null,style,styleIndex,false);remove=applyToSingletonTag.bind(null,style,styleIndex,true);}else{style=insertStyleElement(options);update=applyToTag.bind(null,style,options);remove=()=>{removeStyleElement(style);};}update(obj);return function updateStyle(newObj){if(newObj){if(newObj.css===obj.css&&newObj.media===obj.media&&newObj.sourceMap===obj.sourceMap){return;}update(obj=newObj);}else{remove();}};}module.exports=(list,options)=>{options=options||{};// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
if(!options.singleton&&typeof options.singleton!=='boolean'){options.singleton=isOldIE();}list=list||[];let lastIdentifiers=modulesToDom(list,options);return function update(newList){newList=newList||[];if(Object.prototype.toString.call(newList)!=='[object Array]'){return;}for(let i=0;i<lastIdentifiers.length;i++){const identifier=lastIdentifiers[i];const index=getIndexByIdentifier(identifier);stylesInDom[index].references--;}const newLastIdentifiers=modulesToDom(newList,options);for(let i=0;i<lastIdentifiers.length;i++){const identifier=lastIdentifiers[i];const index=getIndexByIdentifier(identifier);if(stylesInDom[index].references===0){stylesInDom[index].updater();stylesInDom.splice(index,1);}}lastIdentifiers=newLastIdentifiers;};};
//# sourceMappingURL=injectStylesIntoStyleTag.js.map

/***/ }),

/***/ "./node_modules/next/dist/client/image.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/image.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _toConsumableArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = Image;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"));

var _extends2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js"));

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _head = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/head */ "./node_modules/next/dist/next-server/lib/head.js"));

var _toBase = __webpack_require__(/*! ../next-server/lib/to-base-64 */ "./node_modules/next/dist/next-server/lib/to-base-64.js");

var _imageConfig = __webpack_require__(/*! ../next-server/server/image-config */ "./node_modules/next/dist/next-server/server/image-config.js");

var _useIntersection = __webpack_require__(/*! ./use-intersection */ "./node_modules/next/dist/client/use-intersection.js");

if (false) {}

var VALID_LOADING_VALUES = ['lazy', 'eager', undefined];
var loaders = new Map([['imgix', imgixLoader], ['cloudinary', cloudinaryLoader], ['akamai', akamaiLoader], ['default', defaultLoader]]);
var VALID_LAYOUT_VALUES = ['fill', 'fixed', 'intrinsic', 'responsive', undefined];

var _ref2 = {"deviceSizes":[640,750,828,1080,1200,1920,2048,3840],"imageSizes":[16,32,48,64,96,128,256,384],"path":"https://cdn.statically.io/gh/HiltonWS/hiltonws.github.io/master/smile/image","loader":"default","domains":[]} || _imageConfig.imageConfigDefault,
    configDeviceSizes = _ref2.deviceSizes,
    configImageSizes = _ref2.imageSizes,
    configLoader = _ref2.loader,
    configPath = _ref2.path,
    configDomains = _ref2.domains; // sort smallest to largest


var allSizes = [].concat(_toConsumableArray(configDeviceSizes), _toConsumableArray(configImageSizes));
configDeviceSizes.sort(function (a, b) {
  return a - b;
});
allSizes.sort(function (a, b) {
  return a - b;
});

function getWidths(width, layout, sizes) {
  if (sizes && (layout === 'fill' || layout === 'responsive')) {
    // Find all the "vw" percent sizes used in the sizes prop
    var percentSizes = _toConsumableArray(sizes.matchAll(/(^|\s)(1?\d?\d)vw/g)).map(function (m) {
      return parseInt(m[2]);
    });

    if (percentSizes.length) {
      var smallestRatio = Math.min.apply(Math, _toConsumableArray(percentSizes)) * 0.01;
      return {
        widths: allSizes.filter(function (s) {
          return s >= configDeviceSizes[0] * smallestRatio;
        }),
        kind: 'w'
      };
    }

    return {
      widths: allSizes,
      kind: 'w'
    };
  }

  if (typeof width !== 'number' || layout === 'fill' || layout === 'responsive') {
    return {
      widths: configDeviceSizes,
      kind: 'w'
    };
  }

  var widths = _toConsumableArray(new Set( // > This means that most OLED screens that say they are 3x resolution,
  // > are actually 3x in the green color, but only 1.5x in the red and
  // > blue colors. Showing a 3x resolution image in the app vs a 2x
  // > resolution image will be visually the same, though the 3x image
  // > takes significantly more data. Even true 3x resolution screens are
  // > wasteful as the human eye cannot see that level of detail without
  // > something like a magnifying glass.
  // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html
  [width, width * 2
  /*, width * 3*/
  ].map(function (w) {
    return allSizes.find(function (p) {
      return p >= w;
    }) || allSizes[allSizes.length - 1];
  })));

  return {
    widths: widths,
    kind: 'x'
  };
}

function generateImgAttrs(_ref3) {
  var src = _ref3.src,
      unoptimized = _ref3.unoptimized,
      layout = _ref3.layout,
      width = _ref3.width,
      quality = _ref3.quality,
      sizes = _ref3.sizes,
      loader = _ref3.loader;

  if (unoptimized) {
    return {
      src: src,
      srcSet: undefined,
      sizes: undefined
    };
  }

  var _getWidths = getWidths(width, layout, sizes),
      widths = _getWidths.widths,
      kind = _getWidths.kind;

  var last = widths.length - 1;
  return {
    sizes: !sizes && kind === 'w' ? '100vw' : sizes,
    srcSet: widths.map(function (w, i) {
      return "".concat(loader({
        src: src,
        quality: quality,
        width: w
      }), " ").concat(kind === 'w' ? w : i + 1).concat(kind);
    }).join(', '),
    // It's intended to keep `src` the last attribute because React updates
    // attributes in order. If we keep `src` the first one, Safari will
    // immediately start to fetch `src`, before `sizes` and `srcSet` are even
    // updated by React. That causes multiple unnecessary requests if `srcSet`
    // and `sizes` are defined.
    // This bug cannot be reproduced in Chrome or Firefox.
    src: loader({
      src: src,
      quality: quality,
      width: widths[last]
    })
  };
}

function getInt(x) {
  if (typeof x === 'number') {
    return x;
  }

  if (typeof x === 'string') {
    return parseInt(x, 10);
  }

  return undefined;
}

function defaultImageLoader(loaderProps) {
  var load = loaders.get(configLoader);

  if (load) {
    return load((0, _extends2["default"])({
      root: configPath
    }, loaderProps));
  }

  throw new Error("Unknown \"loader\" found in \"next.config.js\". Expected: ".concat(_imageConfig.VALID_LOADERS.join(', '), ". Received: ").concat(configLoader));
}

function Image(_ref) {
  var src = _ref.src,
      sizes = _ref.sizes,
      _ref$unoptimized = _ref.unoptimized,
      unoptimized = _ref$unoptimized === void 0 ? false : _ref$unoptimized,
      _ref$priority = _ref.priority,
      priority = _ref$priority === void 0 ? false : _ref$priority,
      loading = _ref.loading,
      className = _ref.className,
      quality = _ref.quality,
      width = _ref.width,
      height = _ref.height,
      objectFit = _ref.objectFit,
      objectPosition = _ref.objectPosition,
      _ref$loader = _ref.loader,
      loader = _ref$loader === void 0 ? defaultImageLoader : _ref$loader,
      all = (0, _objectWithoutPropertiesLoose2["default"])(_ref, ["src", "sizes", "unoptimized", "priority", "loading", "className", "quality", "width", "height", "objectFit", "objectPosition", "loader"]);
  var rest = all;
  var layout = sizes ? 'responsive' : 'intrinsic';
  var unsized = false;

  if ('unsized' in rest) {
    unsized = Boolean(rest.unsized); // Remove property so it's not spread into image:

    delete rest['unsized'];
  } else if ('layout' in rest) {
    // Override default layout if the user specified one:
    if (rest.layout) layout = rest.layout; // Remove property so it's not spread into image:

    delete rest['layout'];
  }

  if (true) {
    if (!src) {
      throw new Error("Image is missing required \"src\" property. Make sure you pass \"src\" in props to the `next/image` component. Received: ".concat(JSON.stringify({
        width: width,
        height: height,
        quality: quality
      })));
    }

    if (!VALID_LAYOUT_VALUES.includes(layout)) {
      throw new Error("Image with src \"".concat(src, "\" has invalid \"layout\" property. Provided \"").concat(layout, "\" should be one of ").concat(VALID_LAYOUT_VALUES.map(String).join(','), "."));
    }

    if (!VALID_LOADING_VALUES.includes(loading)) {
      throw new Error("Image with src \"".concat(src, "\" has invalid \"loading\" property. Provided \"").concat(loading, "\" should be one of ").concat(VALID_LOADING_VALUES.map(String).join(','), "."));
    }

    if (priority && loading === 'lazy') {
      throw new Error("Image with src \"".concat(src, "\" has both \"priority\" and \"loading='lazy'\" properties. Only one should be used."));
    }

    if (unsized) {
      throw new Error("Image with src \"".concat(src, "\" has deprecated \"unsized\" property, which was removed in favor of the \"layout='fill'\" property"));
    }
  }

  var isLazy = !priority && (loading === 'lazy' || typeof loading === 'undefined');

  if (src && src.startsWith('data:')) {
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
    unoptimized = true;
    isLazy = false;
  }

  var _ref4 = (0, _useIntersection.useIntersection)({
    rootMargin: '200px',
    disabled: !isLazy
  }),
      _ref5 = _slicedToArray(_ref4, 2),
      setRef = _ref5[0],
      isIntersected = _ref5[1];

  var isVisible = !isLazy || isIntersected;
  var widthInt = getInt(width);
  var heightInt = getInt(height);
  var qualityInt = getInt(quality);
  var wrapperStyle;
  var sizerStyle;
  var sizerSvg;
  var imgStyle = {
    visibility: isVisible ? 'inherit' : 'hidden',
    position: 'absolute',
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    boxSizing: 'border-box',
    padding: 0,
    border: 'none',
    margin: 'auto',
    display: 'block',
    width: 0,
    height: 0,
    minWidth: '100%',
    maxWidth: '100%',
    minHeight: '100%',
    maxHeight: '100%',
    objectFit: objectFit,
    objectPosition: objectPosition
  };

  if (typeof widthInt !== 'undefined' && typeof heightInt !== 'undefined' && layout !== 'fill') {
    // <Image src="i.png" width="100" height="100" />
    var quotient = heightInt / widthInt;
    var paddingTop = isNaN(quotient) ? '100%' : "".concat(quotient * 100, "%");

    if (layout === 'responsive') {
      // <Image src="i.png" width="100" height="100" layout="responsive" />
      wrapperStyle = {
        display: 'block',
        overflow: 'hidden',
        position: 'relative',
        boxSizing: 'border-box',
        margin: 0
      };
      sizerStyle = {
        display: 'block',
        boxSizing: 'border-box',
        paddingTop: paddingTop
      };
    } else if (layout === 'intrinsic') {
      // <Image src="i.png" width="100" height="100" layout="intrinsic" />
      wrapperStyle = {
        display: 'inline-block',
        maxWidth: '100%',
        overflow: 'hidden',
        position: 'relative',
        boxSizing: 'border-box',
        margin: 0
      };
      sizerStyle = {
        boxSizing: 'border-box',
        display: 'block',
        maxWidth: '100%'
      };
      sizerSvg = "<svg width=\"".concat(widthInt, "\" height=\"").concat(heightInt, "\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"/>");
    } else if (layout === 'fixed') {
      // <Image src="i.png" width="100" height="100" layout="fixed" />
      wrapperStyle = {
        overflow: 'hidden',
        boxSizing: 'border-box',
        display: 'inline-block',
        position: 'relative',
        width: widthInt,
        height: heightInt
      };
    }
  } else if (typeof widthInt === 'undefined' && typeof heightInt === 'undefined' && layout === 'fill') {
    // <Image src="i.png" layout="fill" />
    wrapperStyle = {
      display: 'block',
      overflow: 'hidden',
      position: 'absolute',
      top: 0,
      left: 0,
      bottom: 0,
      right: 0,
      boxSizing: 'border-box',
      margin: 0
    };
  } else {
    // <Image src="i.png" />
    if (true) {
      throw new Error("Image with src \"".concat(src, "\" must use \"width\" and \"height\" properties or \"layout='fill'\" property."));
    }
  }

  var imgAttributes = {
    src: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
    srcSet: undefined,
    sizes: undefined
  };

  if (isVisible) {
    imgAttributes = generateImgAttrs({
      src: src,
      unoptimized: unoptimized,
      layout: layout,
      width: widthInt,
      quality: qualityInt,
      sizes: sizes,
      loader: loader
    });
  }

  if (unsized) {
    wrapperStyle = undefined;
    sizerStyle = undefined;
    imgStyle = undefined;
  }

  return /*#__PURE__*/_react["default"].createElement("div", {
    style: wrapperStyle
  }, sizerStyle ? /*#__PURE__*/_react["default"].createElement("div", {
    style: sizerStyle
  }, sizerSvg ? /*#__PURE__*/_react["default"].createElement("img", {
    style: {
      maxWidth: '100%',
      display: 'block',
      margin: 0,
      border: 'none',
      padding: 0
    },
    alt: "",
    "aria-hidden": true,
    role: "presentation",
    src: "data:image/svg+xml;base64,".concat((0, _toBase.toBase64)(sizerSvg))
  }) : null) : null, /*#__PURE__*/_react["default"].createElement("img", Object.assign({}, rest, imgAttributes, {
    decoding: "async",
    className: className,
    ref: setRef,
    style: imgStyle
  })), priority ?
  /*#__PURE__*/
  // Note how we omit the `href` attribute, as it would only be relevant
  // for browsers that do not support `imagesrcset`, and in those cases
  // it would likely cause the incorrect image to be preloaded.
  //
  // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset
  _react["default"].createElement(_head["default"], null, /*#__PURE__*/_react["default"].createElement("link", {
    key: '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,
    rel: "preload",
    as: "image",
    href: imgAttributes.srcSet ? undefined : imgAttributes.src // @ts-ignore: imagesrcset is not yet in the link element type
    ,
    imagesrcset: imgAttributes.srcSet // @ts-ignore: imagesizes is not yet in the link element type
    ,
    imagesizes: imgAttributes.sizes
  })) : null);
} //BUILT IN LOADERS


_c = Image;

function normalizeSrc(src) {
  return src[0] === '/' ? src.slice(1) : src;
}

function imgixLoader(_ref6) {
  var root = _ref6.root,
      src = _ref6.src,
      width = _ref6.width,
      quality = _ref6.quality;
  // Demo: https://static.imgix.net/daisy.png?format=auto&fit=max&w=300
  var params = ['auto=format', 'fit=max', 'w=' + width];
  var paramsString = '';

  if (quality) {
    params.push('q=' + quality);
  }

  if (params.length) {
    paramsString = '?' + params.join('&');
  }

  return "".concat(root).concat(normalizeSrc(src)).concat(paramsString);
}

function akamaiLoader(_ref7) {
  var root = _ref7.root,
      src = _ref7.src,
      width = _ref7.width;
  return "".concat(root).concat(normalizeSrc(src), "?imwidth=").concat(width);
}

function cloudinaryLoader(_ref8) {
  var root = _ref8.root,
      src = _ref8.src,
      width = _ref8.width,
      quality = _ref8.quality;
  // Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg
  var params = ['f_auto', 'c_limit', 'w_' + width, 'q_' + (quality || 'auto')];
  var paramsString = params.join(',') + '/';
  return "".concat(root).concat(paramsString).concat(normalizeSrc(src));
}

function defaultLoader(_ref9) {
  var root = _ref9.root,
      src = _ref9.src,
      width = _ref9.width,
      quality = _ref9.quality;

  if (true) {
    var missingValues = []; // these should always be provided but make sure they are

    if (!src) missingValues.push('src');
    if (!width) missingValues.push('width');

    if (missingValues.length > 0) {
      throw new Error("Next Image Optimization requires ".concat(missingValues.join(', '), " to be provided. Make sure you pass them as props to the `next/image` component. Received: ").concat(JSON.stringify({
        src: src,
        width: width,
        quality: quality
      })));
    }

    if (src.startsWith('//')) {
      throw new Error("Failed to parse src \"".concat(src, "\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)"));
    }

    if (!src.startsWith('/') && configDomains) {
      var parsedSrc;

      try {
        parsedSrc = new URL(src);
      } catch (err) {
        console.error(err);
        throw new Error("Failed to parse src \"".concat(src, "\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)"));
      }

      if (!configDomains.includes(parsedSrc.hostname)) {
        throw new Error("Invalid src prop (".concat(src, ") on `next/image`, hostname \"").concat(parsedSrc.hostname, "\" is not configured under images in your `next.config.js`\n") + "See more info: https://err.sh/next.js/next-image-unconfigured-host");
      }
    }
  }

  return "".concat(root, "?url=").concat(encodeURIComponent(src), "&w=").concat(width, "&q=").concat(quality || 75);
}

var _c;

$RefreshReg$(_c, "Image");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _s = $RefreshSig$();

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports["default"] = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

var _router2 = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

var _useIntersection = __webpack_require__(/*! ./use-intersection */ "./node_modules/next/dist/client/use-intersection.js");

var prefetched = {};

function prefetch(router, href, as, options) {
  if ( false || !router) return;
  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)
  // We need to handle a prefetch error here since we may be
  // loading with priority which can reject but we don't
  // want to force navigation since this is only a prefetch

  router.prefetch(href, as, options)["catch"](function (err) {
    if (true) {
      // rethrow to show invalid URL errors
      throw err;
    }
  });
  var curLocale = options && typeof options.locale !== 'undefined' ? options.locale : router && router.locale; // Join on an invalid URI character

  prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')] = true;
}

function isModifiedEvent(event) {
  var target = event.currentTarget.target;
  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
  event.nativeEvent && event.nativeEvent.which === 2;
}

function linkClicked(e, router, href, as, replace, shallow, scroll, locale) {
  var nodeName = e.currentTarget.nodeName;

  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {
    // ignore click for browsers default behavior
    return;
  }

  e.preventDefault(); //  avoid scroll for urls with anchor refs

  if (scroll == null) {
    scroll = as.indexOf('#') < 0;
  } // replace state instead of push if prop is present


  router[replace ? 'replace' : 'push'](href, as, {
    shallow: shallow,
    locale: locale,
    scroll: scroll
  }).then(function (success) {
    if (!success) return;

    if (scroll) {
      // FIXME: proper route announcing at Router level, not Link:
      document.body.focus();
    }
  });
}

function Link(props) {
  _s();

  if (true) {
    var createPropError = function createPropError(args) {
      return new Error("Failed prop type: The prop `".concat(args.key, "` expects a ").concat(args.expected, " in `<Link>`, but got `").concat(args.actual, "` instead.") + (true ? "\nOpen your browser's console to view the Component stack trace." : undefined));
    }; // TypeScript trick for type-guarding:


    var requiredPropsGuard = {
      href: true
    };
    var requiredProps = Object.keys(requiredPropsGuard);
    requiredProps.forEach(function (key) {
      if (key === 'href') {
        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
          throw createPropError({
            key: key,
            expected: '`string` or `object`',
            actual: props[key] === null ? 'null' : typeof props[key]
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _ = key;
      }
    }); // TypeScript trick for type-guarding:

    var optionalPropsGuard = {
      as: true,
      replace: true,
      scroll: true,
      shallow: true,
      passHref: true,
      prefetch: true,
      locale: true
    };
    var optionalProps = Object.keys(optionalPropsGuard);
    optionalProps.forEach(function (key) {
      var valType = typeof props[key];

      if (key === 'as') {
        if (props[key] && valType !== 'string' && valType !== 'object') {
          throw createPropError({
            key: key,
            expected: '`string` or `object`',
            actual: valType
          });
        }
      } else if (key === 'locale') {
        if (props[key] && valType !== 'string') {
          throw createPropError({
            key: key,
            expected: '`string`',
            actual: valType
          });
        }
      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {
        if (props[key] != null && valType !== 'boolean') {
          throw createPropError({
            key: key,
            expected: '`boolean`',
            actual: valType
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _ = key;
      }
    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    var hasWarned = _react["default"].useRef(false);

    if (props.prefetch && !hasWarned.current) {
      hasWarned.current = true;
      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://err.sh/vercel/next.js/prefetch-true-deprecated');
    }
  }

  var p = props.prefetch !== false;
  var router = (0, _router2.useRouter)();
  var pathname = router && router.pathname || '/';

  var _react$default$useMem = _react["default"].useMemo(function () {
    var _ref = (0, _router.resolveHref)(pathname, props.href, true),
        _ref2 = _slicedToArray(_ref, 2),
        resolvedHref = _ref2[0],
        resolvedAs = _ref2[1];

    return {
      href: resolvedHref,
      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedAs || resolvedHref
    };
  }, [pathname, props.href, props.as]),
      href = _react$default$useMem.href,
      as = _react$default$useMem.as;

  var children = props.children,
      replace = props.replace,
      shallow = props.shallow,
      scroll = props.scroll,
      locale = props.locale; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag

  if (typeof children === 'string') {
    children = /*#__PURE__*/_react["default"].createElement("a", null, children);
  } // This will return the first child, if multiple are provided it will throw an error


  var child = _react.Children.only(children);

  var childRef = child && typeof child === 'object' && child.ref;

  var _ref3 = (0, _useIntersection.useIntersection)({
    rootMargin: '200px'
  }),
      _ref4 = _slicedToArray(_ref3, 2),
      setIntersectionRef = _ref4[0],
      isVisible = _ref4[1];

  var setRef = _react["default"].useCallback(function (el) {
    setIntersectionRef(el);

    if (childRef) {
      if (typeof childRef === 'function') childRef(el);else if (typeof childRef === 'object') {
        childRef.current = el;
      }
    }
  }, [childRef, setIntersectionRef]);

  (0, _react.useEffect)(function () {
    var shouldPrefetch = isVisible && p && (0, _router.isLocalURL)(href);
    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;
    var isPrefetched = prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')];

    if (shouldPrefetch && !isPrefetched) {
      prefetch(router, href, as, {
        locale: curLocale
      });
    }
  }, [as, href, isVisible, locale, p, router]);
  var childProps = {
    ref: setRef,
    onClick: function onClick(e) {
      if (child.props && typeof child.props.onClick === 'function') {
        child.props.onClick(e);
      }

      if (!e.defaultPrevented) {
        linkClicked(e, router, href, as, replace, shallow, scroll, locale);
      }
    }
  };

  childProps.onMouseEnter = function (e) {
    if (!(0, _router.isLocalURL)(href)) return;

    if (child.props && typeof child.props.onMouseEnter === 'function') {
      child.props.onMouseEnter(e);
    }

    prefetch(router, href, as, {
      priority: true
    });
  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
  // defined, we specify the current 'href', so that repetition is not needed by the user


  if (props.passHref || child.type === 'a' && !('href' in child.props)) {
    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale; // we only render domain locales if we are currently on a domain locale
    // so that locale links are still visitable in development/preview envs

    var localeDomain = router && router.isLocaleDomain && (0, _router.getDomainLocale)(as, curLocale, router && router.locales, router && router.domainLocales);
    childProps.href = localeDomain || (0, _router.addBasePath)((0, _router.addLocale)(as, curLocale, router && router.defaultLocale));
  }

  return /*#__PURE__*/_react["default"].cloneElement(child, childProps);
}

_s(Link, "7cX92ILFgstKFyzTMH+g73G4t5k=");

_c = Link;
var _default = Link;
exports["default"] = _default;

var _c;

$RefreshReg$(_c, "Link");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.removePathTrailingSlash = removePathTrailingSlash;
exports.normalizePathTrailingSlash = void 0;
/**
* Removes the trailing slash of a path if there is one. Preserves the root path `/`.
*/

function removePathTrailingSlash(path) {
  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;
}
/**
* Normalizes the trailing slash of a path according to the `trailingSlash` option
* in `next.config.js`.
*/


var normalizePathTrailingSlash =  false ? undefined : removePathTrailingSlash;
exports.normalizePathTrailingSlash = normalizePathTrailingSlash;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.cancelIdleCallback = exports.requestIdleCallback = void 0;

var requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback || function (cb) {
  var start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};

exports.requestIdleCallback = requestIdleCallback;

var cancelIdleCallback = typeof self !== 'undefined' && self.cancelIdleCallback || function (id) {
  return clearTimeout(id);
};

exports.cancelIdleCallback = cancelIdleCallback;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _slicedToArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _asyncToGenerator = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.markAssetError = markAssetError;
exports.isAssetError = isAssetError;
exports.getClientBuildManifest = getClientBuildManifest;
exports["default"] = void 0;

var _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/router/utils/get-asset-path-from-route */ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js"));

var _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js"); // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive
// considers as "Good" time-to-interactive. We must assume something went
// wrong beyond this point, and then fall-back to a full page transition to
// show the user something of value.


var MS_MAX_IDLE_DELAY = 3800;

function withFuture(key, map, generator) {
  var entry = map.get(key);

  if (entry) {
    if ('future' in entry) {
      return entry.future;
    }

    return Promise.resolve(entry);
  }

  var resolver;
  var prom = new Promise(function (resolve) {
    resolver = resolve;
  });
  map.set(key, entry = {
    resolve: resolver,
    future: prom
  });
  return generator ? // eslint-disable-next-line no-sequences
  generator().then(function (value) {
    return resolver(value), value;
  }) : prom;
}

function hasPrefetch(link) {
  try {
    link = document.createElement('link');
    return (// detect IE11 since it supports prefetch but isn't detected
      // with relList.support
      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')
    );
  } catch (_unused) {
    return false;
  }
}

var canPrefetch = hasPrefetch();

function prefetchViaDom(href, as, link) {
  return new Promise(function (res, rej) {
    if (document.querySelector("link[rel=\"prefetch\"][href^=\"".concat(href, "\"]"))) {
      return res();
    }

    link = document.createElement('link'); // The order of property assignment here is intentional:

    if (as) link.as = as;
    link.rel = "prefetch";
    link.crossOrigin = undefined;
    link.onload = res;
    link.onerror = rej; // `href` should always be last:

    link.href = href;
    document.head.appendChild(link);
  });
}

var ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR'); // TODO: unexport

function markAssetError(err) {
  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
}

function isAssetError(err) {
  return err && ASSET_LOAD_ERROR in err;
}

function appendScript(src, script) {
  return new Promise(function (resolve, reject) {
    script = document.createElement('script'); // The order of property assignment here is intentional.
    // 1. Setup success/failure hooks in case the browser synchronously
    //    executes when `src` is set.

    script.onload = resolve;

    script.onerror = function () {
      return reject(markAssetError(new Error("Failed to load script: ".concat(src))));
    }; // 2. Configure the cross-origin attribute before setting `src` in case the
    //    browser begins to fetch.


    script.crossOrigin = undefined; // 3. Finally, set the source and inject into the DOM in case the child
    //    must be appended for fetching to start.

    script.src = src;
    document.body.appendChild(script);
  });
} // Resolve a promise that times out after given amount of milliseconds.


function resolvePromiseWithTimeout(p, ms, err) {
  return new Promise(function (resolve, reject) {
    var cancelled = false;
    p.then(function (r) {
      // Resolved, cancel the timeout
      cancelled = true;
      resolve(r);
    })["catch"](reject);
    (0, _requestIdleCallback.requestIdleCallback)(function () {
      return setTimeout(function () {
        if (!cancelled) {
          reject(err);
        }
      }, ms);
    });
  });
} // TODO: stop exporting or cache the failure
// It'd be best to stop exporting this. It's an implementation detail. We're
// only exporting it for backwards compatibilty with the `page-loader`.
// Only cache this response as a last resort if we cannot eliminate all other
// code branches that use the Build Manifest Callback and push them through
// the Route Loader interface.


function getClientBuildManifest() {
  if (self.__BUILD_MANIFEST) {
    return Promise.resolve(self.__BUILD_MANIFEST);
  }

  var onBuildManifest = new Promise(function (resolve) {
    // Mandatory because this is not concurrent safe:
    var cb = self.__BUILD_MANIFEST_CB;

    self.__BUILD_MANIFEST_CB = function () {
      resolve(self.__BUILD_MANIFEST);
      cb && cb();
    };
  });
  return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));
}

function getFilesForRoute(assetPrefix, route) {
  if (true) {
    return Promise.resolve({
      scripts: [assetPrefix + 'https://cdn.statically.io/gh/HiltonWS/hiltonws.github.io/master/smile/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute["default"])(route, '.js'))],
      // Styles are handled by `style-loader` in development:
      css: []
    });
  }

  return getClientBuildManifest().then(function (manifest) {
    if (!(route in manifest)) {
      throw markAssetError(new Error("Failed to lookup route: ".concat(route)));
    }

    var allFiles = manifest[route].map(function (entry) {
      return assetPrefix + 'https://cdn.statically.io/gh/HiltonWS/hiltonws.github.io/master/smile/' + encodeURI(entry);
    });
    return {
      scripts: allFiles.filter(function (v) {
        return v.endsWith('.js');
      }),
      css: allFiles.filter(function (v) {
        return v.endsWith('.css');
      })
    };
  });
}

function createRouteLoader(assetPrefix) {
  var entrypoints = new Map();
  var loadedScripts = new Map();
  var styleSheets = new Map();
  var routes = new Map();

  function maybeExecuteScript(src) {
    var prom = loadedScripts.get(src);

    if (prom) {
      return prom;
    } // Skip executing script if it's already in the DOM:


    if (document.querySelector("script[src^=\"".concat(src, "\"]"))) {
      return Promise.resolve();
    }

    loadedScripts.set(src, prom = appendScript(src));
    return prom;
  }

  function fetchStyleSheet(href) {
    var prom = styleSheets.get(href);

    if (prom) {
      return prom;
    }

    styleSheets.set(href, prom = fetch(href).then(function (res) {
      if (!res.ok) {
        throw new Error("Failed to load stylesheet: ".concat(href));
      }

      return res.text().then(function (text) {
        return {
          href: href,
          content: text
        };
      });
    })["catch"](function (err) {
      throw markAssetError(err);
    }));
    return prom;
  }

  return {
    whenEntrypoint: function whenEntrypoint(route) {
      return withFuture(route, entrypoints);
    },
    onEntrypoint: function onEntrypoint(route, execute) {
      Promise.resolve(execute).then(function (fn) {
        return fn();
      }).then(function (exports) {
        return {
          component: exports && exports["default"] || exports,
          exports: exports
        };
      }, function (err) {
        return {
          error: err
        };
      }).then(function (input) {
        var old = entrypoints.get(route);
        entrypoints.set(route, input);
        if (old && 'resolve' in old) old.resolve(input);
      });
    },
    loadRoute: function loadRoute(route) {
      var _this = this;

      return withFuture(route, routes, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _yield$getFilesForRou, scripts, css, _yield$Promise$all, _yield$Promise$all2, styles, entrypoint, res;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return getFilesForRoute(assetPrefix, route);

              case 3:
                _yield$getFilesForRou = _context.sent;
                scripts = _yield$getFilesForRou.scripts;
                css = _yield$getFilesForRou.css;
                _context.next = 8;
                return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);

              case 8:
                _yield$Promise$all = _context.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                styles = _yield$Promise$all2[1];
                _context.next = 13;
                return resolvePromiseWithTimeout(_this.whenEntrypoint(route), MS_MAX_IDLE_DELAY, markAssetError(new Error("Route did not complete loading: ".concat(route))));

              case 13:
                entrypoint = _context.sent;
                res = Object.assign({
                  styles: styles
                }, entrypoint);
                return _context.abrupt("return", 'error' in entrypoint ? entrypoint : res);

              case 18:
                _context.prev = 18;
                _context.t0 = _context["catch"](0);
                return _context.abrupt("return", {
                  error: _context.t0
                });

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 18]]);
      })));
    },
    prefetch: function prefetch(route) {
      var _this2 = this;

      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
      // License: Apache 2.0
      var cn;

      if (cn = navigator.connection) {
        // Don't prefetch if using 2G or if Save-Data is enabled.
        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
      }

      return getFilesForRoute(assetPrefix, route).then(function (output) {
        return Promise.all(canPrefetch ? output.scripts.map(function (script) {
          return prefetchViaDom(script, 'script');
        }) : []);
      }).then(function () {
        (0, _requestIdleCallback.requestIdleCallback)(function () {
          return _this2.loadRoute(route);
        });
      })["catch"]( // swallow prefetch errors
      function () {});
    }
  };
}

var _default = createRouteLoader;
exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _construct = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/construct */ "./node_modules/@babel/runtime/helpers/construct.js");

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2["default"];
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter["default"];
/* global window */

var singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }
}; // Create public properties and methods of the router in the singletonRouter

var urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale', 'isReady', 'isPreview', 'isLocaleDomain'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get: function get() {
    return _router2["default"].events;
  }
});
urlPropertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get: function get() {
      var router = getRouter();
      return router[field];
    }
  });
});
coreMethodFields.forEach(function (field) {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = function () {
    var router = getRouter();
    return router[field].apply(router, arguments);
  };
});
routerEvents.forEach(function (event) {
  singletonRouter.ready(function () {
    _router2["default"].events.on(event, function () {
      var eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      var _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField].apply(_singletonRouter, arguments);
        } catch (err) {
          console.error("Error when running the Router event: ".concat(eventField));
          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports["default"] = _default;

function useRouter() {
  _s();

  return _react["default"].useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var createRouter = function createRouter() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  singletonRouter.router = _construct(_router2["default"], args);
  singletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  var _router = router;
  var instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign(Array.isArray(_router[property]) ? [] : {}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2["default"].events;
  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return _router[field].apply(_router, arguments);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.useIntersection = useIntersection;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js");

var hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';

function useIntersection(_ref) {
  var rootMargin = _ref.rootMargin,
      disabled = _ref.disabled;
  var isDisabled = disabled || !hasIntersectionObserver;
  var unobserve = (0, _react.useRef)();

  var _ref2 = (0, _react.useState)(false),
      _ref3 = _slicedToArray(_ref2, 2),
      visible = _ref3[0],
      setVisible = _ref3[1];

  var setRef = (0, _react.useCallback)(function (el) {
    if (unobserve.current) {
      unobserve.current();
      unobserve.current = undefined;
    }

    if (isDisabled || visible) return;

    if (el && el.tagName) {
      unobserve.current = observe(el, function (isVisible) {
        return isVisible && setVisible(isVisible);
      }, {
        rootMargin: rootMargin
      });
    }
  }, [isDisabled, rootMargin, visible]);
  (0, _react.useEffect)(function () {
    if (!hasIntersectionObserver) {
      if (!visible) {
        var idleCallback = (0, _requestIdleCallback.requestIdleCallback)(function () {
          return setVisible(true);
        });
        return function () {
          return (0, _requestIdleCallback.cancelIdleCallback)(idleCallback);
        };
      }
    }
  }, [visible]);
  return [setRef, visible];
}

function observe(element, callback, options) {
  var _createObserver = createObserver(options),
      id = _createObserver.id,
      observer = _createObserver.observer,
      elements = _createObserver.elements;

  elements.set(element, callback);
  observer.observe(element);
  return function unobserve() {
    elements["delete"](element);
    observer.unobserve(element); // Destroy observer when there's nothing left to watch:

    if (elements.size === 0) {
      observer.disconnect();
      observers["delete"](id);
    }
  };
}

var observers = new Map();

function createObserver(options) {
  var id = options.rootMargin || '';
  var instance = observers.get(id);

  if (instance) {
    return instance;
  }

  var elements = new Map();
  var observer = new IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      var callback = elements.get(entry.target);
      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;

      if (callback && isVisible) {
        callback(isVisible);
      }
    });
  }, options);
  observers.set(id, instance = {
    id: id,
    observer: observer,
    elements: elements
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/api.js":
/*!***********************************!*\
  !*** (webpack)/css-loader/api.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports=function(){"use strict";var n={762:function(n){n.exports=function(n){var t=[];t.toString=function toString(){return this.map(function(t){var r=cssWithMappingToString(t,n);if(t[2]){return"@media ".concat(t[2]," {").concat(r,"}")}return r}).join("")};t.i=function(n,r,o){if(typeof n==="string"){n=[[null,n,""]]}var e={};if(o){for(var a=0;a<this.length;a++){var c=this[a][0];if(c!=null){e[c]=true}}}for(var i=0;i<n.length;i++){var u=[].concat(n[i]);if(o&&e[u[0]]){continue}if(r){if(!u[2]){u[2]=r}else{u[2]="".concat(r," and ").concat(u[2])}}t.push(u)}};return t};function cssWithMappingToString(n,t){var r=n[1]||"";var o=n[3];if(!o){return r}if(t&&typeof btoa==="function"){var e=toComment(o);var a=o.sources.map(function(n){return"/*# sourceURL=".concat(o.sourceRoot||"").concat(n," */")});return[r].concat(a).concat([e]).join("\n")}return[r].join("\n")}function toComment(n){var t=btoa(unescape(encodeURIComponent(JSON.stringify(n))));var r="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(t);return"/*# ".concat(r," */")}}};var t={};function __nccwpck_require__(r){if(t[r]){return t[r].exports}var o=t[r]={exports:{}};var e=true;try{n[r](o,o.exports,__nccwpck_require__);e=false}finally{if(e)delete t[r]}return o.exports}__nccwpck_require__.ab=__dirname+"/";return __nccwpck_require__(762)}();
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./components/layout.module.css":
/*!**************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./components/layout.module.css ***!
  \**************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".layout_container__2t4v2 {\r\n    max-width: 36rem;\r\n    padding: 0 1rem;\r\n    margin: 3rem auto 6rem;\r\n}\r\n\r\n.layout_header__2rhWq {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n}\r\n\r\n.layout_backTohome__10oyl {\r\n    margin: 3rem 0 0;\r\n}", "",{"version":3,"sources":["webpack://components/layout.module.css"],"names":[],"mappings":"AAAA;IACI,gBAAgB;IAChB,eAAe;IACf,sBAAsB;AAC1B;;AAEA;IACI,aAAa;IACb,sBAAsB;IACtB,mBAAmB;AACvB;;AAEA;IACI,gBAAgB;AACpB","sourcesContent":[".container {\r\n    max-width: 36rem;\r\n    padding: 0 1rem;\r\n    margin: 3rem auto 6rem;\r\n}\r\n\r\n.header {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n}\r\n\r\n.backTohome {\r\n    margin: 3rem 0 0;\r\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"container": "layout_container__2t4v2",
	"header": "layout_header__2rhWq",
	"backTohome": "layout_backTohome__10oyl"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/utils.module.css":
/*!*********************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-2-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-2-2!./styles/utils.module.css ***!
  \*********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".utils_heading2Xl__1I65m {\r\n    font-size: 2.5rem;\r\n    line-height: 1.2;\r\n    font-weight: 800;\r\n    letter-spacing: -0.05rem;\r\n    margin: 1rem 0;\r\n  }\r\n  \r\n  .utils_headingXl__1XecN {\r\n    font-size: 2rem;\r\n    line-height: 1.3;\r\n    font-weight: 800;\r\n    letter-spacing: -0.05rem;\r\n    margin: 1rem 0;\r\n  }\r\n  \r\n  .utils_headingLg__de7p0 {\r\n    font-size: 1.5rem;\r\n    line-height: 1.4;\r\n    margin: 1rem 0;\r\n  }\r\n  \r\n  .utils_headingMd__3de6G {\r\n    font-size: 1.2rem;\r\n    line-height: 1.5;\r\n  }\r\n  \r\n  .utils_borderCircle__13qdJ {\r\n    border-radius: 9999px;\r\n  }\r\n  \r\n  .utils_colorInherit__3Gudf {\r\n    color: inherit;\r\n  }\r\n  \r\n  .utils_padding1px__oCny8 {\r\n    padding-top: 1px;\r\n  }\r\n  \r\n  .utils_list__S7_pe {\r\n    list-style: none;\r\n    padding: 0;\r\n    margin: 0;\r\n  }\r\n  \r\n  .utils_listItem__2eJpJ {\r\n    margin: 0 0 1.25rem;\r\n  }\r\n  \r\n  .utils_lightText__12Ckm {\r\n    color: #666;\r\n  }\r\n\r\n  .utils_canvas__1SWLi {\r\n    position: absolute;\r\n    top: 100px;\r\n    z-index: 10;\r\n    margin: 3rem auto 6rem;\r\n    background-color: white;\r\n  }", "",{"version":3,"sources":["webpack://styles/utils.module.css"],"names":[],"mappings":"AAAA;IACI,iBAAiB;IACjB,gBAAgB;IAChB,gBAAgB;IAChB,wBAAwB;IACxB,cAAc;EAChB;;EAEA;IACE,eAAe;IACf,gBAAgB;IAChB,gBAAgB;IAChB,wBAAwB;IACxB,cAAc;EAChB;;EAEA;IACE,iBAAiB;IACjB,gBAAgB;IAChB,cAAc;EAChB;;EAEA;IACE,iBAAiB;IACjB,gBAAgB;EAClB;;EAEA;IACE,qBAAqB;EACvB;;EAEA;IACE,cAAc;EAChB;;EAEA;IACE,gBAAgB;EAClB;;EAEA;IACE,gBAAgB;IAChB,UAAU;IACV,SAAS;EACX;;EAEA;IACE,mBAAmB;EACrB;;EAEA;IACE,WAAW;EACb;;EAEA;IACE,kBAAkB;IAClB,UAAU;IACV,WAAW;IACX,sBAAsB;IACtB,uBAAuB;EACzB","sourcesContent":[".heading2Xl {\r\n    font-size: 2.5rem;\r\n    line-height: 1.2;\r\n    font-weight: 800;\r\n    letter-spacing: -0.05rem;\r\n    margin: 1rem 0;\r\n  }\r\n  \r\n  .headingXl {\r\n    font-size: 2rem;\r\n    line-height: 1.3;\r\n    font-weight: 800;\r\n    letter-spacing: -0.05rem;\r\n    margin: 1rem 0;\r\n  }\r\n  \r\n  .headingLg {\r\n    font-size: 1.5rem;\r\n    line-height: 1.4;\r\n    margin: 1rem 0;\r\n  }\r\n  \r\n  .headingMd {\r\n    font-size: 1.2rem;\r\n    line-height: 1.5;\r\n  }\r\n  \r\n  .borderCircle {\r\n    border-radius: 9999px;\r\n  }\r\n  \r\n  .colorInherit {\r\n    color: inherit;\r\n  }\r\n  \r\n  .padding1px {\r\n    padding-top: 1px;\r\n  }\r\n  \r\n  .list {\r\n    list-style: none;\r\n    padding: 0;\r\n    margin: 0;\r\n  }\r\n  \r\n  .listItem {\r\n    margin: 0 0 1.25rem;\r\n  }\r\n  \r\n  .lightText {\r\n    color: #666;\r\n  }\r\n\r\n  .canvas {\r\n    position: absolute;\r\n    top: 100px;\r\n    z-index: 10;\r\n    margin: 3rem auto 6rem;\r\n    background-color: white;\r\n  }"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"heading2Xl": "utils_heading2Xl__1I65m",
	"headingXl": "utils_headingXl__1XecN",
	"headingLg": "utils_headingLg__de7p0",
	"headingMd": "utils_headingMd__3de6G",
	"borderCircle": "utils_borderCircle__13qdJ",
	"colorInherit": "utils_colorInherit__3Gudf",
	"padding1px": "utils_padding1px__oCny8",
	"list": "utils_list__S7_pe",
	"listItem": "utils_listItem__2eJpJ",
	"lightText": "utils_lightText__12Ckm",
	"canvas": "utils_canvas__1SWLi"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/next/dist/compiled/webpack/global.js":
/*!***********************************!*\
  !*** (webpack)/webpack/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports =
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 149:
/***/ (function(module) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	__nccwpck_require__.ab = __dirname + "/";/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __nccwpck_require__(149);
/******/ })()
;
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/next/dist/compiled/webpack/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/webpack/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports =
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 931:
/***/ (function(module) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	__nccwpck_require__.ab = __dirname + "/";/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __nccwpck_require__(931);
/******/ })()
;
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/next/dist/compiled/webpack/module.js":
/*!***********************************!*\
  !*** (webpack)/webpack/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports =
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 880:
/***/ (function(module) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	__nccwpck_require__.ab = __dirname + "/";/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __nccwpck_require__(880);
/******/ })()
;
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp-context.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp-context.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.AmpStateContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var AmpStateContext = /*#__PURE__*/_react["default"].createContext({});

exports.AmpStateContext = AmpStateContext;

if (true) {
  AmpStateContext.displayName = 'AmpStateContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _s = $RefreshSig$();

exports.__esModule = true;
exports.isInAmpMode = isInAmpMode;
exports.useAmp = useAmp;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function isInAmpMode() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$ampFirst = _ref.ampFirst,
      ampFirst = _ref$ampFirst === void 0 ? false : _ref$ampFirst,
      _ref$hybrid = _ref.hybrid,
      hybrid = _ref$hybrid === void 0 ? false : _ref$hybrid,
      _ref$hasQuery = _ref.hasQuery,
      hasQuery = _ref$hasQuery === void 0 ? false : _ref$hasQuery;

  return ampFirst || hybrid && hasQuery;
}

function useAmp() {
  _s();

  // Don't assign the context value to a variable to save bytes
  return isInAmpMode(_react["default"].useContext(_ampContext.AmpStateContext));
}

_s(useAmp, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.HeadManagerContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var HeadManagerContext = /*#__PURE__*/_react["default"].createContext({});

exports.HeadManagerContext = HeadManagerContext;

if (true) {
  HeadManagerContext.displayName = 'HeadManagerContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.defaultHead = defaultHead;
exports["default"] = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _sideEffect = _interopRequireDefault(__webpack_require__(/*! ./side-effect */ "./node_modules/next/dist/next-server/lib/side-effect.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

var _headManagerContext = __webpack_require__(/*! ./head-manager-context */ "./node_modules/next/dist/next-server/lib/head-manager-context.js");

var _amp = __webpack_require__(/*! ./amp */ "./node_modules/next/dist/next-server/lib/amp.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function defaultHead() {
  var inAmpMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var head = [/*#__PURE__*/_react["default"].createElement("meta", {
    charSet: "utf-8"
  })];

  if (!inAmpMode) {
    head.push( /*#__PURE__*/_react["default"].createElement("meta", {
      name: "viewport",
      content: "width=device-width"
    }));
  }

  return head;
}

function onlyReactElement(list, child) {
  // React children can be "string" or "number" in this case we ignore them for backwards compat
  if (typeof child === 'string' || typeof child === 'number') {
    return list;
  } // Adds support for React.Fragment


  if (child.type === _react["default"].Fragment) {
    return list.concat(_react["default"].Children.toArray(child.props.children).reduce(function (fragmentList, fragmentChild) {
      if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
        return fragmentList;
      }

      return fragmentList.concat(fragmentChild);
    }, []));
  }

  return list.concat(child);
}

var METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp'];
/*
returns a function for filtering head child elements
which shouldn't be duplicated, like <title/>
Also adds support for deduplicated `key` properties
*/

function unique() {
  var keys = new Set();
  var tags = new Set();
  var metaTypes = new Set();
  var metaCategories = {};
  return function (h) {
    var isUnique = true;
    var hasKey = false;

    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
      hasKey = true;
      var key = h.key.slice(h.key.indexOf('$') + 1);

      if (keys.has(key)) {
        isUnique = false;
      } else {
        keys.add(key);
      }
    } // eslint-disable-next-line default-case


    switch (h.type) {
      case 'title':
      case 'base':
        if (tags.has(h.type)) {
          isUnique = false;
        } else {
          tags.add(h.type);
        }

        break;

      case 'meta':
        for (var i = 0, len = METATYPES.length; i < len; i++) {
          var metatype = METATYPES[i];
          if (!h.props.hasOwnProperty(metatype)) continue;

          if (metatype === 'charSet') {
            if (metaTypes.has(metatype)) {
              isUnique = false;
            } else {
              metaTypes.add(metatype);
            }
          } else {
            var category = h.props[metatype];
            var categories = metaCategories[metatype] || new Set();

            if ((metatype !== 'name' || !hasKey) && categories.has(category)) {
              isUnique = false;
            } else {
              categories.add(category);
              metaCategories[metatype] = categories;
            }
          }
        }

        break;
    }

    return isUnique;
  };
}
/**
*
* @param headElements List of multiple <Head> instances
*/


function reduceComponents(headElements, props) {
  return headElements.reduce(function (list, headElement) {
    var headElementChildren = _react["default"].Children.toArray(headElement.props.children);

    return list.concat(headElementChildren);
  }, []).reduce(onlyReactElement, []).reverse().concat(defaultHead(props.inAmpMode)).filter(unique()).reverse().map(function (c, i) {
    var key = c.key || i;

    if (false) { var newProps; }

    return /*#__PURE__*/_react["default"].cloneElement(c, {
      key: key
    });
  });
}
/**
* This component injects elements to `<head>` of your page.
* To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
*/


function Head(_ref) {
  var children = _ref.children;
  var ampState = (0, _react.useContext)(_ampContext.AmpStateContext);
  var headManager = (0, _react.useContext)(_headManagerContext.HeadManagerContext);
  return /*#__PURE__*/_react["default"].createElement(_sideEffect["default"], {
    reduceComponentsToState: reduceComponents,
    headManager: headManager,
    inAmpMode: (0, _amp.isInAmpMode)(ampState)
  }, children);
} // TODO: Remove in the next major release


_c = Head;

Head.rewind = function () {};

var _default = Head;
exports["default"] = _default;

var _c;

$RefreshReg$(_c, "Head");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.normalizeLocalePath = normalizeLocalePath;

function normalizeLocalePath(pathname, locales) {
  var detectedLocale; // first item will be empty string from splitting at first char

  var pathnameParts = pathname.split('/');
  (locales || []).some(function (locale) {
    if (pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
      detectedLocale = locale;
      pathnameParts.splice(1, 1);
      pathname = pathnameParts.join('/') || '/';
      return true;
    }

    return false;
  });
  return {
    pathname: pathname,
    detectedLocale: detectedLocale
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var RouterContext = /*#__PURE__*/_react["default"].createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _classCallCheck = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _slicedToArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.getDomainLocale = getDomainLocale;
exports.addLocale = addLocale;
exports.delLocale = delLocale;
exports.hasBasePath = hasBasePath;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports.isLocalURL = isLocalURL;
exports.interpolateAs = interpolateAs;
exports.resolveHref = resolveHref;
exports["default"] = void 0;

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ "./node_modules/next/dist/client/route-loader.js");

var _denormalizePagePath = __webpack_require__(/*! ../../server/denormalize-page-path */ "./node_modules/next/dist/next-server/server/denormalize-page-path.js");

var _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var _querystring = __webpack_require__(/*! ./utils/querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites-noop.js"));

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* global __NEXT_DATA__ */
// tslint:disable:no-console


var detectDomainLocale;

if (false) {}

var basePath =  false || '';

function buildCancellationError() {
  return Object.assign(new Error('Route Cancelled'), {
    cancelled: true
  });
}

function addPathPrefix(path, prefix) {
  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : "".concat(prefix).concat(pathNoQueryHash(path) === '/' ? path.substring(1) : path) : path;
}

function getDomainLocale(path, locale, locales, domainLocales) {
  if (false) { var detectedDomain; }

  return false;
}

function addLocale(path, locale, defaultLocale) {
  if (false) {}

  return path;
}

function delLocale(path, locale) {
  if (false) {}

  return path;
}

function pathNoQueryHash(path) {
  var queryIndex = path.indexOf('?');
  var hashIndex = path.indexOf('#');

  if (queryIndex > -1 || hashIndex > -1) {
    path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);
  }

  return path;
}

function hasBasePath(path) {
  path = pathNoQueryHash(path);
  return path === basePath || path.startsWith(basePath + '/');
}

function addBasePath(path) {
  // we only add the basepath on relative urls
  return addPathPrefix(path, basePath);
}

function delBasePath(path) {
  path = path.slice(basePath.length);
  if (!path.startsWith('/')) path = "/".concat(path);
  return path;
}
/**
* Detects whether a given url is routable by the Next.js router (browser only).
*/


function isLocalURL(url) {
  // prevent a hydration mismatch on href for url with anchor refs
  if (url.startsWith('/') || url.startsWith('#')) return true;

  try {
    // absolute urls can be local if they are on the same origin
    var locationOrigin = (0, _utils.getLocationOrigin)();
    var resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}

function interpolateAs(route, asPathname, query) {
  var interpolatedRoute = '';
  var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
  var dynamicGroups = dynamicRegex.groups;
  var dynamicMatches = // Try to match the dynamic route against the asPath
  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
  // TODO: should this take priority; also need to change in the router.
  query;
  interpolatedRoute = route;
  var params = Object.keys(dynamicGroups);

  if (!params.every(function (param) {
    var value = dynamicMatches[param] || '';
    var _dynamicGroups$param = dynamicGroups[param],
        repeat = _dynamicGroups$param.repeat,
        optional = _dynamicGroups$param.optional; // support single-level catch-all
    // TODO: more robust handling for user-error (passing `/`)

    var replaced = "[".concat(repeat ? '...' : '').concat(param, "]");

    if (optional) {
      replaced = "".concat(!value ? '/' : '', "[").concat(replaced, "]");
    }

    if (repeat && !Array.isArray(value)) value = [value];
    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present
    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just
    // path delimiter escaped since they are being inserted
    // into the URL and we expect URL encoded segments
    // when parsing dynamic route params
    function (segment) {
      return encodeURIComponent(segment);
    }).join('/') : encodeURIComponent(value)) || '/');
  })) {
    interpolatedRoute = ''; // did not satisfy all requirements
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
  }

  return {
    params: params,
    result: interpolatedRoute
  };
}

function omitParmsFromQuery(query, params) {
  var filteredQuery = {};
  Object.keys(query).forEach(function (key) {
    if (!params.includes(key)) {
      filteredQuery[key] = query[key];
    }
  });
  return filteredQuery;
}
/**
* Resolves a given hyperlink with a certain router state (basePath not included).
* Preserves absolute urls.
*/


function resolveHref(currentPath, href, resolveAs) {
  // we use a dummy base url for relative urls
  var base = new URL(currentPath, 'http://n');
  var urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href); // Return because it cannot be routed by the Next.js router

  if (!isLocalURL(urlAsString)) {
    return resolveAs ? [urlAsString] : urlAsString;
  }

  try {
    var finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);
    var interpolatedAs = '';

    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
      var query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);

      var _interpolateAs = interpolateAs(finalUrl.pathname, finalUrl.pathname, query),
          result = _interpolateAs.result,
          params = _interpolateAs.params;

      if (result) {
        interpolatedAs = (0, _utils.formatWithValidation)({
          pathname: result,
          hash: finalUrl.hash,
          query: omitParmsFromQuery(query, params)
        });
      }
    } // if the origin didn't change, it means we received a relative href


    var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
  } catch (_) {
    return resolveAs ? [urlAsString] : urlAsString;
  }
}

function stripOrigin(url) {
  var origin = (0, _utils.getLocationOrigin)();
  return url.startsWith(origin) ? url.substring(origin.length) : url;
}

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  var _resolveHref = resolveHref(router.pathname, url, true),
      _resolveHref2 = _slicedToArray(_resolveHref, 2),
      resolvedHref = _resolveHref2[0],
      resolvedAs = _resolveHref2[1];

  var origin = (0, _utils.getLocationOrigin)();
  var hrefHadOrigin = resolvedHref.startsWith(origin);
  var asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);
  resolvedHref = stripOrigin(resolvedHref);
  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;
  var preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);
  var preparedAs = as ? stripOrigin(resolveHref(router.pathname, as)) : resolvedAs || resolvedHref;
  return {
    url: preparedUrl,
    as: asHadOrigin ? preparedAs : addBasePath(preparedAs)
  };
}

function resolveDynamicRoute(parsedHref, pages) {
  var applyBasePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var pathname = parsedHref.pathname;
  var cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(applyBasePath ? delBasePath(pathname) : pathname));

  if (cleanPathname === '/404' || cleanPathname === '/_error') {
    return parsedHref;
  } // handle resolving href for dynamic routes


  if (!pages.includes(cleanPathname)) {
    // eslint-disable-next-line array-callback-return
    pages.some(function (page) {
      if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {
        parsedHref.pathname = applyBasePath ? addBasePath(page) : page;
        return true;
      }
    });
  }

  parsedHref.pathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)(parsedHref.pathname);
  return parsedHref;
}

var manualScrollRestoration =  false && false;
var SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Next.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` wont send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: 'same-origin'
  }).then(function (res) {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      if (res.status === 404) {
        return res.json().then(function (data) {
          if (data.notFound) {
            return {
              notFound: SSG_DATA_NOT_FOUND
            };
          }

          throw new Error("Failed to load static props");
        });
      }

      throw new Error("Failed to load static props");
    }

    return res.json();
  });
}

function fetchNextData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1)["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      (0, _routeLoader.markAssetError)(err);
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  // In-flight Server Data Requests, for deduping
  function Router(_pathname, _query, _as, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback,
        locale = _ref.locale,
        locales = _ref.locales,
        defaultLocale = _ref.defaultLocale,
        domainLocales = _ref.domainLocales,
        isPreview = _ref.isPreview;

    _classCallCheck(this, Router);

    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sdr = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;
    this._inFlightRoute = void 0;
    this._shallow = void 0;
    this.locale = void 0;
    this.locales = void 0;
    this.defaultLocale = void 0;
    this.domainLocales = void 0;
    this.isReady = void 0;
    this.isPreview = void 0;
    this.isLocaleDomain = void 0;
    this._idx = 0;

    this.onPopState = function (e) {
      var state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var _pathname2 = _this.pathname,
            query = _this.query;

        _this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname2),
          query: query
        }), (0, _utils.getURL)());

        return;
      }

      if (!state.__N) {
        return;
      }

      var forcedScroll;
      var url = state.url,
          as = state.as,
          options = state.options,
          idx = state.idx;

      if (false) { var v; }

      _this._idx = idx;

      var _ref2 = (0, _parseRelativeUrl.parseRelativeUrl)(url),
          pathname = _ref2.pathname; // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (_this.isSsr && as === _this.asPath && pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(state)) {
        return;
      }

      _this.change('replaceState', url, as, Object.assign({}, options, {
        shallow: options.shallow && _this._shallow,
        locale: options.locale || _this.defaultLocale
      }), forcedScroll);
    }; // represents the current component key


    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component: Component,
        initial: true,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App,
      styleSheets: [
        /* /_app does not need its stylesheets managed */
      ]
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    var autoExportDynamic = (0, _isDynamic.isDynamicRoute)(_pathname) && self.__NEXT_DATA__.autoExport;

    this.asPath = autoExportDynamic ? _pathname : _as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;
    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || !autoExportDynamic && !self.location.search);
    this.isPreview = !!isPreview;
    this.isLocaleDomain = false;

    if (false) {}

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname),
          query: _query
        }), (0, _utils.getURL)(), {
          locale: locale
        });
      }

      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available
      // otherwise fallback to browser's default handling

      if (false) {}
    }
  }

  _createClass(Router, [{
    key: "reload",
    value: function reload() {
      window.location.reload();
    }
    /**
    * Go back in history
    */

  }, {
    key: "back",
    value: function back() {
      window.history.back();
    }
    /**
    * Performs a `pushState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "push",
    value: function push(url, as) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (false) {}

      ;

      var _prepareUrlAs = prepareUrlAs(this, url, as);

      url = _prepareUrlAs.url;
      as = _prepareUrlAs.as;
      return this.change('pushState', url, as, options);
    }
    /**
    * Performs a `replaceState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "replace",
    value: function replace(url, as) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      ;

      var _prepareUrlAs2 = prepareUrlAs(this, url, as);

      url = _prepareUrlAs2.url;
      as = _prepareUrlAs2.as;
      return this.change('replaceState', url, as, options);
    }
  }, {
    key: "change",
    value: function () {
      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(method, url, as, options, forcedScroll) {
        var _options$scroll, localeChange, parsedAs, localePathResult, didNavigate, _this$locales, detectedDomain, asNoBasePath, _options$shallow, shallow, routeProps, cleanedAs, parsed, _parsed, pathname, query, pages, rewrites, _yield, route, resolvedAs, rewritesResult, _parsedAs, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, _self$__NEXT_DATA__$p, _self$__NEXT_DATA__$p2, routeInfo, _routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, notFoundRoute, appComp, isValidShallowRoute;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (isLocalURL(url)) {
                  _context.next = 3;
                  break;
                }

                window.location.href = url;
                return _context.abrupt("return", false);

              case 3:
                // for static pages with query params in the URL we delay
                // marking the router ready until after the query is updated
                if (options._h) {
                  this.isReady = true;
                } // Default to scroll reset behavior unless explicitly specified to be
                // `false`! This makes the behavior between using `Router#push` and a
                // `<Link />` consistent.


                options.scroll = !!((_options$scroll = options.scroll) != null ? _options$scroll : true);
                localeChange = options.locale !== this.locale;

                if (true) {
                  _context.next = 18;
                  break;
                }

                this.locale = options.locale === false ? this.defaultLocale : options.locale || this.locale;

                if (typeof options.locale === 'undefined') {
                  options.locale = this.locale;
                }

                parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(hasBasePath(as) ? delBasePath(as) : as);
                localePathResult = (0, _normalizeLocalePath.normalizeLocalePath)(parsedAs.pathname, this.locales);

                if (localePathResult.detectedLocale) {
                  this.locale = localePathResult.detectedLocale;
                  parsedAs.pathname = addBasePath(parsedAs.pathname);
                  as = (0, _utils.formatWithValidation)(parsedAs);
                  url = addBasePath((0, _normalizeLocalePath.normalizeLocalePath)(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);
                }

                didNavigate = false; // we need to wrap this in the env check again since regenerator runtime
                // moves this on its own due to the return

                if (false) {}

                detectedDomain = detectDomainLocale(this.domainLocales, undefined, this.locale); // we need to wrap this in the env check again since regenerator runtime
                // moves this on its own due to the return

                if (false) {}

                if (!didNavigate) {
                  _context.next = 18;
                  break;
                }

                return _context.abrupt("return", new Promise(function () {}));

              case 18:
                if (!options._h) {
                  this.isSsr = false;
                } // marking route changes as a navigation start entry


                if (_utils.ST) {
                  performance.mark('routeChange');
                }

                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow;
                routeProps = {
                  shallow: shallow
                };

                if (this._inFlightRoute) {
                  this.abortComponentLoad(this._inFlightRoute, routeProps);
                }

                as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));
                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);
                this._inFlightRoute = as; // If the url change is only related to a hash change
                // We should not proceed. We should only change the state.
                // WARNING: `_h` is an internal option for handing Next.js client-side
                // hydration. Your app should _never_ use this property. It may change at
                // any time without notice.

                if (!(!options._h && this.onlyAHashChange(cleanedAs))) {
                  _context.next = 34;
                  break;
                }

                this.asPath = cleanedAs;
                Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?

                this.changeState(method, url, as, options);
                this.scrollToHash(cleanedAs);
                this.notify(this.components[this.route], null);
                Router.events.emit('hashChangeComplete', as, routeProps);
                return _context.abrupt("return", true);

              case 34:
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                _parsed = parsed, pathname = _parsed.pathname, query = _parsed.query; // The build manifest needs to be loaded before auto-static dynamic pages
                // get their query parameters to allow ensuring they can be parsed properly
                // when rewritten to

                _context.prev = 36;
                _context.next = 39;
                return this.pageLoader.getPageList();

              case 39:
                pages = _context.sent;
                _context.next = 42;
                return (0, _routeLoader.getClientBuildManifest)();

              case 42:
                _yield = _context.sent;
                rewrites = _yield.__rewrites;
                _context.next = 50;
                break;

              case 46:
                _context.prev = 46;
                _context.t0 = _context["catch"](36);
                // If we fail to resolve the page list or client-build manifest, we must
                // do a server-side transition:
                window.location.href = as;
                return _context.abrupt("return", false);

              case 50:
                parsed = resolveDynamicRoute(parsed, pages);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                } // url and as should always be prefixed with basePath by this
                // point by either next/link or router.push/replace so strip the
                // basePath from the pathname to match the pages dir 1-to-1


                pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname; // If asked to change the current URL we should reload the current page
                // (not location.reload() but reload getInitialProps and other Next.js stuffs)
                // We also need to set the method = replaceState always
                // as this should not go into the history (That's how browsers work)
                // We should compare the new asPath to the current asPath, not the url

                if (!this.urlIsNew(cleanedAs) && !localeChange) {
                  method = 'replaceState';
                }

                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname); // we need to resolve the as value using rewrites for dynamic SSG
                // pages to allow building the data URL correctly

                resolvedAs = as;

                if (false) {}

                if (isLocalURL(as)) {
                  _context.next = 62;
                  break;
                }

                if (false) {}

                throw new Error("Invalid href: \"".concat(url, "\" and as: \"").concat(as, "\", received relative href and external as") + "\nSee more info: https://err.sh/next.js/invalid-relative-url-external-as");

              case 60:
                window.location.href = as;
                return _context.abrupt("return", false);

              case 62:
                resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);

                if (!(0, _isDynamic.isDynamicRoute)(route)) {
                  _context.next = 78;
                  break;
                }

                _parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);
                asPathname = _parsedAs.pathname;
                routeRegex = (0, _routeRegex.getRouteRegex)(route);
                routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);
                shouldInterpolate = route === asPathname;
                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};

                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {
                  _context.next = 77;
                  break;
                }

                missingParams = Object.keys(routeRegex.groups).filter(function (param) {
                  return !query[param];
                });

                if (!(missingParams.length > 0)) {
                  _context.next = 75;
                  break;
                }

                if (true) {
                  console.warn("".concat(shouldInterpolate ? "Interpolating href" : "Mismatching `as` and `href`", " failed to manually provide ") + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
                }

                throw new Error((shouldInterpolate ? "The provided `href` (".concat(url, ") value is missing query values (").concat(missingParams.join(', '), ") to be interpolated properly. ") : "The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ")) + "Read more: https://err.sh/vercel/next.js/".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));

              case 75:
                _context.next = 78;
                break;

              case 77:
                if (shouldInterpolate) {
                  as = (0, _utils.formatWithValidation)(Object.assign({}, _parsedAs, {
                    pathname: interpolatedAs.result,
                    query: omitParmsFromQuery(query, interpolatedAs.params)
                  }));
                } else {
                  // Merge params into `query`, overwriting any specified in search
                  Object.assign(query, routeMatch);
                }

              case 78:
                Router.events.emit('routeChangeStart', as, routeProps);
                _context.prev = 79;
                _context.next = 82;
                return this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps);

              case 82:
                routeInfo = _context.sent;
                _routeInfo = routeInfo, error = _routeInfo.error, props = _routeInfo.props, __N_SSG = _routeInfo.__N_SSG, __N_SSP = _routeInfo.__N_SSP; // handle redirect on client-transition

                if (!((__N_SSG || __N_SSP) && props)) {
                  _context.next = 109;
                  break;
                }

                if (!(props.pageProps && props.pageProps.__N_REDIRECT)) {
                  _context.next = 95;
                  break;
                }

                destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt
                // client-navigation if it is falling back to hard navigation if
                // it's not

                if (!destination.startsWith('/')) {
                  _context.next = 93;
                  break;
                }

                parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);
                resolveDynamicRoute(parsedHref, pages, false);

                if (!pages.includes(parsedHref.pathname)) {
                  _context.next = 93;
                  break;
                }

                _prepareUrlAs3 = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;
                return _context.abrupt("return", this.change(method, newUrl, newAs, options));

              case 93:
                window.location.href = destination;
                return _context.abrupt("return", new Promise(function () {}));

              case 95:
                this.isPreview = !!props.__N_PREVIEW; // handle SSG data 404

                if (!(props.notFound === SSG_DATA_NOT_FOUND)) {
                  _context.next = 109;
                  break;
                }

                _context.prev = 97;
                _context.next = 100;
                return this.fetchComponent('/404');

              case 100:
                notFoundRoute = '/404';
                _context.next = 106;
                break;

              case 103:
                _context.prev = 103;
                _context.t1 = _context["catch"](97);
                notFoundRoute = '/_error';

              case 106:
                _context.next = 108;
                return this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {
                  shallow: false
                });

              case 108:
                routeInfo = _context.sent;

              case 109:
                Router.events.emit('beforeHistoryChange', as, routeProps);
                this.changeState(method, url, as, options);

                if (true) {
                  appComp = this.components['/_app'].Component;
                  window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
                } // shallow routing is only allowed for same page URL changes.


                isValidShallowRoute = options.shallow && this.route === route;

                if (options._h && pathname === '/_error' && ((_self$__NEXT_DATA__$p = self.__NEXT_DATA__.props) == null ? void 0 : (_self$__NEXT_DATA__$p2 = _self$__NEXT_DATA__$p.pageProps) == null ? void 0 : _self$__NEXT_DATA__$p2.statusCode) === 500 && props != null && props.pageProps) {
                  // ensure statusCode is still correct for static 500 page
                  // when updating query information
                  props.pageProps.statusCode = 500;
                }

                _context.next = 116;
                return this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll || (isValidShallowRoute || !options.scroll ? null : {
                  x: 0,
                  y: 0
                }))["catch"](function (e) {
                  if (e.cancelled) error = error || e;else throw e;
                });

              case 116:
                if (!error) {
                  _context.next = 119;
                  break;
                }

                Router.events.emit('routeChangeError', error, cleanedAs, routeProps);
                throw error;

              case 119:
                if (false) {}

                Router.events.emit('routeChangeComplete', as, routeProps);
                return _context.abrupt("return", true);

              case 124:
                _context.prev = 124;
                _context.t2 = _context["catch"](79);

                if (!_context.t2.cancelled) {
                  _context.next = 128;
                  break;
                }

                return _context.abrupt("return", false);

              case 128:
                throw _context.t2;

              case 129:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[36, 46], [79, 124], [97, 103]]);
      }));

      function change(_x, _x2, _x3, _x4, _x5) {
        return _change.apply(this, arguments);
      }

      return change;
    }()
  }, {
    key: "changeState",
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (true) {
        if (typeof window.history === 'undefined') {
          console.error("Warning: window.history is not available.");
          return;
        }

        if (typeof window.history[method] === 'undefined') {
          console.error("Warning: window.history.".concat(method, " is not available"));
          return;
        }
      }

      if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
        this._shallow = options.shallow;
        window.history[method]({
          url: url,
          as: as,
          options: options,
          __N: true,
          idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1
        }, // Most browsers currently ignores this parameter, although they may use it in the future.
        // Passing the empty string here should be safe against future changes to the method.
        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
        '', as);
      }
    }
  }, {
    key: "handleRouteInfoError",
    value: function () {
      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(err, pathname, query, as, routeProps, loadErrorFail) {
        var Component, styleSheets, props, _yield$this$fetchComp, routeInfo;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!err.cancelled) {
                  _context2.next = 2;
                  break;
                }

                throw err;

              case 2:
                if (!((0, _routeLoader.isAssetError)(err) || loadErrorFail)) {
                  _context2.next = 6;
                  break;
                }

                Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons
                //  1. Page doesn't exists
                //  2. Page does exist in a different zone
                //  3. Internal error while loading the page
                // So, doing a hard reload is the proper way to deal with this.

                window.location.href = as; // Changing the URL doesn't block executing the current code path.
                // So let's throw a cancellation error stop the routing logic.

                throw buildCancellationError();

              case 6:
                _context2.prev = 6;

                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {
                  _context2.next = 14;
                  break;
                }

                ;
                _context2.next = 11;
                return this.fetchComponent('/_error');

              case 11:
                _yield$this$fetchComp = _context2.sent;
                Component = _yield$this$fetchComp.page;
                styleSheets = _yield$this$fetchComp.styleSheets;

              case 14:
                routeInfo = {
                  props: props,
                  Component: Component,
                  styleSheets: styleSheets,
                  err: err,
                  error: err
                };

                if (routeInfo.props) {
                  _context2.next = 26;
                  break;
                }

                _context2.prev = 16;
                _context2.next = 19;
                return this.getInitialProps(Component, {
                  err: err,
                  pathname: pathname,
                  query: query
                });

              case 19:
                routeInfo.props = _context2.sent;
                _context2.next = 26;
                break;

              case 22:
                _context2.prev = 22;
                _context2.t0 = _context2["catch"](16);
                console.error('Error in error page `getInitialProps`: ', _context2.t0);
                routeInfo.props = {};

              case 26:
                return _context2.abrupt("return", routeInfo);

              case 29:
                _context2.prev = 29;
                _context2.t1 = _context2["catch"](6);
                return _context2.abrupt("return", this.handleRouteInfoError(_context2.t1, pathname, query, as, routeProps, true));

              case 32:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 29], [16, 22]]);
      }));

      function handleRouteInfoError(_x6, _x7, _x8, _x9, _x10, _x11) {
        return _handleRouteInfoError.apply(this, arguments);
      }

      return handleRouteInfoError;
    }()
  }, {
    key: "getRouteInfo",
    value: function () {
      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(route, pathname, query, as, resolvedAs, routeProps) {
        var _this2 = this;

        var existingRouteInfo, cachedRouteInfo, routeInfo, Component, __N_SSG, __N_SSP, _require, isValidElementType, dataHref, props;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                existingRouteInfo = this.components[route];

                if (!(routeProps.shallow && existingRouteInfo && this.route === route)) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return", existingRouteInfo);

              case 4:
                cachedRouteInfo = existingRouteInfo && 'initial' in existingRouteInfo ? undefined : existingRouteInfo;

                if (!cachedRouteInfo) {
                  _context3.next = 9;
                  break;
                }

                _context3.t0 = cachedRouteInfo;
                _context3.next = 12;
                break;

              case 9:
                _context3.next = 11;
                return this.fetchComponent(route).then(function (res) {
                  return {
                    Component: res.page,
                    styleSheets: res.styleSheets,
                    __N_SSG: res.mod.__N_SSG,
                    __N_SSP: res.mod.__N_SSP
                  };
                });

              case 11:
                _context3.t0 = _context3.sent;

              case 12:
                routeInfo = _context3.t0;
                Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP;

                if (false) {}

                _require = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"), isValidElementType = _require.isValidElementType;

                if (isValidElementType(Component)) {
                  _context3.next = 18;
                  break;
                }

                throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));

              case 18:
                if (__N_SSG || __N_SSP) {
                  dataHref = this.pageLoader.getDataHref((0, _utils.formatWithValidation)({
                    pathname: pathname,
                    query: query
                  }), resolvedAs, __N_SSG, this.locale);
                }

                _context3.next = 21;
                return this._getData(function () {
                  return __N_SSG ? _this2._getStaticData(dataHref) : __N_SSP ? _this2._getServerData(dataHref) : _this2.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
                  {
                    pathname: pathname,
                    query: query,
                    asPath: as
                  });
                });

              case 21:
                props = _context3.sent;
                routeInfo.props = props;
                this.components[route] = routeInfo;
                return _context3.abrupt("return", routeInfo);

              case 27:
                _context3.prev = 27;
                _context3.t1 = _context3["catch"](0);
                return _context3.abrupt("return", this.handleRouteInfoError(_context3.t1, pathname, query, as, routeProps));

              case 30:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 27]]);
      }));

      function getRouteInfo(_x12, _x13, _x14, _x15, _x16, _x17) {
        return _getRouteInfo.apply(this, arguments);
      }

      return getRouteInfo;
    }()
  }, {
    key: "set",
    value: function set(route, pathname, query, as, data, resetScroll) {
      this.isFallback = false;
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      return this.notify(data, resetScroll);
    }
    /**
    * Callback to execute before replacing router state
    * @param cb callback to be executed
    */

  }, {
    key: "beforePopState",
    value: function beforePopState(cb) {
      this._bps = cb;
    }
  }, {
    key: "onlyAHashChange",
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
        return true;
      } // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      } // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.


      return oldHash !== newHash;
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value or `#top`
      // To mirror browsers


      if (hash === '' || hash === 'top') {
        window.scrollTo(0, 0);
        return;
      } // First we check if the element by id is found


      var idEl = document.getElementById(hash);

      if (idEl) {
        idEl.scrollIntoView();
        return;
      } // If there's no element with the id, we check the `name` property
      // To mirror browsers


      var nameEl = document.getElementsByName(hash)[0];

      if (nameEl) {
        nameEl.scrollIntoView();
      }
    }
  }, {
    key: "urlIsNew",
    value: function urlIsNew(asPath) {
      return this.asPath !== asPath;
    }
    /**
    * Prefetch page code, you may wait for the data during page rendering.
    * This feature only works in production!
    * @param url the href of prefetched page
    * @param asPath the as path of the prefetched page
    */

  }, {
    key: "prefetch",
    value: function () {
      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(url) {
        var _this3 = this;

        var asPath,
            options,
            parsed,
            _parsed2,
            pathname,
            parsedAs,
            localePathResult,
            pages,
            route,
            resolvedAs,
            rewrites,
            _yield2,
            rewritesResult,
            _args4 = arguments;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                asPath = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : url;
                options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                _parsed2 = parsed, pathname = _parsed2.pathname;

                if (false) {}

                _context4.next = 7;
                return this.pageLoader.getPageList();

              case 7:
                pages = _context4.sent;
                parsed = resolveDynamicRoute(parsed, pages, false);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                }

                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
                resolvedAs = asPath;

                if (true) {
                  _context4.next = 19;
                  break;
                }

                _context4.next = 15;
                return (0, _routeLoader.getClientBuildManifest)();

              case 15:
                _yield2 = _context4.sent;
                rewrites = _yield2.__rewrites;
                rewritesResult = (0, _resolveRewrites["default"])(addBasePath(addLocale(delBasePath(asPath), this.locale)), pages, rewrites, parsed.query, function (p) {
                  return resolveDynamicRoute({
                    pathname: p
                  }, pages).pathname;
                }, this.locales);

                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {
                  // if this directly matches a page we need to update the href to
                  // allow the correct page chunk to be loaded
                  route = rewritesResult.resolvedHref;
                  pathname = rewritesResult.resolvedHref;
                  parsed.pathname = pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                  resolvedAs = rewritesResult.asPath;
                }

              case 19:
                if (false) {}

                return _context4.abrupt("return");

              case 21:
                _context4.next = 23;
                return Promise.all([this.pageLoader._isSsg(url).then(function (isSsg) {
                  return isSsg ? _this3._getStaticData(_this3.pageLoader.getDataHref(url, resolvedAs, true, typeof options.locale !== 'undefined' ? options.locale : _this3.locale)) : false;
                }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);

              case 23:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function prefetch(_x18) {
        return _prefetch.apply(this, arguments);
      }

      return prefetch;
    }()
  }, {
    key: "fetchComponent",
    value: function () {
      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(route) {
        var cancelled, cancel, componentResult, error;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                cancelled = false;

                cancel = this.clc = function () {
                  cancelled = true;
                };

                _context5.next = 4;
                return this.pageLoader.loadPage(route);

              case 4:
                componentResult = _context5.sent;

                if (!cancelled) {
                  _context5.next = 9;
                  break;
                }

                error = new Error("Abort fetching component for route: \"".concat(route, "\""));
                error.cancelled = true;
                throw error;

              case 9:
                if (cancel === this.clc) {
                  this.clc = null;
                }

                return _context5.abrupt("return", componentResult);

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function fetchComponent(_x19) {
        return _fetchComponent.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: "_getData",
    value: function _getData(fn) {
      var _this4 = this;

      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      this.clc = cancel;
      return fn().then(function (data) {
        if (cancel === _this4.clc) {
          _this4.clc = null;
        }

        if (cancelled) {
          var err = new Error('Loading initial props cancelled');
          err.cancelled = true;
          throw err;
        }

        return data;
      });
    }
  }, {
    key: "_getStaticData",
    value: function _getStaticData(dataHref) {
      var _this5 = this;

      var _URL = new URL(dataHref, window.location.href),
          cacheKey = _URL.href;

      if (false) {}

      return fetchNextData(dataHref, this.isSsr).then(function (data) {
        _this5.sdc[cacheKey] = data;
        return data;
      });
    }
  }, {
    key: "_getServerData",
    value: function _getServerData(dataHref) {
      var _this6 = this;

      var _URL2 = new URL(dataHref, window.location.href),
          resourceKey = _URL2.href;

      if (this.sdr[resourceKey]) {
        return this.sdr[resourceKey];
      }

      return this.sdr[resourceKey] = fetchNextData(dataHref, this.isSsr).then(function (data) {
        delete _this6.sdr[resourceKey];
        return data;
      })["catch"](function (err) {
        delete _this6.sdr[resourceKey];
        throw err;
      });
    }
  }, {
    key: "getInitialProps",
    value: function getInitialProps(Component, ctx) {
      var App = this.components['/_app'].Component;

      var AppTree = this._wrapApp(App);

      ctx.AppTree = AppTree;
      return (0, _utils.loadGetInitialProps)(App, {
        AppTree: AppTree,
        Component: Component,
        router: this,
        ctx: ctx
      });
    }
  }, {
    key: "abortComponentLoad",
    value: function abortComponentLoad(as, routeProps) {
      if (this.clc) {
        Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);
        this.clc();
        this.clc = null;
      }
    }
  }, {
    key: "notify",
    value: function notify(data, resetScroll) {
      return this.sub(data, this.components['/_app'].Component, resetScroll);
    }
  }]);

  return Router;
}();

exports["default"] = Router;
Router.events = (0, _mitt["default"])();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.formatUrl = formatUrl;

var querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var slashedProtocols = /https?|ftp|gopher|file/;

function formatUrl(urlObj) {
  var auth = urlObj.auth,
      hostname = urlObj.hostname;
  var protocol = urlObj.protocol || '';
  var pathname = urlObj.pathname || '';
  var hash = urlObj.hash || '';
  var query = urlObj.query || '';
  var host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';

  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(':') ? "[".concat(hostname, "]") : hostname);

    if (urlObj.port) {
      host += ':' + urlObj.port;
    }
  }

  if (query && typeof query === 'object') {
    query = String(querystring.urlQueryToSearchParams(query));
  }

  var search = urlObj.search || query && "?".concat(query) || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash[0] !== '#') hash = '#' + hash;
  if (search && search[0] !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace('#', '%23');
  return "".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = getAssetPathFromRoute; // Translates a logical route into its pages asset path (relative from a common prefix)
// "asset path" being its javascript file, data file, prerendered html,...

function getAssetPathFromRoute(route) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var path = route === '/' ? '/index' : /^\/index(\/|$)/.test(route) ? "/index".concat(route) : "".concat(route);
  return path + ext;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.parseRelativeUrl = parseRelativeUrl;

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");
/**
* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative
* (e.g. `./hello`) then at least base must be.
* Absolute urls are rejected with one exception, in the browser, absolute urls that are on
* the current origin will be parsed as relative
*/


function parseRelativeUrl(url, base) {
  var globalBase = new URL(false ? undefined : (0, _utils.getLocationOrigin)());
  var resolvedBase = base ? new URL(base, globalBase) : globalBase;

  var _URL = new URL(url, resolvedBase),
      pathname = _URL.pathname,
      searchParams = _URL.searchParams,
      search = _URL.search,
      hash = _URL.hash,
      href = _URL.href,
      origin = _URL.origin;

  if (origin !== globalBase.origin) {
    throw new Error("invariant: invalid relative URL, router received ".concat(url));
  }

  return {
    pathname: pathname,
    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
    search: search,
    hash: hash,
    href: href.slice(globalBase.origin.length)
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
exports.urlQueryToSearchParams = urlQueryToSearchParams;
exports.assign = assign;

function searchParamsToUrlQuery(searchParams) {
  var query = {};
  searchParams.forEach(function (value, key) {
    if (typeof query[key] === 'undefined') {
      query[key] = value;
    } else if (Array.isArray(query[key])) {
      ;
      query[key].push(value);
    } else {
      query[key] = [query[key], value];
    }
  });
  return query;
}

function stringifyUrlQueryParam(param) {
  if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
    return String(param);
  } else {
    return '';
  }
}

function urlQueryToSearchParams(urlQuery) {
  var result = new URLSearchParams();
  Object.entries(urlQuery).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    if (Array.isArray(value)) {
      value.forEach(function (item) {
        return result.append(key, stringifyUrlQueryParam(item));
      });
    } else {
      result.set(key, stringifyUrlQueryParam(value));
    }
  });
  return result;
}

function assign(target) {
  for (var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    searchParamsList[_key - 1] = arguments[_key];
  }

  searchParamsList.forEach(function (searchParams) {
    Array.from(searchParams.keys()).forEach(function (key) {
      return target["delete"](key);
    });
    searchParams.forEach(function (value, key) {
      return target.append(key, value);
    });
  });
  return target;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites-noop.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites-noop.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = resolveRewrites;

function resolveRewrites() {}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function parseParameter(param) {
  var optional = param.startsWith('[') && param.endsWith(']');

  if (optional) {
    param = param.slice(1, -1);
  }

  var repeat = param.startsWith('...');

  if (repeat) {
    param = param.slice(3);
  }

  return {
    key: param,
    repeat: repeat,
    optional: optional
  };
}

function getRouteRegex(normalizedRoute) {
  var segments = (normalizedRoute.replace(/\/$/, '') || '/').slice(1).split('/');
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = segments.map(function (segment) {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      var _parseParameter = parseParameter(segment.slice(1, -1)),
          key = _parseParameter.key,
          optional = _parseParameter.optional,
          repeat = _parseParameter.repeat;

      groups[key] = {
        pos: groupIndex++,
        repeat: repeat,
        optional: optional
      };
      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
    } else {
      return "/".concat(escapeRegex(segment));
    }
  }).join(''); // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) { var namedParameterizedRoute, routeKeys, getSafeRouteKey, routeKeyCharLength, routeKeyCharCode; }

  return {
    re: new RegExp("^".concat(parameterizedRoute, "(?:/)?$")),
    groups: groups
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/side-effect.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/side-effect.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _toConsumableArray = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");

var _classCallCheck = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _assertThisInitialized = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

var _inherits = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");

var _possibleConstructorReturn = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");

var _getPrototypeOf = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

exports.__esModule = true;
exports["default"] = void 0;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var isServer = false;

var _default = /*#__PURE__*/function (_react$Component) {
  _inherits(_default, _react$Component);

  var _super = _createSuper(_default);

  function _default(props) {
    var _this;

    _classCallCheck(this, _default);

    _this = _super.call(this, props);
    _this._hasHeadManager = void 0;

    _this.emitChange = function () {
      if (_this._hasHeadManager) {
        _this.props.headManager.updateHead(_this.props.reduceComponentsToState(_toConsumableArray(_this.props.headManager.mountedInstances), _this.props));
      }
    };

    _this._hasHeadManager = _this.props.headManager && _this.props.headManager.mountedInstances;

    if (isServer && _this._hasHeadManager) {
      _this.props.headManager.mountedInstances.add(_assertThisInitialized(_this));

      _this.emitChange();
    }

    return _this;
  }

  _createClass(_default, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this._hasHeadManager) {
        this.props.headManager.mountedInstances.add(this);
      }

      this.emitChange();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.emitChange();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._hasHeadManager) {
        this.props.headManager.mountedInstances["delete"](this);
      }

      this.emitChange();
    }
  }, {
    key: "render",
    value: function render() {
      return null;
    }
  }]);

  return _default;
}(_react.Component);

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/to-base-64.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/to-base-64.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.toBase64 = toBase64;
/**
* Isomorphic base64 that works on the server and client
*/

function toBase64(str) {
  if (false) {} else {
    return window.btoa(str);
  }
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js");
/**
* Utils
*/


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _App$prototype, message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {}

            if (!((_App$prototype = App.prototype) != null && _App$prototype.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.");
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
            throw new Error(_message);

          case 20:
            if (true) {
              if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps"));
              }
            }

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

var urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(function (key) {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _formatUrl.formatUrl)(url);
}

var SP = typeof performance !== 'undefined';
exports.SP = SP;
var ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/denormalize-page-path.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/denormalize-page-path.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
exports.__esModule=true;exports.normalizePathSep=normalizePathSep;exports.denormalizePagePath=denormalizePagePath;function normalizePathSep(path){return path.replace(/\\/g,'/');}function denormalizePagePath(page){page=normalizePathSep(page);if(page.startsWith('/index/')){page=page.slice(6);}else if(page==='/index'){page='/';}return page;}
//# sourceMappingURL=denormalize-page-path.js.map

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/image-config.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/image-config.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
exports.__esModule=true;exports.imageConfigDefault=exports.VALID_LOADERS=void 0;const VALID_LOADERS=['default','imgix','cloudinary','akamai'];exports.VALID_LOADERS=VALID_LOADERS;const imageConfigDefault={deviceSizes:[640,750,828,1080,1200,1920,2048,3840],imageSizes:[16,32,48,64,96,128,256,384],path:'https://cdn.statically.io/gh/HiltonWS/hiltonws.github.io/master/smile/image',loader:'default',domains:[]};exports.imageConfigDefault=imageConfigDefault;
//# sourceMappingURL=image-config.js.map

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/next-server/lib/head */ "./node_modules/next/dist/next-server/lib/head.js")


/***/ }),

/***/ "./node_modules/next/image.js":
/*!************************************!*\
  !*** ./node_modules/next/image.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/image */ "./node_modules/next/dist/client/image.js")


/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/link */ "./node_modules/next/dist/client/link.js")


/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/buffer/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/buffer/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../next/dist/compiled/webpack/global.js */ "./node_modules/next/dist/compiled/webpack/global.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev

var jsxDEV$1 =  jsxWithValidation ;

exports.jsxDEV = jsxDEV$1;
  })();
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.1';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js");
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Home; });
/* harmony import */ var C_Personal_Projects_smile_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var C_Personal_Projects_smile_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(C_Personal_Projects_smile_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var C_Personal_Projects_smile_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/head */ "./node_modules/next/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _components_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/layout */ "./components/layout.js");
/* harmony import */ var _styles_utils_module_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles/utils.module.css */ "./styles/utils.module.css");
/* harmony import */ var _styles_utils_module_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_utils_module_css__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var face_api_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! face-api.js */ "./node_modules/face-api.js/build/es6/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);



var _jsxFileName = "C:\\Personal\\Projects\\smile\\pages\\index.js";





function Home() {
  var MODEL_URL = 'https://cdn.statically.io/gh/HiltonWS/hiltonws.github.io/master/smile/models';
  Promise.all([face_api_js__WEBPACK_IMPORTED_MODULE_6__["loadTinyFaceDetectorModel"](MODEL_URL), face_api_js__WEBPACK_IMPORTED_MODULE_6__["loadFaceLandmarkModel"](MODEL_URL), face_api_js__WEBPACK_IMPORTED_MODULE_6__["loadFaceExpressionModel"](MODEL_URL), face_api_js__WEBPACK_IMPORTED_MODULE_6__["loadFaceRecognitionModel"](MODEL_URL), face_api_js__WEBPACK_IMPORTED_MODULE_6__["loadSsdMobilenetv1Model"](MODEL_URL)]).then(start())["catch"](function (e) {
    return console.error(e);
  });

  function start() {
    return _start.apply(this, arguments);
  }

  function _start() {
    var _s = $RefreshSig$();

    _start = Object(C_Personal_Projects_smile_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_s( /*#__PURE__*/C_Personal_Projects_smile_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2() {
      return C_Personal_Projects_smile_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _s();

              Object(react__WEBPACK_IMPORTED_MODULE_7__["useEffect"])( /*#__PURE__*/Object(C_Personal_Projects_smile_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])( /*#__PURE__*/C_Personal_Projects_smile_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {
                var video;
                return C_Personal_Projects_smile_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        video = document.getElementById('inputVideo');
                        navigator.getUserMedia({
                          video: {}
                        }, function (stream) {
                          return video.srcObject = stream;
                        }, function (err) {
                          return console.error(err);
                        });
                        video.addEventListener('play', function () {
                          onPlay();
                        });

                      case 3:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              })));

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }), "OD7bBpZva5O2jO+Puf00hKivP7c="));
    return _start.apply(this, arguments);
  }

  function onPlay() {
    return _onPlay.apply(this, arguments);
  }

  function _onPlay() {
    _onPlay = Object(C_Personal_Projects_smile_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])( /*#__PURE__*/C_Personal_Projects_smile_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee4() {
      var video1, overlay, tinyOptions, lastSetInterval, onInterval;
      return C_Personal_Projects_smile_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              onInterval = function _onInterval() {
                lastSetInterval = setInterval( /*#__PURE__*/Object(C_Personal_Projects_smile_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])( /*#__PURE__*/C_Personal_Projects_smile_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee3() {
                  var fullFaceDescriptions;
                  return C_Personal_Projects_smile_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 2;
                          return face_api_js__WEBPACK_IMPORTED_MODULE_6__["detectAllFaces"](video1, tinyOptions).withFaceExpressions();

                        case 2:
                          fullFaceDescriptions = _context3.sent;
                          fullFaceDescriptions.forEach(function (element) {
                            if (element.expressions.happy > 0.90 && element.expressions.happy <= 1) {
                              overlay.style.display = "none";
                            } else {
                              overlay.style.display = "block";
                            }
                          });
                          clearInterval(lastSetInterval);
                          onInterval();

                        case 6:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                })), 200);
              };

              video1 = document.getElementById('inputVideo');
              overlay = document.getElementById('overlay');
              overlay.width = video1.offsetWidth;
              overlay.height = video1.offsetHeight;
              tinyOptions = new face_api_js__WEBPACK_IMPORTED_MODULE_6__["TinyFaceDetectorOptions"]();
              overlay.style.borderStyle = "dotted";
              onInterval();

            case 8:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _onPlay.apply(this, arguments);
  }

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_components_layout__WEBPACK_IMPORTED_MODULE_4__["default"], {
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(next_head__WEBPACK_IMPORTED_MODULE_3___default.a, {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("title", {
        children: _components_layout__WEBPACK_IMPORTED_MODULE_4__["siteTitle"]
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 66,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 65,
      columnNumber: 7
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("section", {
      className: _styles_utils_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.headingMd,
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("h1", {
        children: "Smile"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 69,
        columnNumber: 9
      }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("video", {
        id: "inputVideo",
        autoPlay: true,
        muted: true,
        children: " "
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 70,
        columnNumber: 9
      }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("canvas", {
        className: _styles_utils_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.canvas,
        id: "overlay"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 71,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 68,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 64,
    columnNumber: 5
  }, this);
}
_c = Home;

var _c;

$RefreshReg$(_c, "Home");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./styles/utils.module.css":
/*!*********************************!*\
  !*** ./styles/utils.module.css ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./utils.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/utils.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./utils.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/utils.module.css",
      function () {
        content = __webpack_require__(/*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-2-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./utils.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./styles/utils.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ 1:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!****************************!*\
  !*** node-fetch (ignored) ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

},[["./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=C%3A%5CPersonal%5CProjects%5Csmile%5Cpages%5Cindex.js!./","webpack"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvbGF5b3V0Lm1vZHVsZS5jc3M/OGEzMiIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L05ldXJhbE5ldHdvcmsuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvYWdlR2VuZGVyTmV0L0FnZUdlbmRlck5ldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9hZ2VHZW5kZXJOZXQvZXh0cmFjdFBhcmFtcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9hZ2VHZW5kZXJOZXQvZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvYWdlR2VuZGVyTmV0L2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2FnZUdlbmRlck5ldC90eXBlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jbGFzc2VzL0JvdW5kaW5nQm94LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NsYXNzZXMvQm94LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NsYXNzZXMvRGltZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jbGFzc2VzL0ZhY2VEZXRlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY2xhc3Nlcy9GYWNlTGFuZG1hcmtzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NsYXNzZXMvRmFjZUxhbmRtYXJrczUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY2xhc3Nlcy9GYWNlTGFuZG1hcmtzNjguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY2xhc3Nlcy9GYWNlTWF0Y2guanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY2xhc3Nlcy9MYWJlbGVkQm94LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NsYXNzZXMvTGFiZWxlZEZhY2VEZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jbGFzc2VzL09iamVjdERldGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jbGFzc2VzL1BvaW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NsYXNzZXMvUHJlZGljdGVkQm94LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NsYXNzZXMvUmVjdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jbGFzc2VzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NvbW1vbi9jb252TGF5ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY29tbW9uL2RlcHRod2lzZVNlcGFyYWJsZUNvbnYuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY29tbW9uL2Rpc3Bvc2VVbnVzZWRXZWlnaHRUZW5zb3JzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NvbW1vbi9leHRyYWN0Q29udlBhcmFtc0ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY29tbW9uL2V4dHJhY3RGQ1BhcmFtc0ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY29tbW9uL2V4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jb21tb24vZXh0cmFjdFdlaWdodEVudHJ5RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9jb21tb24vZXh0cmFjdFdlaWdodHNGYWN0b3J5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NvbW1vbi9mdWxseUNvbm5lY3RlZExheWVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NvbW1vbi9nZXRNb2RlbFVyaXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY29tbW9uL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2NvbW1vbi9sb2FkQ29udlBhcmFtc0ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvY29tbW9uL3R5cGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RvbS9OZXRJbnB1dC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vYXdhaXRNZWRpYUxvYWRlZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vYnVmZmVyVG9JbWFnZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vY3JlYXRlQ2FudmFzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RvbS9leHRyYWN0RmFjZVRlbnNvcnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZG9tL2V4dHJhY3RGYWNlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vZmV0Y2hJbWFnZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vZmV0Y2hKc29uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RvbS9mZXRjaE5ldFdlaWdodHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZG9tL2ZldGNoT3JUaHJvdy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vZ2V0Q29udGV4dDJkT3JUaHJvdy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vZ2V0TWVkaWFEaW1lbnNpb25zLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RvbS9pbWFnZVRlbnNvclRvQ2FudmFzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RvbS9pbWFnZVRvU3F1YXJlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vaXNNZWRpYUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZG9tL2lzTWVkaWFMb2FkZWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZG9tL2xvYWRXZWlnaHRNYXAuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZG9tL21hdGNoRGltZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kb20vcmVzb2x2ZUlucHV0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RvbS90b05ldElucHV0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RyYXcvRHJhd0JveC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kcmF3L0RyYXdGYWNlTGFuZG1hcmtzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RyYXcvRHJhd1RleHRGaWVsZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9kcmF3L2RyYXdDb250b3VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RyYXcvZHJhd0RldGVjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZHJhdy9kcmF3RmFjZUV4cHJlc3Npb25zLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2RyYXcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZW52L2NyZWF0ZUJyb3dzZXJFbnYuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZW52L2NyZWF0ZUZpbGVTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZW52L2NyZWF0ZU5vZGVqc0Vudi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9lbnYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZW52L2lzQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9lbnYvaXNOb2RlanMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZXVjbGlkZWFuRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZUV4cHJlc3Npb25OZXQvRmFjZUV4cHJlc3Npb25OZXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZUV4cHJlc3Npb25OZXQvRmFjZUV4cHJlc3Npb25zLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VFeHByZXNzaW9uTmV0L2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VGZWF0dXJlRXh0cmFjdG9yL0ZhY2VGZWF0dXJlRXh0cmFjdG9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VGZWF0dXJlRXh0cmFjdG9yL1RpbnlGYWNlRmVhdHVyZUV4dHJhY3Rvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlRmVhdHVyZUV4dHJhY3Rvci9kZW5zZUJsb2NrLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VGZWF0dXJlRXh0cmFjdG9yL2V4dHJhY3RQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZUZlYXR1cmVFeHRyYWN0b3IvZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZUZlYXR1cmVFeHRyYWN0b3IvZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXBUaW55LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VGZWF0dXJlRXh0cmFjdG9yL2V4dHJhY3RQYXJhbXNUaW55LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VGZWF0dXJlRXh0cmFjdG9yL2V4dHJhY3RvcnNGYWN0b3J5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VGZWF0dXJlRXh0cmFjdG9yL2xvYWRQYXJhbXNGYWN0b3J5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VMYW5kbWFya05ldC9GYWNlTGFuZG1hcms2OE5ldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlTGFuZG1hcmtOZXQvRmFjZUxhbmRtYXJrNjhOZXRCYXNlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VMYW5kbWFya05ldC9GYWNlTGFuZG1hcms2OFRpbnlOZXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZUxhbmRtYXJrTmV0L2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VQcm9jZXNzb3IvRmFjZVByb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlUHJvY2Vzc29yL2V4dHJhY3RQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZVByb2Nlc3Nvci9leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlUHJvY2Vzc29yL3V0aWwuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZVJlY29nbml0aW9uTmV0L0ZhY2VSZWNvZ25pdGlvbk5ldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlUmVjb2duaXRpb25OZXQvY29udkxheWVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VSZWNvZ25pdGlvbk5ldC9leHRyYWN0UGFyYW1zLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY2VSZWNvZ25pdGlvbk5ldC9leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWNlUmVjb2duaXRpb25OZXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZVJlY29nbml0aW9uTmV0L3Jlc2lkdWFsTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjZVJlY29nbml0aW9uTmV0L3NjYWxlTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjdG9yaWVzL1dpdGhBZ2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjdG9yaWVzL1dpdGhGYWNlRGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9mYWN0b3JpZXMvV2l0aEZhY2VEZXRlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjdG9yaWVzL1dpdGhGYWNlRXhwcmVzc2lvbnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZmFjdG9yaWVzL1dpdGhGYWNlTGFuZG1hcmtzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY3Rvcmllcy9XaXRoR2VuZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2ZhY3Rvcmllcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9nbG9iYWxBcGkvQ29tcG9zYWJsZVRhc2suanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZ2xvYmFsQXBpL0NvbXB1dGVGYWNlRGVzY3JpcHRvcnNUYXNrcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9nbG9iYWxBcGkvRGV0ZWN0RmFjZUxhbmRtYXJrc1Rhc2tzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2dsb2JhbEFwaS9EZXRlY3RGYWNlc1Rhc2tzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2dsb2JhbEFwaS9GYWNlTWF0Y2hlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9nbG9iYWxBcGkvUHJlZGljdEFnZUFuZEdlbmRlclRhc2suanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZ2xvYmFsQXBpL1ByZWRpY3RGYWNlRXhwcmVzc2lvbnNUYXNrLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2dsb2JhbEFwaS9hbGxGYWNlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9nbG9iYWxBcGkvZGV0ZWN0RmFjZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvZ2xvYmFsQXBpL2V4dHJhY3RGYWNlc0FuZENvbXB1dGVSZXN1bHRzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L2dsb2JhbEFwaS9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9nbG9iYWxBcGkvbmV0cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9NdGNubi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9NdGNubkJveC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9NdGNubk9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vT05ldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9QTmV0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L210Y25uL1JOZXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vYmdyVG9SZ2JUZW5zb3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vY29uZmlnLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L210Y25uL2V4dHJhY3RJbWFnZVBhdGNoZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vZXh0cmFjdFBhcmFtcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9nZXRTaXplc0ZvclNjYWxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L210Y25uL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L210Y25uL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9wcmVsdS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9weXJhbWlkRG93bi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9zaGFyZWRMYXllcnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvbXRjbm4vc3RhZ2UxLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L210Y25uL3N0YWdlMi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9tdGNubi9zdGFnZTMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvb3BzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L29wcy9pb3UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvb3BzL21pbkJib3guanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvb3BzL25vbk1heFN1cHByZXNzaW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L29wcy9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvb3BzL3BhZFRvU3F1YXJlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L29wcy9zaHVmZmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvcmVzaXplUmVzdWx0cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9zc2RNb2JpbGVuZXR2MS9Tc2RNb2JpbGVuZXR2MS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi9zc2RNb2JpbGVuZXR2MS9Tc2RNb2JpbGVuZXR2MU9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvc3NkTW9iaWxlbmV0djEvYm94UHJlZGljdGlvbkxheWVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3NzZE1vYmlsZW5ldHYxL2V4dHJhY3RQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvc3NkTW9iaWxlbmV0djEvZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvc3NkTW9iaWxlbmV0djEvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvc3NkTW9iaWxlbmV0djEvbW9iaWxlTmV0VjEuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvc3NkTW9iaWxlbmV0djEvbm9uTWF4U3VwcHJlc3Npb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvc3NkTW9iaWxlbmV0djEvb3V0cHV0TGF5ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvc3NkTW9iaWxlbmV0djEvcG9pbnR3aXNlQ29udkxheWVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3NzZE1vYmlsZW5ldHYxL3ByZWRpY3Rpb25MYXllci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi90aW55RmFjZURldGVjdG9yL1RpbnlGYWNlRGV0ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvdGlueUZhY2VEZXRlY3Rvci9UaW55RmFjZURldGVjdG9yT3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi90aW55RmFjZURldGVjdG9yL2NvbnN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3RpbnlGYWNlRGV0ZWN0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvdGlueVlvbG92Mi9UaW55WW9sb3YyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3RpbnlZb2xvdjIvVGlueVlvbG92MkJhc2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvdGlueVlvbG92Mi9UaW55WW9sb3YyT3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi90aW55WW9sb3YyL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi90aW55WW9sb3YyL2NvbnN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3RpbnlZb2xvdjIvY29udldpdGhCYXRjaE5vcm0uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvdGlueVlvbG92Mi9kZXB0aHdpc2VTZXBhcmFibGVDb252LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3RpbnlZb2xvdjIvZXh0cmFjdFBhcmFtcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi90aW55WW9sb3YyL2V4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFjZS1hcGkuanMvYnVpbGQvZXM2L3RpbnlZb2xvdjIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYvdGlueVlvbG92Mi9sZWFreS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi91dGlscy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi94Y2VwdGlvbi9UaW55WGNlcHRpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYWNlLWFwaS5qcy9idWlsZC9lczYveGNlcHRpb24vZXh0cmFjdFBhcmFtcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL2J1aWxkL2VzNi94Y2VwdGlvbi9leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZhY2UtYXBpLmpzL25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC90Zi1jb3JlLmVzbS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L2ltYWdlLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9saW5rLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvcmVxdWVzdC1pZGxlLWNhbGxiYWNrLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvdXNlLWludGVyc2VjdGlvbi50c3giLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvd2l0aC1yb3V0ZXIudHN4Iiwid2VicGFjazovL19OX0UvKHdlYnBhY2spL2Nzcy1sb2FkZXIvYXBpLmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2xheW91dC5tb2R1bGUuY3NzIiwid2VicGFjazovL19OX0UvLi9zdHlsZXMvdXRpbHMubW9kdWxlLmNzcyIsIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS93ZWJwYWNrL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS93ZWJwYWNrL2hhcm1vbnktbW9kdWxlLmpzIiwid2VicGFjazovL19OX0UvKHdlYnBhY2spL3dlYnBhY2svbW9kdWxlLmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2FtcC1jb250ZXh0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2FtcC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9taXR0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGUudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXMtbm9vcC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXgudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvc2lkZS1lZmZlY3QudHN4Iiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3RvLWJhc2UtNjQudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9zZXJ2ZXIvaW1hZ2UtY29uZmlnLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9pbWFnZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbGluay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy91dGlscy5tb2R1bGUuY3NzPzhhN2MiLCJ3ZWJwYWNrOi8vX05fRS9jcnlwdG8gKGlnbm9yZWQpIiwid2VicGFjazovL19OX0Uvbm9kZS1mZXRjaCAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vX05fRS91dGlsIChpZ25vcmVkKSJdLCJuYW1lcyI6WyJuYW1lIiwic2l0ZVRpdGxlIiwiTGF5b3V0IiwiY2hpbGRyZW4iLCJob21lIiwic3R5bGVzIiwiY29udGFpbmVyIiwiaGVhZGVyIiwiYmFja1RvSG9tZSIsIlZBTElEX0xPQURJTkdfVkFMVUVTIiwibG9hZGVycyIsIlZBTElEX0xBWU9VVF9WQUxVRVMiLCJwcm9jZXNzIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiZGV2aWNlU2l6ZXMiLCJpbWFnZVNpemVzIiwibG9hZGVyIiwicGF0aCIsImRvbWFpbnMiLCJhbGxTaXplcyIsImNvbmZpZ0RldmljZVNpemVzIiwiYSIsInNpemVzIiwibGF5b3V0IiwicGVyY2VudFNpemVzIiwibSIsInBhcnNlSW50Iiwic21hbGxlc3RSYXRpbyIsIk1hdGgiLCJ3aWR0aHMiLCJzIiwia2luZCIsIndpZHRoIiwidyIsInAiLCJzcmMiLCJzcmNTZXQiLCJnZXRXaWR0aHMiLCJsYXN0IiwicXVhbGl0eSIsImkiLCJsb2FkIiwicm9vdCIsIlZBTElEX0xPQURFUlMiLCJ1bm9wdGltaXplZCIsInByaW9yaXR5IiwiYWxsIiwicmVzdCIsInVuc2l6ZWQiLCJCb29sZWFuIiwiSlNPTiIsImhlaWdodCIsImxvYWRpbmciLCJpc0xhenkiLCJyb290TWFyZ2luIiwiZGlzYWJsZWQiLCJpc1Zpc2libGUiLCJ3aWR0aEludCIsImdldEludCIsImhlaWdodEludCIsInF1YWxpdHlJbnQiLCJpbWdTdHlsZSIsInZpc2liaWxpdHkiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsImJveFNpemluZyIsInBhZGRpbmciLCJib3JkZXIiLCJtYXJnaW4iLCJkaXNwbGF5IiwibWluV2lkdGgiLCJtYXhXaWR0aCIsIm1pbkhlaWdodCIsIm1heEhlaWdodCIsIm9iamVjdEZpdCIsIm9iamVjdFBvc2l0aW9uIiwicXVvdGllbnQiLCJwYWRkaW5nVG9wIiwiaXNOYU4iLCJ3cmFwcGVyU3R5bGUiLCJvdmVyZmxvdyIsInNpemVyU3R5bGUiLCJzaXplclN2ZyIsImltZ0F0dHJpYnV0ZXMiLCJnZW5lcmF0ZUltZ0F0dHJzIiwicGFyYW1zIiwicGFyYW1zU3RyaW5nIiwibm9ybWFsaXplU3JjIiwibWlzc2luZ1ZhbHVlcyIsInBhcnNlZFNyYyIsImNvbnNvbGUiLCJjb25maWdEb21haW5zIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicHJlZmV0Y2hlZCIsInJvdXRlciIsImVyciIsImN1ckxvY2FsZSIsIm9wdGlvbnMiLCJocmVmIiwiZXZlbnQiLCJ0YXJnZXQiLCJlIiwibm9kZU5hbWUiLCJpc01vZGlmaWVkRXZlbnQiLCJzY3JvbGwiLCJhcyIsInJlcGxhY2UiLCJzaGFsbG93IiwibG9jYWxlIiwic3VjY2VzcyIsImRvY3VtZW50IiwiYXJncyIsImtleSIsImV4cGVjdGVkIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsIk9iamVjdCIsInByb3BzIiwiY3JlYXRlUHJvcEVycm9yIiwiYWN0dWFsIiwiXyIsIm9wdGlvbmFsUHJvcHNHdWFyZCIsInBhc3NIcmVmIiwicHJlZmV0Y2giLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImhhc1dhcm5lZCIsIlJlYWN0IiwicGF0aG5hbWUiLCJyZXNvbHZlZEFzIiwiY2hpbGQiLCJDaGlsZHJlbiIsImNoaWxkUmVmIiwic2V0UmVmIiwiZWwiLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJzaG91bGRQcmVmZXRjaCIsImlzUHJlZmV0Y2hlZCIsImNoaWxkUHJvcHMiLCJyZWYiLCJvbkNsaWNrIiwibGlua0NsaWNrZWQiLCJsb2NhbGVEb21haW4iLCJMaW5rIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwic2VsZiIsInN0YXJ0IiwiRGF0ZSIsInNldFRpbWVvdXQiLCJjYiIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwiY2xlYXJUaW1lb3V0IiwiTVNfTUFYX0lETEVfREVMQVkiLCJlbnRyeSIsIm1hcCIsIlByb21pc2UiLCJwcm9tIiwicmVzb2x2ZSIsInJlc29sdmVyIiwiZnV0dXJlIiwiZ2VuZXJhdG9yIiwidmFsdWUiLCJsaW5rIiwid2luZG93IiwiY2FuUHJlZmV0Y2giLCJoYXNQcmVmZXRjaCIsInJlcyIsIkFTU0VUX0xPQURfRVJST1IiLCJTeW1ib2wiLCJzY3JpcHQiLCJyZWplY3QiLCJtYXJrQXNzZXRFcnJvciIsImNhbmNlbGxlZCIsInIiLCJvbkJ1aWxkTWFuaWZlc3QiLCJyZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0Iiwic2NyaXB0cyIsImFzc2V0UHJlZml4IiwiZW5jb2RlVVJJIiwiY3NzIiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsIm1hbmlmZXN0Iiwicm91dGUiLCJhbGxGaWxlcyIsInYiLCJlbnRyeXBvaW50cyIsImxvYWRlZFNjcmlwdHMiLCJzdHlsZVNoZWV0cyIsInJvdXRlcyIsImFwcGVuZFNjcmlwdCIsImZldGNoIiwidGV4dCIsImNvbnRlbnQiLCJ3aGVuRW50cnlwb2ludCIsIndpdGhGdXR1cmUiLCJvbkVudHJ5cG9pbnQiLCJmbiIsImV4cG9ydHMiLCJjb21wb25lbnQiLCJlcnJvciIsImlucHV0Iiwib2xkIiwibG9hZFJvdXRlIiwiZ2V0RmlsZXNGb3JSb3V0ZSIsImVudHJ5cG9pbnQiLCJjbiIsIm5hdmlnYXRvciIsIm91dHB1dCIsInByZWZldGNoVmlhRG9tIiwiY3JlYXRlUm91dGVMb2FkZXIiLCJzaW5nbGV0b25Sb3V0ZXIiLCJyZWFkeUNhbGxiYWNrcyIsInJlYWR5IiwidXJsUHJvcGVydHlGaWVsZHMiLCJyb3V0ZXJFdmVudHMiLCJjb3JlTWV0aG9kRmllbGRzIiwiZ2V0IiwiUm91dGVyIiwiZmllbGQiLCJnZXRSb3V0ZXIiLCJldmVudEZpZWxkIiwiX3NpbmdsZXRvblJvdXRlciIsIm1lc3NhZ2UiLCJSb3V0ZXJDb250ZXh0IiwiY3JlYXRlUm91dGVyIiwiX3JvdXRlciIsImluc3RhbmNlIiwiQXJyYXkiLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsImlzRGlzYWJsZWQiLCJ1bm9ic2VydmUiLCJvYnNlcnZlIiwic2V0VmlzaWJsZSIsImlkbGVDYWxsYmFjayIsImNyZWF0ZU9ic2VydmVyIiwiZWxlbWVudHMiLCJvYnNlcnZlciIsIm9ic2VydmVycyIsImlkIiwiZW50cmllcyIsImNhbGxiYWNrIiwiQ29tcG9zZWRDb21wb25lbnQiLCJnZXRJbml0aWFsUHJvcHMiLCJXaXRoUm91dGVyV3JhcHBlciIsIkFtcFN0YXRlQ29udGV4dCIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiLCJpc0luQW1wTW9kZSIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsImluQW1wTW9kZSIsImhlYWQiLCJsaXN0IiwiZnJhZ21lbnRMaXN0IiwiTUVUQVRZUEVTIiwia2V5cyIsInRhZ3MiLCJtZXRhVHlwZXMiLCJtZXRhQ2F0ZWdvcmllcyIsImgiLCJpc1VuaXF1ZSIsImhhc0tleSIsImxlbiIsIm1ldGF0eXBlIiwiY2F0ZWdvcnkiLCJjYXRlZ29yaWVzIiwiaGVhZEVsZW1lbnRzIiwiaGVhZEVsZW1lbnRDaGlsZHJlbiIsImhlYWRFbGVtZW50IiwiZGVmYXVsdEhlYWQiLCJ1bmlxdWUiLCJjIiwiYW1wU3RhdGUiLCJoZWFkTWFuYWdlciIsIkhlYWQiLCJwYXRobmFtZVBhcnRzIiwibG9jYWxlcyIsImRldGVjdGVkTG9jYWxlIiwib24iLCJvZmYiLCJlbWl0IiwiaGFuZGxlciIsImJhc2VQYXRoIiwicHJlZml4IiwicGF0aE5vUXVlcnlIYXNoIiwicXVlcnlJbmRleCIsImhhc2hJbmRleCIsImFkZFBhdGhQcmVmaXgiLCJ1cmwiLCJsb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiaGFzQmFzZVBhdGgiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImR5bmFtaWNHcm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImFzUGF0aG5hbWUiLCJwYXJhbSIsInJlcGxhY2VkIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJzZWdtZW50IiwicmVzdWx0IiwiZmlsdGVyZWRRdWVyeSIsInF1ZXJ5IiwiYmFzZSIsInVybEFzU3RyaW5nIiwiaXNMb2NhbFVSTCIsInJlc29sdmVBcyIsImZpbmFsVXJsIiwiaW50ZXJwb2xhdGVkQXMiLCJpbnRlcnBvbGF0ZUFzIiwiaGFzaCIsIm9taXRQYXJtc0Zyb21RdWVyeSIsInJlc29sdmVkSHJlZiIsIm9yaWdpbiIsInJlc29sdmVIcmVmIiwiaHJlZkhhZE9yaWdpbiIsImFzSGFkT3JpZ2luIiwic3RyaXBPcmlnaW4iLCJwcmVwYXJlZFVybCIsImFkZEJhc2VQYXRoIiwicHJlcGFyZWRBcyIsImFwcGx5QmFzZVBhdGgiLCJjbGVhblBhdGhuYW1lIiwiZGVsQmFzZVBhdGgiLCJwYWdlcyIsInBhZ2UiLCJwYXJzZWRIcmVmIiwibWFudWFsU2Nyb2xsUmVzdG9yYXRpb24iLCJTU0dfREFUQV9OT1RfRk9VTkQiLCJjcmVkZW50aWFscyIsImF0dGVtcHRzIiwiZmV0Y2hSZXRyeSIsImRhdGEiLCJub3RGb3VuZCIsImlzU2VydmVyUmVuZGVyIiwiY29uc3RydWN0b3IiLCJhc1BhdGgiLCJjb21wb25lbnRzIiwic2RjIiwic2RyIiwic3ViIiwiY2xjIiwicGFnZUxvYWRlciIsIl9icHMiLCJldmVudHMiLCJfd3JhcEFwcCIsImlzU3NyIiwiaXNGYWxsYmFjayIsIl9pbkZsaWdodFJvdXRlIiwiX3NoYWxsb3ciLCJkZWZhdWx0TG9jYWxlIiwiZG9tYWluTG9jYWxlcyIsImlzUmVhZHkiLCJpc1ByZXZpZXciLCJpc0xvY2FsZURvbWFpbiIsIl9pZHgiLCJzdGF0ZSIsIkNvbXBvbmVudCIsImluaXRpYWwiLCJfX05fU1NHIiwiaW5pdGlhbFByb3BzIiwiX19OX1NTUCIsImF1dG9FeHBvcnREeW5hbWljIiwicmVsb2FkIiwicHJlcGFyZVVybEFzIiwibG9jYWxlQ2hhbmdlIiwicGFyc2VkQXMiLCJsb2NhbGVQYXRoUmVzdWx0IiwiZGlkTmF2aWdhdGUiLCJkZXRlY3RlZERvbWFpbiIsImRldGVjdERvbWFpbkxvY2FsZSIsIlNUIiwicGVyZm9ybWFuY2UiLCJyb3V0ZVByb3BzIiwiYWRkTG9jYWxlIiwiY2xlYW5lZEFzIiwiZGVsTG9jYWxlIiwicGFyc2VkIiwiX19yZXdyaXRlcyIsInJlc29sdmVEeW5hbWljUm91dGUiLCJtZXRob2QiLCJyb3V0ZVJlZ2V4Iiwicm91dGVNYXRjaCIsInNob3VsZEludGVycG9sYXRlIiwibWlzc2luZ1BhcmFtcyIsInJvdXRlSW5mbyIsImRlc3RpbmF0aW9uIiwibm90Rm91bmRSb3V0ZSIsImFwcENvbXAiLCJpc1ZhbGlkU2hhbGxvd1JvdXRlIiwiZm9yY2VkU2Nyb2xsIiwieCIsInkiLCJfX04iLCJpZHgiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwiZXhpc3RpbmdSb3V0ZUluZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJyZXF1aXJlIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZGF0YUhyZWYiLCJvbmx5QUhhc2hDaGFuZ2UiLCJuZXdIYXNoIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsInNjcm9sbFRvSGFzaCIsImlkRWwiLCJuYW1lRWwiLCJ1cmxJc05ldyIsInJld3JpdGVzUmVzdWx0IiwiaXNTc2ciLCJjYW5jZWwiLCJjb21wb25lbnRSZXN1bHQiLCJfZ2V0U3RhdGljRGF0YSIsImZldGNoTmV4dERhdGEiLCJfZ2V0U2VydmVyRGF0YSIsIkFwcFRyZWUiLCJjdHgiLCJhYm9ydENvbXBvbmVudExvYWQiLCJub3RpZnkiLCJzbGFzaGVkUHJvdG9jb2xzIiwicHJvdG9jb2wiLCJ1cmxPYmoiLCJob3N0IiwiYXV0aCIsImhvc3RuYW1lIiwiU3RyaW5nIiwicXVlcnlzdHJpbmciLCJzZWFyY2giLCJleHQiLCJURVNUX1JPVVRFIiwiZ2xvYmFsQmFzZSIsInJlc29sdmVkQmFzZSIsInNlYXJjaFBhcmFtcyIsIml0ZW0iLCJzdHJpbmdpZnlVcmxRdWVyeVBhcmFtIiwic2VhcmNoUGFyYW1zTGlzdCIsInJlIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic2x1Z05hbWUiLCJnIiwiZ3JvdXBzIiwic3RyIiwic2VnbWVudHMiLCJub3JtYWxpemVkUm91dGUiLCJncm91cEluZGV4IiwicGFyYW1ldGVyaXplZFJvdXRlIiwicGFyc2VQYXJhbWV0ZXIiLCJwb3MiLCJlc2NhcGVSZWdleCIsImlzU2VydmVyIiwiX2hhc0hlYWRNYW5hZ2VyIiwiZW1pdENoYW5nZSIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkVXBkYXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW5kZXIiLCJ1c2VkIiwicG9ydCIsImdldExvY2F0aW9uT3JpZ2luIiwiQXBwIiwiZ2V0RGlzcGxheU5hbWUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwicGFnZVByb3BzIiwiaXNSZXNTZW50IiwidXJsT2JqZWN0S2V5cyIsIlNQIiwiSG9tZSIsIk1PREVMX1VSTCIsImZhY2VhcGkiLCJ0aGVuIiwidXNlRWZmZWN0IiwidmlkZW8iLCJnZXRFbGVtZW50QnlJZCIsImdldFVzZXJNZWRpYSIsInN0cmVhbSIsInNyY09iamVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJvblBsYXkiLCJvbkludGVydmFsIiwibGFzdFNldEludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ2aWRlbzEiLCJ0aW55T3B0aW9ucyIsIndpdGhGYWNlRXhwcmVzc2lvbnMiLCJmdWxsRmFjZURlc2NyaXB0aW9ucyIsImZvckVhY2giLCJlbGVtZW50IiwiZXhwcmVzc2lvbnMiLCJoYXBweSIsIm92ZXJsYXkiLCJzdHlsZSIsImNsZWFySW50ZXJ2YWwiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImJvcmRlclN0eWxlIiwidXRpbFN0eWxlcyIsImhlYWRpbmdNZCIsImNhbnZhcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxJQUFNQSxJQUFJLEdBQUcsT0FBYjtBQUNPLElBQU1DLFNBQVMsR0FBRyxPQUFsQjtBQUVRLFNBQVNDLE1BQVQsT0FBb0M7QUFBQSxNQUFsQkMsUUFBa0IsUUFBbEJBLFFBQWtCO0FBQUEsTUFBUkMsSUFBUSxRQUFSQSxJQUFRO0FBQ2pELHNCQUNFO0FBQUssYUFBUyxFQUFFQyx5REFBTSxDQUFDQyxTQUF2QjtBQUFBLDRCQUNFLHFFQUFDLGdEQUFEO0FBQUEsNkJBQ0U7QUFBTSxXQUFHLEVBQUMsTUFBVjtBQUFpQixZQUFJLEVBQUM7QUFBdEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFERixlQUlFO0FBQVEsZUFBUyxFQUFFRCx5REFBTSxDQUFDRTtBQUExQjtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBSkYsZUFNRTtBQUFBLGdCQUFPSjtBQUFQO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFORixlQU9JO0FBQUssZUFBUyxFQUFFRSx5REFBTSxDQUFDRyxVQUF2QjtBQUFBLDZCQUNFLHFFQUFDLGdEQUFEO0FBQU0sWUFBSSxFQUFDLEdBQVg7QUFBQSwrQkFDRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFERjtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBUEo7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBREY7QUFlRDtLQWhCdUJOLE07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1R4QixVQUFVLG1CQUFPLENBQUMsbU5BQXdHO0FBQzFILDBCQUEwQixtQkFBTyxDQUFDLDRUQUF5Szs7QUFFM007O0FBRUE7QUFDQSwwQkFBMEIsUUFBUztBQUNuQzs7QUFFQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQSxzRUFBc0Usd0NBQXdDO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkO0FBQ0Esa0VBQWtFLGlCQUFpQixjQUFjLE1BQU0sWUFBWSxpQ0FBaUM7QUFDcEosVUFBVSxnQkFBZ0IsZUFBZSxZQUFZLGlDQUFpQztBQUN0RixVQUFVLFVBQVUsZUFBZTtBQUNuQzs7QUFFQTtBQUNBLE1BQU0sNFRBQXlLO0FBQy9LO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNFRBQXlLOztBQUVuTTs7QUFFQTtBQUNBLDRCQUE0QixRQUFTO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHNDOzs7Ozs7Ozs7OztBQzNEQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQzs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7Ozs7O0FDSkEsdUJBQXVCLG1CQUFPLENBQUMscUZBQW9COztBQUVuRDtBQUNBO0FBQ0E7O0FBRUEsb0M7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Qzs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQzs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQzs7Ozs7Ozs7Ozs7QUNOQSxxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBa0I7O0FBRS9DLCtCQUErQixtQkFBTyxDQUFDLHFHQUE0Qjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCOzs7Ozs7Ozs7OztBQ3JCQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Qjs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQzs7Ozs7Ozs7Ozs7O0FDZkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEM7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEI7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQzs7Ozs7Ozs7Ozs7QUNQQSxxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBa0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLDJCOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDOzs7Ozs7Ozs7OztBQ05BLGNBQWMsbUJBQU8sQ0FBQyxzRkFBK0I7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDOzs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsMkM7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBOztBQUVBLGtDOzs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QywrQkFBK0I7QUFDNUU7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUM7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTs7QUFFQSxrQzs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7O0FBRUEsb0M7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDOzs7Ozs7Ozs7OztBQ2ZBLGNBQWMsbUJBQU8sQ0FBQyxzRkFBK0I7O0FBRXJELDRCQUE0QixtQkFBTyxDQUFDLCtGQUF5Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0Qzs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7Ozs7O0FDVEEscUJBQXFCLG1CQUFPLENBQUMsaUZBQWtCOztBQUUvQywyQkFBMkIsbUJBQU8sQ0FBQyw2RkFBd0I7O0FBRTNELGlDQUFpQyxtQkFBTyxDQUFDLHlHQUE4Qjs7QUFFdkUsc0JBQXNCLG1CQUFPLENBQUMsbUZBQW1COztBQUVqRDtBQUNBO0FBQ0E7O0FBRUEsZ0M7Ozs7Ozs7Ozs7O0FDWkEsd0JBQXdCLG1CQUFPLENBQUMsdUZBQXFCOztBQUVyRCxzQkFBc0IsbUJBQU8sQ0FBQyxtRkFBbUI7O0FBRWpELGlDQUFpQyxtQkFBTyxDQUFDLHlHQUE4Qjs7QUFFdkUsd0JBQXdCLG1CQUFPLENBQUMsdUZBQXFCOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUEsb0M7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCOzs7Ozs7Ozs7OztBQ2hCQSx1QkFBdUIsbUJBQU8sQ0FBQyxxRkFBb0I7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkM7Ozs7Ozs7Ozs7O0FDWEEsaUJBQWlCLG1CQUFPLENBQUMsMEVBQXFCOzs7Ozs7Ozs7Ozs7O0FDQWxDOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErQztBQUNIO0FBQ1M7QUFDZjtBQUNWO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQixFQUFFO0FBQ2pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIsNEJBQTRCLEVBQUU7QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQixzQkFBc0IsRUFBRTtBQUNsRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNERBQTRELGdDQUFnQyw4REFBVyxDQUFDLEVBQUU7QUFDMUc7QUFDQTtBQUNBLDREQUE0RCxrQ0FBa0MsOERBQVcsRUFBRSxFQUFFO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFTO0FBQ2xDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBDQUEwQyx5QkFBeUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwwQ0FBMEMseUJBQXlCLEVBQUU7QUFDckU7QUFDQTtBQUNBLGVBQWUsdURBQVM7QUFDeEIsbUJBQW1CLHlEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLHVEQUFTO0FBQ3hCO0FBQ0EsbUJBQW1CLHlEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMERBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsdURBQVM7QUFDeEI7QUFDQSxtQkFBbUIseURBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3Q0FBRztBQUN0Qyw2QkFBNkIseUVBQVk7QUFDekMscUVBQXFFLHVEQUF1RCxnREFBZ0QsbUJBQW1CLEVBQUUsRUFBRSxFQUFFLEdBQUc7QUFDeE0sc0NBQXNDLHdEQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixTQUFTLEdBQUcsdUJBQXVCO0FBQ25DO0FBQ0EsMERBQTBELDREQUFTO0FBQ25FO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLENBQUM7QUFDd0I7QUFDekIseUM7Ozs7Ozs7Ozs7OztBQy9LQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMEQ7QUFDZDtBQUN3QjtBQUNUO0FBQ0g7QUFDUjtBQUMwQjtBQUN6QztBQUNnQjtBQUNIO0FBQzlDO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0EsOENBQThDLDRCQUE0QixtRUFBWSxJQUFJO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBTztBQUN0QixzREFBc0QsNkNBQVE7QUFDOUQ7QUFDQTtBQUNBLHlCQUF5Qiw2REFBVTtBQUNuQyxzQkFBc0IsdUZBQW1CO0FBQ3pDLHlCQUF5Qix1RkFBbUI7QUFDNUMsb0JBQW9CO0FBQ3BCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFPO0FBQ3RCO0FBQ0Esb0JBQW9CLG1CQUFtQiw2REFBVTtBQUNqRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsdURBQVM7QUFDeEI7QUFDQSxtQkFBbUIseURBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVEQUFVO0FBQ3ZEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLHVEQUFTO0FBQ3hCO0FBQ0E7QUFDQSxtQkFBbUIseURBQVc7QUFDOUI7QUFDQSxpREFBaUQsdURBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2REFBVTtBQUN6QyxrQ0FBa0MsNkRBQVU7QUFDNUMsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRSxFQUFFO0FBQzdCO0FBQ0E7QUFDQSx1Q0FBdUMsdURBQVM7QUFDaEQ7QUFDQSwyQ0FBMkMseURBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSw2Q0FBTSxRQUFRLDZDQUFNO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxpRUFBaUU7QUFDeEk7QUFDQSxxQ0FBcUM7QUFDckMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9FQUFhO0FBQzVCO0FBQ0E7QUFDQSxpQkFBaUIsOEVBQWtCO0FBQ25DO0FBQ0EsZUFBZSw4RkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLDREQUFhO0FBQ1M7QUFDeEIsd0M7Ozs7Ozs7Ozs7OztBQy9JQTtBQUFBO0FBQUE7QUFBMEU7QUFDbkU7QUFDUDtBQUNBLGFBQWEscUVBQXFCO0FBQ2xDLDBCQUEwQixzRUFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTSwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBLHlDOzs7Ozs7Ozs7Ozs7QUNmQTtBQUFBO0FBQUE7QUFBa0Y7QUFDM0U7QUFDUDtBQUNBLDZCQUE2Qix5RUFBeUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwRUFBMEI7QUFDOUIsWUFBWTtBQUNaO0FBQ0Esc0Q7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErQjtBQUNQO0FBQ3hCLGlDOzs7Ozs7Ozs7Ozs7QUNGQTtBQUFBO0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QjtBQUN6QixpQzs7Ozs7Ozs7Ozs7O0FDTEE7QUFBQTtBQUFBO0FBQUE7QUFBa0M7QUFDTjtBQUM1QjtBQUNBLElBQUksdURBQVM7QUFDYjtBQUNBLGlEQUFpRCxpQ0FBaUM7QUFDbEYsa0NBQWtDLHFEQUFxRDtBQUN2RjtBQUNBO0FBQ0EsQ0FBQyxDQUFDLHdDQUFHO0FBQ2tCO0FBQ3ZCLHVDOzs7Ozs7Ozs7Ozs7QUNYQTtBQUFBO0FBQUE7QUFBQTtBQUF1RDtBQUN2QjtBQUNoQztBQUNBO0FBQ0EsaURBQWlELGdDQUFnQztBQUNqRiw2QkFBNkI7QUFDN0Isc0VBQXNFLG9EQUFhO0FBQ25GLGlFQUFpRSxvREFBYTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkNBQTJDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxvREFBYTtBQUN0RjtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQixFQUFFO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIsZ0JBQWdCLEVBQUU7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQixvQkFBb0IsRUFBRTtBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLHFCQUFxQixFQUFFO0FBQ2pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIsZUFBZSxFQUFFO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIsZUFBZSxFQUFFO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIsNEJBQTRCLEVBQUU7QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQiw2QkFBNkIsRUFBRTtBQUN6RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLGlDQUFpQyxFQUFFO0FBQzdEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIsWUFBWSw0Q0FBSyxzQkFBc0IsRUFBRTtBQUNuRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLFlBQVksNENBQUssdUJBQXVCLEVBQUU7QUFDcEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQixZQUFZLDRDQUFLLHlCQUF5QixFQUFFO0FBQ3RFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIsWUFBWSw0Q0FBSywwQkFBMEIsRUFBRTtBQUN2RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQ0FBaUMsd0JBQXdCLEVBQUU7QUFDM0Qsd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0JBQXdCLEVBQUU7QUFDM0Qsd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkNBQTJDO0FBQ25FO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQVk7QUFDakMscUJBQXFCLDJEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQ0FBMkM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVFQUF1RTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNjO0FBQ2YsK0I7Ozs7Ozs7Ozs7OztBQ25NQTtBQUFBO0FBQUE7QUFBeUM7QUFDekM7QUFDQTtBQUNBLGFBQWEsNERBQWEsWUFBWSw0REFBYTtBQUNuRCxzSUFBc0ksK0JBQStCO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQW9CLEVBQUU7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQixxQkFBcUIsRUFBRTtBQUNqRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNxQjtBQUN0QixzQzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQUE7QUFBQTtBQUFBO0FBQWtDO0FBQ2tCO0FBQ3BEO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0VBQWU7QUFDUTtBQUN6Qix5Qzs7Ozs7Ozs7Ozs7O0FDZEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWlDO0FBQ1M7QUFDZDtBQUNjO0FBQ007QUFDaEI7QUFDRjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYSw0Q0FBSyxPQUFPO0FBQ3hEO0FBQ0EsNEJBQTRCLHNEQUFVO0FBQ3RDO0FBQ0EsMkVBQTJFLG1CQUFtQiw0Q0FBSyw0QkFBNEIsRUFBRTtBQUNqSTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVksNENBQUssK0JBQStCLEVBQUU7QUFDNUU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQiw0QkFBNEIsRUFBRTtBQUN4RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLDZCQUE2QixFQUFFO0FBQ3pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIsd0JBQXdCLEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUNBQXFDLDRDQUFLLHVDQUF1QyxFQUFFO0FBQ3pJLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkRBQTZELCtCQUErQjtBQUM1RjtBQUNBO0FBQ0EsK0VBQStFLDRDQUFLO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQSwyQ0FBMkMsNERBQWE7QUFDeEQ7QUFDQSxzQkFBc0Isd0NBQUc7QUFDekI7QUFDQTtBQUNBLGlDQUFpQyxHQUFHLDhDQUE4QztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHdDQUF3QztBQUNqRjtBQUNBO0FBQ0EsdUJBQXVCLDZEQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBSTtBQUN2QjtBQUNBO0FBQ0Esa0JBQWtCLG9EQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDd0I7QUFDekIseUM7Ozs7Ozs7Ozs7OztBQ3ZHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWtDO0FBQ1E7QUFDTTtBQUNoRDtBQUNBLElBQUksdURBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2REFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsNERBQWE7QUFDVztBQUMxQiwwQzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBa0M7QUFDUTtBQUNNO0FBQ2hEO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFEQUFjO0FBQzVCO0FBQ0E7QUFDQSxDQUFDLENBQUMsNERBQWE7QUFDWTtBQUMzQiwyQzs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQUE7QUFBQTtBQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQW9CLEVBQUU7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQix1QkFBdUIsRUFBRTtBQUNuRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRCx3REFBd0Qsb0RBQUs7QUFDN0Q7QUFDQTtBQUNBLENBQUM7QUFDb0I7QUFDckIscUM7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWtDO0FBQ087QUFDYjtBQUM1QjtBQUNBLElBQUksdURBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdDQUFHO0FBQ1gsYUFBYSw0REFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0IsRUFBRTtBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQyxDQUFDLHdDQUFHO0FBQ2lCO0FBQ3RCLHNDOzs7Ozs7Ozs7Ozs7QUN4QkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsd0NBQXdDLEVBQUU7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQixFQUFFO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIsMEJBQTBCLEVBQUU7QUFDdEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsc0JBQXNCLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ2lDO0FBQ2xDLGtEOzs7Ozs7Ozs7Ozs7QUNwQ0E7QUFBQTtBQUFBO0FBQUE7QUFBNEI7QUFDYztBQUMxQztBQUNBO0FBQ0EsOEJBQThCLHNEQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3Q0FBRztBQUMzQjtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQixFQUFFO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIseUJBQXlCLEVBQUU7QUFDckQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQix3QkFBd0IsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLGtCQUFrQixFQUFFO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIsd0JBQXdCLEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQiw2QkFBNkIsRUFBRTtBQUN6RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLDhCQUE4QixFQUFFO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIsWUFBWSx3Q0FBRyw4Q0FBOEMsRUFBRTtBQUN6RjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUdBQW1HLCtCQUErQjtBQUNsSTtBQUNBO0FBQ0EsQ0FBQztBQUMwQjtBQUMzQiwyQzs7Ozs7Ozs7Ozs7O0FDeERBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCLEVBQUU7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQixnQkFBZ0IsRUFBRTtBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNnQjtBQUNqQixpQzs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBa0M7QUFDWTtBQUNKO0FBQzFDO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBVTtBQUNsQixhQUFhLGlFQUFrQjtBQUMvQixnQkFBZ0IsaUVBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQixFQUFFO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIseUJBQXlCLEVBQUU7QUFDckQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUMsQ0FBQyxzREFBVTtBQUNZO0FBQ3hCLHdDOzs7Ozs7Ozs7Ozs7QUMvQkE7QUFBQTtBQUFBO0FBQUE7QUFBa0M7QUFDTjtBQUM1QjtBQUNBLElBQUksdURBQVM7QUFDYjtBQUNBLGlEQUFpRCxpQ0FBaUM7QUFDbEYsa0NBQWtDLDJDQUEyQztBQUM3RTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLHdDQUFHO0FBQ1c7QUFDaEIsZ0M7Ozs7Ozs7Ozs7OztBQ1hBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQThCO0FBQ1I7QUFDTztBQUNHO0FBQ0E7QUFDQztBQUNDO0FBQ047QUFDQztBQUNZO0FBQ1A7QUFDVjtBQUNPO0FBQ1I7QUFDdkIsaUM7Ozs7Ozs7Ozs7OztBQ2RBO0FBQUE7QUFBQTtBQUE0QztBQUNyQztBQUNQLDZCQUE2QixrQkFBa0I7QUFDL0MsOEJBQThCLGtCQUFrQjtBQUNoRCxXQUFXLDBEQUFPO0FBQ2xCLGtCQUFrQix5REFBTSxDQUFDLDREQUFTO0FBQ2xDLDBCQUEwQiwwREFBTztBQUNqQyxLQUFLO0FBQ0w7QUFDQSxxQzs7Ozs7Ozs7Ozs7O0FDVEE7QUFBQTtBQUFBO0FBQTRDO0FBQ3JDO0FBQ1AsV0FBVywwREFBTztBQUNsQixrQkFBa0IscUVBQWtCO0FBQ3BDLGNBQWMseURBQU07QUFDcEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrRDs7Ozs7Ozs7Ozs7O0FDUkE7QUFBQTtBQUFPO0FBQ1A7QUFDQSwrQ0FBK0MsaUNBQWlDLEVBQUU7QUFDbEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNEOzs7Ozs7Ozs7Ozs7QUNQQTtBQUFBO0FBQUE7QUFBNEM7QUFDckM7QUFDUDtBQUNBLHNCQUFzQiw4REFBVztBQUNqQyxtQkFBbUIsOERBQVc7QUFDOUIsNEJBQTRCLHVDQUF1QyxHQUFHLG9DQUFvQztBQUMxRyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLG9EOzs7Ozs7Ozs7Ozs7QUNUQTtBQUFBO0FBQUE7QUFBNEM7QUFDckM7QUFDUDtBQUNBLHlCQUF5Qiw4REFBVztBQUNwQyxzQkFBc0IsOERBQVc7QUFDakMsNEJBQTRCLHVDQUF1QyxHQUFHLG9DQUFvQztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRDs7Ozs7Ozs7Ozs7O0FDWkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE0QztBQUNFO0FBQ3ZDO0FBQ1A7QUFDQSwrQkFBK0IsOERBQVc7QUFDMUMsK0JBQStCLDhEQUFXO0FBQzFDLG1CQUFtQiw4REFBVztBQUM5Qiw0QkFBNEIsZ0RBQWdELEdBQUcsZ0RBQWdELEdBQUcsb0NBQW9DO0FBQ3RLLG1CQUFtQiwwREFBbUI7QUFDdEM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQW1CO0FBQ3RDO0FBQ0E7QUFDQSw2RDs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQUE7QUFBQTtBQUFvQztBQUM3QjtBQUNQO0FBQ0E7QUFDQSxhQUFhLHVEQUFRO0FBQ3JCO0FBQ0E7QUFDQSw0QkFBNEIsb0VBQW9FO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLHFEOzs7Ozs7Ozs7Ozs7QUNYQTtBQUFBO0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUQ7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQUE7QUFBQTtBQUE0QztBQUNyQztBQUNQLFdBQVcsMERBQU87QUFDbEIsZUFBZSx5REFBTSxDQUFDLDREQUFTO0FBQy9CLEtBQUs7QUFDTDtBQUNBLCtDOzs7Ozs7Ozs7Ozs7QUNOQTtBQUFBO0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsVUFBVSxFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0M7Ozs7Ozs7Ozs7OztBQzNCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBNEI7QUFDYTtBQUNJO0FBQ0Y7QUFDRjtBQUNXO0FBQ1I7QUFDSjtBQUNUO0FBQ1A7QUFDeEIsaUM7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQUE7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsaUQ7Ozs7Ozs7Ozs7OztBQ1BBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDOEI7QUFDL0IsaUM7Ozs7Ozs7Ozs7OztBQ1RBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBNEM7QUFDZjtBQUNvQjtBQUNtQztBQUM3QjtBQUNQO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyQkFBMkI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3Q0FBRywyQkFBMkIsMkVBQXFCO0FBQzdGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQUssbURBQW1ELG1EQUFtRCxFQUFFO0FBQ2hJLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0VBQXlCLEVBQUUsK0JBQStCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1QkFBdUI7QUFDL0Q7QUFDQSxlQUFlLDBEQUFPO0FBQ3RCLCtCQUErQixvREFBSztBQUNwQztBQUNBLHFDQUFxQyw0REFBUztBQUM5QyxvQ0FBb0MseURBQVU7QUFDOUMsZ0NBQWdDLG9FQUFXO0FBQzNDO0FBQ0Esb0NBQW9DLDJEQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3Q0FBRztBQUN4QywyQkFBMkIsNkRBQVUsWUFBWSxvRUFBYTtBQUM5RDtBQUNBO0FBQ0EsYUFBYTtBQUNiLDhCQUE4QiwyREFBUSxnQ0FBZ0Msb0JBQW9CLEVBQUU7QUFDNUY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDbUI7QUFDcEIsb0M7Ozs7Ozs7Ozs7OztBQ2pKQTtBQUFBO0FBQUE7QUFBQTtBQUE2QjtBQUNtQjtBQUN6QztBQUNQO0FBQ0EsNkJBQTZCLHdDQUFHLG9CQUFvQixvRUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0Qzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQUE7QUFBQTtBQUE2QjtBQUN0QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3Q0FBRztBQUN6QixzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5Qzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTZCO0FBQytCO0FBQ0Y7QUFDVjtBQUN6QztBQUNQO0FBQ0EsOEJBQThCLHdDQUFHO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG9CQUFvQix3Q0FBRztBQUN2QiwwQ0FBMEMsb0VBQWE7QUFDdkQ7QUFDQTtBQUNBLHFCQUFxQiw4RUFBa0I7QUFDdkMsK0JBQStCLCtCQUErQjtBQUM5RDtBQUNBLFFBQVEsZ0ZBQW1CO0FBQzNCO0FBQ0E7QUFDQSxRQUFRLGdGQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSx3Qzs7Ozs7Ozs7Ozs7O0FDM0JBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErQztBQUNIO0FBQ2E7QUFDUDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyx1REFBUztBQUNwQixlQUFlLHlEQUFXO0FBQzFCLGlCQUFpQix5REFBVSxrQkFBa0IseURBQVU7QUFDdkQ7QUFDQTtBQUNBLGdCQUFnQix5REFBVTtBQUMxQjtBQUNBO0FBQ0Esa0NBQWtDLDBEQUFPO0FBQ3pDLHFEQUFxRCx5REFBVTtBQUMvRCwrREFBK0QsdUJBQXVCLG9FQUFhO0FBQ25HO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEMsNkNBQTZDLG9EQUFvRCxFQUFFO0FBQ25HO0FBQ0E7QUFDQSwrQkFBK0IsNkRBQVU7QUFDekMscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSw4Qzs7Ozs7Ozs7Ozs7O0FDdENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErQztBQUNVO0FBQzVCO0FBQ2lCO0FBQ2M7QUFDQTtBQUNsQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyx1REFBUztBQUNwQjtBQUNBLGVBQWUseURBQVc7QUFDMUI7QUFDQTtBQUNBLDZCQUE2Qix3Q0FBRztBQUNoQztBQUNBO0FBQ0EseUNBQXlDLDhEQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnRkFBbUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0ZBQW1CO0FBQzdDLDJEQUEyRCx1QkFBdUIsb0VBQWE7QUFDL0Y7QUFDQSw4QkFBOEIsRUFBRTtBQUNoQyw2Q0FBNkMsNERBQTRELEVBQUU7QUFDM0c7QUFDQTtBQUNBLDBDQUEwQyxrRUFBWSxFQUFFLCtCQUErQjtBQUN2Riw0QkFBNEIsZ0ZBQW1CO0FBQy9DO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0Esd0M7Ozs7Ozs7Ozs7OztBQ3pEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQStDO0FBQ0M7QUFDRjtBQUN2QztBQUNQLFdBQVcsdURBQVM7QUFDcEI7QUFDQSxlQUFlLHlEQUFXO0FBQzFCO0FBQ0EsNkNBQTZDLGtFQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0VBQWE7QUFDdkQ7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0Esc0M7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUFBO0FBQUE7QUFBQTtBQUErQztBQUNEO0FBQ3ZDO0FBQ1AsV0FBVyx1REFBUztBQUNwQixlQUFlLHlEQUFXO0FBQzFCO0FBQ0EsNkNBQTZDLGtFQUFZO0FBQ3pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EscUM7Ozs7Ozs7Ozs7OztBQ1pBO0FBQUE7QUFBQTtBQUFBO0FBQStDO0FBQ0Q7QUFDdkM7QUFDUCxXQUFXLHVEQUFTO0FBQ3BCO0FBQ0EsZUFBZSx5REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0VBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLDJDOzs7Ozs7Ozs7Ozs7QUNoQkE7QUFBQTtBQUFBO0FBQUE7QUFBK0M7QUFDbEI7QUFDdEI7QUFDUCxXQUFXLHVEQUFTO0FBQ3BCO0FBQ0EsZUFBZSx5REFBVztBQUMxQjtBQUNBO0FBQ0EsNEJBQTRCLHdDQUFHO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0Esd0M7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUFBO0FBQUE7QUFBQTtBQUE2QjtBQUNpQjtBQUN2QztBQUNQLGFBQWEsd0NBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtFQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDOzs7Ozs7Ozs7Ozs7QUNqQkE7QUFBQTtBQUFBO0FBQUE7QUFBbUQ7QUFDdEI7QUFDdEI7QUFDUCxhQUFhLHdDQUFHO0FBQ2hCO0FBQ0EsbUJBQW1CLDhEQUFVO0FBQzdCO0FBQ0E7QUFDQSxtQkFBbUIsOERBQVU7QUFDN0I7QUFDQSxlQUFlLDhEQUFVO0FBQ3pCO0FBQ0EsOEM7Ozs7Ozs7Ozs7OztBQ1pBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErQztBQUNIO0FBQ2Y7QUFDUztBQUMvQjtBQUNQLFdBQVcsdURBQVM7QUFDcEI7QUFDQSxlQUFlLHlEQUFXO0FBQzFCO0FBQ0E7QUFDQSw2Q0FBNkMsd0NBQUc7QUFDaEQsK0NBQStDLHlEQUFVO0FBQ3pELGtDQUFrQywwREFBTyxjQUFjLDJEQUEyRCxFQUFFO0FBQ3BILHlDQUF5Qyw2REFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLCtDOzs7Ozs7Ozs7Ozs7QUN0QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTZCO0FBQ3dDO0FBQ1Q7QUFDRjtBQUNuRDtBQUNQLGlDQUFpQyxxQkFBcUI7QUFDdEQsYUFBYSx3Q0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhFQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0VBQVksRUFBRSxzQ0FBc0M7QUFDM0Usd0RBQXdELDJFQUFxQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdGQUFtQjtBQUN2QjtBQUNBO0FBQ0EseUM7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBbUM7QUFDSDtBQUNEO0FBQ0E7QUFDTTtBQUNSO0FBQ0Q7QUFDTTtBQUNIO0FBQ087QUFDRDtBQUNDO0FBQ047QUFDQztBQUNEO0FBQ0E7QUFDRTtBQUNQO0FBQ0k7QUFDRjtBQUM3QixpQzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQUE7QUFBQTtBQUE2QjtBQUN0QjtBQUNQLGFBQWEsd0NBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQzs7Ozs7Ozs7Ozs7O0FDUEE7QUFBQTtBQUFBO0FBQTZCO0FBQ3RCO0FBQ1AsYUFBYSx3Q0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5Qzs7Ozs7Ozs7Ozs7O0FDTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQStDO0FBQ0g7QUFDVTtBQUNkO0FBQ2pDO0FBQ1AsV0FBVyx1REFBUztBQUNwQjtBQUNBLGVBQWUseURBQVc7QUFDMUI7QUFDQTtBQUNBLHlCQUF5Qix5RUFBWTtBQUNyQyx5Q0FBeUMsNERBQVM7QUFDbEQ7QUFDQTtBQUNBLDBDQUEwQyx3REFBSztBQUMvQztBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSx5Qzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQUE7QUFBQTtBQUEwRDtBQUNuRDtBQUNQLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQSxVQUFVLDhFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSwyQzs7Ozs7Ozs7Ozs7O0FDVkE7QUFBQTtBQUFBO0FBQTZCO0FBQ3RCO0FBQ1AsU0FBUyx3Q0FBRztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0M7Ozs7Ozs7Ozs7OztBQ1BBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBK0M7QUFDRztBQUNJO0FBQ0o7QUFDWjtBQUNRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHVEQUFTO0FBQ3BCO0FBQ0EsZUFBZSx5REFBVztBQUMxQjtBQUNBO0FBQ0EsMENBQTBDLGtEQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0VBQW9FO0FBQ3JILG1EQUFtRCwwREFBWTtBQUMvRDtBQUNBLDZCQUE2QixzRUFBYyxZQUFZLHlEQUFVLFlBQVkseURBQVU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5REFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxzRkFBc0YsUUFBUSxzRUFBYyxXQUFXLDBFQUFnQixRQUFRLEVBQUU7QUFDako7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtEQUFRO0FBQ3REO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLHNDOzs7Ozs7Ozs7Ozs7QUN2REE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWlDO0FBQ2dDO0FBQ3FCO0FBQ3RGO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZEQUFjO0FBQzFDO0FBQ0E7QUFDQSxvQ0FBb0MsbUVBQW9CLGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0EsQ0FBQztBQUN5QjtBQUMxQjtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0MsdUJBQXVCLDRDQUFHO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvRkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQWEsV0FBVywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNrQjtBQUNuQixtQzs7Ozs7Ozs7Ozs7O0FDeENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUF5RDtBQUNJO0FBQ0k7QUFDSTtBQUN6QjtBQUM1QztBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNtQztBQUNwQztBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0ZBQW1CO0FBQ3JDO0FBQ0EsdURBQXVELHdFQUFlO0FBQ3RFO0FBQ0E7QUFDQSxZQUFZLGdFQUFXO0FBQ3ZCLFlBQVksZ0VBQVc7QUFDdkIsWUFBWSxnRUFBVztBQUN2QixZQUFZLGdFQUFXO0FBQ3ZCLFlBQVksZ0VBQVc7QUFDdkIsWUFBWSxnRUFBVztBQUN2QixZQUFZLGdFQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QjtBQUN0QjtBQUNQO0FBQ0E7QUFDQSxxQ0FBcUMsb0VBQWE7QUFDbEQ7QUFDQSxlQUFlLHdGQUFtQjtBQUNsQztBQUNBLHNJQUFzSTtBQUN0STtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkM7Ozs7Ozs7Ozs7OztBQ2pFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBaUU7QUFDZDtBQUM1QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMrQjtBQUNoQztBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQ0FBaUMsRUFBRSw0QkFBNEIsMEJBQTBCLEVBQUU7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxxQkFBcUIsc0VBQVk7QUFDakMsa0JBQWtCLG9GQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDd0I7QUFDekIseUM7Ozs7Ozs7Ozs7OztBQzdFQTtBQUFBO0FBQU87QUFDUCw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFpQztBQUN3QjtBQUNZO0FBQ3BDO0FBQ0c7QUFDN0I7QUFDUDtBQUNBO0FBQ0EsbUNBQW1DLG9FQUFhO0FBQ2hEO0FBQ0EsZUFBZSx3RkFBbUI7QUFDbEMsaUNBQWlDLG9FQUFhO0FBQzlDO0FBQ0EsZUFBZSx3RkFBbUIsZ0NBQWdDLDRDQUFHO0FBQ3JFLGlDQUFpQyxvREFBSztBQUN0QyxZQUFZLGdEQUFPLE9BQU8sZUFBZTtBQUN6QyxLQUFLO0FBQ0w7QUFDQSwwQzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBbUM7QUFDb0I7QUFDYztBQUNJO0FBQ3hDO0FBQ2U7QUFDekM7QUFDUCxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQSxnQ0FBZ0Msa0VBQWU7QUFDL0M7QUFDQSxlQUFlLDRGQUFxQjtBQUNwQztBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0EsOERBQThELHlDQUF5QyxFQUFFO0FBQ3pHLHFCQUFxQix3RkFBbUI7QUFDeEM7QUFDQSxzQ0FBc0MsOENBQUs7QUFDM0MsZ0NBQWdDLDREQUFhLHVDQUF1QyxpQ0FBaUMsb0RBQUsseUJBQXlCLEVBQUU7QUFDcko7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBOEI7QUFDRztBQUNLO0FBQ1o7QUFDVTtBQUNKO0FBQ2hDLGlDOzs7Ozs7Ozs7Ozs7QUNOQTtBQUFBO0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseUNBQXlDLEVBQUU7QUFDckYseUNBQXlDLHNDQUFzQyxFQUFFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEM7Ozs7Ozs7Ozs7OztBQ25CQTtBQUFBO0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw0SEFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDOzs7Ozs7Ozs7Ozs7QUN6QkE7QUFBQTtBQUFBO0FBQUE7QUFBaUM7QUFDcUI7QUFDL0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBFQUFnQjtBQUNyQyxXQUFXLHNEQUFRLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLDJDOzs7Ozs7Ozs7Ozs7O0FDN0NBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXNEO0FBQ0E7QUFDRjtBQUNaO0FBQ0Y7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFTO0FBQ2pCLGVBQWUsMEVBQWdCO0FBQy9CO0FBQ0EsUUFBUSwwREFBUTtBQUNoQixlQUFlLHdFQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxxQkFBcUIsRUFBRTtBQUN0Ryw2RUFBNkUsb0JBQW9CLEVBQUU7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtFQUFnQjtBQUN0QyxzQkFBc0Isa0VBQWdCO0FBQ3RDLHFCQUFxQixnRUFBZTtBQUNwQztBQUNBLGVBQWUsb0RBQVM7QUFDeEIsY0FBYyxrREFBUTtBQUN0QjtBQUNBO0FBQ0EsaUM7Ozs7Ozs7Ozs7OztBQ3REQTtBQUFBO0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7Ozs7Ozs7OztBQ1RBO0FBQUE7QUFBTztBQUNQO0FBQ0EsV0FBVyxVQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQzs7Ozs7Ozs7Ozs7OztBQ1JBO0FBQUE7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCLEVBQUU7QUFDekQsc0NBQXNDLGdDQUFnQyxFQUFFO0FBQ3hFO0FBQ0EsNkM7Ozs7Ozs7Ozs7OztBQ1RBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMEQ7QUFDZDtBQUNSO0FBQ2dEO0FBQ3JCO0FBQ1g7QUFDcEQ7QUFDQSxJQUFJLHVEQUFTO0FBQ2I7QUFDQSw4Q0FBOEMsNEJBQTRCLCtGQUFvQixHQUFHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBTyxjQUFjLFFBQVEsNkRBQVUsc0JBQXNCLEVBQUU7QUFDOUU7QUFDQTtBQUNBLGVBQWUsdURBQVM7QUFDeEI7QUFDQSxtQkFBbUIseURBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVEQUFVO0FBQ3ZEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLHVEQUFTO0FBQ3hCO0FBQ0E7QUFDQSxtQkFBbUIseURBQVc7QUFDOUI7QUFDQSxpREFBaUQsdURBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw2REFBVSx3QkFBd0IsUUFBUSx1REFBUztBQUM1RztBQUNBLHVDQUF1Qyx5REFBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkIsRUFBRSxFQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVksZ0VBQWUsZUFBZSxFQUFFO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLDBFQUFhO0FBQ2M7QUFDN0IsNkM7Ozs7Ozs7Ozs7OztBQzdFQTtBQUFBO0FBQUE7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVSx5REFBeUQsRUFBRSxFQUFFO0FBQy9HLHFDQUFxQyx3Q0FBd0MsRUFBRTtBQUMvRTtBQUNBO0FBQ0EsQ0FBQztBQUMwQjtBQUMzQiwyQzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFvQztBQUNGO0FBQ2xDLGlDOzs7Ozs7Ozs7Ozs7QUNGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUEwRDtBQUNkO0FBQ1I7QUFDYTtBQUNkO0FBQ1E7QUFDSztBQUMwQjtBQUMxRTtBQUNBLElBQUksdURBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBTztBQUN0QjtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFTLDJCQUEyQiw0REFBUztBQUMxRSxzQkFBc0IsK0RBQVc7QUFDakMsa0JBQWtCLCtEQUFXO0FBQzdCLGtCQUFrQiwrREFBVztBQUM3QixrQkFBa0IsK0RBQVc7QUFDN0Isa0JBQWtCLDZEQUFVO0FBQzVCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLHVEQUFTO0FBQ3hCO0FBQ0EsbUJBQW1CLHlEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1REFBVTtBQUN2RDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4RkFBMEI7QUFDekM7QUFDQTtBQUNBLGVBQWUsb0VBQWE7QUFDNUI7QUFDQTtBQUNBLENBQUMsQ0FBQyw0REFBYTtBQUNpQjtBQUNoQyxnRDs7Ozs7Ozs7Ozs7O0FDdkRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTBEO0FBQ2Q7QUFDUjtBQUNhO0FBQ2Q7QUFDUTtBQUN1QztBQUMxQjtBQUN4RDtBQUNBLElBQUksdURBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBTztBQUN0QjtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFTLDJCQUEyQiw0REFBUztBQUMxRSxzQkFBc0IsK0RBQVc7QUFDakMsa0JBQWtCLCtEQUFXO0FBQzdCLGtCQUFrQiwrREFBVztBQUM3QixrQkFBa0IsNkRBQVU7QUFDNUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsdURBQVM7QUFDeEI7QUFDQSxtQkFBbUIseURBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVEQUFVO0FBQ3ZEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNHQUE4QjtBQUM3QztBQUNBO0FBQ0EsZUFBZSw0RUFBaUI7QUFDaEM7QUFDQTtBQUNBLENBQUMsQ0FBQyw0REFBYTtBQUNxQjtBQUNwQyxvRDs7Ozs7Ozs7Ozs7O0FDdERBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBNEM7QUFDOEI7QUFDbkU7QUFDUCxrQ0FBa0Msc0JBQXNCO0FBQ3hELFdBQVcsMERBQU87QUFDbEIsbUJBQW1CLDBEQUFPO0FBQzFCLGNBQWMseURBQU0sQ0FBQyw0REFBUztBQUM5QixjQUFjLDZGQUFzQjtBQUNwQyxtQkFBbUIsNkZBQXNCO0FBQ3pDLGtCQUFrQiwwREFBTyxDQUFDLHlEQUFNO0FBQ2hDLG1CQUFtQiw2RkFBc0I7QUFDekMsZUFBZSwwREFBTyxDQUFDLHlEQUFNLE9BQU8seURBQU07QUFDMUMsS0FBSztBQUNMO0FBQ087QUFDUCxrQ0FBa0Msc0JBQXNCO0FBQ3hELGlDQUFpQyxvQkFBb0I7QUFDckQsV0FBVywwREFBTztBQUNsQixtQkFBbUIsMERBQU87QUFDMUIsY0FBYyx5REFBTSxDQUFDLDREQUFTO0FBQzlCLGNBQWMsNkZBQXNCO0FBQ3BDLG1CQUFtQiw2RkFBc0I7QUFDekMsa0JBQWtCLDBEQUFPLENBQUMseURBQU07QUFDaEMsbUJBQW1CLDZGQUFzQjtBQUN6QyxrQkFBa0IsMERBQU8sQ0FBQyx5REFBTSxPQUFPLHlEQUFNO0FBQzdDLG1CQUFtQiw2RkFBc0I7QUFDekMsZUFBZSwwREFBTyxDQUFDLHlEQUFNLE9BQU8seURBQU0sT0FBTyx5REFBTTtBQUN2RCxLQUFLO0FBQ0w7QUFDQSxzQzs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQUE7QUFBQTtBQUFBO0FBQWtEO0FBQ007QUFDakQ7QUFDUDtBQUNBLGFBQWEscUVBQXFCO0FBQ2xDLG1DQUFtQyw0RUFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx5Qzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQUE7QUFBQTtBQUFBO0FBQXVEO0FBQ0M7QUFDakQ7QUFDUDtBQUNBLG1DQUFtQyw0RUFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwRUFBMEI7QUFDOUIsWUFBWTtBQUNaO0FBQ0Esc0Q7Ozs7Ozs7Ozs7OztBQ2RBO0FBQUE7QUFBQTtBQUFBO0FBQXVEO0FBQ0M7QUFDakQ7QUFDUDtBQUNBLG1DQUFtQyw0RUFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMEVBQTBCO0FBQzlCLFlBQVk7QUFDWjtBQUNBLDBEOzs7Ozs7Ozs7Ozs7QUNiQTtBQUFBO0FBQUE7QUFBQTtBQUFrRDtBQUNNO0FBQ2pEO0FBQ1A7QUFDQSxhQUFhLHFFQUFxQjtBQUNsQyxtQ0FBbUMsNEVBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDZDOzs7Ozs7Ozs7Ozs7QUNqQkE7QUFBQTtBQUFBO0FBQXlGO0FBQ2xGO0FBQ1AsNEJBQTRCLHdFQUF3QjtBQUNwRCxxQ0FBcUMsaUZBQWlDO0FBQ3RFO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkM7Ozs7Ozs7Ozs7OztBQ3hCQTtBQUFBO0FBQUE7QUFBQTtBQUFzRjtBQUNkO0FBQ2pFO0FBQ1AsNkJBQTZCLHlFQUF5QjtBQUN0RCw0QkFBNEIsMkZBQXFCO0FBQ2pELHFDQUFxQyw4RUFBOEI7QUFDbkU7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDOzs7Ozs7Ozs7Ozs7QUM5QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFrQztBQUNrRDtBQUNwQjtBQUNoRTtBQUNBLElBQUksdURBQVM7QUFDYjtBQUNBLDhDQUE4Qyw0QkFBNEIsK0ZBQW9CLEdBQUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLDRFQUFxQjtBQUNNO0FBQzdCLDZDOzs7Ozs7Ozs7Ozs7QUNsQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTBEO0FBQ2Q7QUFDVDtBQUMwQjtBQUN6QjtBQUMyQjtBQUM3QjtBQUNsQztBQUNBLElBQUksdURBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZSwwREFBTztBQUN0QjtBQUNBLHVCQUF1QiwyREFBUTtBQUMvQixvQkFBb0IsMERBQU87QUFDM0Isb0JBQW9CLDBEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw4Q0FBOEMsY0FBYyxFQUFFLEVBQUU7QUFDbkgsbURBQW1ELDhDQUE4QyxjQUFjLEVBQUUsRUFBRTtBQUNuSDtBQUNBLHFCQUFxQiwwREFBTztBQUM1QixxQkFBcUIsMkRBQVE7QUFDN0I7QUFDQSxhQUFhO0FBQ2IscUJBQXFCLDJEQUFRO0FBQzdCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMERBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtCQUErQjtBQUN4RCxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLHVEQUFTO0FBQ3hCO0FBQ0EsbUJBQW1CLHlEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1REFBVTtBQUN2RDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSx1REFBUztBQUN4QjtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFXO0FBQzlCO0FBQ0EsaURBQWlELHVEQUFVO0FBQzNEO0FBQ0E7QUFDQSwwQ0FBMEMsMERBQU8sY0FBYyxRQUFRLDZEQUFVLCtCQUErQixFQUFFO0FBQ2xILGtIQUFrSCxRQUFRLHVEQUFTO0FBQ25JO0FBQ0EsdUNBQXVDLHlEQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixRQUFRLHFEQUFNLElBQUksRUFBRTtBQUNqSCw2RkFBNkYsU0FBUyxxREFBTSxJQUFJLEVBQUU7QUFDbEgsc0VBQXNFLHdFQUFlLHdDQUF3QyxZQUFZLDhDQUFLLHlCQUF5QixFQUFFO0FBQ3pLO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCLEVBQUUsRUFBRTtBQUNqQztBQUNBO0FBQ0EsOERBQThELG9CQUFvQixFQUFFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLDBFQUFhO0FBQ2tCO0FBQ2pDLGlEOzs7Ozs7Ozs7Ozs7QUNqSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFrQztBQUMwRDtBQUM1QjtBQUNoRTtBQUNBLElBQUksdURBQVM7QUFDYjtBQUNBLDhDQUE4Qyw0QkFBNEIsdUdBQXdCLEdBQUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLDRFQUFxQjtBQUNVO0FBQ2pDLGlEOzs7Ozs7Ozs7Ozs7QUNsQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWtDO0FBQ3NCO0FBQ3BCO0FBQ0k7QUFDeEM7QUFDQSxJQUFJLHVEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsb0VBQWlCO0FBQ1E7QUFDM0IsaUM7Ozs7Ozs7Ozs7OztBQ1pBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWtDO0FBQ1U7QUFDd0I7QUFDbEM7QUFDZTtBQUNEO0FBQzBCO0FBQzlCO0FBQzVDO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFPO0FBQ3RCLHNEQUFzRCw2Q0FBUTtBQUM5RDtBQUNBO0FBQ0EsbUJBQW1CLHVGQUFtQjtBQUN0QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBDQUEwQyx5QkFBeUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvRUFBYTtBQUM1QjtBQUNBO0FBQ0EsaUJBQWlCLGdFQUFrQjtBQUNuQztBQUNBLGVBQWUsOEZBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsNERBQWE7QUFDVTtBQUN6Qix5Qzs7Ozs7Ozs7Ozs7O0FDakVBO0FBQUE7QUFBQTtBQUEwRTtBQUNuRTtBQUNQO0FBQ0EsYUFBYSxxRUFBcUI7QUFDbEMsMEJBQTBCLHNFQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHlDOzs7Ozs7Ozs7Ozs7QUNkQTtBQUFBO0FBQUE7QUFBa0Y7QUFDM0U7QUFDUDtBQUNBLDZCQUE2Qix5RUFBeUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwRUFBMEI7QUFDOUIsWUFBWTtBQUNaO0FBQ0Esc0Q7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQUE7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaO0FBQ0EsZ0M7Ozs7Ozs7Ozs7OztBQ1RBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMEQ7QUFDZDtBQUNSO0FBQ2E7QUFDZDtBQUNJO0FBQ1M7QUFDMEI7QUFDakI7QUFDekQ7QUFDQSxJQUFJLHVEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMERBQU87QUFDdEI7QUFDQTtBQUNBLDZCQUE2QixzREFBUywyQkFBMkIsNERBQVM7QUFDMUUsc0JBQXNCLDJEQUFRO0FBQzlCLGtCQUFrQiw2REFBVTtBQUM1QixrQkFBa0IsK0RBQVE7QUFDMUIsa0JBQWtCLCtEQUFRO0FBQzFCLGtCQUFrQiwrREFBUTtBQUMxQixrQkFBa0IsbUVBQVk7QUFDOUIsa0JBQWtCLCtEQUFRO0FBQzFCLGtCQUFrQiwrREFBUTtBQUMxQixrQkFBa0IsK0RBQVE7QUFDMUIsa0JBQWtCLG1FQUFZO0FBQzlCLGtCQUFrQiwrREFBUTtBQUMxQixrQkFBa0IsK0RBQVE7QUFDMUIsa0JBQWtCLG1FQUFZO0FBQzlCLGtCQUFrQiwrREFBUTtBQUMxQixrQkFBa0IsK0RBQVE7QUFDMUIsa0JBQWtCLG1FQUFZO0FBQzlCO0FBQ0EsaUNBQWlDLDREQUFTO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLHVEQUFTO0FBQ3hCO0FBQ0EsbUJBQW1CLHlEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1REFBVTtBQUN2RDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSx1REFBUztBQUN4QjtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFXO0FBQzlCO0FBQ0EsaURBQWlELHVEQUFVO0FBQzNEO0FBQ0E7QUFDQSxnREFBZ0QsMERBQU8sY0FBYyxRQUFRLDZEQUFVLCtCQUErQixFQUFFO0FBQ3hILGlHQUFpRyxpQkFBaUIsRUFBRTtBQUNwSDtBQUNBO0FBQ0Esb0VBQW9FLG9CQUFvQixFQUFFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4RkFBMEI7QUFDekM7QUFDQTtBQUNBLGVBQWUsb0VBQWE7QUFDNUI7QUFDQTtBQUNBLENBQUMsQ0FBQyw0REFBYTtBQUNlO0FBQzlCLDhDOzs7Ozs7Ozs7Ozs7QUMxRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTRDO0FBQ1A7QUFDckM7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0EsY0FBYyw0REFBUztBQUN2QixVQUFVLHlEQUFNO0FBQ2hCLFVBQVUseURBQUs7QUFDZixzQkFBc0IsMERBQU87QUFDN0I7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxxQzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBNEM7QUFDTTtBQUNmO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBTztBQUNuQjtBQUNBO0FBQ0EsZUFBZSwwREFBTyxjQUFjLFFBQVEsK0RBQVksQ0FBQyw4REFBVyxzRUFBc0UsRUFBRTtBQUM1STtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOERBQVc7QUFDOUIsNEJBQTRCLHVDQUF1QyxHQUFHLG9DQUFvQztBQUMxRyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHNCQUFzQiw4REFBVztBQUNqQyxxQkFBcUIsOERBQVc7QUFDaEMsNEJBQTRCLHVDQUF1QyxHQUFHLHNDQUFzQztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxhQUFhLHFFQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwREFBTyxjQUFjLFFBQVEsK0RBQVksQ0FBQyw4REFBVyxpREFBaUQsRUFBRTtBQUNySCx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLHlDOzs7Ozs7Ozs7Ozs7QUN2RkE7QUFBQTtBQUFBO0FBQUE7QUFBa0Y7QUFDNUM7QUFDdEM7QUFDQSw2QkFBNkIseUVBQXlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVEsK0JBQStCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RCxTQUFTLHlEQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBFQUEwQjtBQUM5QixZQUFZO0FBQ1o7QUFDQSxzRDs7Ozs7Ozs7Ozs7O0FDdEVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMEQ7QUFDckI7QUFDOUI7QUFDUCxrQkFBa0Isc0VBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7Ozs7Ozs7QUNQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdUM7QUFDSztBQUNhO0FBQ2xEO0FBQ1AsY0FBYyx1REFBSTtBQUNsQixVQUFVLDZEQUFVO0FBQ3BCLFVBQVUseURBQU07QUFDaEIsVUFBVSwwREFBTztBQUNqQjtBQUNBO0FBQ087QUFDUCxjQUFjLDJEQUFRO0FBQ3RCLFVBQVUsNkRBQVU7QUFDcEIsaUJBQWlCLDZEQUFVO0FBQzNCLGdCQUFnQiwyREFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNERBQWM7QUFDdEM7QUFDQSxxQkFBcUIsMkRBQVE7QUFDN0IsY0FBYyw0REFBUztBQUN2Qix3QkFBd0IsNERBQWM7QUFDdEM7QUFDQSxxQkFBcUIsMkRBQVE7QUFDN0IsY0FBYyw0REFBUztBQUN2QjtBQUNBLHFCQUFxQiw0REFBUztBQUM5QixVQUFVLHlEQUFNO0FBQ2hCLFVBQVUsMERBQU87QUFDakI7QUFDQTtBQUNBLHlDOzs7Ozs7Ozs7Ozs7QUNoQ0E7QUFBQTtBQUFBO0FBQTRDO0FBQ3JDO0FBQ1AsV0FBVyx5REFBTSxDQUFDLHlEQUFNO0FBQ3hCO0FBQ0Esc0M7Ozs7Ozs7Ozs7OztBQ0pBO0FBQUE7QUFBQTtBQUFPO0FBQ1A7QUFDQTtBQUNPO0FBQ1AscUJBQXFCO0FBQ3JCLDJCQUEyQjtBQUMzQjtBQUNBLG1DOzs7Ozs7Ozs7Ozs7QUNQQTtBQUFBO0FBQU87QUFDUCxxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCO0FBQ0EsOEM7Ozs7Ozs7Ozs7OztBQ0pBO0FBQUE7QUFBQTtBQUFBO0FBQXlEO0FBQ2xEO0FBQ1AsdUNBQXVDLG9FQUFhO0FBQ3BEO0FBQ087QUFDUCxxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCO0FBQ0EsNkM7Ozs7Ozs7Ozs7OztBQ1JBO0FBQUE7QUFBQTtBQUFBO0FBQXVFO0FBQ2hFO0FBQ1AseUNBQXlDLGtGQUFlO0FBQ3hEO0FBQ087QUFDUCxxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCO0FBQ0EsK0M7Ozs7Ozs7Ozs7OztBQ1JBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUF5RDtBQUNBO0FBQ0M7QUFDbkQ7QUFDUCxXQUFXLDhFQUFtQjtBQUM5Qix1Q0FBdUMsb0VBQWE7QUFDcEQsZ0RBQWdELG9FQUFhO0FBQzdELHlDQUF5QyxvRUFBYTtBQUN0RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0VBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDZDOzs7Ozs7Ozs7Ozs7QUN0QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErQztBQUNEO0FBQ3ZDO0FBQ1AsOEJBQThCLDBEQUFNLDJCQUEyQiwwREFBTTtBQUNyRSxXQUFXLGlFQUFrQjtBQUM3QjtBQUNPO0FBQ1AscUJBQXFCO0FBQ3JCLDJCQUEyQjtBQUMzQjtBQUNBLHNDOzs7Ozs7Ozs7Ozs7QUNWQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXFDO0FBQ0Q7QUFDRTtBQUNGO0FBQ1Y7QUFDRztBQUM3QixpQzs7Ozs7Ozs7Ozs7O0FDTkE7QUFBQTtBQUFBO0FBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBUztBQUN4QjtBQUNBLG1CQUFtQix5REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLHVEQUFTO0FBQ3hCLG1CQUFtQix5REFBVztBQUM5QjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDeUI7QUFDMUIsMEM7Ozs7Ozs7Ozs7OztBQzNCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTBEO0FBQ2lCO0FBQ3pCO0FBQ29FO0FBQ3hGO0FBQzJHO0FBQ1M7QUFDbEo7QUFDQSxJQUFJLHVEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsOERBQWM7QUFDMEI7QUFDMUM7QUFDQSxJQUFJLHVEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFTO0FBQ3hCO0FBQ0EsbUJBQW1CLHlEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVHQUFnQyw4Q0FBOEM7QUFDM0gsdUNBQXVDLDBDQUFJO0FBQzNDLDZCQUE2QixHQUFHLEVBQUUsaUNBQWlDLDRDQUE0Qyx5QkFBeUIsRUFBRSxFQUFFO0FBQzVJO0FBQ0E7QUFDQSx3RkFBd0YsUUFBUSw4RkFBd0IsK0JBQStCLEVBQUU7QUFDeko7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsMEdBQThDO0FBQ2pFO0FBQ0E7QUFDQSxtQkFBbUIsb0dBQTJDO0FBQzlEO0FBQ0E7QUFDQSxDQUFDO0FBQ3dDO0FBQ3pDO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBUztBQUN4QjtBQUNBLG1CQUFtQix5REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx3R0FBaUMsNENBQTRDLFFBQVEsMENBQUksZ0RBQWdELEVBQUUsaUNBQWlDLDRDQUE0Qyx5QkFBeUIsRUFBRSxFQUFFO0FBQ2xTO0FBQ0E7QUFDQSw4Q0FBOEMsOEZBQXdCO0FBQ3RFO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLDZHQUFpRDtBQUNwRTtBQUNBO0FBQ0EsbUJBQW1CLHVHQUE4QztBQUNqRTtBQUNBO0FBQ0EsQ0FBQztBQUMwQztBQUMzQyx1RDs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTBEO0FBQ2Q7QUFDYztBQUNlO0FBQ3ZCO0FBQzZEO0FBQ2pGO0FBQzJHO0FBQ1M7QUFDbEo7QUFDQSxJQUFJLHVEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMENBQUk7QUFDdEIsa0JBQWtCLDBDQUFJO0FBQ3RCLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQyxDQUFDLDhEQUFjO0FBQ3VCO0FBQ3ZDO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBUztBQUN4QjtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHNCQUFzQixFQUFFO0FBQy9GLG9EQUFvRCw0REFBUztBQUM3RCw2Q0FBNkMsK0RBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx5REFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGdEQUFnRCxFQUFFO0FBQ3RJO0FBQ0E7QUFDQSxvREFBb0QscUJBQXFCLDREQUFTLGdCQUFnQixFQUFFO0FBQ3BHO0FBQ0EsdUNBQXVDLDRGQUF1QjtBQUM5RCw2QkFBNkI7QUFDN0I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsMEdBQThDO0FBQ2pFO0FBQ0E7QUFDQSxtQkFBbUIsb0dBQTJDO0FBQzlEO0FBQ0E7QUFDQSxtQkFBbUIsMEZBQTZCO0FBQ2hEO0FBQ0E7QUFDQSxDQUFDO0FBQ3FDO0FBQ3RDO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBUztBQUN4QjtBQUNBLG1CQUFtQix5REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDREQUFTO0FBQzdELDZDQUE2QywrREFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHlEQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QscUJBQXFCLDREQUFTLGdCQUFnQixFQUFFO0FBQ3BHLDhDQUE4Qyw0RkFBdUI7QUFDckU7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsNkdBQWlEO0FBQ3BFO0FBQ0E7QUFDQSxtQkFBbUIsdUdBQThDO0FBQ2pFO0FBQ0E7QUFDQSxtQkFBbUIsNEZBQStCO0FBQ2xEO0FBQ0E7QUFDQSxDQUFDO0FBQ3dDO0FBQ3pDLG9EOzs7Ozs7Ozs7Ozs7QUNoSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTBEO0FBQ2U7QUFDcEI7QUFDMkI7QUFDTTtBQUNwQztBQUNBO0FBQ3FEO0FBQ3pFO0FBQ3dFO0FBQ1M7QUFDL0c7QUFDQSxJQUFJLHVEQUFTO0FBQ2I7QUFDQSxpQ0FBaUMsZUFBZSwyRkFBcUIsR0FBRztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsOERBQWM7QUFDZTtBQUMvQjtBQUNBLElBQUksdURBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQVM7QUFDeEI7QUFDQSxtQkFBbUIseURBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdFQUFZO0FBQzdELDZDQUE2QywwQ0FBSTtBQUNqRDtBQUNBLG9EQUFvRCx5QkFBeUIsRUFBRTtBQUMvRTtBQUNBLG1FQUFtRSxpR0FBdUI7QUFDMUYsZ0RBQWdELFFBQVEsMENBQUksOENBQThDO0FBQzFHLGtEQUFrRCwyRkFBcUI7QUFDdkUsb0RBQW9ELFFBQVEsMENBQUksNENBQTRDO0FBQzVHLHNEQUFzRCw2REFBaUI7QUFDdkUsd0RBQXdELFFBQVEsMENBQUksd0NBQXdDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsdURBQVM7QUFDNUQ7QUFDQSxtQkFBbUIseURBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsUUFBUSw0RkFBdUIsR0FBRyxhQUFhLEVBQUU7QUFDeEk7QUFDQSxhQUFhO0FBQ2IsU0FBUyxFQUFFLEVBQUU7QUFDYjtBQUNBO0FBQ0EsNENBQTRDLDRCQUE0QjtBQUN4RSxtQkFBbUIsb0ZBQTBCO0FBQzdDO0FBQ0E7QUFDQSxtQkFBbUIsMEZBQTZCO0FBQ2hEO0FBQ0E7QUFDQSxtQkFBbUIsbUZBQTBCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQzZCO0FBQzlCO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBUztBQUN4QjtBQUNBLG1CQUFtQix5REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsdURBQVM7QUFDNUQ7QUFDQSxtQkFBbUIseURBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsNEZBQXVCLEdBQUc7QUFDeEY7QUFDQSxhQUFhO0FBQ2IsU0FBUyxFQUFFLEVBQUU7QUFDYjtBQUNBO0FBQ0EsNENBQTRDLDRCQUE0QjtBQUN4RSxtQkFBbUIsdUZBQTZCO0FBQ2hEO0FBQ0E7QUFDQSxtQkFBbUIsNkZBQWdDO0FBQ25EO0FBQ0E7QUFDQSxtQkFBbUIsc0ZBQTZCO0FBQ2hEO0FBQ0E7QUFDQSxDQUFDO0FBQytCO0FBQ2hDLDRDOzs7Ozs7Ozs7Ozs7QUNySUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFpRDtBQUMwQjtBQUNsQjtBQUN6RDtBQUNBO0FBQ0EsMkNBQTJDLHlCQUF5QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCO0FBQ3pFO0FBQ0EsZ0NBQWdDLHNGQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0ZBQXNCO0FBQ2pEO0FBQ0E7QUFDQSwyQkFBMkIsc0ZBQXNCO0FBQ2pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBCQUEwQixpQ0FBaUMsRUFBRTtBQUM3RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLGdDQUFnQyxFQUFFO0FBQzVEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtCQUErQixRQUFRLDRFQUFpQixxQkFBcUIsRUFBRTtBQUMvRSx1Q0FBdUMsZ0JBQWdCLEVBQUU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNERBQVM7QUFDaEMsU0FBUztBQUNULDJDQUEyQyxvREFBb0QsRUFBRTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDREQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLG9CQUFvQixFQUFFO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVEsc0ZBQXNCLGNBQWMsRUFBRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3NCO0FBQ3ZCLHVDOzs7Ozs7Ozs7Ozs7QUN2RUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUEwRDtBQUNMO0FBQ007QUFDVDtBQUM2RDtBQUNPO0FBQ3hGO0FBQ3FMO0FBQ25OO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsOERBQWM7QUFDdUI7QUFDdkM7QUFDQSxJQUFJLHVEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFTO0FBQ3hCO0FBQ0E7QUFDQSxtQkFBbUIseURBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUdBQWdDLDhDQUE4QyxRQUFRLHVEQUFTO0FBQzVJLHVDQUF1Qyx5REFBVztBQUNsRDtBQUNBLDRHQUE0RyxRQUFRLDBDQUFJLHdDQUF3QyxFQUFFO0FBQ2xLO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCLEVBQUUsRUFBRTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3RUFBYSxDQUFDLDhFQUFnQjtBQUNyRSw2QkFBNkI7QUFDN0I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIseUZBQTZCO0FBQ2hEO0FBQ0E7QUFDQSxDQUFDO0FBQ3FDO0FBQ3RDO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBUztBQUN4QjtBQUNBLG1CQUFtQix5REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx3R0FBaUMsNENBQTRDLFFBQVEsMENBQUksd0NBQXdDLEVBQUU7QUFDaEw7QUFDQTtBQUNBLDhDQUE4Qyx3RUFBYSxDQUFDLDhFQUFnQjtBQUM1RTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQiw0RkFBZ0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDd0M7QUFDekM7QUFDQSxJQUFJLHVEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEdBQThDO0FBQ2pFO0FBQ0E7QUFDQSxtQkFBbUIsMEZBQTZCO0FBQ2hEO0FBQ0E7QUFDQSxDQUFDO0FBQ3NEO0FBQ3ZEO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZHQUFpRDtBQUNwRTtBQUNBO0FBQ0EsbUJBQW1CLDRGQUErQjtBQUNsRDtBQUNBO0FBQ0EsQ0FBQztBQUN5RDtBQUMxRCxtRDs7Ozs7Ozs7Ozs7O0FDcEhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTBEO0FBQ21CO0FBQzNCO0FBQzZEO0FBQ087QUFDeEY7QUFDc0s7QUFDcE07QUFDQSxJQUFJLHVEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyw4REFBYztBQUMwQjtBQUMxQztBQUNBLElBQUksdURBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQVM7QUFDeEI7QUFDQTtBQUNBLG1CQUFtQix5REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1R0FBZ0MsOENBQThDLFFBQVEsdURBQVM7QUFDNUksdUNBQXVDLHlEQUFXO0FBQ2xEO0FBQ0EsNEdBQTRHLFFBQVEsMENBQUksNENBQTRDLEVBQUU7QUFDdEs7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkIsRUFBRSxFQUFFO0FBQ2pDO0FBQ0E7QUFDQSw0RkFBNEYsUUFBUSxnR0FBeUIseUNBQXlDLEVBQUU7QUFDeEs7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsbUZBQTBCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ3dDO0FBQ3pDO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBUztBQUN4QjtBQUNBLG1CQUFtQix5REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx3R0FBaUMsNENBQTRDLFFBQVEsMENBQUksNENBQTRDLEVBQUU7QUFDcEw7QUFDQTtBQUNBLDhDQUE4QyxnR0FBeUI7QUFDdkU7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsc0ZBQTZCO0FBQ2hEO0FBQ0E7QUFDQSxDQUFDO0FBQzJDO0FBQzVDO0FBQ0EsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9HQUEyQztBQUM5RDtBQUNBO0FBQ0EsbUJBQW1CLDBGQUE2QjtBQUNoRDtBQUNBO0FBQ0EsQ0FBQztBQUN5RDtBQUMxRDtBQUNBLElBQUksdURBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1R0FBOEM7QUFDakU7QUFDQTtBQUNBLG1CQUFtQiw0RkFBK0I7QUFDbEQ7QUFDQTtBQUNBLENBQUM7QUFDNEQ7QUFDN0Qsc0Q7Ozs7Ozs7Ozs7OztBQ2hIQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErQztBQUNNO0FBQ0s7QUFDUjtBQUNIO0FBQy9DO0FBQ087QUFDUCxXQUFXLHVEQUFTO0FBQ3BCLGVBQWUseURBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1FQUFjLFlBQVkscUVBQXFCLGtCQUFrQiwrQkFBK0IsS0FBSztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDTztBQUNQLG1DQUFtQyxvQkFBb0I7QUFDdkQsV0FBVyx1REFBUztBQUNwQixlQUFlLHlEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtRUFBYyxZQUFZLDZEQUFpQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDTztBQUNQLG1DQUFtQyxvQkFBb0I7QUFDdkQsV0FBVyx1REFBUztBQUNwQixlQUFlLHlEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtRUFBYyxZQUFZLGdFQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNPO0FBQ1Asb0M7Ozs7Ozs7Ozs7OztBQ25EQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWdGO0FBQ0Y7QUFDdkU7QUFDUCw2QkFBNkIsZUFBZSwyRkFBcUIsR0FBRztBQUNwRSxlQUFlLHNFQUFvQjtBQUNuQztBQUNPO0FBQ1AsNkJBQTZCLGVBQWUsMkZBQXFCLEdBQUc7QUFDcEUsZUFBZSxvRUFBa0I7QUFDakM7QUFDQSx1Qzs7Ozs7Ozs7Ozs7O0FDVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBK0M7QUFDSDtBQUNjO0FBQ1c7QUFDOUQ7QUFDUCx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLE1BQU07QUFDTixXQUFXLHVEQUFTO0FBQ3BCO0FBQ0EsZUFBZSx5REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0ZBQW1CO0FBQ2xEO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDJDQUEyQyw0REFBUztBQUNwRCx5Q0FBeUMsK0RBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx5REFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFCQUFxQiw0REFBUyxnQkFBZ0IsRUFBRTtBQUNoRztBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNPO0FBQ1AsV0FBVyx1REFBUztBQUNwQjtBQUNBLGVBQWUseURBQVc7QUFDMUIsNEdBQTRHLFFBQVEsdURBQVMscUNBQXFDLFFBQVEseURBQVc7QUFDckw7QUFDQSxpQkFBaUIsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUN6QixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EseUQ7Ozs7Ozs7Ozs7OztBQ3REQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMkI7QUFDTTtBQUNhO0FBQ2hCO0FBQ0s7QUFDUTtBQUNiO0FBQ1A7QUFDdkIsaUM7Ozs7Ozs7Ozs7OztBQ1JBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBNEQ7QUFDZTtBQUNGO0FBQ1E7QUFDSDtBQUN2QztBQUMyQjtBQUNNO0FBQzdCO0FBQ3BDO0FBQ1Asd0JBQXdCLDZFQUFjO0FBQ3RDLDBCQUEwQixtRkFBZ0I7QUFDMUMsb0JBQW9CLHNEQUFVO0FBQzlCLGVBQWUsa0RBQUs7QUFDcEIsMkJBQTJCLG9GQUFpQjtBQUM1QywrQkFBK0IsNEZBQXFCO0FBQ3BELDRCQUE0Qix5RkFBa0I7QUFDOUMsMkJBQTJCLHNGQUFpQjtBQUM1QyxzQkFBc0IsdUVBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTyw4Q0FBOEMsc0NBQXNDO0FBQ3BGLGdEQUFnRCx3Q0FBd0M7QUFDeEYscUNBQXFDLDZCQUE2QjtBQUNsRSwwQ0FBMEMsa0NBQWtDO0FBQzVFLDRDQUE0Qyx5Q0FBeUM7QUFDckYsZ0RBQWdELDZDQUE2QztBQUM3RiwrQ0FBK0MsMENBQTBDO0FBQ3pGLDhDQUE4Qyx5Q0FBeUM7QUFDdkYseUNBQXlDLG9DQUFvQztBQUNwRjtBQUNPO0FBQ0E7QUFDQTtBQUNQLGdDOzs7Ozs7Ozs7Ozs7QUNqSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFB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QUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNXZEQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7Ozs7Ozs7O0FDdkx0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOzs7O0FBSWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtB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LFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EOztBQUVuRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTBCLG9CQUFvQixTQUFFO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzN1QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ25GLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTs7QUFFTztBQUNQO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBOztBQUVPO0FBQ1A7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGNBQWM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBOztBQUVPO0FBQ1AsbUNBQW1DLG9DQUFvQztBQUN2RTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUCwyQkFBMkIsK0RBQStELGdCQUFnQixFQUFFLEVBQUU7QUFDOUc7QUFDQSxtQ0FBbUMsTUFBTSw2QkFBNkIsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNqRyxrQ0FBa0MsTUFBTSxpQ0FBaUMsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNwRywrQkFBK0IscUZBQXFGO0FBQ3BIO0FBQ0EsS0FBSztBQUNMOztBQUVPO0FBQ1AsYUFBYSw2QkFBNkIsMEJBQTBCLGFBQWEsRUFBRSxxQkFBcUI7QUFDeEcsZ0JBQWdCLHFEQUFxRCxvRUFBb0UsYUFBYSxFQUFFO0FBQ3hKLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGtDQUFrQyxTQUFTO0FBQzNDLGtDQUFrQyxXQUFXLFVBQVU7QUFDdkQseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQSw2R0FBNkcsT0FBTyxVQUFVO0FBQzlILGdGQUFnRixpQkFBaUIsT0FBTztBQUN4Ryx3REFBd0QsZ0JBQWdCLFFBQVEsT0FBTztBQUN2Riw4Q0FBOEMsZ0JBQWdCLGdCQUFnQixPQUFPO0FBQ3JGO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTLFlBQVksYUFBYSxPQUFPLEVBQUUsVUFBVSxXQUFXO0FBQ2hFLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBOztBQUVPO0FBQ1AsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRU87QUFDUCxpREFBaUQsUUFBUTtBQUN6RCx3Q0FBd0MsUUFBUTtBQUNoRCx3REFBd0QsUUFBUTtBQUNoRTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQixzRkFBc0YsYUFBYSxFQUFFO0FBQ3RILHNCQUFzQixnQ0FBZ0MscUNBQXFDLDBDQUEwQyxFQUFFLEVBQUUsR0FBRztBQUM1SSwyQkFBMkIsTUFBTSxlQUFlLEVBQUUsWUFBWSxvQkFBb0IsRUFBRTtBQUNwRixzQkFBc0Isb0dBQW9HO0FBQzFILDZCQUE2Qix1QkFBdUI7QUFDcEQsNEJBQTRCLHdCQUF3QjtBQUNwRCwyQkFBMkIseURBQXlEO0FBQ3BGOztBQUVPO0FBQ1A7QUFDQSxpQkFBaUIsNENBQTRDLFNBQVMsRUFBRSxxREFBcUQsYUFBYSxFQUFFO0FBQzVJLHlCQUF5Qiw2QkFBNkIsb0JBQW9CLGdEQUFnRCxnQkFBZ0IsRUFBRSxLQUFLO0FBQ2pKOztBQUVPO0FBQ1A7QUFDQTtBQUNBLDJHQUEyRyxzRkFBc0YsYUFBYSxFQUFFO0FBQ2hOLHNCQUFzQiw4QkFBOEIsZ0RBQWdELHVEQUF1RCxFQUFFLEVBQUUsR0FBRztBQUNsSyw0Q0FBNEMsc0NBQXNDLFVBQVUsb0JBQW9CLEVBQUUsRUFBRSxVQUFVO0FBQzlIOztBQUVPO0FBQ1AsZ0NBQWdDLHVDQUF1QyxhQUFhLEVBQUUsRUFBRSxPQUFPLGtCQUFrQjtBQUNqSDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsNENBQTRDO0FBQzVDOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVlLFNBQVNnRyxJQUFULEdBQWdCO0FBQzdCLE1BQU1DLFNBQVMsR0FBRyxTQUFsQjtBQUNBNVQsU0FBTyxDQUFDbkgsR0FBUixDQUNFLENBQ0VnYixxRUFBQSxDQUFrQ0QsU0FBbEMsQ0FERixFQUVFQyxpRUFBQSxDQUE4QkQsU0FBOUIsQ0FGRixFQUdFQyxtRUFBQSxDQUFnQ0QsU0FBaEMsQ0FIRixFQUlFQyxvRUFBQSxDQUFpQ0QsU0FBakMsQ0FKRixFQUtFQyxtRUFBQSxDQUFnQ0QsU0FBaEMsQ0FMRixDQURGLEVBU0dFLElBVEgsQ0FTUXpVLEtBQUssRUFUYixXQVVTLFVBQUM5QyxDQUFEO0FBQUEsV0FBT1gsT0FBTyxDQUFDZ0gsS0FBUixDQUFjckcsQ0FBZCxDQUFQO0FBQUEsR0FWVDs7QUFGNkIsV0FjZDhDLEtBZGM7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUEsNlFBYzdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDRTBVLHFFQUFTLDRRQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNGQyw2QkFERSxHQUNNaFgsUUFBUSxDQUFDaVgsY0FBVCxDQUF3QixZQUF4QixDQUROO0FBRVI5USxpQ0FBUyxDQUFDK1EsWUFBVixDQUNFO0FBQUVGLCtCQUFLLEVBQUU7QUFBVCx5QkFERixFQUVFLFVBQUFHLE1BQU07QUFBQSxpQ0FBSUgsS0FBSyxDQUFDSSxTQUFOLEdBQWtCRCxNQUF0QjtBQUFBLHlCQUZSLEVBR0UsVUFBQWxZLEdBQUc7QUFBQSxpQ0FBSUwsT0FBTyxDQUFDZ0gsS0FBUixDQUFjM0csR0FBZCxDQUFKO0FBQUEseUJBSEw7QUFNQStYLDZCQUFLLENBQUNLLGdCQUFOLENBQXVCLE1BQXZCLEVBQStCLFlBQU07QUFDbkNDLGdDQUFNO0FBQ1AseUJBRkQ7O0FBUlE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFBRCxHQUFUOztBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBZDZCO0FBQUE7QUFBQTs7QUFBQSxXQStCZEEsTUEvQmM7QUFBQTtBQUFBOztBQUFBO0FBQUEsMlFBK0I3QjtBQUFBLHlEQVFXQyxVQVJYO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRV0Esd0JBUlgsMEJBUXdCO0FBQ3BCQywrQkFBZSxHQUFHQyxXQUFXLDRRQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUNBQ0taLDBEQUFBLENBQXVCYSxNQUF2QixFQUErQkMsV0FBL0IsRUFBNENDLG1CQUE1QyxFQURMOztBQUFBO0FBQ3hCQyw4Q0FEd0I7QUFFNUJBLDhDQUFvQixDQUFDQyxPQUFyQixDQUE2QixVQUFBQyxPQUFPLEVBQUk7QUFDdEMsZ0NBQUlBLE9BQU8sQ0FBQ0MsV0FBUixDQUFvQkMsS0FBcEIsR0FBNEIsSUFBNUIsSUFBb0NGLE9BQU8sQ0FBQ0MsV0FBUixDQUFvQkMsS0FBcEIsSUFBNkIsQ0FBckUsRUFBd0U7QUFDdEVDLHFDQUFPLENBQUNDLEtBQVIsQ0FBYzVhLE9BQWQsR0FBd0IsTUFBeEI7QUFDRCw2QkFGRCxNQUVPO0FBQ0wyYSxxQ0FBTyxDQUFDQyxLQUFSLENBQWM1YSxPQUFkLEdBQXdCLE9BQXhCO0FBQ0Q7QUFDRiwyQkFORDtBQU9BNmEsdUNBQWEsQ0FBQ1osZUFBRCxDQUFiO0FBQ0FELG9DQUFVOztBQVZrQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFBRCxJQVcxQixHQVgwQixDQUE3QjtBQVlELGVBckJIOztBQUNRRyxvQkFEUixHQUNpQjFYLFFBQVEsQ0FBQ2lYLGNBQVQsQ0FBd0IsWUFBeEIsQ0FEakI7QUFFUWlCLHFCQUZSLEdBRWtCbFksUUFBUSxDQUFDaVgsY0FBVCxDQUF3QixTQUF4QixDQUZsQjtBQUdFaUIscUJBQU8sQ0FBQ25kLEtBQVIsR0FBZ0IyYyxNQUFNLENBQUNXLFdBQXZCO0FBQ0FILHFCQUFPLENBQUNoYyxNQUFSLEdBQWlCd2IsTUFBTSxDQUFDWSxZQUF4QjtBQUNNWCx5QkFMUixHQUtzQixJQUFJZCxtRUFBSixFQUx0QjtBQU9FcUIscUJBQU8sQ0FBQ0MsS0FBUixDQUFjSSxXQUFkLEdBQTRCLFFBQTVCO0FBZUFoQix3QkFBVTs7QUF0Qlo7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0EvQjZCO0FBQUE7QUFBQTs7QUF3RDdCLHNCQUNFLHFFQUFDLDBEQUFEO0FBQUEsNEJBQ0UscUVBQUMsZ0RBQUQ7QUFBQSw2QkFDRTtBQUFBLGtCQUFRdmUsNERBQVNBO0FBQWpCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFERjtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBREYsZUFJRTtBQUFTLGVBQVMsRUFBRXdmLCtEQUFVLENBQUNDLFNBQS9CO0FBQUEsOEJBQ0U7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FERixlQUVFO0FBQU8sVUFBRSxFQUFDLFlBQVY7QUFBdUIsZ0JBQVEsTUFBL0I7QUFBZ0MsYUFBSyxNQUFyQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUZGLGVBR0U7QUFBUSxpQkFBUyxFQUFFRCwrREFBVSxDQUFDRSxNQUE5QjtBQUFzQyxVQUFFLEVBQUM7QUFBekM7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUhGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUpGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQURGO0FBWUQ7S0FwRXVCL0IsSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTnhCLFVBQVUsbUJBQU8sQ0FBQyxtTkFBd0c7QUFDMUgsMEJBQTBCLG1CQUFPLENBQUMsc1RBQXdLOztBQUUxTTs7QUFFQTtBQUNBLDBCQUEwQixRQUFTO0FBQ25DOztBQUVBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBLHNFQUFzRSx3Q0FBd0M7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2Q7QUFDQSxrRUFBa0UsaUJBQWlCLGNBQWMsTUFBTSxZQUFZLGlDQUFpQztBQUNwSixVQUFVLGdCQUFnQixlQUFlLFlBQVksaUNBQWlDO0FBQ3RGLFVBQVUsVUFBVSxlQUFlO0FBQ25DOztBQUVBO0FBQ0EsTUFBTSxzVEFBd0s7QUFDOUs7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxzVEFBd0s7O0FBRWxNOztBQUVBO0FBQ0EsNEJBQTRCLFFBQVM7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsc0M7Ozs7Ozs7Ozs7O0FDM0RBLGU7Ozs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7Ozs7QUNBQSxlIiwiZmlsZSI6InN0YXRpYy9jaHVua3MvcGFnZXMvaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSGVhZCBmcm9tICduZXh0L2hlYWQnXHJcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJ1xyXG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vbGF5b3V0Lm1vZHVsZS5jc3MnXHJcbmltcG9ydCB1dGlsU3R5bGVzIGZyb20gJy4uL3N0eWxlcy91dGlscy5tb2R1bGUuY3NzJ1xyXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnXHJcblxyXG5jb25zdCBuYW1lID0gJ1NtaWxlJ1xyXG5leHBvcnQgY29uc3Qgc2l0ZVRpdGxlID0gJ1NtaWxlJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGF5b3V0KHsgY2hpbGRyZW4sIGhvbWUgfSkge1xyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhaW5lcn0+XHJcbiAgICAgIDxIZWFkPlxyXG4gICAgICAgIDxsaW5rIHJlbD1cImljb25cIiBocmVmPVwiL2Zhdmljb24uaWNvXCIgLz5cclxuICAgICAgPC9IZWFkPlxyXG4gICAgICA8aGVhZGVyIGNsYXNzTmFtZT17c3R5bGVzLmhlYWRlcn0+XHJcbiAgICAgIDwvaGVhZGVyPlxyXG4gICAgICA8bWFpbj57Y2hpbGRyZW59PC9tYWluPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYmFja1RvSG9tZX0+XHJcbiAgICAgICAgICA8TGluayBocmVmPVwiL1wiPlxyXG4gICAgICAgICAgICA8YT7ihpAgQmFjayB0byBob21lPC9hPlxyXG4gICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgKVxyXG59IiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9sYXlvdXQubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLGIsaXNOYW1lZEV4cG9ydCl7aWYoIWEmJmJ8fGEmJiFiKXtyZXR1cm4gZmFsc2U7fWxldCBwO2ZvcihwIGluIGEpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKGFbcF0hPT1iW3BdKXtyZXR1cm4gZmFsc2U7fX1mb3IocCBpbiBiKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZighYVtwXSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vbGF5b3V0Lm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9sYXlvdXQubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXk7IiwiZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlczsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXlcIik7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkOyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZShcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0XCIpO1xuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBzZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0OyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5OyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufSIsImZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZXh0ZW5kczsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2Y7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7XG4gIHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcblxuICByZXR1cm4gY2FjaGU7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpO1xuXG4gIGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQob2JqKTtcbiAgfVxuXG4gIHZhciBuZXdPYmogPSB7fTtcbiAgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG5cbiAgICAgIGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajtcblxuICBpZiAoY2FjaGUpIHtcbiAgICBjYWNoZS5zZXQob2JqLCBuZXdPYmopO1xuICB9XG5cbiAgcmV0dXJuIG5ld09iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDsiLCJmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdDsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDsiLCJmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZTsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWRcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGdldE1vZGVsVXJpcyB9IGZyb20gJy4vY29tbW9uL2dldE1vZGVsVXJpcyc7XHJcbmltcG9ydCB7IGxvYWRXZWlnaHRNYXAgfSBmcm9tICcuL2RvbSc7XHJcbmltcG9ydCB7IGVudiB9IGZyb20gJy4vZW52JztcclxudmFyIE5ldXJhbE5ldHdvcmsgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZXVyYWxOZXR3b3JrKF9uYW1lKSB7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IF9uYW1lO1xyXG4gICAgICAgIHRoaXMuX3BhcmFtcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9wYXJhbU1hcHBpbmdzID0gW107XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmV1cmFsTmV0d29yay5wcm90b3R5cGUsIFwicGFyYW1zXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmFtczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmV1cmFsTmV0d29yay5wcm90b3R5cGUsIFwicGFyYW1NYXBwaW5nc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJhbU1hcHBpbmdzOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXVyYWxOZXR3b3JrLnByb3RvdHlwZSwgXCJpc0xvYWRlZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhIXRoaXMucGFyYW1zOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLmdldFBhcmFtRnJvbVBhdGggPSBmdW5jdGlvbiAocGFyYW1QYXRoKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy50cmF2ZXJzZVByb3BlcnR5UGF0aChwYXJhbVBhdGgpLCBvYmogPSBfYS5vYmosIG9ialByb3AgPSBfYS5vYmpQcm9wO1xyXG4gICAgICAgIHJldHVybiBvYmpbb2JqUHJvcF07XHJcbiAgICB9O1xyXG4gICAgTmV1cmFsTmV0d29yay5wcm90b3R5cGUucmVhc3NpZ25QYXJhbUZyb21QYXRoID0gZnVuY3Rpb24gKHBhcmFtUGF0aCwgdGVuc29yKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy50cmF2ZXJzZVByb3BlcnR5UGF0aChwYXJhbVBhdGgpLCBvYmogPSBfYS5vYmosIG9ialByb3AgPSBfYS5vYmpQcm9wO1xyXG4gICAgICAgIG9ialtvYmpQcm9wXS5kaXNwb3NlKCk7XHJcbiAgICAgICAgb2JqW29ialByb3BdID0gdGVuc29yO1xyXG4gICAgfTtcclxuICAgIE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLmdldFBhcmFtTGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbU1hcHBpbmdzLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtUGF0aCA9IF9hLnBhcmFtUGF0aDtcclxuICAgICAgICAgICAgcmV0dXJuICh7XHJcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXJhbVBhdGgsXHJcbiAgICAgICAgICAgICAgICB0ZW5zb3I6IF90aGlzLmdldFBhcmFtRnJvbVBhdGgocGFyYW1QYXRoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBOZXVyYWxOZXR3b3JrLnByb3RvdHlwZS5nZXRUcmFpbmFibGVQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyYW1MaXN0KCkuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0udGVuc29yIGluc3RhbmNlb2YgdGYuVmFyaWFibGU7IH0pO1xyXG4gICAgfTtcclxuICAgIE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLmdldEZyb3plblBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJhbUxpc3QoKS5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhKHBhcmFtLnRlbnNvciBpbnN0YW5jZW9mIHRmLlZhcmlhYmxlKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgTmV1cmFsTmV0d29yay5wcm90b3R5cGUudmFyaWFibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmdldEZyb3plblBhcmFtcygpLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gX2EucGF0aCwgdGVuc29yID0gX2EudGVuc29yO1xyXG4gICAgICAgICAgICBfdGhpcy5yZWFzc2lnblBhcmFtRnJvbVBhdGgocGF0aCwgdGVuc29yLnZhcmlhYmxlKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLmZyZWV6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZ2V0VHJhaW5hYmxlUGFyYW1zKCkuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIHBhdGggPSBfYS5wYXRoLCB2YXJpYWJsZSA9IF9hLnRlbnNvcjtcclxuICAgICAgICAgICAgdmFyIHRlbnNvciA9IHRmLnRlbnNvcih2YXJpYWJsZS5kYXRhU3luYygpKTtcclxuICAgICAgICAgICAgdmFyaWFibGUuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5yZWFzc2lnblBhcmFtRnJvbVBhdGgocGF0aCwgdGVuc29yKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBOZXVyYWxOZXR3b3JrLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHRocm93T25SZWRpc3Bvc2UpIHtcclxuICAgICAgICBpZiAodGhyb3dPblJlZGlzcG9zZSA9PT0gdm9pZCAwKSB7IHRocm93T25SZWRpc3Bvc2UgPSB0cnVlOyB9XHJcbiAgICAgICAgdGhpcy5nZXRQYXJhbUxpc3QoKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgICAgICBpZiAodGhyb3dPblJlZGlzcG9zZSAmJiBwYXJhbS50ZW5zb3IuaXNEaXNwb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFyYW0gdGVuc29yIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQgZm9yIHBhdGggXCIgKyBwYXJhbS5wYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJhbS50ZW5zb3IuZGlzcG9zZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3BhcmFtcyA9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBOZXVyYWxOZXR3b3JrLnByb3RvdHlwZS5zZXJpYWxpemVQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5nZXRQYXJhbUxpc3QoKVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgdGVuc29yID0gX2EudGVuc29yO1xyXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0ZW5zb3IuZGF0YVN5bmMoKSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoZmxhdCwgYXJyKSB7IHJldHVybiBmbGF0LmNvbmNhdChhcnIpOyB9KSk7XHJcbiAgICB9O1xyXG4gICAgTmV1cmFsTmV0d29yay5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICh3ZWlnaHRzT3JVcmwpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3ZWlnaHRzT3JVcmwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXh0cmFjdFdlaWdodHMod2VpZ2h0c09yVXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmxvYWRGcm9tVXJpKHdlaWdodHNPclVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLmxvYWRGcm9tVXJpID0gZnVuY3Rpb24gKHVyaSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHdlaWdodE1hcDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVyaSAmJiB0eXBlb2YgdXJpICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuX25hbWUgKyBcIi5sb2FkRnJvbVVyaSAtIGV4cGVjdGVkIG1vZGVsIHVyaVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsb2FkV2VpZ2h0TWFwKHVyaSwgdGhpcy5nZXREZWZhdWx0TW9kZWxOYW1lKCkpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodE1hcCA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkRnJvbVdlaWdodE1hcCh3ZWlnaHRNYXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLmxvYWRGcm9tRGlzayA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlYWRGaWxlLCBfYSwgbWFuaWZlc3RVcmksIG1vZGVsQmFzZVVyaSwgZmV0Y2hXZWlnaHRzRnJvbURpc2ssIGxvYWRXZWlnaHRzLCBtYW5pZmVzdCwgX2IsIF9jLCB3ZWlnaHRNYXA7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2QpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2QubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlUGF0aCAmJiB0eXBlb2YgZmlsZVBhdGggIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fbmFtZSArIFwiLmxvYWRGcm9tRGlzayAtIGV4cGVjdGVkIG1vZGVsIGZpbGUgcGF0aFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkRmlsZSA9IGVudi5nZXRFbnYoKS5yZWFkRmlsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBnZXRNb2RlbFVyaXMoZmlsZVBhdGgsIHRoaXMuZ2V0RGVmYXVsdE1vZGVsTmFtZSgpKSwgbWFuaWZlc3RVcmkgPSBfYS5tYW5pZmVzdFVyaSwgbW9kZWxCYXNlVXJpID0gX2EubW9kZWxCYXNlVXJpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFdlaWdodHNGcm9tRGlzayA9IGZ1bmN0aW9uIChmaWxlUGF0aHMpIHsgcmV0dXJuIFByb21pc2UuYWxsKGZpbGVQYXRocy5tYXAoZnVuY3Rpb24gKGZpbGVQYXRoKSB7IHJldHVybiByZWFkRmlsZShmaWxlUGF0aCkudGhlbihmdW5jdGlvbiAoYnVmKSB7IHJldHVybiBidWYuYnVmZmVyOyB9KTsgfSkpOyB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkV2VpZ2h0cyA9IHRmLmlvLndlaWdodHNMb2FkZXJGYWN0b3J5KGZldGNoV2VpZ2h0c0Zyb21EaXNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSAoX2IgPSBKU09OKS5wYXJzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVhZEZpbGUobWFuaWZlc3RVcmkpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0ID0gX2MuYXBwbHkoX2IsIFsoX2Quc2VudCgpKS50b1N0cmluZygpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxvYWRXZWlnaHRzKG1hbmlmZXN0LCBtb2RlbEJhc2VVcmkpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodE1hcCA9IF9kLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkRnJvbVdlaWdodE1hcCh3ZWlnaHRNYXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE5ldXJhbE5ldHdvcmsucHJvdG90eXBlLmxvYWRGcm9tV2VpZ2h0TWFwID0gZnVuY3Rpb24gKHdlaWdodE1hcCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMuZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAod2VpZ2h0TWFwKSwgcGFyYW1NYXBwaW5ncyA9IF9hLnBhcmFtTWFwcGluZ3MsIHBhcmFtcyA9IF9hLnBhcmFtcztcclxuICAgICAgICB0aGlzLl9wYXJhbU1hcHBpbmdzID0gcGFyYW1NYXBwaW5ncztcclxuICAgICAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICB9O1xyXG4gICAgTmV1cmFsTmV0d29yay5wcm90b3R5cGUuZXh0cmFjdFdlaWdodHMgPSBmdW5jdGlvbiAod2VpZ2h0cykge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMuZXh0cmFjdFBhcmFtcyh3ZWlnaHRzKSwgcGFyYW1NYXBwaW5ncyA9IF9hLnBhcmFtTWFwcGluZ3MsIHBhcmFtcyA9IF9hLnBhcmFtcztcclxuICAgICAgICB0aGlzLl9wYXJhbU1hcHBpbmdzID0gcGFyYW1NYXBwaW5ncztcclxuICAgICAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICB9O1xyXG4gICAgTmV1cmFsTmV0d29yay5wcm90b3R5cGUudHJhdmVyc2VQcm9wZXJ0eVBhdGggPSBmdW5jdGlvbiAocGFyYW1QYXRoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBhcmFtcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmF2ZXJzZVByb3BlcnR5UGF0aCAtIG1vZGVsIGhhcyBubyBsb2FkZWQgcGFyYW1zXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyYW1QYXRoLnNwbGl0KCcvJykucmVkdWNlKGZ1bmN0aW9uIChyZXMsIG9ialByb3ApIHtcclxuICAgICAgICAgICAgaWYgKCFyZXMubmV4dE9iai5oYXNPd25Qcm9wZXJ0eShvYmpQcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJhdmVyc2VQcm9wZXJ0eVBhdGggLSBvYmplY3QgZG9lcyBub3QgaGF2ZSBwcm9wZXJ0eSBcIiArIG9ialByb3AgKyBcIiwgZm9yIHBhdGggXCIgKyBwYXJhbVBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IG9iajogcmVzLm5leHRPYmosIG9ialByb3A6IG9ialByb3AsIG5leHRPYmo6IHJlcy5uZXh0T2JqW29ialByb3BdIH07XHJcbiAgICAgICAgfSwgeyBuZXh0T2JqOiB0aGlzLnBhcmFtcyB9KTtcclxuICAgICAgICB2YXIgb2JqID0gcmVzdWx0Lm9iaiwgb2JqUHJvcCA9IHJlc3VsdC5vYmpQcm9wO1xyXG4gICAgICAgIGlmICghb2JqIHx8ICFvYmpQcm9wIHx8ICEob2JqW29ialByb3BdIGluc3RhbmNlb2YgdGYuVGVuc29yKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmF2ZXJzZVByb3BlcnR5UGF0aCAtIHBhcmFtZXRlciBpcyBub3QgYSB0ZW5zb3IsIGZvciBwYXRoIFwiICsgcGFyYW1QYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgb2JqOiBvYmosIG9ialByb3A6IG9ialByb3AgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTmV1cmFsTmV0d29yaztcclxufSgpKTtcclxuZXhwb3J0IHsgTmV1cmFsTmV0d29yayB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1OZXVyYWxOZXR3b3JrLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19leHRlbmRzLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBmdWxseUNvbm5lY3RlZExheWVyIH0gZnJvbSAnLi4vY29tbW9uL2Z1bGx5Q29ubmVjdGVkTGF5ZXInO1xyXG5pbXBvcnQgeyBzZXBlcmF0ZVdlaWdodE1hcHMgfSBmcm9tICcuLi9mYWNlUHJvY2Vzc29yL3V0aWwnO1xyXG5pbXBvcnQgeyBUaW55WGNlcHRpb24gfSBmcm9tICcuLi94Y2VwdGlvbi9UaW55WGNlcHRpb24nO1xyXG5pbXBvcnQgeyBleHRyYWN0UGFyYW1zIH0gZnJvbSAnLi9leHRyYWN0UGFyYW1zJztcclxuaW1wb3J0IHsgZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAgfSBmcm9tICcuL2V4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwJztcclxuaW1wb3J0IHsgR2VuZGVyIH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB7IE5ldXJhbE5ldHdvcmsgfSBmcm9tICcuLi9OZXVyYWxOZXR3b3JrJztcclxuaW1wb3J0IHsgTmV0SW5wdXQsIHRvTmV0SW5wdXQgfSBmcm9tICcuLi9kb20nO1xyXG52YXIgQWdlR2VuZGVyTmV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFnZUdlbmRlck5ldCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFnZUdlbmRlck5ldChmYWNlRmVhdHVyZUV4dHJhY3Rvcikge1xyXG4gICAgICAgIGlmIChmYWNlRmVhdHVyZUV4dHJhY3RvciA9PT0gdm9pZCAwKSB7IGZhY2VGZWF0dXJlRXh0cmFjdG9yID0gbmV3IFRpbnlYY2VwdGlvbigyKTsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICdBZ2VHZW5kZXJOZXQnKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl9mYWNlRmVhdHVyZUV4dHJhY3RvciA9IGZhY2VGZWF0dXJlRXh0cmFjdG9yO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBZ2VHZW5kZXJOZXQucHJvdG90eXBlLCBcImZhY2VGZWF0dXJlRXh0cmFjdG9yXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhY2VGZWF0dXJlRXh0cmFjdG9yO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWdlR2VuZGVyTmV0LnByb3RvdHlwZS5ydW5OZXQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcztcclxuICAgICAgICBpZiAoIXBhcmFtcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fbmFtZSArIFwiIC0gbG9hZCBtb2RlbCBiZWZvcmUgaW5mZXJlbmNlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBib3R0bGVuZWNrRmVhdHVyZXMgPSBpbnB1dCBpbnN0YW5jZW9mIE5ldElucHV0XHJcbiAgICAgICAgICAgICAgICA/IF90aGlzLmZhY2VGZWF0dXJlRXh0cmFjdG9yLmZvcndhcmRJbnB1dChpbnB1dClcclxuICAgICAgICAgICAgICAgIDogaW5wdXQ7XHJcbiAgICAgICAgICAgIHZhciBwb29sZWQgPSB0Zi5hdmdQb29sKGJvdHRsZW5lY2tGZWF0dXJlcywgWzcsIDddLCBbMiwgMl0sICd2YWxpZCcpLmFzMkQoYm90dGxlbmVja0ZlYXR1cmVzLnNoYXBlWzBdLCAtMSk7XHJcbiAgICAgICAgICAgIHZhciBhZ2UgPSBmdWxseUNvbm5lY3RlZExheWVyKHBvb2xlZCwgcGFyYW1zLmZjLmFnZSkuYXMxRCgpO1xyXG4gICAgICAgICAgICB2YXIgZ2VuZGVyID0gZnVsbHlDb25uZWN0ZWRMYXllcihwb29sZWQsIHBhcmFtcy5mYy5nZW5kZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBhZ2U6IGFnZSwgZ2VuZGVyOiBnZW5kZXIgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBZ2VHZW5kZXJOZXQucHJvdG90eXBlLmZvcndhcmRJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5ydW5OZXQoaW5wdXQpLCBhZ2UgPSBfYS5hZ2UsIGdlbmRlciA9IF9hLmdlbmRlcjtcclxuICAgICAgICAgICAgcmV0dXJuIHsgYWdlOiBhZ2UsIGdlbmRlcjogdGYuc29mdG1heChnZW5kZXIpIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWdlR2VuZGVyTmV0LnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcy5mb3J3YXJkSW5wdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRvTmV0SW5wdXQoaW5wdXQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5hcHBseSh0aGlzLCBbX2Iuc2VudCgpXSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBZ2VHZW5kZXJOZXQucHJvdG90eXBlLnByZWRpY3RBZ2VBbmRHZW5kZXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXRJbnB1dCwgb3V0LCBhZ2VzLCBnZW5kZXJzLCBhZ2VBbmRHZW5kZXJUZW5zb3JzLCBwcmVkaWN0aW9uc0J5QmF0Y2g7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRvTmV0SW5wdXQoaW5wdXQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldElucHV0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZvcndhcmRJbnB1dChuZXRJbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2VzID0gdGYudW5zdGFjayhvdXQuYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZGVycyA9IHRmLnVuc3RhY2sob3V0LmdlbmRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZUFuZEdlbmRlclRlbnNvcnMgPSBhZ2VzLm1hcChmdW5jdGlvbiAoYWdlVGVuc29yLCBpKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlVGVuc29yOiBhZ2VUZW5zb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5kZXJUZW5zb3I6IGdlbmRlcnNbaV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChhZ2VBbmRHZW5kZXJUZW5zb3JzLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWdlVGVuc29yID0gX2EuYWdlVGVuc29yLCBnZW5kZXJUZW5zb3IgPSBfYS5nZW5kZXJUZW5zb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFnZSwgcHJvYk1hbGUsIGlzTWFsZSwgZ2VuZGVyLCBnZW5kZXJQcm9iYWJpbGl0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgYWdlVGVuc29yLmRhdGEoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2UgPSAoX2Iuc2VudCgpKVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2VuZGVyVGVuc29yLmRhdGEoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9iTWFsZSA9IChfYi5zZW50KCkpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc01hbGUgPSBwcm9iTWFsZSA+IDAuNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZGVyID0gaXNNYWxlID8gR2VuZGVyLk1BTEUgOiBHZW5kZXIuRkVNQUxFO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5kZXJQcm9iYWJpbGl0eSA9IGlzTWFsZSA/IHByb2JNYWxlIDogKDEgLSBwcm9iTWFsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZVRlbnNvci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmRlclRlbnNvci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7IGFnZTogYWdlLCBnZW5kZXI6IGdlbmRlciwgZ2VuZGVyUHJvYmFiaWxpdHk6IGdlbmRlclByb2JhYmlsaXR5IH1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWN0aW9uc0J5QmF0Y2ggPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5hZ2UuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuZ2VuZGVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldElucHV0LmlzQmF0Y2hJbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcHJlZGljdGlvbnNCeUJhdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwcmVkaWN0aW9uc0J5QmF0Y2hbMF1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBZ2VHZW5kZXJOZXQucHJvdG90eXBlLmdldERlZmF1bHRNb2RlbE5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICdhZ2VfZ2VuZGVyX21vZGVsJztcclxuICAgIH07XHJcbiAgICBBZ2VHZW5kZXJOZXQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAodGhyb3dPblJlZGlzcG9zZSkge1xyXG4gICAgICAgIGlmICh0aHJvd09uUmVkaXNwb3NlID09PSB2b2lkIDApIHsgdGhyb3dPblJlZGlzcG9zZSA9IHRydWU7IH1cclxuICAgICAgICB0aGlzLmZhY2VGZWF0dXJlRXh0cmFjdG9yLmRpc3Bvc2UodGhyb3dPblJlZGlzcG9zZSk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcywgdGhyb3dPblJlZGlzcG9zZSk7XHJcbiAgICB9O1xyXG4gICAgQWdlR2VuZGVyTmV0LnByb3RvdHlwZS5sb2FkQ2xhc3NpZmllclBhcmFtcyA9IGZ1bmN0aW9uICh3ZWlnaHRzKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5leHRyYWN0Q2xhc3NpZmllclBhcmFtcyh3ZWlnaHRzKSwgcGFyYW1zID0gX2EucGFyYW1zLCBwYXJhbU1hcHBpbmdzID0gX2EucGFyYW1NYXBwaW5ncztcclxuICAgICAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICAgICAgdGhpcy5fcGFyYW1NYXBwaW5ncyA9IHBhcmFtTWFwcGluZ3M7XHJcbiAgICB9O1xyXG4gICAgQWdlR2VuZGVyTmV0LnByb3RvdHlwZS5leHRyYWN0Q2xhc3NpZmllclBhcmFtcyA9IGZ1bmN0aW9uICh3ZWlnaHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RQYXJhbXMod2VpZ2h0cyk7XHJcbiAgICB9O1xyXG4gICAgQWdlR2VuZGVyTmV0LnByb3RvdHlwZS5leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCA9IGZ1bmN0aW9uICh3ZWlnaHRNYXApIHtcclxuICAgICAgICB2YXIgX2EgPSBzZXBlcmF0ZVdlaWdodE1hcHMod2VpZ2h0TWFwKSwgZmVhdHVyZUV4dHJhY3Rvck1hcCA9IF9hLmZlYXR1cmVFeHRyYWN0b3JNYXAsIGNsYXNzaWZpZXJNYXAgPSBfYS5jbGFzc2lmaWVyTWFwO1xyXG4gICAgICAgIHRoaXMuZmFjZUZlYXR1cmVFeHRyYWN0b3IubG9hZEZyb21XZWlnaHRNYXAoZmVhdHVyZUV4dHJhY3Rvck1hcCk7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwKGNsYXNzaWZpZXJNYXApO1xyXG4gICAgfTtcclxuICAgIEFnZUdlbmRlck5ldC5wcm90b3R5cGUuZXh0cmFjdFBhcmFtcyA9IGZ1bmN0aW9uICh3ZWlnaHRzKSB7XHJcbiAgICAgICAgdmFyIGNsYXNzaWZpZXJXZWlnaHRTaXplID0gKDUxMiAqIDEgKyAxKSArICg1MTIgKiAyICsgMik7XHJcbiAgICAgICAgdmFyIGZlYXR1cmVFeHRyYWN0b3JXZWlnaHRzID0gd2VpZ2h0cy5zbGljZSgwLCB3ZWlnaHRzLmxlbmd0aCAtIGNsYXNzaWZpZXJXZWlnaHRTaXplKTtcclxuICAgICAgICB2YXIgY2xhc3NpZmllcldlaWdodHMgPSB3ZWlnaHRzLnNsaWNlKHdlaWdodHMubGVuZ3RoIC0gY2xhc3NpZmllcldlaWdodFNpemUpO1xyXG4gICAgICAgIHRoaXMuZmFjZUZlYXR1cmVFeHRyYWN0b3IuZXh0cmFjdFdlaWdodHMoZmVhdHVyZUV4dHJhY3RvcldlaWdodHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RDbGFzc2lmaWVyUGFyYW1zKGNsYXNzaWZpZXJXZWlnaHRzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQWdlR2VuZGVyTmV0O1xyXG59KE5ldXJhbE5ldHdvcmspKTtcclxuZXhwb3J0IHsgQWdlR2VuZGVyTmV0IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFnZUdlbmRlck5ldC5qcy5tYXAiLCJpbXBvcnQgeyBleHRyYWN0RkNQYXJhbXNGYWN0b3J5LCBleHRyYWN0V2VpZ2h0c0ZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24nO1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtcyh3ZWlnaHRzKSB7XHJcbiAgICB2YXIgcGFyYW1NYXBwaW5ncyA9IFtdO1xyXG4gICAgdmFyIF9hID0gZXh0cmFjdFdlaWdodHNGYWN0b3J5KHdlaWdodHMpLCBleHRyYWN0V2VpZ2h0cyA9IF9hLmV4dHJhY3RXZWlnaHRzLCBnZXRSZW1haW5pbmdXZWlnaHRzID0gX2EuZ2V0UmVtYWluaW5nV2VpZ2h0cztcclxuICAgIHZhciBleHRyYWN0RkNQYXJhbXMgPSBleHRyYWN0RkNQYXJhbXNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIHZhciBhZ2UgPSBleHRyYWN0RkNQYXJhbXMoNTEyLCAxLCAnZmMvYWdlJyk7XHJcbiAgICB2YXIgZ2VuZGVyID0gZXh0cmFjdEZDUGFyYW1zKDUxMiwgMiwgJ2ZjL2dlbmRlcicpO1xyXG4gICAgaWYgKGdldFJlbWFpbmluZ1dlaWdodHMoKS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWlnaHRzIHJlbWFpbmcgYWZ0ZXIgZXh0cmFjdDogXCIgKyBnZXRSZW1haW5pbmdXZWlnaHRzKCkubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcGFyYW1NYXBwaW5nczogcGFyYW1NYXBwaW5ncyxcclxuICAgICAgICBwYXJhbXM6IHsgZmM6IHsgYWdlOiBhZ2UsIGdlbmRlcjogZ2VuZGVyIH0gfVxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0UGFyYW1zLmpzLm1hcCIsImltcG9ydCB7IGRpc3Bvc2VVbnVzZWRXZWlnaHRUZW5zb3JzLCBleHRyYWN0V2VpZ2h0RW50cnlGYWN0b3J5IH0gZnJvbSAnLi4vY29tbW9uJztcclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwKHdlaWdodE1hcCkge1xyXG4gICAgdmFyIHBhcmFtTWFwcGluZ3MgPSBbXTtcclxuICAgIHZhciBleHRyYWN0V2VpZ2h0RW50cnkgPSBleHRyYWN0V2VpZ2h0RW50cnlGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0RmNQYXJhbXMocHJlZml4KSB7XHJcbiAgICAgICAgdmFyIHdlaWdodHMgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvd2VpZ2h0c1wiLCAyKTtcclxuICAgICAgICB2YXIgYmlhcyA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi9iaWFzXCIsIDEpO1xyXG4gICAgICAgIHJldHVybiB7IHdlaWdodHM6IHdlaWdodHMsIGJpYXM6IGJpYXMgfTtcclxuICAgIH1cclxuICAgIHZhciBwYXJhbXMgPSB7XHJcbiAgICAgICAgZmM6IHtcclxuICAgICAgICAgICAgYWdlOiBleHRyYWN0RmNQYXJhbXMoJ2ZjL2FnZScpLFxyXG4gICAgICAgICAgICBnZW5kZXI6IGV4dHJhY3RGY1BhcmFtcygnZmMvZ2VuZGVyJylcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIHJldHVybiB7IHBhcmFtczogcGFyYW1zLCBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuanMubWFwIiwiZXhwb3J0ICogZnJvbSAnLi9BZ2VHZW5kZXJOZXQnO1xyXG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IHZhciBHZW5kZXI7XHJcbihmdW5jdGlvbiAoR2VuZGVyKSB7XHJcbiAgICBHZW5kZXJbXCJGRU1BTEVcIl0gPSBcImZlbWFsZVwiO1xyXG4gICAgR2VuZGVyW1wiTUFMRVwiXSA9IFwibWFsZVwiO1xyXG59KShHZW5kZXIgfHwgKEdlbmRlciA9IHt9KSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBCb3ggfSBmcm9tICcuL0JveCc7XHJcbnZhciBCb3VuZGluZ0JveCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCb3VuZGluZ0JveCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJvdW5kaW5nQm94KGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSwgYWxsb3dOZWdhdGl2ZURpbWVuc2lvbnMpIHtcclxuICAgICAgICBpZiAoYWxsb3dOZWdhdGl2ZURpbWVuc2lvbnMgPT09IHZvaWQgMCkgeyBhbGxvd05lZ2F0aXZlRGltZW5zaW9ucyA9IGZhbHNlOyB9XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AsIHJpZ2h0OiByaWdodCwgYm90dG9tOiBib3R0b20gfSwgYWxsb3dOZWdhdGl2ZURpbWVuc2lvbnMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQm91bmRpbmdCb3g7XHJcbn0oQm94KSk7XHJcbmV4cG9ydCB7IEJvdW5kaW5nQm94IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJvdW5kaW5nQm94LmpzLm1hcCIsImltcG9ydCB7IGlzRGltZW5zaW9ucywgaXNWYWxpZE51bWJlciB9IGZyb20gJy4uL3V0aWxzJztcclxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL1BvaW50JztcclxudmFyIEJveCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJveChfYm94LCBhbGxvd05lZ2F0aXZlRGltZW5zaW9ucykge1xyXG4gICAgICAgIGlmIChhbGxvd05lZ2F0aXZlRGltZW5zaW9ucyA9PT0gdm9pZCAwKSB7IGFsbG93TmVnYXRpdmVEaW1lbnNpb25zID0gdHJ1ZTsgfVxyXG4gICAgICAgIHZhciBib3ggPSAoX2JveCB8fCB7fSk7XHJcbiAgICAgICAgdmFyIGlzQmJveCA9IFtib3gubGVmdCwgYm94LnRvcCwgYm94LnJpZ2h0LCBib3guYm90dG9tXS5ldmVyeShpc1ZhbGlkTnVtYmVyKTtcclxuICAgICAgICB2YXIgaXNSZWN0ID0gW2JveC54LCBib3gueSwgYm94LndpZHRoLCBib3guaGVpZ2h0XS5ldmVyeShpc1ZhbGlkTnVtYmVyKTtcclxuICAgICAgICBpZiAoIWlzUmVjdCAmJiAhaXNCYm94KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJveC5jb25zdHJ1Y3RvciAtIGV4cGVjdGVkIGJveCB0byBiZSBJQm91bmRpbmdCb3ggfCBJUmVjdCwgaW5zdGVhZCBoYXZlIFwiICsgSlNPTi5zdHJpbmdpZnkoYm94KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYSA9IGlzUmVjdFxyXG4gICAgICAgICAgICA/IFtib3gueCwgYm94LnksIGJveC53aWR0aCwgYm94LmhlaWdodF1cclxuICAgICAgICAgICAgOiBbYm94LmxlZnQsIGJveC50b3AsIGJveC5yaWdodCAtIGJveC5sZWZ0LCBib3guYm90dG9tIC0gYm94LnRvcF0sIHggPSBfYVswXSwgeSA9IF9hWzFdLCB3aWR0aCA9IF9hWzJdLCBoZWlnaHQgPSBfYVszXTtcclxuICAgICAgICBCb3guYXNzZXJ0SXNWYWxpZEJveCh7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSwgJ0JveC5jb25zdHJ1Y3RvcicsIGFsbG93TmVnYXRpdmVEaW1lbnNpb25zKTtcclxuICAgICAgICB0aGlzLl94ID0geDtcclxuICAgICAgICB0aGlzLl95ID0geTtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcclxuICAgIH1cclxuICAgIEJveC5pc1JlY3QgPSBmdW5jdGlvbiAocmVjdCkge1xyXG4gICAgICAgIHJldHVybiAhIXJlY3QgJiYgW3JlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodF0uZXZlcnkoaXNWYWxpZE51bWJlcik7XHJcbiAgICB9O1xyXG4gICAgQm94LmFzc2VydElzVmFsaWRCb3ggPSBmdW5jdGlvbiAoYm94LCBjYWxsZWUsIGFsbG93TmVnYXRpdmVEaW1lbnNpb25zKSB7XHJcbiAgICAgICAgaWYgKGFsbG93TmVnYXRpdmVEaW1lbnNpb25zID09PSB2b2lkIDApIHsgYWxsb3dOZWdhdGl2ZURpbWVuc2lvbnMgPSBmYWxzZTsgfVxyXG4gICAgICAgIGlmICghQm94LmlzUmVjdChib3gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjYWxsZWUgKyBcIiAtIGludmFsaWQgYm94OiBcIiArIEpTT04uc3RyaW5naWZ5KGJveCkgKyBcIiwgZXhwZWN0ZWQgb2JqZWN0IHdpdGggcHJvcGVydGllcyB4LCB5LCB3aWR0aCwgaGVpZ2h0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFsbG93TmVnYXRpdmVEaW1lbnNpb25zICYmIChib3gud2lkdGggPCAwIHx8IGJveC5oZWlnaHQgPCAwKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY2FsbGVlICsgXCIgLSB3aWR0aCAoXCIgKyBib3gud2lkdGggKyBcIikgYW5kIGhlaWdodCAoXCIgKyBib3guaGVpZ2h0ICsgXCIpIG11c3QgYmUgcG9zaXRpdmUgbnVtYmVyc1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJveC5wcm90b3R5cGUsIFwieFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl94OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3gucHJvdG90eXBlLCBcInlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5feTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm94LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl93aWR0aDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm94LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faGVpZ2h0OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3gucHJvdG90eXBlLCBcImxlZnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy54OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3gucHJvdG90eXBlLCBcInRvcFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJveC5wcm90b3R5cGUsIFwicmlnaHRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm94LnByb3RvdHlwZSwgXCJib3R0b21cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJveC5wcm90b3R5cGUsIFwiYXJlYVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJveC5wcm90b3R5cGUsIFwidG9wTGVmdFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJveC5wcm90b3R5cGUsIFwidG9wUmlnaHRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMucmlnaHQsIHRoaXMudG9wKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm94LnByb3RvdHlwZSwgXCJib3R0b21MZWZ0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmxlZnQsIHRoaXMuYm90dG9tKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm94LnByb3RvdHlwZSwgXCJib3R0b21SaWdodFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUG9pbnQodGhpcy5yaWdodCwgdGhpcy5ib3R0b20pOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEJveC5wcm90b3R5cGUucm91bmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hID0gW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF1cclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBNYXRoLnJvdW5kKHZhbCk7IH0pLCB4ID0gX2FbMF0sIHkgPSBfYVsxXSwgd2lkdGggPSBfYVsyXSwgaGVpZ2h0ID0gX2FbM107XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3goeyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xyXG4gICAgfTtcclxuICAgIEJveC5wcm90b3R5cGUuZmxvb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hID0gW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF1cclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBNYXRoLmZsb29yKHZhbCk7IH0pLCB4ID0gX2FbMF0sIHkgPSBfYVsxXSwgd2lkdGggPSBfYVsyXSwgaGVpZ2h0ID0gX2FbM107XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3goeyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xyXG4gICAgfTtcclxuICAgIEJveC5wcm90b3R5cGUudG9TcXVhcmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcywgeCA9IF9hLngsIHkgPSBfYS55LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyh3aWR0aCAtIGhlaWdodCk7XHJcbiAgICAgICAgaWYgKHdpZHRoIDwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHggLT0gKGRpZmYgLyAyKTtcclxuICAgICAgICAgICAgd2lkdGggKz0gZGlmZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhlaWdodCA8IHdpZHRoKSB7XHJcbiAgICAgICAgICAgIHkgLT0gKGRpZmYgLyAyKTtcclxuICAgICAgICAgICAgaGVpZ2h0ICs9IGRpZmY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQm94KHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcclxuICAgIH07XHJcbiAgICBCb3gucHJvdG90eXBlLnJlc2NhbGUgPSBmdW5jdGlvbiAocykge1xyXG4gICAgICAgIHZhciBzY2FsZVggPSBpc0RpbWVuc2lvbnMocykgPyBzLndpZHRoIDogcztcclxuICAgICAgICB2YXIgc2NhbGVZID0gaXNEaW1lbnNpb25zKHMpID8gcy5oZWlnaHQgOiBzO1xyXG4gICAgICAgIHJldHVybiBuZXcgQm94KHtcclxuICAgICAgICAgICAgeDogdGhpcy54ICogc2NhbGVYLFxyXG4gICAgICAgICAgICB5OiB0aGlzLnkgKiBzY2FsZVksXHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoICogc2NhbGVYLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0ICogc2NhbGVZXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQm94LnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbiAocGFkWCwgcGFkWSkge1xyXG4gICAgICAgIHZhciBfYSA9IFtcclxuICAgICAgICAgICAgdGhpcy54IC0gKHBhZFggLyAyKSxcclxuICAgICAgICAgICAgdGhpcy55IC0gKHBhZFkgLyAyKSxcclxuICAgICAgICAgICAgdGhpcy53aWR0aCArIHBhZFgsXHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ICsgcGFkWVxyXG4gICAgICAgIF0sIHggPSBfYVswXSwgeSA9IF9hWzFdLCB3aWR0aCA9IF9hWzJdLCBoZWlnaHQgPSBfYVszXTtcclxuICAgICAgICByZXR1cm4gbmV3IEJveCh7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcbiAgICB9O1xyXG4gICAgQm94LnByb3RvdHlwZS5jbGlwQXRJbWFnZUJvcmRlcnMgPSBmdW5jdGlvbiAoaW1nV2lkdGgsIGltZ0hlaWdodCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHggPSBfYS54LCB5ID0gX2EueSwgcmlnaHQgPSBfYS5yaWdodCwgYm90dG9tID0gX2EuYm90dG9tO1xyXG4gICAgICAgIHZhciBjbGlwcGVkWCA9IE1hdGgubWF4KHgsIDApO1xyXG4gICAgICAgIHZhciBjbGlwcGVkWSA9IE1hdGgubWF4KHksIDApO1xyXG4gICAgICAgIHZhciBuZXdXaWR0aCA9IHJpZ2h0IC0gY2xpcHBlZFg7XHJcbiAgICAgICAgdmFyIG5ld0hlaWdodCA9IGJvdHRvbSAtIGNsaXBwZWRZO1xyXG4gICAgICAgIHZhciBjbGlwcGVkV2lkdGggPSBNYXRoLm1pbihuZXdXaWR0aCwgaW1nV2lkdGggLSBjbGlwcGVkWCk7XHJcbiAgICAgICAgdmFyIGNsaXBwZWRIZWlnaHQgPSBNYXRoLm1pbihuZXdIZWlnaHQsIGltZ0hlaWdodCAtIGNsaXBwZWRZKTtcclxuICAgICAgICByZXR1cm4gKG5ldyBCb3goeyB4OiBjbGlwcGVkWCwgeTogY2xpcHBlZFksIHdpZHRoOiBjbGlwcGVkV2lkdGgsIGhlaWdodDogY2xpcHBlZEhlaWdodCB9KSkuZmxvb3IoKTtcclxuICAgIH07XHJcbiAgICBCb3gucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKHN4LCBzeSkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICB2YXIgeCA9IHRoaXMueCArIHN4O1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy55ICsgc3k7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3goeyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xyXG4gICAgfTtcclxuICAgIEJveC5wcm90b3R5cGUucGFkQXRCb3JkZXJzID0gZnVuY3Rpb24gKGltYWdlSGVpZ2h0LCBpbWFnZVdpZHRoKSB7XHJcbiAgICAgICAgdmFyIHcgPSB0aGlzLndpZHRoICsgMTtcclxuICAgICAgICB2YXIgaCA9IHRoaXMuaGVpZ2h0ICsgMTtcclxuICAgICAgICB2YXIgZHggPSAxO1xyXG4gICAgICAgIHZhciBkeSA9IDE7XHJcbiAgICAgICAgdmFyIGVkeCA9IHc7XHJcbiAgICAgICAgdmFyIGVkeSA9IGg7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnRvcDtcclxuICAgICAgICB2YXIgZXggPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgIHZhciBleSA9IHRoaXMuYm90dG9tO1xyXG4gICAgICAgIGlmIChleCA+IGltYWdlV2lkdGgpIHtcclxuICAgICAgICAgICAgZWR4ID0gLWV4ICsgaW1hZ2VXaWR0aCArIHc7XHJcbiAgICAgICAgICAgIGV4ID0gaW1hZ2VXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV5ID4gaW1hZ2VIZWlnaHQpIHtcclxuICAgICAgICAgICAgZWR5ID0gLWV5ICsgaW1hZ2VIZWlnaHQgKyBoO1xyXG4gICAgICAgICAgICBleSA9IGltYWdlSGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeCA8IDEpIHtcclxuICAgICAgICAgICAgZWR5ID0gMiAtIHg7XHJcbiAgICAgICAgICAgIHggPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeSA8IDEpIHtcclxuICAgICAgICAgICAgZWR5ID0gMiAtIHk7XHJcbiAgICAgICAgICAgIHkgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBkeTogZHksIGVkeTogZWR5LCBkeDogZHgsIGVkeDogZWR4LCB5OiB5LCBleTogZXksIHg6IHgsIGV4OiBleCwgdzogdywgaDogaCB9O1xyXG4gICAgfTtcclxuICAgIEJveC5wcm90b3R5cGUuY2FsaWJyYXRlID0gZnVuY3Rpb24gKHJlZ2lvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgQm94KHtcclxuICAgICAgICAgICAgbGVmdDogdGhpcy5sZWZ0ICsgKHJlZ2lvbi5sZWZ0ICogdGhpcy53aWR0aCksXHJcbiAgICAgICAgICAgIHRvcDogdGhpcy50b3AgKyAocmVnaW9uLnRvcCAqIHRoaXMuaGVpZ2h0KSxcclxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMucmlnaHQgKyAocmVnaW9uLnJpZ2h0ICogdGhpcy53aWR0aCksXHJcbiAgICAgICAgICAgIGJvdHRvbTogdGhpcy5ib3R0b20gKyAocmVnaW9uLmJvdHRvbSAqIHRoaXMuaGVpZ2h0KVxyXG4gICAgICAgIH0pLnRvU3F1YXJlKCkucm91bmQoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQm94O1xyXG59KCkpO1xyXG5leHBvcnQgeyBCb3ggfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm94LmpzLm1hcCIsImltcG9ydCB7IGlzVmFsaWROdW1iZXIgfSBmcm9tICcuLi91dGlscyc7XHJcbnZhciBEaW1lbnNpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkTnVtYmVyKHdpZHRoKSB8fCAhaXNWYWxpZE51bWJlcihoZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbnMuY29uc3RydWN0b3IgLSBleHBlY3RlZCB3aWR0aCBhbmQgaGVpZ2h0IHRvIGJlIHZhbGlkIG51bWJlcnMsIGluc3RlYWQgaGF2ZSBcIiArIEpTT04uc3RyaW5naWZ5KHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpbWVuc2lvbnMucHJvdG90eXBlLCBcIndpZHRoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3dpZHRoOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaW1lbnNpb25zLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faGVpZ2h0OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIERpbWVuc2lvbnMucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb25zKDEgLyB0aGlzLndpZHRoLCAxIC8gdGhpcy5oZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEaW1lbnNpb25zO1xyXG59KCkpO1xyXG5leHBvcnQgeyBEaW1lbnNpb25zIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpbWVuc2lvbnMuanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IE9iamVjdERldGVjdGlvbiB9IGZyb20gJy4vT2JqZWN0RGV0ZWN0aW9uJztcclxudmFyIEZhY2VEZXRlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmFjZURldGVjdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZhY2VEZXRlY3Rpb24oc2NvcmUsIHJlbGF0aXZlQm94LCBpbWFnZURpbXMpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc2NvcmUsIHNjb3JlLCAnJywgcmVsYXRpdmVCb3gsIGltYWdlRGltcykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEZhY2VEZXRlY3Rpb24ucHJvdG90eXBlLmZvclNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHZhciBfYSA9IF9zdXBlci5wcm90b3R5cGUuZm9yU2l6ZS5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpLCBzY29yZSA9IF9hLnNjb3JlLCByZWxhdGl2ZUJveCA9IF9hLnJlbGF0aXZlQm94LCBpbWFnZURpbXMgPSBfYS5pbWFnZURpbXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNlRGV0ZWN0aW9uKHNjb3JlLCByZWxhdGl2ZUJveCwgaW1hZ2VEaW1zKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmFjZURldGVjdGlvbjtcclxufShPYmplY3REZXRlY3Rpb24pKTtcclxuZXhwb3J0IHsgRmFjZURldGVjdGlvbiB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYWNlRGV0ZWN0aW9uLmpzLm1hcCIsImltcG9ydCB7IG1pbkJib3ggfSBmcm9tICcuLi9vcHMnO1xyXG5pbXBvcnQgeyBnZXRDZW50ZXJQb2ludCB9IGZyb20gJy4uL3V0aWxzJztcclxuaW1wb3J0IHsgQm94IH0gZnJvbSAnLi9Cb3gnO1xyXG5pbXBvcnQgeyBEaW1lbnNpb25zIH0gZnJvbSAnLi9EaW1lbnNpb25zJztcclxuaW1wb3J0IHsgRmFjZURldGVjdGlvbiB9IGZyb20gJy4vRmFjZURldGVjdGlvbic7XHJcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9Qb2ludCc7XHJcbmltcG9ydCB7IFJlY3QgfSBmcm9tICcuL1JlY3QnO1xyXG4vLyBmYWNlIGFsaWdubWVudCBjb25zdGFudHNcclxudmFyIHJlbFggPSAwLjU7XHJcbnZhciByZWxZID0gMC40MztcclxudmFyIHJlbFNjYWxlID0gMC40NTtcclxudmFyIEZhY2VMYW5kbWFya3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGYWNlTGFuZG1hcmtzKHJlbGF0aXZlRmFjZUxhbmRtYXJrUG9zaXRpb25zLCBpbWdEaW1zLCBzaGlmdCkge1xyXG4gICAgICAgIGlmIChzaGlmdCA9PT0gdm9pZCAwKSB7IHNoaWZ0ID0gbmV3IFBvaW50KDAsIDApOyB9XHJcbiAgICAgICAgdmFyIHdpZHRoID0gaW1nRGltcy53aWR0aCwgaGVpZ2h0ID0gaW1nRGltcy5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5faW1nRGltcyA9IG5ldyBEaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX3NoaWZ0ID0gc2hpZnQ7XHJcbiAgICAgICAgdGhpcy5fcG9zaXRpb25zID0gcmVsYXRpdmVGYWNlTGFuZG1hcmtQb3NpdGlvbnMubWFwKGZ1bmN0aW9uIChwdCkgeyByZXR1cm4gcHQubXVsKG5ldyBQb2ludCh3aWR0aCwgaGVpZ2h0KSkuYWRkKHNoaWZ0KTsgfSk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFjZUxhbmRtYXJrcy5wcm90b3R5cGUsIFwic2hpZnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMuX3NoaWZ0LngsIHRoaXMuX3NoaWZ0LnkpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWNlTGFuZG1hcmtzLnByb3RvdHlwZSwgXCJpbWFnZVdpZHRoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2ltZ0RpbXMud2lkdGg7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZhY2VMYW5kbWFya3MucHJvdG90eXBlLCBcImltYWdlSGVpZ2h0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2ltZ0RpbXMuaGVpZ2h0OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWNlTGFuZG1hcmtzLnByb3RvdHlwZSwgXCJwb3NpdGlvbnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcG9zaXRpb25zOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWNlTGFuZG1hcmtzLnByb3RvdHlwZSwgXCJyZWxhdGl2ZVBvc2l0aW9uc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbnMubWFwKGZ1bmN0aW9uIChwdCkgeyByZXR1cm4gcHQuc3ViKF90aGlzLl9zaGlmdCkuZGl2KG5ldyBQb2ludChfdGhpcy5pbWFnZVdpZHRoLCBfdGhpcy5pbWFnZUhlaWdodCkpOyB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEZhY2VMYW5kbWFya3MucHJvdG90eXBlLmZvclNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnJlbGF0aXZlUG9zaXRpb25zLCB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUxhbmRtYXJrcy5wcm90b3R5cGUuc2hpZnRCeSA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucmVsYXRpdmVQb3NpdGlvbnMsIHRoaXMuX2ltZ0RpbXMsIG5ldyBQb2ludCh4LCB5KSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUxhbmRtYXJrcy5wcm90b3R5cGUuc2hpZnRCeVBvaW50ID0gZnVuY3Rpb24gKHB0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hpZnRCeShwdC54LCBwdC55KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFsaWducyB0aGUgZmFjZSBsYW5kbWFya3MgYWZ0ZXIgZmFjZSBkZXRlY3Rpb24gZnJvbSB0aGUgcmVsYXRpdmUgcG9zaXRpb25zIG9mIHRoZSBmYWNlc1xyXG4gICAgICogYm91bmRpbmcgYm94LCBvciBpdCdzIGN1cnJlbnQgc2hpZnQuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQgdG8gYWxpZ24gdGhlIGZhY2UgaW1hZ2VzXHJcbiAgICAgKiBhZnRlciBmYWNlIGRldGVjdGlvbiBoYXMgYmVlbiBwZXJmb3JtZWQsIGJlZm9yZSB0aGV5IGFyZSBwYXNzZWQgdG8gdGhlIGZhY2UgcmVjb2duaXRpb24gbmV0LlxyXG4gICAgICogVGhpcyB3aWxsIG1ha2UgdGhlIGNvbXB1dGVkIGZhY2UgZGVzY3JpcHRvciBtb3JlIGFjY3VyYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkZXRlY3Rpb24gKG9wdGlvbmFsKSBUaGUgYm91bmRpbmcgYm94IG9mIHRoZSBmYWNlIG9yIHRoZSBmYWNlIGRldGVjdGlvbiByZXN1bHQuIElmXHJcbiAgICAgKiBubyBhcmd1bWVudCB3YXMgcGFzc2VkIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmFjZSBsYW5kbWFya3MgYXJlIGFzc3VtZWQgdG8gYmUgcmVsYXRpdmUgdG9cclxuICAgICAqIGl0J3MgY3VycmVudCBzaGlmdC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBib3VuZGluZyBib3ggb2YgdGhlIGFsaWduZWQgZmFjZS5cclxuICAgICAqL1xyXG4gICAgRmFjZUxhbmRtYXJrcy5wcm90b3R5cGUuYWxpZ24gPSBmdW5jdGlvbiAoZGV0ZWN0aW9uLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICBpZiAoZGV0ZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBib3ggPSBkZXRlY3Rpb24gaW5zdGFuY2VvZiBGYWNlRGV0ZWN0aW9uXHJcbiAgICAgICAgICAgICAgICA/IGRldGVjdGlvbi5ib3guZmxvb3IoKVxyXG4gICAgICAgICAgICAgICAgOiBuZXcgQm94KGRldGVjdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNoaWZ0QnkoYm94LngsIGJveC55KS5hbGlnbihudWxsLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9hID0gT2JqZWN0LmFzc2lnbih7fSwgeyB1c2VEbGliQWxpZ25tZW50OiBmYWxzZSwgbWluQm94UGFkZGluZzogMC4yIH0sIG9wdGlvbnMpLCB1c2VEbGliQWxpZ25tZW50ID0gX2EudXNlRGxpYkFsaWdubWVudCwgbWluQm94UGFkZGluZyA9IF9hLm1pbkJveFBhZGRpbmc7XHJcbiAgICAgICAgaWYgKHVzZURsaWJBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ25EbGliKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmFsaWduTWluQmJveChtaW5Cb3hQYWRkaW5nKTtcclxuICAgIH07XHJcbiAgICBGYWNlTGFuZG1hcmtzLnByb3RvdHlwZS5hbGlnbkRsaWIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNlbnRlcnMgPSB0aGlzLmdldFJlZlBvaW50c0ZvckFsaWdubWVudCgpO1xyXG4gICAgICAgIHZhciBsZWZ0RXllQ2VudGVyID0gY2VudGVyc1swXSwgcmlnaHRFeWVDZW50ZXIgPSBjZW50ZXJzWzFdLCBtb3V0aENlbnRlciA9IGNlbnRlcnNbMl07XHJcbiAgICAgICAgdmFyIGRpc3RUb01vdXRoID0gZnVuY3Rpb24gKHB0KSB7IHJldHVybiBtb3V0aENlbnRlci5zdWIocHQpLm1hZ25pdHVkZSgpOyB9O1xyXG4gICAgICAgIHZhciBleWVUb01vdXRoRGlzdCA9IChkaXN0VG9Nb3V0aChsZWZ0RXllQ2VudGVyKSArIGRpc3RUb01vdXRoKHJpZ2h0RXllQ2VudGVyKSkgLyAyO1xyXG4gICAgICAgIHZhciBzaXplID0gTWF0aC5mbG9vcihleWVUb01vdXRoRGlzdCAvIHJlbFNjYWxlKTtcclxuICAgICAgICB2YXIgcmVmUG9pbnQgPSBnZXRDZW50ZXJQb2ludChjZW50ZXJzKTtcclxuICAgICAgICAvLyBUT0RPOiBwYWQgaW4gY2FzZSByZWN0YW5nbGUgaXMgb3V0IG9mIGltYWdlIGJvdW5kc1xyXG4gICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCByZWZQb2ludC54IC0gKHJlbFggKiBzaXplKSkpO1xyXG4gICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCByZWZQb2ludC55IC0gKHJlbFkgKiBzaXplKSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdCh4LCB5LCBNYXRoLm1pbihzaXplLCB0aGlzLmltYWdlV2lkdGggKyB4KSwgTWF0aC5taW4oc2l6ZSwgdGhpcy5pbWFnZUhlaWdodCArIHkpKTtcclxuICAgIH07XHJcbiAgICBGYWNlTGFuZG1hcmtzLnByb3RvdHlwZS5hbGlnbk1pbkJib3ggPSBmdW5jdGlvbiAocGFkZGluZykge1xyXG4gICAgICAgIHZhciBib3ggPSBtaW5CYm94KHRoaXMucG9zaXRpb25zKTtcclxuICAgICAgICByZXR1cm4gYm94LnBhZChib3gud2lkdGggKiBwYWRkaW5nLCBib3guaGVpZ2h0ICogcGFkZGluZyk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUxhbmRtYXJrcy5wcm90b3R5cGUuZ2V0UmVmUG9pbnRzRm9yQWxpZ25tZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0UmVmUG9pbnRzRm9yQWxpZ25tZW50IG5vdCBpbXBsZW1lbnRlZCBieSBiYXNlIGNsYXNzJyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZhY2VMYW5kbWFya3M7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IEZhY2VMYW5kbWFya3MgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmFjZUxhbmRtYXJrcy5qcy5tYXAiLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgZ2V0Q2VudGVyUG9pbnQgfSBmcm9tICcuLi91dGlscyc7XHJcbmltcG9ydCB7IEZhY2VMYW5kbWFya3MgfSBmcm9tICcuL0ZhY2VMYW5kbWFya3MnO1xyXG52YXIgRmFjZUxhbmRtYXJrczUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmFjZUxhbmRtYXJrczUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGYWNlTGFuZG1hcmtzNSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBGYWNlTGFuZG1hcmtzNS5wcm90b3R5cGUuZ2V0UmVmUG9pbnRzRm9yQWxpZ25tZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwdHMgPSB0aGlzLnBvc2l0aW9ucztcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBwdHNbMF0sXHJcbiAgICAgICAgICAgIHB0c1sxXSxcclxuICAgICAgICAgICAgZ2V0Q2VudGVyUG9pbnQoW3B0c1szXSwgcHRzWzRdXSlcclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGYWNlTGFuZG1hcmtzNTtcclxufShGYWNlTGFuZG1hcmtzKSk7XHJcbmV4cG9ydCB7IEZhY2VMYW5kbWFya3M1IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZhY2VMYW5kbWFya3M1LmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBnZXRDZW50ZXJQb2ludCB9IGZyb20gJy4uL3V0aWxzJztcclxuaW1wb3J0IHsgRmFjZUxhbmRtYXJrcyB9IGZyb20gJy4vRmFjZUxhbmRtYXJrcyc7XHJcbnZhciBGYWNlTGFuZG1hcmtzNjggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmFjZUxhbmRtYXJrczY4LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRmFjZUxhbmRtYXJrczY4KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEZhY2VMYW5kbWFya3M2OC5wcm90b3R5cGUuZ2V0SmF3T3V0bGluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnMuc2xpY2UoMCwgMTcpO1xyXG4gICAgfTtcclxuICAgIEZhY2VMYW5kbWFya3M2OC5wcm90b3R5cGUuZ2V0TGVmdEV5ZUJyb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25zLnNsaWNlKDE3LCAyMik7XHJcbiAgICB9O1xyXG4gICAgRmFjZUxhbmRtYXJrczY4LnByb3RvdHlwZS5nZXRSaWdodEV5ZUJyb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25zLnNsaWNlKDIyLCAyNyk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUxhbmRtYXJrczY4LnByb3RvdHlwZS5nZXROb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucy5zbGljZSgyNywgMzYpO1xyXG4gICAgfTtcclxuICAgIEZhY2VMYW5kbWFya3M2OC5wcm90b3R5cGUuZ2V0TGVmdEV5ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnMuc2xpY2UoMzYsIDQyKTtcclxuICAgIH07XHJcbiAgICBGYWNlTGFuZG1hcmtzNjgucHJvdG90eXBlLmdldFJpZ2h0RXllID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucy5zbGljZSg0MiwgNDgpO1xyXG4gICAgfTtcclxuICAgIEZhY2VMYW5kbWFya3M2OC5wcm90b3R5cGUuZ2V0TW91dGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25zLnNsaWNlKDQ4LCA2OCk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUxhbmRtYXJrczY4LnByb3RvdHlwZS5nZXRSZWZQb2ludHNGb3JBbGlnbm1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgdGhpcy5nZXRMZWZ0RXllKCksXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0UmlnaHRFeWUoKSxcclxuICAgICAgICAgICAgdGhpcy5nZXRNb3V0aCgpXHJcbiAgICAgICAgXS5tYXAoZ2V0Q2VudGVyUG9pbnQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGYWNlTGFuZG1hcmtzNjg7XHJcbn0oRmFjZUxhbmRtYXJrcykpO1xyXG5leHBvcnQgeyBGYWNlTGFuZG1hcmtzNjggfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmFjZUxhbmRtYXJrczY4LmpzLm1hcCIsImltcG9ydCB7IHJvdW5kIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG52YXIgRmFjZU1hdGNoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRmFjZU1hdGNoKGxhYmVsLCBkaXN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMuX2xhYmVsID0gbGFiZWw7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWNlTWF0Y2gucHJvdG90eXBlLCBcImxhYmVsXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xhYmVsOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWNlTWF0Y2gucHJvdG90eXBlLCBcImRpc3RhbmNlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEZhY2VNYXRjaC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAod2l0aERpc3RhbmNlKSB7XHJcbiAgICAgICAgaWYgKHdpdGhEaXN0YW5jZSA9PT0gdm9pZCAwKSB7IHdpdGhEaXN0YW5jZSA9IHRydWU7IH1cclxuICAgICAgICByZXR1cm4gXCJcIiArIHRoaXMubGFiZWwgKyAod2l0aERpc3RhbmNlID8gXCIgKFwiICsgcm91bmQodGhpcy5kaXN0YW5jZSkgKyBcIilcIiA6ICcnKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmFjZU1hdGNoO1xyXG59KCkpO1xyXG5leHBvcnQgeyBGYWNlTWF0Y2ggfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmFjZU1hdGNoLmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBpc1ZhbGlkTnVtYmVyIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQgeyBCb3ggfSBmcm9tICcuL0JveCc7XHJcbnZhciBMYWJlbGVkQm94ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKExhYmVsZWRCb3gsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBMYWJlbGVkQm94KGJveCwgbGFiZWwpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib3gpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2xhYmVsID0gbGFiZWw7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTGFiZWxlZEJveC5hc3NlcnRJc1ZhbGlkTGFiZWxlZEJveCA9IGZ1bmN0aW9uIChib3gsIGNhbGxlZSkge1xyXG4gICAgICAgIEJveC5hc3NlcnRJc1ZhbGlkQm94KGJveCwgY2FsbGVlKTtcclxuICAgICAgICBpZiAoIWlzVmFsaWROdW1iZXIoYm94LmxhYmVsKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY2FsbGVlICsgXCIgLSBleHBlY3RlZCBwcm9wZXJ0eSBsYWJlbCAoXCIgKyBib3gubGFiZWwgKyBcIikgdG8gYmUgYSBudW1iZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYWJlbGVkQm94LnByb3RvdHlwZSwgXCJsYWJlbFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sYWJlbDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gTGFiZWxlZEJveDtcclxufShCb3gpKTtcclxuZXhwb3J0IHsgTGFiZWxlZEJveCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYWJlbGVkQm94LmpzLm1hcCIsInZhciBMYWJlbGVkRmFjZURlc2NyaXB0b3JzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTGFiZWxlZEZhY2VEZXNjcmlwdG9ycyhsYWJlbCwgZGVzY3JpcHRvcnMpIHtcclxuICAgICAgICBpZiAoISh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xhYmVsZWRGYWNlRGVzY3JpcHRvcnMgLSBjb25zdHJ1Y3RvciBleHBlY3RlZCBsYWJlbCB0byBiZSBhIHN0cmluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVzY3JpcHRvcnMpIHx8IGRlc2NyaXB0b3JzLnNvbWUoZnVuY3Rpb24gKGRlc2MpIHsgcmV0dXJuICEoZGVzYyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSk7IH0pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGFiZWxlZEZhY2VEZXNjcmlwdG9ycyAtIGNvbnN0cnVjdG9yIGV4cGVjdGVkIGRlc2NyaXB0b3JzIHRvIGJlIGFuIGFycmF5IG9mIEZsb2F0MzJBcnJheScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0b3JzID0gZGVzY3JpcHRvcnM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGFiZWxlZEZhY2VEZXNjcmlwdG9ycy5wcm90b3R5cGUsIFwibGFiZWxcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGFiZWw7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExhYmVsZWRGYWNlRGVzY3JpcHRvcnMucHJvdG90eXBlLCBcImRlc2NyaXB0b3JzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rlc2NyaXB0b3JzOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIExhYmVsZWRGYWNlRGVzY3JpcHRvcnMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsYWJlbDogdGhpcy5sYWJlbCxcclxuICAgICAgICAgICAgZGVzY3JpcHRvcnM6IHRoaXMuZGVzY3JpcHRvcnMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBBcnJheS5mcm9tKGQpOyB9KVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgTGFiZWxlZEZhY2VEZXNjcmlwdG9ycy5mcm9tSlNPTiA9IGZ1bmN0aW9uIChqc29uKSB7XHJcbiAgICAgICAgdmFyIGRlc2NyaXB0b3JzID0ganNvbi5kZXNjcmlwdG9ycy5tYXAoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMYWJlbGVkRmFjZURlc2NyaXB0b3JzKGpzb24ubGFiZWwsIGRlc2NyaXB0b3JzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTGFiZWxlZEZhY2VEZXNjcmlwdG9ycztcclxufSgpKTtcclxuZXhwb3J0IHsgTGFiZWxlZEZhY2VEZXNjcmlwdG9ycyB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYWJlbGVkRmFjZURlc2NyaXB0b3JzLmpzLm1hcCIsImltcG9ydCB7IEJveCB9IGZyb20gJy4vQm94JztcclxuaW1wb3J0IHsgRGltZW5zaW9ucyB9IGZyb20gJy4vRGltZW5zaW9ucyc7XHJcbnZhciBPYmplY3REZXRlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBPYmplY3REZXRlY3Rpb24oc2NvcmUsIGNsYXNzU2NvcmUsIGNsYXNzTmFtZSwgcmVsYXRpdmVCb3gsIGltYWdlRGltcykge1xyXG4gICAgICAgIHRoaXMuX2ltYWdlRGltcyA9IG5ldyBEaW1lbnNpb25zKGltYWdlRGltcy53aWR0aCwgaW1hZ2VEaW1zLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5fc2NvcmUgPSBzY29yZTtcclxuICAgICAgICB0aGlzLl9jbGFzc1Njb3JlID0gY2xhc3NTY29yZTtcclxuICAgICAgICB0aGlzLl9jbGFzc05hbWUgPSBjbGFzc05hbWU7XHJcbiAgICAgICAgdGhpcy5fYm94ID0gbmV3IEJveChyZWxhdGl2ZUJveCkucmVzY2FsZSh0aGlzLl9pbWFnZURpbXMpO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdERldGVjdGlvbi5wcm90b3R5cGUsIFwic2NvcmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2NvcmU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdERldGVjdGlvbi5wcm90b3R5cGUsIFwiY2xhc3NTY29yZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jbGFzc1Njb3JlOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3REZXRlY3Rpb24ucHJvdG90eXBlLCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jbGFzc05hbWU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdERldGVjdGlvbi5wcm90b3R5cGUsIFwiYm94XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2JveDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0RGV0ZWN0aW9uLnByb3RvdHlwZSwgXCJpbWFnZURpbXNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faW1hZ2VEaW1zOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3REZXRlY3Rpb24ucHJvdG90eXBlLCBcImltYWdlV2lkdGhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbWFnZURpbXMud2lkdGg7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdERldGVjdGlvbi5wcm90b3R5cGUsIFwiaW1hZ2VIZWlnaHRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbWFnZURpbXMuaGVpZ2h0OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3REZXRlY3Rpb24ucHJvdG90eXBlLCBcInJlbGF0aXZlQm94XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBCb3godGhpcy5fYm94KS5yZXNjYWxlKHRoaXMuaW1hZ2VEaW1zLnJldmVyc2UoKSk7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0RGV0ZWN0aW9uLnByb3RvdHlwZS5mb3JTaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9iamVjdERldGVjdGlvbih0aGlzLnNjb3JlLCB0aGlzLmNsYXNzU2NvcmUsIHRoaXMuY2xhc3NOYW1lLCB0aGlzLnJlbGF0aXZlQm94LCB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9iamVjdERldGVjdGlvbjtcclxufSgpKTtcclxuZXhwb3J0IHsgT2JqZWN0RGV0ZWN0aW9uIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdERldGVjdGlvbi5qcy5tYXAiLCJ2YXIgUG9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQb2ludCh4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5feCA9IHg7XHJcbiAgICAgICAgdGhpcy5feSA9IHk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9pbnQucHJvdG90eXBlLCBcInhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5feDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9pbnQucHJvdG90eXBlLCBcInlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5feTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBQb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHB0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBwdC54LCB0aGlzLnkgKyBwdC55KTtcclxuICAgIH07XHJcbiAgICBQb2ludC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKHB0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSBwdC54LCB0aGlzLnkgLSBwdC55KTtcclxuICAgIH07XHJcbiAgICBQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gKHB0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwdC54LCB0aGlzLnkgKiBwdC55KTtcclxuICAgIH07XHJcbiAgICBQb2ludC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKHB0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBwdC54LCB0aGlzLnkgLyBwdC55KTtcclxuICAgIH07XHJcbiAgICBQb2ludC5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoTWF0aC5hYnModGhpcy54KSwgTWF0aC5hYnModGhpcy55KSk7XHJcbiAgICB9O1xyXG4gICAgUG9pbnQucHJvdG90eXBlLm1hZ25pdHVkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMueCwgMikgKyBNYXRoLnBvdyh0aGlzLnksIDIpKTtcclxuICAgIH07XHJcbiAgICBQb2ludC5wcm90b3R5cGUuZmxvb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLmZsb29yKHRoaXMueCksIE1hdGguZmxvb3IodGhpcy55KSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBvaW50O1xyXG59KCkpO1xyXG5leHBvcnQgeyBQb2ludCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2ludC5qcy5tYXAiLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgaXNWYWxpZFByb2JhYmxpdGl5IH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQgeyBMYWJlbGVkQm94IH0gZnJvbSAnLi9MYWJlbGVkQm94JztcclxudmFyIFByZWRpY3RlZEJveCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcmVkaWN0ZWRCb3gsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQcmVkaWN0ZWRCb3goYm94LCBsYWJlbCwgc2NvcmUsIGNsYXNzU2NvcmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib3gsIGxhYmVsKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl9zY29yZSA9IHNjb3JlO1xyXG4gICAgICAgIF90aGlzLl9jbGFzc1Njb3JlID0gY2xhc3NTY29yZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBQcmVkaWN0ZWRCb3guYXNzZXJ0SXNWYWxpZFByZWRpY3RlZEJveCA9IGZ1bmN0aW9uIChib3gsIGNhbGxlZSkge1xyXG4gICAgICAgIExhYmVsZWRCb3guYXNzZXJ0SXNWYWxpZExhYmVsZWRCb3goYm94LCBjYWxsZWUpO1xyXG4gICAgICAgIGlmICghaXNWYWxpZFByb2JhYmxpdGl5KGJveC5zY29yZSlcclxuICAgICAgICAgICAgfHwgIWlzVmFsaWRQcm9iYWJsaXRpeShib3guY2xhc3NTY29yZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNhbGxlZSArIFwiIC0gZXhwZWN0ZWQgcHJvcGVydGllcyBzY29yZSAoXCIgKyBib3guc2NvcmUgKyBcIikgYW5kIChcIiArIGJveC5jbGFzc1Njb3JlICsgXCIpIHRvIGJlIGEgbnVtYmVyIGJldHdlZW4gWzAsIDFdXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJlZGljdGVkQm94LnByb3RvdHlwZSwgXCJzY29yZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zY29yZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJlZGljdGVkQm94LnByb3RvdHlwZSwgXCJjbGFzc1Njb3JlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NsYXNzU2NvcmU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFByZWRpY3RlZEJveDtcclxufShMYWJlbGVkQm94KSk7XHJcbmV4cG9ydCB7IFByZWRpY3RlZEJveCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QcmVkaWN0ZWRCb3guanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IEJveCB9IGZyb20gJy4vQm94JztcclxudmFyIFJlY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUmVjdCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgYWxsb3dOZWdhdGl2ZURpbWVuc2lvbnMpIHtcclxuICAgICAgICBpZiAoYWxsb3dOZWdhdGl2ZURpbWVuc2lvbnMgPT09IHZvaWQgMCkgeyBhbGxvd05lZ2F0aXZlRGltZW5zaW9ucyA9IGZhbHNlOyB9XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9LCBhbGxvd05lZ2F0aXZlRGltZW5zaW9ucykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBSZWN0O1xyXG59KEJveCkpO1xyXG5leHBvcnQgeyBSZWN0IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlY3QuanMubWFwIiwiZXhwb3J0ICogZnJvbSAnLi9Cb3VuZGluZ0JveCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vQm94JztcclxuZXhwb3J0ICogZnJvbSAnLi9EaW1lbnNpb25zJztcclxuZXhwb3J0ICogZnJvbSAnLi9GYWNlRGV0ZWN0aW9uJztcclxuZXhwb3J0ICogZnJvbSAnLi9GYWNlTGFuZG1hcmtzJztcclxuZXhwb3J0ICogZnJvbSAnLi9GYWNlTGFuZG1hcmtzNSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vRmFjZUxhbmRtYXJrczY4JztcclxuZXhwb3J0ICogZnJvbSAnLi9GYWNlTWF0Y2gnO1xyXG5leHBvcnQgKiBmcm9tICcuL0xhYmVsZWRCb3gnO1xyXG5leHBvcnQgKiBmcm9tICcuL0xhYmVsZWRGYWNlRGVzY3JpcHRvcnMnO1xyXG5leHBvcnQgKiBmcm9tICcuL09iamVjdERldGVjdGlvbic7XHJcbmV4cG9ydCAqIGZyb20gJy4vUG9pbnQnO1xyXG5leHBvcnQgKiBmcm9tICcuL1ByZWRpY3RlZEJveCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vUmVjdCc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBjb252TGF5ZXIoeCwgcGFyYW1zLCBwYWRkaW5nLCB3aXRoUmVsdSkge1xyXG4gICAgaWYgKHBhZGRpbmcgPT09IHZvaWQgMCkgeyBwYWRkaW5nID0gJ3NhbWUnOyB9XHJcbiAgICBpZiAod2l0aFJlbHUgPT09IHZvaWQgMCkgeyB3aXRoUmVsdSA9IGZhbHNlOyB9XHJcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG91dCA9IHRmLmFkZCh0Zi5jb252MmQoeCwgcGFyYW1zLmZpbHRlcnMsIFsxLCAxXSwgcGFkZGluZyksIHBhcmFtcy5iaWFzKTtcclxuICAgICAgICByZXR1cm4gd2l0aFJlbHUgPyB0Zi5yZWx1KG91dCkgOiBvdXQ7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252TGF5ZXIuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuZXhwb3J0IGZ1bmN0aW9uIGRlcHRod2lzZVNlcGFyYWJsZUNvbnYoeCwgcGFyYW1zLCBzdHJpZGUpIHtcclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3V0ID0gdGYuc2VwYXJhYmxlQ29udjJkKHgsIHBhcmFtcy5kZXB0aHdpc2VfZmlsdGVyLCBwYXJhbXMucG9pbnR3aXNlX2ZpbHRlciwgc3RyaWRlLCAnc2FtZScpO1xyXG4gICAgICAgIG91dCA9IHRmLmFkZChvdXQsIHBhcmFtcy5iaWFzKTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwdGh3aXNlU2VwYXJhYmxlQ29udi5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKSB7XHJcbiAgICBPYmplY3Qua2V5cyh3ZWlnaHRNYXApLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgICAgICBpZiAoIXBhcmFtTWFwcGluZ3Muc29tZShmdW5jdGlvbiAocG0pIHsgcmV0dXJuIHBtLm9yaWdpbmFsUGF0aCA9PT0gcGF0aDsgfSkpIHtcclxuICAgICAgICAgICAgd2VpZ2h0TWFwW3BhdGhdLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycy5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdENvbnZQYXJhbXNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCBmaWx0ZXJTaXplLCBtYXBwZWRQcmVmaXgpIHtcclxuICAgICAgICB2YXIgZmlsdGVycyA9IHRmLnRlbnNvcjRkKGV4dHJhY3RXZWlnaHRzKGNoYW5uZWxzSW4gKiBjaGFubmVsc091dCAqIGZpbHRlclNpemUgKiBmaWx0ZXJTaXplKSwgW2ZpbHRlclNpemUsIGZpbHRlclNpemUsIGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0XSk7XHJcbiAgICAgICAgdmFyIGJpYXMgPSB0Zi50ZW5zb3IxZChleHRyYWN0V2VpZ2h0cyhjaGFubmVsc091dCkpO1xyXG4gICAgICAgIHBhcmFtTWFwcGluZ3MucHVzaCh7IHBhcmFtUGF0aDogbWFwcGVkUHJlZml4ICsgXCIvZmlsdGVyc1wiIH0sIHsgcGFyYW1QYXRoOiBtYXBwZWRQcmVmaXggKyBcIi9iaWFzXCIgfSk7XHJcbiAgICAgICAgcmV0dXJuIHsgZmlsdGVyczogZmlsdGVycywgYmlhczogYmlhcyB9O1xyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0Q29udlBhcmFtc0ZhY3RvcnkuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RGQ1BhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXQsIG1hcHBlZFByZWZpeCkge1xyXG4gICAgICAgIHZhciBmY193ZWlnaHRzID0gdGYudGVuc29yMmQoZXh0cmFjdFdlaWdodHMoY2hhbm5lbHNJbiAqIGNoYW5uZWxzT3V0KSwgW2NoYW5uZWxzSW4sIGNoYW5uZWxzT3V0XSk7XHJcbiAgICAgICAgdmFyIGZjX2JpYXMgPSB0Zi50ZW5zb3IxZChleHRyYWN0V2VpZ2h0cyhjaGFubmVsc091dCkpO1xyXG4gICAgICAgIHBhcmFtTWFwcGluZ3MucHVzaCh7IHBhcmFtUGF0aDogbWFwcGVkUHJlZml4ICsgXCIvd2VpZ2h0c1wiIH0sIHsgcGFyYW1QYXRoOiBtYXBwZWRQcmVmaXggKyBcIi9iaWFzXCIgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgd2VpZ2h0czogZmNfd2VpZ2h0cyxcclxuICAgICAgICAgICAgYmlhczogZmNfYmlhc1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RGQ1BhcmFtc0ZhY3RvcnkuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgU2VwYXJhYmxlQ29udlBhcmFtcyB9IGZyb20gJy4vdHlwZXMnO1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCBtYXBwZWRQcmVmaXgpIHtcclxuICAgICAgICB2YXIgZGVwdGh3aXNlX2ZpbHRlciA9IHRmLnRlbnNvcjRkKGV4dHJhY3RXZWlnaHRzKDMgKiAzICogY2hhbm5lbHNJbiksIFszLCAzLCBjaGFubmVsc0luLCAxXSk7XHJcbiAgICAgICAgdmFyIHBvaW50d2lzZV9maWx0ZXIgPSB0Zi50ZW5zb3I0ZChleHRyYWN0V2VpZ2h0cyhjaGFubmVsc0luICogY2hhbm5lbHNPdXQpLCBbMSwgMSwgY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXRdKTtcclxuICAgICAgICB2YXIgYmlhcyA9IHRmLnRlbnNvcjFkKGV4dHJhY3RXZWlnaHRzKGNoYW5uZWxzT3V0KSk7XHJcbiAgICAgICAgcGFyYW1NYXBwaW5ncy5wdXNoKHsgcGFyYW1QYXRoOiBtYXBwZWRQcmVmaXggKyBcIi9kZXB0aHdpc2VfZmlsdGVyXCIgfSwgeyBwYXJhbVBhdGg6IG1hcHBlZFByZWZpeCArIFwiL3BvaW50d2lzZV9maWx0ZXJcIiB9LCB7IHBhcmFtUGF0aDogbWFwcGVkUHJlZml4ICsgXCIvYmlhc1wiIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VwYXJhYmxlQ29udlBhcmFtcyhkZXB0aHdpc2VfZmlsdGVyLCBwb2ludHdpc2VfZmlsdGVyLCBiaWFzKTtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRTZXBhcmFibGVDb252UGFyYW1zRmFjdG9yeShleHRyYWN0V2VpZ2h0RW50cnkpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHJlZml4KSB7XHJcbiAgICAgICAgdmFyIGRlcHRod2lzZV9maWx0ZXIgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvZGVwdGh3aXNlX2ZpbHRlclwiLCA0KTtcclxuICAgICAgICB2YXIgcG9pbnR3aXNlX2ZpbHRlciA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi9wb2ludHdpc2VfZmlsdGVyXCIsIDQpO1xyXG4gICAgICAgIHZhciBiaWFzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL2JpYXNcIiwgMSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZXBhcmFibGVDb252UGFyYW1zKGRlcHRod2lzZV9maWx0ZXIsIHBvaW50d2lzZV9maWx0ZXIsIGJpYXMpO1xyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnkuanMubWFwIiwiaW1wb3J0IHsgaXNUZW5zb3IgfSBmcm9tICcuLi91dGlscyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0V2VpZ2h0RW50cnlGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvcmlnaW5hbFBhdGgsIHBhcmFtUmFuaywgbWFwcGVkUGF0aCkge1xyXG4gICAgICAgIHZhciB0ZW5zb3IgPSB3ZWlnaHRNYXBbb3JpZ2luYWxQYXRoXTtcclxuICAgICAgICBpZiAoIWlzVGVuc29yKHRlbnNvciwgcGFyYW1SYW5rKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCB3ZWlnaHRNYXBbXCIgKyBvcmlnaW5hbFBhdGggKyBcIl0gdG8gYmUgYSBUZW5zb3JcIiArIHBhcmFtUmFuayArIFwiRCwgaW5zdGVhZCBoYXZlIFwiICsgdGVuc29yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyYW1NYXBwaW5ncy5wdXNoKHsgb3JpZ2luYWxQYXRoOiBvcmlnaW5hbFBhdGgsIHBhcmFtUGF0aDogbWFwcGVkUGF0aCB8fCBvcmlnaW5hbFBhdGggfSk7XHJcbiAgICAgICAgcmV0dXJuIHRlbnNvcjtcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFdlaWdodEVudHJ5RmFjdG9yeS5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gZXh0cmFjdFdlaWdodHNGYWN0b3J5KHdlaWdodHMpIHtcclxuICAgIHZhciByZW1haW5pbmdXZWlnaHRzID0gd2VpZ2h0cztcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RXZWlnaHRzKG51bVdlaWdodHMpIHtcclxuICAgICAgICB2YXIgcmV0ID0gcmVtYWluaW5nV2VpZ2h0cy5zbGljZSgwLCBudW1XZWlnaHRzKTtcclxuICAgICAgICByZW1haW5pbmdXZWlnaHRzID0gcmVtYWluaW5nV2VpZ2h0cy5zbGljZShudW1XZWlnaHRzKTtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0UmVtYWluaW5nV2VpZ2h0cygpIHtcclxuICAgICAgICByZXR1cm4gcmVtYWluaW5nV2VpZ2h0cztcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZXh0cmFjdFdlaWdodHM6IGV4dHJhY3RXZWlnaHRzLFxyXG4gICAgICAgIGdldFJlbWFpbmluZ1dlaWdodHM6IGdldFJlbWFpbmluZ1dlaWdodHNcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFdlaWdodHNGYWN0b3J5LmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBmdWxseUNvbm5lY3RlZExheWVyKHgsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0Zi5hZGQodGYubWF0TXVsKHgsIHBhcmFtcy53ZWlnaHRzKSwgcGFyYW1zLmJpYXMpO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVsbHlDb25uZWN0ZWRMYXllci5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gZ2V0TW9kZWxVcmlzKHVyaSwgZGVmYXVsdE1vZGVsTmFtZSkge1xyXG4gICAgdmFyIGRlZmF1bHRNYW5pZmVzdEZpbGVuYW1lID0gZGVmYXVsdE1vZGVsTmFtZSArIFwiLXdlaWdodHNfbWFuaWZlc3QuanNvblwiO1xyXG4gICAgaWYgKCF1cmkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtb2RlbEJhc2VVcmk6ICcnLFxyXG4gICAgICAgICAgICBtYW5pZmVzdFVyaTogZGVmYXVsdE1hbmlmZXN0RmlsZW5hbWVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHVyaSA9PT0gJy8nKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbW9kZWxCYXNlVXJpOiAnLycsXHJcbiAgICAgICAgICAgIG1hbmlmZXN0VXJpOiBcIi9cIiArIGRlZmF1bHRNYW5pZmVzdEZpbGVuYW1lXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHZhciBwcm90b2NvbCA9IHVyaS5zdGFydHNXaXRoKCdodHRwOi8vJykgPyAnaHR0cDovLycgOiB1cmkuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSA/ICdodHRwczovLycgOiAnJztcclxuICAgIHVyaSA9IHVyaS5yZXBsYWNlKHByb3RvY29sLCAnJyk7XHJcbiAgICB2YXIgcGFydHMgPSB1cmkuc3BsaXQoJy8nKS5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHM7IH0pO1xyXG4gICAgdmFyIG1hbmlmZXN0RmlsZSA9IHVyaS5lbmRzV2l0aCgnLmpzb24nKVxyXG4gICAgICAgID8gcGFydHNbcGFydHMubGVuZ3RoIC0gMV1cclxuICAgICAgICA6IGRlZmF1bHRNYW5pZmVzdEZpbGVuYW1lO1xyXG4gICAgdmFyIG1vZGVsQmFzZVVyaSA9IHByb3RvY29sICsgKHVyaS5lbmRzV2l0aCgnLmpzb24nKSA/IHBhcnRzLnNsaWNlKDAsIHBhcnRzLmxlbmd0aCAtIDEpIDogcGFydHMpLmpvaW4oJy8nKTtcclxuICAgIG1vZGVsQmFzZVVyaSA9IHVyaS5zdGFydHNXaXRoKCcvJykgPyBcIi9cIiArIG1vZGVsQmFzZVVyaSA6IG1vZGVsQmFzZVVyaTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbW9kZWxCYXNlVXJpOiBtb2RlbEJhc2VVcmksXHJcbiAgICAgICAgbWFuaWZlc3RVcmk6IG1vZGVsQmFzZVVyaSA9PT0gJy8nID8gXCIvXCIgKyBtYW5pZmVzdEZpbGUgOiBtb2RlbEJhc2VVcmkgKyBcIi9cIiArIG1hbmlmZXN0RmlsZVxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRNb2RlbFVyaXMuanMubWFwIiwiZXhwb3J0ICogZnJvbSAnLi9jb252TGF5ZXInO1xyXG5leHBvcnQgKiBmcm9tICcuL2RlcHRod2lzZVNlcGFyYWJsZUNvbnYnO1xyXG5leHBvcnQgKiBmcm9tICcuL2Rpc3Bvc2VVbnVzZWRXZWlnaHRUZW5zb3JzJztcclxuZXhwb3J0ICogZnJvbSAnLi9leHRyYWN0Q29udlBhcmFtc0ZhY3RvcnknO1xyXG5leHBvcnQgKiBmcm9tICcuL2V4dHJhY3RGQ1BhcmFtc0ZhY3RvcnknO1xyXG5leHBvcnQgKiBmcm9tICcuL2V4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zRmFjdG9yeSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZXh0cmFjdFdlaWdodEVudHJ5RmFjdG9yeSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZXh0cmFjdFdlaWdodHNGYWN0b3J5JztcclxuZXhwb3J0ICogZnJvbSAnLi9nZXRNb2RlbFVyaXMnO1xyXG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGxvYWRDb252UGFyYW1zRmFjdG9yeShleHRyYWN0V2VpZ2h0RW50cnkpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHJlZml4KSB7XHJcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvZmlsdGVyc1wiLCA0KTtcclxuICAgICAgICB2YXIgYmlhcyA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi9iaWFzXCIsIDEpO1xyXG4gICAgICAgIHJldHVybiB7IGZpbHRlcnM6IGZpbHRlcnMsIGJpYXM6IGJpYXMgfTtcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZENvbnZQYXJhbXNGYWN0b3J5LmpzLm1hcCIsInZhciBTZXBhcmFibGVDb252UGFyYW1zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2VwYXJhYmxlQ29udlBhcmFtcyhkZXB0aHdpc2VfZmlsdGVyLCBwb2ludHdpc2VfZmlsdGVyLCBiaWFzKSB7XHJcbiAgICAgICAgdGhpcy5kZXB0aHdpc2VfZmlsdGVyID0gZGVwdGh3aXNlX2ZpbHRlcjtcclxuICAgICAgICB0aGlzLnBvaW50d2lzZV9maWx0ZXIgPSBwb2ludHdpc2VfZmlsdGVyO1xyXG4gICAgICAgIHRoaXMuYmlhcyA9IGJpYXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU2VwYXJhYmxlQ29udlBhcmFtcztcclxufSgpKTtcclxuZXhwb3J0IHsgU2VwYXJhYmxlQ29udlBhcmFtcyB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYnO1xyXG5pbXBvcnQgeyBwYWRUb1NxdWFyZSB9IGZyb20gJy4uL29wcy9wYWRUb1NxdWFyZSc7XHJcbmltcG9ydCB7IGNvbXB1dGVSZXNoYXBlZERpbWVuc2lvbnMsIGlzVGVuc29yM0QsIGlzVGVuc29yNEQsIHJhbmdlIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQgeyBjcmVhdGVDYW52YXNGcm9tTWVkaWEgfSBmcm9tICcuL2NyZWF0ZUNhbnZhcyc7XHJcbmltcG9ydCB7IGltYWdlVG9TcXVhcmUgfSBmcm9tICcuL2ltYWdlVG9TcXVhcmUnO1xyXG52YXIgTmV0SW5wdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZXRJbnB1dChpbnB1dHMsIHRyZWF0QXNCYXRjaElucHV0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodHJlYXRBc0JhdGNoSW5wdXQgPT09IHZvaWQgMCkgeyB0cmVhdEFzQmF0Y2hJbnB1dCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdGhpcy5faW1hZ2VUZW5zb3JzID0gW107XHJcbiAgICAgICAgdGhpcy5fY2FudmFzZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl90cmVhdEFzQmF0Y2hJbnB1dCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2lucHV0RGltZW5zaW9ucyA9IFtdO1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ldElucHV0LmNvbnN0cnVjdG9yIC0gZXhwZWN0ZWQgaW5wdXRzIHRvIGJlIGFuIEFycmF5IG9mIFRSZXNvbHZlZE5ldElucHV0IG9yIHRvIGJlIGluc3RhbmNlb2YgdGYuVGVuc29yNEQsIGluc3RlYWQgaGF2ZSBcIiArIGlucHV0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RyZWF0QXNCYXRjaElucHV0ID0gdHJlYXRBc0JhdGNoSW5wdXQ7XHJcbiAgICAgICAgdGhpcy5fYmF0Y2hTaXplID0gaW5wdXRzLmxlbmd0aDtcclxuICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQsIGlkeCkge1xyXG4gICAgICAgICAgICBpZiAoaXNUZW5zb3IzRChpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9pbWFnZVRlbnNvcnNbaWR4XSA9IGlucHV0O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2lucHV0RGltZW5zaW9uc1tpZHhdID0gaW5wdXQuc2hhcGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzVGVuc29yNEQoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmF0Y2hTaXplID0gaW5wdXQuc2hhcGVbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAoYmF0Y2hTaXplICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmV0SW5wdXQgLSB0Zi5UZW5zb3I0RCB3aXRoIGJhdGNoU2l6ZSBcIiArIGJhdGNoU2l6ZSArIFwiIHBhc3NlZCwgYnV0IG5vdCBzdXBwb3J0ZWQgaW4gaW5wdXQgYXJyYXlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5faW1hZ2VUZW5zb3JzW2lkeF0gPSBpbnB1dDtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9pbnB1dERpbWVuc2lvbnNbaWR4XSA9IGlucHV0LnNoYXBlLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBpbnB1dCBpbnN0YW5jZW9mIGVudi5nZXRFbnYoKS5DYW52YXMgPyBpbnB1dCA6IGNyZWF0ZUNhbnZhc0Zyb21NZWRpYShpbnB1dCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9jYW52YXNlc1tpZHhdID0gY2FudmFzO1xyXG4gICAgICAgICAgICBfdGhpcy5faW5wdXREaW1lbnNpb25zW2lkeF0gPSBbY2FudmFzLmhlaWdodCwgY2FudmFzLndpZHRoLCAzXTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXRJbnB1dC5wcm90b3R5cGUsIFwiaW1hZ2VUZW5zb3JzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlVGVuc29ycztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXRJbnB1dC5wcm90b3R5cGUsIFwiY2FudmFzZXNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmV0SW5wdXQucHJvdG90eXBlLCBcImlzQmF0Y2hJbnB1dFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhdGNoU2l6ZSA+IDEgfHwgdGhpcy5fdHJlYXRBc0JhdGNoSW5wdXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmV0SW5wdXQucHJvdG90eXBlLCBcImJhdGNoU2l6ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYXRjaFNpemU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmV0SW5wdXQucHJvdG90eXBlLCBcImlucHV0RGltZW5zaW9uc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dERpbWVuc2lvbnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmV0SW5wdXQucHJvdG90eXBlLCBcImlucHV0U2l6ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dFNpemU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmV0SW5wdXQucHJvdG90eXBlLCBcInJlc2hhcGVkSW5wdXREaW1lbnNpb25zXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlKHRoaXMuYmF0Y2hTaXplLCAwLCAxKS5tYXAoZnVuY3Rpb24gKF8sIGJhdGNoSWR4KSB7IHJldHVybiBfdGhpcy5nZXRSZXNoYXBlZElucHV0RGltZW5zaW9ucyhiYXRjaElkeCk7IH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTmV0SW5wdXQucHJvdG90eXBlLmdldElucHV0ID0gZnVuY3Rpb24gKGJhdGNoSWR4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzZXNbYmF0Y2hJZHhdIHx8IHRoaXMuaW1hZ2VUZW5zb3JzW2JhdGNoSWR4XTtcclxuICAgIH07XHJcbiAgICBOZXRJbnB1dC5wcm90b3R5cGUuZ2V0SW5wdXREaW1lbnNpb25zID0gZnVuY3Rpb24gKGJhdGNoSWR4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0RGltZW5zaW9uc1tiYXRjaElkeF07XHJcbiAgICB9O1xyXG4gICAgTmV0SW5wdXQucHJvdG90eXBlLmdldElucHV0SGVpZ2h0ID0gZnVuY3Rpb24gKGJhdGNoSWR4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0RGltZW5zaW9uc1tiYXRjaElkeF1bMF07XHJcbiAgICB9O1xyXG4gICAgTmV0SW5wdXQucHJvdG90eXBlLmdldElucHV0V2lkdGggPSBmdW5jdGlvbiAoYmF0Y2hJZHgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5wdXREaW1lbnNpb25zW2JhdGNoSWR4XVsxXTtcclxuICAgIH07XHJcbiAgICBOZXRJbnB1dC5wcm90b3R5cGUuZ2V0UmVzaGFwZWRJbnB1dERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoYmF0Y2hJZHgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW5wdXRTaXplICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldFJlc2hhcGVkSW5wdXREaW1lbnNpb25zIC0gaW5wdXRTaXplIG5vdCBzZXQsIHRvQmF0Y2hUZW5zb3IgaGFzIG5vdCBiZWVuIGNhbGxlZCB5ZXQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRJbnB1dFdpZHRoKGJhdGNoSWR4KTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRJbnB1dEhlaWdodChiYXRjaElkeCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVSZXNoYXBlZERpbWVuc2lvbnMoeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0sIHRoaXMuaW5wdXRTaXplKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGJhdGNoIHRlbnNvciBmcm9tIGFsbCBpbnB1dCBjYW52YXNlcyBhbmQgdGVuc29yc1xyXG4gICAgICogd2l0aCBzaXplIFtiYXRjaFNpemUsIGlucHV0U2l6ZSwgaW5wdXRTaXplLCAzXS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5wdXRTaXplIEhlaWdodCBhbmQgd2lkdGggb2YgdGhlIHRlbnNvci5cclxuICAgICAqIEBwYXJhbSBpc0NlbnRlckltYWdlIChvcHRpb25hbCwgZGVmYXVsdDogZmFsc2UpIElmIHRydWUsIGFkZCBhbiBlcXVhbCBhbW91bnQgb2YgcGFkZGluZyBvblxyXG4gICAgICogYm90aCBzaWRlcyBvZiB0aGUgbWlub3IgZGltZW5zaW9uIG9vZiB0aGUgaW1hZ2UuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYmF0Y2ggdGVuc29yLlxyXG4gICAgICovXHJcbiAgICBOZXRJbnB1dC5wcm90b3R5cGUudG9CYXRjaFRlbnNvciA9IGZ1bmN0aW9uIChpbnB1dFNpemUsIGlzQ2VudGVySW5wdXRzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoaXNDZW50ZXJJbnB1dHMgPT09IHZvaWQgMCkgeyBpc0NlbnRlcklucHV0cyA9IHRydWU7IH1cclxuICAgICAgICB0aGlzLl9pbnB1dFNpemUgPSBpbnB1dFNpemU7XHJcbiAgICAgICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaW5wdXRUZW5zb3JzID0gcmFuZ2UoX3RoaXMuYmF0Y2hTaXplLCAwLCAxKS5tYXAoZnVuY3Rpb24gKGJhdGNoSWR4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBfdGhpcy5nZXRJbnB1dChiYXRjaElkeCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiB0Zi5UZW5zb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW1nVGVuc29yID0gaXNUZW5zb3I0RChpbnB1dCkgPyBpbnB1dCA6IGlucHV0LmV4cGFuZERpbXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBpbWdUZW5zb3IgPSBwYWRUb1NxdWFyZShpbWdUZW5zb3IsIGlzQ2VudGVySW5wdXRzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1nVGVuc29yLnNoYXBlWzFdICE9PSBpbnB1dFNpemUgfHwgaW1nVGVuc29yLnNoYXBlWzJdICE9PSBpbnB1dFNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nVGVuc29yID0gdGYuaW1hZ2UucmVzaXplQmlsaW5lYXIoaW1nVGVuc29yLCBbaW5wdXRTaXplLCBpbnB1dFNpemVdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltZ1RlbnNvci5hczNEKGlucHV0U2l6ZSwgaW5wdXRTaXplLCAzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIGVudi5nZXRFbnYoKS5DYW52YXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKGltYWdlVG9TcXVhcmUoaW5wdXQsIGlucHV0U2l6ZSwgaXNDZW50ZXJJbnB1dHMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvQmF0Y2hUZW5zb3IgLSBhdCBiYXRjaElkeCBcIiArIGJhdGNoSWR4ICsgXCIsIGV4cGVjdGVkIGlucHV0IHRvIGJlIGluc3RhbmNlb2YgdGYuVGVuc29yIG9yIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQsIGluc3RlYWQgaGF2ZSBcIiArIGlucHV0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBiYXRjaFRlbnNvciA9IHRmLnN0YWNrKGlucHV0VGVuc29ycy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQudG9GbG9hdCgpOyB9KSkuYXM0RChfdGhpcy5iYXRjaFNpemUsIGlucHV0U2l6ZSwgaW5wdXRTaXplLCAzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJhdGNoVGVuc29yO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBOZXRJbnB1dDtcclxufSgpKTtcclxuZXhwb3J0IHsgTmV0SW5wdXQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmV0SW5wdXQuanMubWFwIiwiaW1wb3J0IHsgZW52IH0gZnJvbSAnLi4vZW52JztcclxuaW1wb3J0IHsgaXNNZWRpYUxvYWRlZCB9IGZyb20gJy4vaXNNZWRpYUxvYWRlZCc7XHJcbmV4cG9ydCBmdW5jdGlvbiBhd2FpdE1lZGlhTG9hZGVkKG1lZGlhKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGlmIChtZWRpYSBpbnN0YW5jZW9mIGVudi5nZXRFbnYoKS5DYW52YXMgfHwgaXNNZWRpYUxvYWRlZChtZWRpYSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gb25Mb2FkKGUpIHtcclxuICAgICAgICAgICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcclxuICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XHJcbiAgICAgICAgICAgIHJlc29sdmUoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZSkge1xyXG4gICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xyXG4gICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcclxuICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcclxuICAgICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXdhaXRNZWRpYUxvYWRlZC5qcy5tYXAiLCJpbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYnO1xyXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyVG9JbWFnZShidWYpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgaWYgKCEoYnVmIGluc3RhbmNlb2YgQmxvYikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgnYnVmZmVyVG9JbWFnZSAtIGV4cGVjdGVkIGJ1ZiB0byBiZSBvZiB0eXBlOiBCbG9iJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhZGVyLnJlc3VsdCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoJ2J1ZmZlclRvSW1hZ2UgLSBleHBlY3RlZCByZWFkZXIucmVzdWx0IHRvIGJlIGEgc3RyaW5nLCBpbiBvbmxvYWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW1nID0gZW52LmdldEVudigpLmNyZWF0ZUltYWdlRWxlbWVudCgpO1xyXG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZShpbWcpOyB9O1xyXG4gICAgICAgICAgICBpbWcub25lcnJvciA9IHJlamVjdDtcclxuICAgICAgICAgICAgaW1nLnNyYyA9IHJlYWRlci5yZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcclxuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChidWYpO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyVG9JbWFnZS5qcy5tYXAiLCJpbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYnO1xyXG5pbXBvcnQgeyBnZXRDb250ZXh0MmRPclRocm93IH0gZnJvbSAnLi9nZXRDb250ZXh0MmRPclRocm93JztcclxuaW1wb3J0IHsgZ2V0TWVkaWFEaW1lbnNpb25zIH0gZnJvbSAnLi9nZXRNZWRpYURpbWVuc2lvbnMnO1xyXG5pbXBvcnQgeyBpc01lZGlhTG9hZGVkIH0gZnJvbSAnLi9pc01lZGlhTG9hZGVkJztcclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyhfYSkge1xyXG4gICAgdmFyIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgIHZhciBjcmVhdGVDYW52YXNFbGVtZW50ID0gZW52LmdldEVudigpLmNyZWF0ZUNhbnZhc0VsZW1lbnQ7XHJcbiAgICB2YXIgY2FudmFzID0gY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xyXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgcmV0dXJuIGNhbnZhcztcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FudmFzRnJvbU1lZGlhKG1lZGlhLCBkaW1zKSB7XHJcbiAgICB2YXIgSW1hZ2VEYXRhID0gZW52LmdldEVudigpLkltYWdlRGF0YTtcclxuICAgIGlmICghKG1lZGlhIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSAmJiAhaXNNZWRpYUxvYWRlZChtZWRpYSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZUNhbnZhc0Zyb21NZWRpYSAtIG1lZGlhIGhhcyBub3QgZmluaXNoZWQgbG9hZGluZyB5ZXQnKTtcclxuICAgIH1cclxuICAgIHZhciBfYSA9IGRpbXMgfHwgZ2V0TWVkaWFEaW1lbnNpb25zKG1lZGlhKSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgdmFyIGNhbnZhcyA9IGNyZWF0ZUNhbnZhcyh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcbiAgICBpZiAobWVkaWEgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcclxuICAgICAgICBnZXRDb250ZXh0MmRPclRocm93KGNhbnZhcykucHV0SW1hZ2VEYXRhKG1lZGlhLCAwLCAwKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldENvbnRleHQyZE9yVGhyb3coY2FudmFzKS5kcmF3SW1hZ2UobWVkaWEsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVDYW52YXMuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBGYWNlRGV0ZWN0aW9uIH0gZnJvbSAnLi4vY2xhc3Nlcy9GYWNlRGV0ZWN0aW9uJztcclxuaW1wb3J0IHsgaXNUZW5zb3IzRCwgaXNUZW5zb3I0RCB9IGZyb20gJy4uL3V0aWxzJztcclxuLyoqXHJcbiAqIEV4dHJhY3RzIHRoZSB0ZW5zb3JzIG9mIHRoZSBpbWFnZSByZWdpb25zIGNvbnRhaW5pbmcgdGhlIGRldGVjdGVkIGZhY2VzLlxyXG4gKiBVc2VmdWwgaWYgeW91IHdhbnQgdG8gY29tcHV0ZSB0aGUgZmFjZSBkZXNjcmlwdG9ycyBmb3IgdGhlIGZhY2UgaW1hZ2VzLlxyXG4gKiBVc2luZyB0aGlzIG1ldGhvZCBpcyBmYXN0ZXIgdGhlbiBleHRyYWN0aW5nIGEgY2FudmFzIGZvciBlYWNoIGZhY2UgYW5kXHJcbiAqIGNvbnZlcnRpbmcgdGhlbSB0byB0ZW5zb3JzIGluZGl2aWR1YWxseS5cclxuICpcclxuICogQHBhcmFtIGltYWdlVGVuc29yIFRoZSBpbWFnZSB0ZW5zb3IgdGhhdCBmYWNlIGRldGVjdGlvbiBoYXMgYmVlbiBwZXJmb3JtZWQgb24uXHJcbiAqIEBwYXJhbSBkZXRlY3Rpb25zIFRoZSBmYWNlIGRldGVjdGlvbiByZXN1bHRzIG9yIGZhY2UgYm91bmRpbmcgYm94ZXMgZm9yIHRoYXQgaW1hZ2UuXHJcbiAqIEByZXR1cm5zIFRlbnNvcnMgb2YgdGhlIGNvcnJlc3BvbmRpbmcgaW1hZ2UgcmVnaW9uIGZvciBlYWNoIGRldGVjdGVkIGZhY2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEZhY2VUZW5zb3JzKGltYWdlVGVuc29yLCBkZXRlY3Rpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzVGVuc29yM0QoaW1hZ2VUZW5zb3IpICYmICFpc1RlbnNvcjREKGltYWdlVGVuc29yKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHRyYWN0RmFjZVRlbnNvcnMgLSBleHBlY3RlZCBpbWFnZSB0ZW5zb3IgdG8gYmUgM0Qgb3IgNEQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNUZW5zb3I0RChpbWFnZVRlbnNvcikgJiYgaW1hZ2VUZW5zb3Iuc2hhcGVbMF0gPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dHJhY3RGYWNlVGVuc29ycyAtIGJhdGNoU2l6ZSA+IDEgbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBpbWFnZVRlbnNvci5zaGFwZS5zbGljZShpc1RlbnNvcjREKGltYWdlVGVuc29yKSA/IDEgOiAwKSwgaW1nSGVpZ2h0ID0gX2FbMF0sIGltZ1dpZHRoID0gX2FbMV0sIG51bUNoYW5uZWxzID0gX2FbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJveGVzID0gZGV0ZWN0aW9ucy5tYXAoZnVuY3Rpb24gKGRldCkgeyByZXR1cm4gZGV0IGluc3RhbmNlb2YgRmFjZURldGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRldC5mb3JTaXplKGltZ1dpZHRoLCBpbWdIZWlnaHQpLmJveFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRldDsgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYm94KSB7IHJldHVybiBib3guY2xpcEF0SW1hZ2VCb3JkZXJzKGltZ1dpZHRoLCBpbWdIZWlnaHQpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmFjZVRlbnNvcnMgPSBib3hlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRmLnNsaWNlM2QoaW1hZ2VUZW5zb3IuYXMzRChpbWdIZWlnaHQsIGltZ1dpZHRoLCBudW1DaGFubmVscyksIFt5LCB4LCAwXSwgW2hlaWdodCwgd2lkdGgsIG51bUNoYW5uZWxzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhY2VUZW5zb3JzO1xyXG4gICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdEZhY2VUZW5zb3JzLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgRmFjZURldGVjdGlvbiB9IGZyb20gJy4uL2NsYXNzZXMvRmFjZURldGVjdGlvbic7XHJcbmltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudic7XHJcbmltcG9ydCB7IGNyZWF0ZUNhbnZhcyB9IGZyb20gJy4vY3JlYXRlQ2FudmFzJztcclxuaW1wb3J0IHsgZ2V0Q29udGV4dDJkT3JUaHJvdyB9IGZyb20gJy4vZ2V0Q29udGV4dDJkT3JUaHJvdyc7XHJcbmltcG9ydCB7IGltYWdlVGVuc29yVG9DYW52YXMgfSBmcm9tICcuL2ltYWdlVGVuc29yVG9DYW52YXMnO1xyXG5pbXBvcnQgeyB0b05ldElucHV0IH0gZnJvbSAnLi90b05ldElucHV0JztcclxuLyoqXHJcbiAqIEV4dHJhY3RzIHRoZSBpbWFnZSByZWdpb25zIGNvbnRhaW5pbmcgdGhlIGRldGVjdGVkIGZhY2VzLlxyXG4gKlxyXG4gKiBAcGFyYW0gaW5wdXQgVGhlIGltYWdlIHRoYXQgZmFjZSBkZXRlY3Rpb24gaGFzIGJlZW4gcGVyZm9ybWVkIG9uLlxyXG4gKiBAcGFyYW0gZGV0ZWN0aW9ucyBUaGUgZmFjZSBkZXRlY3Rpb24gcmVzdWx0cyBvciBmYWNlIGJvdW5kaW5nIGJveGVzIGZvciB0aGF0IGltYWdlLlxyXG4gKiBAcmV0dXJucyBUaGUgQ2FudmFzZXMgb2YgdGhlIGNvcnJlc3BvbmRpbmcgaW1hZ2UgcmVnaW9uIGZvciBlYWNoIGRldGVjdGVkIGZhY2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEZhY2VzKGlucHV0LCBkZXRlY3Rpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIENhbnZhcywgY2FudmFzLCBuZXRJbnB1dCwgdGVuc29yT3JDYW52YXMsIF9hLCBjdHgsIGJveGVzO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIENhbnZhcyA9IGVudi5nZXRFbnYoKS5DYW52YXM7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzID0gaW5wdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhKGlucHV0IGluc3RhbmNlb2YgQ2FudmFzKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdG9OZXRJbnB1dChpbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIG5ldElucHV0ID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXRJbnB1dC5iYXRjaFNpemUgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXh0cmFjdEZhY2VzIC0gYmF0Y2hTaXplID4gMSBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRlbnNvck9yQ2FudmFzID0gbmV0SW5wdXQuZ2V0SW5wdXQoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodGVuc29yT3JDYW52YXMgaW5zdGFuY2VvZiBDYW52YXMpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcclxuICAgICAgICAgICAgICAgICAgICBfYSA9IHRlbnNvck9yQ2FudmFzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCBpbWFnZVRlbnNvclRvQ2FudmFzKHRlbnNvck9yQ2FudmFzKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA0O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcyA9IF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSBnZXRDb250ZXh0MmRPclRocm93KGNhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm94ZXMgPSBkZXRlY3Rpb25zLm1hcChmdW5jdGlvbiAoZGV0KSB7IHJldHVybiBkZXQgaW5zdGFuY2VvZiBGYWNlRGV0ZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZGV0LmZvclNpemUoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KS5ib3guZmxvb3IoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRldDsgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYm94KSB7IHJldHVybiBib3guY2xpcEF0SW1hZ2VCb3JkZXJzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBib3hlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjZUltZyA9IGNyZWF0ZUNhbnZhcyh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb250ZXh0MmRPclRocm93KGZhY2VJbWcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnB1dEltYWdlRGF0YShjdHguZ2V0SW1hZ2VEYXRhKHgsIHksIHdpZHRoLCBoZWlnaHQpLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWNlSW1nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RGYWNlcy5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IGJ1ZmZlclRvSW1hZ2UgfSBmcm9tICcuL2J1ZmZlclRvSW1hZ2UnO1xyXG5pbXBvcnQgeyBmZXRjaE9yVGhyb3cgfSBmcm9tICcuL2ZldGNoT3JUaHJvdyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBmZXRjaEltYWdlKHVyaSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXMsIGJsb2I7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoT3JUaHJvdyh1cmkpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKHJlcykuYmxvYigpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBibG9iID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYmxvYi50eXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZldGNoSW1hZ2UgLSBleHBlY3RlZCBibG9iIHR5cGUgdG8gYmUgb2YgdHlwZSBpbWFnZS8qLCBpbnN0ZWFkIGhhdmU6IFwiICsgYmxvYi50eXBlICsgXCIsIGZvciB1cmw6IFwiICsgcmVzLnVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBidWZmZXJUb0ltYWdlKGJsb2IpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2hJbWFnZS5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IGZldGNoT3JUaHJvdyB9IGZyb20gJy4vZmV0Y2hPclRocm93JztcclxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoSnNvbih1cmkpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2hPclRocm93KHVyaSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnNlbnQoKSkuanNvbigpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2hKc29uLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgZmV0Y2hPclRocm93IH0gZnJvbSAnLi9mZXRjaE9yVGhyb3cnO1xyXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hOZXRXZWlnaHRzKHVyaSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBfYSA9IEZsb2F0MzJBcnJheS5iaW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoT3JUaHJvdyh1cmkpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgKF9iLnNlbnQoKSkuYXJyYXlCdWZmZXIoKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgKF9hLmFwcGx5KEZsb2F0MzJBcnJheSwgW3ZvaWQgMCwgX2Iuc2VudCgpXSkpKCldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaE5ldFdlaWdodHMuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYnO1xyXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hPclRocm93KHVybCwgaW5pdCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmZXRjaCwgcmVzO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGZldGNoID0gZW52LmdldEVudigpLmZldGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKHVybCwgaW5pdCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXMuc3RhdHVzIDwgNDAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gZmV0Y2g6IChcIiArIHJlcy5zdGF0dXMgKyBcIikgXCIgKyByZXMuc3RhdHVzVGV4dCArIFwiLCBmcm9tIHVybDogXCIgKyByZXMudXJsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoT3JUaHJvdy5qcy5tYXAiLCJpbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYnO1xyXG5pbXBvcnQgeyByZXNvbHZlSW5wdXQgfSBmcm9tICcuL3Jlc29sdmVJbnB1dCc7XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0MmRPclRocm93KGNhbnZhc0FyZykge1xyXG4gICAgdmFyIF9hID0gZW52LmdldEVudigpLCBDYW52YXMgPSBfYS5DYW52YXMsIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IF9hLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuICAgIGlmIChjYW52YXNBcmcgaW5zdGFuY2VvZiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgICByZXR1cm4gY2FudmFzQXJnO1xyXG4gICAgfVxyXG4gICAgdmFyIGNhbnZhcyA9IHJlc29sdmVJbnB1dChjYW52YXNBcmcpO1xyXG4gICAgaWYgKCEoY2FudmFzIGluc3RhbmNlb2YgQ2FudmFzKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzb2x2ZUNvbnRleHQyZCAtIGV4cGVjdGVkIGNhbnZhcyB0byBiZSBvZiBpbnN0YW5jZSBvZiBDYW52YXMnKTtcclxuICAgIH1cclxuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIGlmICghY3R4KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXNvbHZlQ29udGV4dDJkIC0gY2FudmFzIDJkIGNvbnRleHQgaXMgbnVsbCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGN0eDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRDb250ZXh0MmRPclRocm93LmpzLm1hcCIsImltcG9ydCB7IERpbWVuc2lvbnMgfSBmcm9tICcuLi9jbGFzc2VzL0RpbWVuc2lvbnMnO1xyXG5pbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYnO1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVkaWFEaW1lbnNpb25zKGlucHV0KSB7XHJcbiAgICB2YXIgX2EgPSBlbnYuZ2V0RW52KCksIEltYWdlID0gX2EuSW1hZ2UsIFZpZGVvID0gX2EuVmlkZW87XHJcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBJbWFnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9ucyhpbnB1dC5uYXR1cmFsV2lkdGgsIGlucHV0Lm5hdHVyYWxIZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgVmlkZW8pIHtcclxuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbnMoaW5wdXQudmlkZW9XaWR0aCwgaW5wdXQudmlkZW9IZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBEaW1lbnNpb25zKGlucHV0LndpZHRoLCBpbnB1dC5oZWlnaHQpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldE1lZGlhRGltZW5zaW9ucy5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudic7XHJcbmltcG9ydCB7IGlzVGVuc29yNEQgfSBmcm9tICcuLi91dGlscyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBpbWFnZVRlbnNvclRvQ2FudmFzKGltZ1RlbnNvciwgY2FudmFzKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRhcmdldENhbnZhcywgX2EsIGhlaWdodCwgd2lkdGgsIG51bUNoYW5uZWxzLCBpbWdUZW5zb3IzRDtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDYW52YXMgPSBjYW52YXMgfHwgZW52LmdldEVudigpLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBfYSA9IGltZ1RlbnNvci5zaGFwZS5zbGljZShpc1RlbnNvcjREKGltZ1RlbnNvcikgPyAxIDogMCksIGhlaWdodCA9IF9hWzBdLCB3aWR0aCA9IF9hWzFdLCBudW1DaGFubmVscyA9IF9hWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGltZ1RlbnNvcjNEID0gdGYudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiBpbWdUZW5zb3IuYXMzRChoZWlnaHQsIHdpZHRoLCBudW1DaGFubmVscykudG9JbnQoKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGYuYnJvd3Nlci50b1BpeGVscyhpbWdUZW5zb3IzRCwgdGFyZ2V0Q2FudmFzKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGltZ1RlbnNvcjNELmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGFyZ2V0Q2FudmFzXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2VUZW5zb3JUb0NhbnZhcy5qcy5tYXAiLCJpbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYnO1xyXG5pbXBvcnQgeyBjcmVhdGVDYW52YXMsIGNyZWF0ZUNhbnZhc0Zyb21NZWRpYSB9IGZyb20gJy4vY3JlYXRlQ2FudmFzJztcclxuaW1wb3J0IHsgZ2V0Q29udGV4dDJkT3JUaHJvdyB9IGZyb20gJy4vZ2V0Q29udGV4dDJkT3JUaHJvdyc7XHJcbmltcG9ydCB7IGdldE1lZGlhRGltZW5zaW9ucyB9IGZyb20gJy4vZ2V0TWVkaWFEaW1lbnNpb25zJztcclxuZXhwb3J0IGZ1bmN0aW9uIGltYWdlVG9TcXVhcmUoaW5wdXQsIGlucHV0U2l6ZSwgY2VudGVySW1hZ2UpIHtcclxuICAgIGlmIChjZW50ZXJJbWFnZSA9PT0gdm9pZCAwKSB7IGNlbnRlckltYWdlID0gZmFsc2U7IH1cclxuICAgIHZhciBfYSA9IGVudi5nZXRFbnYoKSwgSW1hZ2UgPSBfYS5JbWFnZSwgQ2FudmFzID0gX2EuQ2FudmFzO1xyXG4gICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBJbWFnZSB8fCBpbnB1dCBpbnN0YW5jZW9mIENhbnZhcykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ltYWdlVG9TcXVhcmUgLSBleHBlY3RlZCBhcmcwIHRvIGJlIEhUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCcpO1xyXG4gICAgfVxyXG4gICAgdmFyIGRpbXMgPSBnZXRNZWRpYURpbWVuc2lvbnMoaW5wdXQpO1xyXG4gICAgdmFyIHNjYWxlID0gaW5wdXRTaXplIC8gTWF0aC5tYXgoZGltcy5oZWlnaHQsIGRpbXMud2lkdGgpO1xyXG4gICAgdmFyIHdpZHRoID0gc2NhbGUgKiBkaW1zLndpZHRoO1xyXG4gICAgdmFyIGhlaWdodCA9IHNjYWxlICogZGltcy5oZWlnaHQ7XHJcbiAgICB2YXIgdGFyZ2V0Q2FudmFzID0gY3JlYXRlQ2FudmFzKHsgd2lkdGg6IGlucHV0U2l6ZSwgaGVpZ2h0OiBpbnB1dFNpemUgfSk7XHJcbiAgICB2YXIgaW5wdXRDYW52YXMgPSBpbnB1dCBpbnN0YW5jZW9mIENhbnZhcyA/IGlucHV0IDogY3JlYXRlQ2FudmFzRnJvbU1lZGlhKGlucHV0KTtcclxuICAgIHZhciBvZmZzZXQgPSBNYXRoLmFicyh3aWR0aCAtIGhlaWdodCkgLyAyO1xyXG4gICAgdmFyIGR4ID0gY2VudGVySW1hZ2UgJiYgd2lkdGggPCBoZWlnaHQgPyBvZmZzZXQgOiAwO1xyXG4gICAgdmFyIGR5ID0gY2VudGVySW1hZ2UgJiYgaGVpZ2h0IDwgd2lkdGggPyBvZmZzZXQgOiAwO1xyXG4gICAgZ2V0Q29udGV4dDJkT3JUaHJvdyh0YXJnZXRDYW52YXMpLmRyYXdJbWFnZShpbnB1dENhbnZhcywgZHgsIGR5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIHJldHVybiB0YXJnZXRDYW52YXM7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2VUb1NxdWFyZS5qcy5tYXAiLCJleHBvcnQgKiBmcm9tICcuL2F3YWl0TWVkaWFMb2FkZWQnO1xyXG5leHBvcnQgKiBmcm9tICcuL2J1ZmZlclRvSW1hZ2UnO1xyXG5leHBvcnQgKiBmcm9tICcuL2NyZWF0ZUNhbnZhcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZXh0cmFjdEZhY2VzJztcclxuZXhwb3J0ICogZnJvbSAnLi9leHRyYWN0RmFjZVRlbnNvcnMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2ZldGNoSW1hZ2UnO1xyXG5leHBvcnQgKiBmcm9tICcuL2ZldGNoSnNvbic7XHJcbmV4cG9ydCAqIGZyb20gJy4vZmV0Y2hOZXRXZWlnaHRzJztcclxuZXhwb3J0ICogZnJvbSAnLi9mZXRjaE9yVGhyb3cnO1xyXG5leHBvcnQgKiBmcm9tICcuL2dldENvbnRleHQyZE9yVGhyb3cnO1xyXG5leHBvcnQgKiBmcm9tICcuL2dldE1lZGlhRGltZW5zaW9ucyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vaW1hZ2VUZW5zb3JUb0NhbnZhcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vaW1hZ2VUb1NxdWFyZSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vaXNNZWRpYUVsZW1lbnQnO1xyXG5leHBvcnQgKiBmcm9tICcuL2lzTWVkaWFMb2FkZWQnO1xyXG5leHBvcnQgKiBmcm9tICcuL2xvYWRXZWlnaHRNYXAnO1xyXG5leHBvcnQgKiBmcm9tICcuL21hdGNoRGltZW5zaW9ucyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vTmV0SW5wdXQnO1xyXG5leHBvcnQgKiBmcm9tICcuL3Jlc29sdmVJbnB1dCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdG9OZXRJbnB1dCc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudic7XHJcbmV4cG9ydCBmdW5jdGlvbiBpc01lZGlhRWxlbWVudChpbnB1dCkge1xyXG4gICAgdmFyIF9hID0gZW52LmdldEVudigpLCBJbWFnZSA9IF9hLkltYWdlLCBDYW52YXMgPSBfYS5DYW52YXMsIFZpZGVvID0gX2EuVmlkZW87XHJcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBJbWFnZVxyXG4gICAgICAgIHx8IGlucHV0IGluc3RhbmNlb2YgQ2FudmFzXHJcbiAgICAgICAgfHwgaW5wdXQgaW5zdGFuY2VvZiBWaWRlbztcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc01lZGlhRWxlbWVudC5qcy5tYXAiLCJpbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYnO1xyXG5leHBvcnQgZnVuY3Rpb24gaXNNZWRpYUxvYWRlZChtZWRpYSkge1xyXG4gICAgdmFyIF9hID0gZW52LmdldEVudigpLCBJbWFnZSA9IF9hLkltYWdlLCBWaWRlbyA9IF9hLlZpZGVvO1xyXG4gICAgcmV0dXJuIChtZWRpYSBpbnN0YW5jZW9mIEltYWdlICYmIG1lZGlhLmNvbXBsZXRlKVxyXG4gICAgICAgIHx8IChtZWRpYSBpbnN0YW5jZW9mIFZpZGVvICYmIG1lZGlhLnJlYWR5U3RhdGUgPj0gMyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNNZWRpYUxvYWRlZC5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGdldE1vZGVsVXJpcyB9IGZyb20gJy4uL2NvbW1vbi9nZXRNb2RlbFVyaXMnO1xyXG5pbXBvcnQgeyBmZXRjaEpzb24gfSBmcm9tICcuL2ZldGNoSnNvbic7XHJcbmV4cG9ydCBmdW5jdGlvbiBsb2FkV2VpZ2h0TWFwKHVyaSwgZGVmYXVsdE1vZGVsTmFtZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSwgbWFuaWZlc3RVcmksIG1vZGVsQmFzZVVyaSwgbWFuaWZlc3Q7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBnZXRNb2RlbFVyaXModXJpLCBkZWZhdWx0TW9kZWxOYW1lKSwgbWFuaWZlc3RVcmkgPSBfYS5tYW5pZmVzdFVyaSwgbW9kZWxCYXNlVXJpID0gX2EubW9kZWxCYXNlVXJpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoSnNvbihtYW5pZmVzdFVyaSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0ID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0Zi5pby5sb2FkV2VpZ2h0cyhtYW5pZmVzdCwgbW9kZWxCYXNlVXJpKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRXZWlnaHRNYXAuanMubWFwIiwiaW1wb3J0IHsgZ2V0TWVkaWFEaW1lbnNpb25zIH0gZnJvbSAnLi9nZXRNZWRpYURpbWVuc2lvbnMnO1xyXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hEaW1lbnNpb25zKGlucHV0LCByZWZlcmVuY2UsIHVzZU1lZGlhRGltZW5zaW9ucykge1xyXG4gICAgaWYgKHVzZU1lZGlhRGltZW5zaW9ucyA9PT0gdm9pZCAwKSB7IHVzZU1lZGlhRGltZW5zaW9ucyA9IGZhbHNlOyB9XHJcbiAgICB2YXIgX2EgPSB1c2VNZWRpYURpbWVuc2lvbnNcclxuICAgICAgICA/IGdldE1lZGlhRGltZW5zaW9ucyhyZWZlcmVuY2UpXHJcbiAgICAgICAgOiByZWZlcmVuY2UsIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgIGlucHV0LndpZHRoID0gd2lkdGg7XHJcbiAgICBpbnB1dC5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICByZXR1cm4geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0Y2hEaW1lbnNpb25zLmpzLm1hcCIsImltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudic7XHJcbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlSW5wdXQoYXJnKSB7XHJcbiAgICBpZiAoIWVudi5pc05vZGVqcygpICYmIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFyZyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJnO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVJbnB1dC5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IGlzVGVuc29yM0QsIGlzVGVuc29yNEQgfSBmcm9tICcuLi91dGlscyc7XHJcbmltcG9ydCB7IGF3YWl0TWVkaWFMb2FkZWQgfSBmcm9tICcuL2F3YWl0TWVkaWFMb2FkZWQnO1xyXG5pbXBvcnQgeyBpc01lZGlhRWxlbWVudCB9IGZyb20gJy4vaXNNZWRpYUVsZW1lbnQnO1xyXG5pbXBvcnQgeyBOZXRJbnB1dCB9IGZyb20gJy4vTmV0SW5wdXQnO1xyXG5pbXBvcnQgeyByZXNvbHZlSW5wdXQgfSBmcm9tICcuL3Jlc29sdmVJbnB1dCc7XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGhlIGlucHV0IHRvIG1ha2Ugc3VyZSwgdGhleSBhcmUgdmFsaWQgbmV0IGlucHV0cyBhbmQgYXdhaXRzIGFsbCBtZWRpYSBlbGVtZW50c1xyXG4gKiB0byBiZSBmaW5pc2hlZCBsb2FkaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0LCB3aGljaCBjYW4gYmUgYSBtZWRpYSBlbGVtZW50IG9yIGFuIGFycmF5IG9mIGRpZmZlcmVudCBtZWRpYSBlbGVtZW50cy5cclxuICogQHJldHVybnMgQSBOZXRJbnB1dCBpbnN0YW5jZSwgd2hpY2ggY2FuIGJlIHBhc3NlZCBpbnRvIG9uZSBvZiB0aGUgbmV1cmFsIG5ldHdvcmtzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTmV0SW5wdXQoaW5wdXRzKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlucHV0QXJnQXJyYXksIGdldElkeEhpbnQsIGlucHV0QXJyYXk7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0cyBpbnN0YW5jZW9mIE5ldElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBpbnB1dHNdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbnB1dEFyZ0FycmF5ID0gQXJyYXkuaXNBcnJheShpbnB1dHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaW5wdXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW2lucHV0c107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnB1dEFyZ0FycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvTmV0SW5wdXQgLSBlbXB0eSBhcnJheSBwYXNzZWQgYXMgaW5wdXQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0SWR4SGludCA9IGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5wdXRzKSA/IFwiIGF0IGlucHV0IGluZGV4IFwiICsgaWR4ICsgXCI6XCIgOiAnJzsgfTtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dEFycmF5ID0gaW5wdXRBcmdBcnJheS5tYXAocmVzb2x2ZUlucHV0KTtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dEFycmF5LmZvckVhY2goZnVuY3Rpb24gKGlucHV0LCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNNZWRpYUVsZW1lbnQoaW5wdXQpICYmICFpc1RlbnNvcjNEKGlucHV0KSAmJiAhaXNUZW5zb3I0RChpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXRBcmdBcnJheVtpXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b05ldElucHV0IC1cIiArIGdldElkeEhpbnQoaSkgKyBcIiBzdHJpbmcgcGFzc2VkLCBidXQgY291bGQgbm90IHJlc29sdmUgSFRNTEVsZW1lbnQgZm9yIGVsZW1lbnQgaWQgXCIgKyBpbnB1dEFyZ0FycmF5W2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvTmV0SW5wdXQgLVwiICsgZ2V0SWR4SGludChpKSArIFwiIGV4cGVjdGVkIG1lZGlhIHRvIGJlIG9mIHR5cGUgSFRNTEltYWdlRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IHRmLlRlbnNvcjNELCBvciB0byBiZSBhbiBlbGVtZW50IGlkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1RlbnNvcjREKGlucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGYuVGVuc29yNEQgaXMgcGFzc2VkIGluIHRoZSBpbnB1dCBhcnJheSwgdGhlIGJhdGNoIHNpemUgaGFzIHRvIGJlIDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXRjaFNpemUgPSBpbnB1dC5zaGFwZVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaFNpemUgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b05ldElucHV0IC1cIiArIGdldElkeEhpbnQoaSkgKyBcIiB0Zi5UZW5zb3I0RCB3aXRoIGJhdGNoU2l6ZSBcIiArIGJhdGNoU2l6ZSArIFwiIHBhc3NlZCwgYnV0IG5vdCBzdXBwb3J0ZWQgaW4gaW5wdXQgYXJyYXlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciBhbGwgbWVkaWEgZWxlbWVudHMgYmVpbmcgbG9hZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoaW5wdXRBcnJheS5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpc01lZGlhRWxlbWVudChpbnB1dCkgJiYgYXdhaXRNZWRpYUxvYWRlZChpbnB1dCk7IH0pKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FpdCBmb3IgYWxsIG1lZGlhIGVsZW1lbnRzIGJlaW5nIGxvYWRlZFxyXG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IE5ldElucHV0KGlucHV0QXJyYXksIEFycmF5LmlzQXJyYXkoaW5wdXRzKSldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b05ldElucHV0LmpzLm1hcCIsImltcG9ydCB7IEJveCB9IGZyb20gJy4uL2NsYXNzZXMnO1xyXG5pbXBvcnQgeyBnZXRDb250ZXh0MmRPclRocm93IH0gZnJvbSAnLi4vZG9tL2dldENvbnRleHQyZE9yVGhyb3cnO1xyXG5pbXBvcnQgeyBBbmNob3JQb3NpdGlvbiwgRHJhd1RleHRGaWVsZCwgRHJhd1RleHRGaWVsZE9wdGlvbnMgfSBmcm9tICcuL0RyYXdUZXh0RmllbGQnO1xyXG52YXIgRHJhd0JveE9wdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEcmF3Qm94T3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICB2YXIgYm94Q29sb3IgPSBvcHRpb25zLmJveENvbG9yLCBsaW5lV2lkdGggPSBvcHRpb25zLmxpbmVXaWR0aCwgbGFiZWwgPSBvcHRpb25zLmxhYmVsLCBkcmF3TGFiZWxPcHRpb25zID0gb3B0aW9ucy5kcmF3TGFiZWxPcHRpb25zO1xyXG4gICAgICAgIHRoaXMuYm94Q29sb3IgPSBib3hDb2xvciB8fCAncmdiYSgwLCAwLCAyNTUsIDEpJztcclxuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IGxpbmVXaWR0aCB8fCAyO1xyXG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcclxuICAgICAgICB2YXIgZGVmYXVsdERyYXdMYWJlbE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGFuY2hvclBvc2l0aW9uOiBBbmNob3JQb3NpdGlvbi5CT1RUT01fTEVGVCxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmJveENvbG9yXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmRyYXdMYWJlbE9wdGlvbnMgPSBuZXcgRHJhd1RleHRGaWVsZE9wdGlvbnMoT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdERyYXdMYWJlbE9wdGlvbnMsIGRyYXdMYWJlbE9wdGlvbnMpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBEcmF3Qm94T3B0aW9ucztcclxufSgpKTtcclxuZXhwb3J0IHsgRHJhd0JveE9wdGlvbnMgfTtcclxudmFyIERyYXdCb3ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEcmF3Qm94KGJveCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgdGhpcy5ib3ggPSBuZXcgQm94KGJveCk7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbmV3IERyYXdCb3hPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgRHJhd0JveC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjYW52YXNBcmcpIHtcclxuICAgICAgICB2YXIgY3R4ID0gZ2V0Q29udGV4dDJkT3JUaHJvdyhjYW52YXNBcmcpO1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgYm94Q29sb3IgPSBfYS5ib3hDb2xvciwgbGluZVdpZHRoID0gX2EubGluZVdpZHRoO1xyXG4gICAgICAgIHZhciBfYiA9IHRoaXMuYm94LCB4ID0gX2IueCwgeSA9IF9iLnksIHdpZHRoID0gX2Iud2lkdGgsIGhlaWdodCA9IF9iLmhlaWdodDtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3hDb2xvcjtcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xyXG4gICAgICAgIGN0eC5zdHJva2VSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHZhciBsYWJlbCA9IHRoaXMub3B0aW9ucy5sYWJlbDtcclxuICAgICAgICBpZiAobGFiZWwpIHtcclxuICAgICAgICAgICAgbmV3IERyYXdUZXh0RmllbGQoW2xhYmVsXSwgeyB4OiB4IC0gKGxpbmVXaWR0aCAvIDIpLCB5OiB5IH0sIHRoaXMub3B0aW9ucy5kcmF3TGFiZWxPcHRpb25zKS5kcmF3KGNhbnZhc0FyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBEcmF3Qm94O1xyXG59KCkpO1xyXG5leHBvcnQgeyBEcmF3Qm94IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyYXdCb3guanMubWFwIiwiaW1wb3J0IHsgRmFjZUxhbmRtYXJrcyB9IGZyb20gJy4uL2NsYXNzZXMvRmFjZUxhbmRtYXJrcyc7XHJcbmltcG9ydCB7IEZhY2VMYW5kbWFya3M2OCB9IGZyb20gJy4uL2NsYXNzZXMvRmFjZUxhbmRtYXJrczY4JztcclxuaW1wb3J0IHsgZ2V0Q29udGV4dDJkT3JUaHJvdyB9IGZyb20gJy4uL2RvbS9nZXRDb250ZXh0MmRPclRocm93JztcclxuaW1wb3J0IHsgaXNXaXRoRmFjZUxhbmRtYXJrcyB9IGZyb20gJy4uL2ZhY3Rvcmllcy9XaXRoRmFjZUxhbmRtYXJrcyc7XHJcbmltcG9ydCB7IGRyYXdDb250b3VyIH0gZnJvbSAnLi9kcmF3Q29udG91cic7XHJcbnZhciBEcmF3RmFjZUxhbmRtYXJrc09wdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEcmF3RmFjZUxhbmRtYXJrc09wdGlvbnMob3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIF9hID0gb3B0aW9ucy5kcmF3TGluZXMsIGRyYXdMaW5lcyA9IF9hID09PSB2b2lkIDAgPyB0cnVlIDogX2EsIF9iID0gb3B0aW9ucy5kcmF3UG9pbnRzLCBkcmF3UG9pbnRzID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYiwgbGluZVdpZHRoID0gb3B0aW9ucy5saW5lV2lkdGgsIGxpbmVDb2xvciA9IG9wdGlvbnMubGluZUNvbG9yLCBwb2ludFNpemUgPSBvcHRpb25zLnBvaW50U2l6ZSwgcG9pbnRDb2xvciA9IG9wdGlvbnMucG9pbnRDb2xvcjtcclxuICAgICAgICB0aGlzLmRyYXdMaW5lcyA9IGRyYXdMaW5lcztcclxuICAgICAgICB0aGlzLmRyYXdQb2ludHMgPSBkcmF3UG9pbnRzO1xyXG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gbGluZVdpZHRoIHx8IDE7XHJcbiAgICAgICAgdGhpcy5wb2ludFNpemUgPSBwb2ludFNpemUgfHwgMjtcclxuICAgICAgICB0aGlzLmxpbmVDb2xvciA9IGxpbmVDb2xvciB8fCAncmdiYSgwLCAyNTUsIDI1NSwgMSknO1xyXG4gICAgICAgIHRoaXMucG9pbnRDb2xvciA9IHBvaW50Q29sb3IgfHwgJ3JnYmEoMjU1LCAwLCAyNTUsIDEpJztcclxuICAgIH1cclxuICAgIHJldHVybiBEcmF3RmFjZUxhbmRtYXJrc09wdGlvbnM7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IERyYXdGYWNlTGFuZG1hcmtzT3B0aW9ucyB9O1xyXG52YXIgRHJhd0ZhY2VMYW5kbWFya3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEcmF3RmFjZUxhbmRtYXJrcyhmYWNlTGFuZG1hcmtzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICB0aGlzLmZhY2VMYW5kbWFya3MgPSBmYWNlTGFuZG1hcmtzO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBEcmF3RmFjZUxhbmRtYXJrc09wdGlvbnMob3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBEcmF3RmFjZUxhbmRtYXJrcy5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjYW52YXNBcmcpIHtcclxuICAgICAgICB2YXIgY3R4ID0gZ2V0Q29udGV4dDJkT3JUaHJvdyhjYW52YXNBcmcpO1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgZHJhd0xpbmVzID0gX2EuZHJhd0xpbmVzLCBkcmF3UG9pbnRzID0gX2EuZHJhd1BvaW50cywgbGluZVdpZHRoID0gX2EubGluZVdpZHRoLCBsaW5lQ29sb3IgPSBfYS5saW5lQ29sb3IsIHBvaW50U2l6ZSA9IF9hLnBvaW50U2l6ZSwgcG9pbnRDb2xvciA9IF9hLnBvaW50Q29sb3I7XHJcbiAgICAgICAgaWYgKGRyYXdMaW5lcyAmJiB0aGlzLmZhY2VMYW5kbWFya3MgaW5zdGFuY2VvZiBGYWNlTGFuZG1hcmtzNjgpIHtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGluZUNvbG9yO1xyXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xyXG4gICAgICAgICAgICBkcmF3Q29udG91cihjdHgsIHRoaXMuZmFjZUxhbmRtYXJrcy5nZXRKYXdPdXRsaW5lKCkpO1xyXG4gICAgICAgICAgICBkcmF3Q29udG91cihjdHgsIHRoaXMuZmFjZUxhbmRtYXJrcy5nZXRMZWZ0RXllQnJvdygpKTtcclxuICAgICAgICAgICAgZHJhd0NvbnRvdXIoY3R4LCB0aGlzLmZhY2VMYW5kbWFya3MuZ2V0UmlnaHRFeWVCcm93KCkpO1xyXG4gICAgICAgICAgICBkcmF3Q29udG91cihjdHgsIHRoaXMuZmFjZUxhbmRtYXJrcy5nZXROb3NlKCkpO1xyXG4gICAgICAgICAgICBkcmF3Q29udG91cihjdHgsIHRoaXMuZmFjZUxhbmRtYXJrcy5nZXRMZWZ0RXllKCksIHRydWUpO1xyXG4gICAgICAgICAgICBkcmF3Q29udG91cihjdHgsIHRoaXMuZmFjZUxhbmRtYXJrcy5nZXRSaWdodEV5ZSgpLCB0cnVlKTtcclxuICAgICAgICAgICAgZHJhd0NvbnRvdXIoY3R4LCB0aGlzLmZhY2VMYW5kbWFya3MuZ2V0TW91dGgoKSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkcmF3UG9pbnRzKSB7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHBvaW50Q29sb3I7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBwb2ludENvbG9yO1xyXG4gICAgICAgICAgICB2YXIgZHJhd1BvaW50ID0gZnVuY3Rpb24gKHB0KSB7XHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguYXJjKHB0LngsIHB0LnksIHBvaW50U2l6ZSwgMCwgMiAqIE1hdGguUEkpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5mYWNlTGFuZG1hcmtzLnBvc2l0aW9ucy5mb3JFYWNoKGRyYXdQb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBEcmF3RmFjZUxhbmRtYXJrcztcclxufSgpKTtcclxuZXhwb3J0IHsgRHJhd0ZhY2VMYW5kbWFya3MgfTtcclxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdGYWNlTGFuZG1hcmtzKGNhbnZhc0FyZywgZmFjZUxhbmRtYXJrcykge1xyXG4gICAgdmFyIGZhY2VMYW5kbWFya3NBcnJheSA9IEFycmF5LmlzQXJyYXkoZmFjZUxhbmRtYXJrcykgPyBmYWNlTGFuZG1hcmtzIDogW2ZhY2VMYW5kbWFya3NdO1xyXG4gICAgZmFjZUxhbmRtYXJrc0FycmF5LmZvckVhY2goZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICB2YXIgbGFuZG1hcmtzID0gZiBpbnN0YW5jZW9mIEZhY2VMYW5kbWFya3NcclxuICAgICAgICAgICAgPyBmXHJcbiAgICAgICAgICAgIDogKGlzV2l0aEZhY2VMYW5kbWFya3MoZikgPyBmLmxhbmRtYXJrcyA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgaWYgKCFsYW5kbWFya3MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmF3RmFjZUxhbmRtYXJrcyAtIGV4cGVjdGVkIGZhY2VFeHByZXNzaW9ucyB0byBiZSBGYWNlTGFuZG1hcmtzIHwgV2l0aEZhY2VMYW5kbWFya3M8V2l0aEZhY2VEZXRlY3Rpb248e30+PiBvciBhcnJheSB0aGVyZW9mJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ldyBEcmF3RmFjZUxhbmRtYXJrcyhsYW5kbWFya3MpLmRyYXcoY2FudmFzQXJnKTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyYXdGYWNlTGFuZG1hcmtzLmpzLm1hcCIsImltcG9ydCB7IGdldENvbnRleHQyZE9yVGhyb3cgfSBmcm9tICcuLi9kb20vZ2V0Q29udGV4dDJkT3JUaHJvdyc7XHJcbmltcG9ydCB7IHJlc29sdmVJbnB1dCB9IGZyb20gJy4uL2RvbS9yZXNvbHZlSW5wdXQnO1xyXG5leHBvcnQgdmFyIEFuY2hvclBvc2l0aW9uO1xyXG4oZnVuY3Rpb24gKEFuY2hvclBvc2l0aW9uKSB7XHJcbiAgICBBbmNob3JQb3NpdGlvbltcIlRPUF9MRUZUXCJdID0gXCJUT1BfTEVGVFwiO1xyXG4gICAgQW5jaG9yUG9zaXRpb25bXCJUT1BfUklHSFRcIl0gPSBcIlRPUF9SSUdIVFwiO1xyXG4gICAgQW5jaG9yUG9zaXRpb25bXCJCT1RUT01fTEVGVFwiXSA9IFwiQk9UVE9NX0xFRlRcIjtcclxuICAgIEFuY2hvclBvc2l0aW9uW1wiQk9UVE9NX1JJR0hUXCJdID0gXCJCT1RUT01fUklHSFRcIjtcclxufSkoQW5jaG9yUG9zaXRpb24gfHwgKEFuY2hvclBvc2l0aW9uID0ge30pKTtcclxudmFyIERyYXdUZXh0RmllbGRPcHRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRHJhd1RleHRGaWVsZE9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIGFuY2hvclBvc2l0aW9uID0gb3B0aW9ucy5hbmNob3JQb3NpdGlvbiwgYmFja2dyb3VuZENvbG9yID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsIGZvbnRDb2xvciA9IG9wdGlvbnMuZm9udENvbG9yLCBmb250U2l6ZSA9IG9wdGlvbnMuZm9udFNpemUsIGZvbnRTdHlsZSA9IG9wdGlvbnMuZm9udFN0eWxlLCBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nO1xyXG4gICAgICAgIHRoaXMuYW5jaG9yUG9zaXRpb24gPSBhbmNob3JQb3NpdGlvbiB8fCBBbmNob3JQb3NpdGlvbi5UT1BfTEVGVDtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvciB8fCAncmdiYSgwLCAwLCAwLCAwLjUpJztcclxuICAgICAgICB0aGlzLmZvbnRDb2xvciA9IGZvbnRDb2xvciB8fCAncmdiYSgyNTUsIDI1NSwgMjU1LCAxKSc7XHJcbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IGZvbnRTaXplIHx8IDE0O1xyXG4gICAgICAgIHRoaXMuZm9udFN0eWxlID0gZm9udFN0eWxlIHx8ICdHZW9yZ2lhJztcclxuICAgICAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nIHx8IDQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRHJhd1RleHRGaWVsZE9wdGlvbnM7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IERyYXdUZXh0RmllbGRPcHRpb25zIH07XHJcbnZhciBEcmF3VGV4dEZpZWxkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRHJhd1RleHRGaWVsZCh0ZXh0LCBhbmNob3IsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIHRoaXMudGV4dCA9IHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICA/IFt0ZXh0XVxyXG4gICAgICAgICAgICA6ICh0ZXh0IGluc3RhbmNlb2YgRHJhd1RleHRGaWVsZCA/IHRleHQudGV4dCA6IHRleHQpO1xyXG4gICAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBEcmF3VGV4dEZpZWxkT3B0aW9ucyhvcHRpb25zKTtcclxuICAgIH1cclxuICAgIERyYXdUZXh0RmllbGQucHJvdG90eXBlLm1lYXN1cmVXaWR0aCA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMub3B0aW9ucy5wYWRkaW5nO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRleHQubWFwKGZ1bmN0aW9uIChsKSB7IHJldHVybiBjdHgubWVhc3VyZVRleHQobCkud2lkdGg7IH0pLnJlZHVjZShmdW5jdGlvbiAodzAsIHcxKSB7IHJldHVybiB3MCA8IHcxID8gdzEgOiB3MDsgfSwgMCkgKyAoMiAqIHBhZGRpbmcpO1xyXG4gICAgfTtcclxuICAgIERyYXdUZXh0RmllbGQucHJvdG90eXBlLm1lYXN1cmVIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBmb250U2l6ZSA9IF9hLmZvbnRTaXplLCBwYWRkaW5nID0gX2EucGFkZGluZztcclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aCAqIGZvbnRTaXplICsgKDIgKiBwYWRkaW5nKTtcclxuICAgIH07XHJcbiAgICBEcmF3VGV4dEZpZWxkLnByb3RvdHlwZS5nZXRVcHBlckxlZnQgPSBmdW5jdGlvbiAoY3R4LCBjYW52YXNEaW1zKSB7XHJcbiAgICAgICAgdmFyIGFuY2hvclBvc2l0aW9uID0gdGhpcy5vcHRpb25zLmFuY2hvclBvc2l0aW9uO1xyXG4gICAgICAgIHZhciBpc1NoaWZ0TGVmdCA9IGFuY2hvclBvc2l0aW9uID09PSBBbmNob3JQb3NpdGlvbi5CT1RUT01fUklHSFQgfHwgYW5jaG9yUG9zaXRpb24gPT09IEFuY2hvclBvc2l0aW9uLlRPUF9SSUdIVDtcclxuICAgICAgICB2YXIgaXNTaGlmdFRvcCA9IGFuY2hvclBvc2l0aW9uID09PSBBbmNob3JQb3NpdGlvbi5CT1RUT01fTEVGVCB8fCBhbmNob3JQb3NpdGlvbiA9PT0gQW5jaG9yUG9zaXRpb24uQk9UVE9NX1JJR0hUO1xyXG4gICAgICAgIHZhciB0ZXh0RmllbGRXaWR0aCA9IHRoaXMubWVhc3VyZVdpZHRoKGN0eCk7XHJcbiAgICAgICAgdmFyIHRleHRGaWVsZEhlaWdodCA9IHRoaXMubWVhc3VyZUhlaWdodCgpO1xyXG4gICAgICAgIHZhciB4ID0gKGlzU2hpZnRMZWZ0ID8gdGhpcy5hbmNob3IueCAtIHRleHRGaWVsZFdpZHRoIDogdGhpcy5hbmNob3IueCk7XHJcbiAgICAgICAgdmFyIHkgPSBpc1NoaWZ0VG9wID8gdGhpcy5hbmNob3IueSAtIHRleHRGaWVsZEhlaWdodCA6IHRoaXMuYW5jaG9yLnk7XHJcbiAgICAgICAgLy8gYWRqdXN0IGFuY2hvciBpZiB0ZXh0IGJveCBleGNlZWRzIGNhbnZhcyBib3JkZXJzXHJcbiAgICAgICAgaWYgKGNhbnZhc0RpbXMpIHtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gY2FudmFzRGltcy53aWR0aCwgaGVpZ2h0ID0gY2FudmFzRGltcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBuZXdYID0gTWF0aC5tYXgoTWF0aC5taW4oeCwgd2lkdGggLSB0ZXh0RmllbGRXaWR0aCksIDApO1xyXG4gICAgICAgICAgICB2YXIgbmV3WSA9IE1hdGgubWF4KE1hdGgubWluKHksIGhlaWdodCAtIHRleHRGaWVsZEhlaWdodCksIDApO1xyXG4gICAgICAgICAgICByZXR1cm4geyB4OiBuZXdYLCB5OiBuZXdZIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcclxuICAgIH07XHJcbiAgICBEcmF3VGV4dEZpZWxkLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGNhbnZhc0FyZykge1xyXG4gICAgICAgIHZhciBjYW52YXMgPSByZXNvbHZlSW5wdXQoY2FudmFzQXJnKTtcclxuICAgICAgICB2YXIgY3R4ID0gZ2V0Q29udGV4dDJkT3JUaHJvdyhjYW52YXMpO1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgYmFja2dyb3VuZENvbG9yID0gX2EuYmFja2dyb3VuZENvbG9yLCBmb250Q29sb3IgPSBfYS5mb250Q29sb3IsIGZvbnRTaXplID0gX2EuZm9udFNpemUsIGZvbnRTdHlsZSA9IF9hLmZvbnRTdHlsZSwgcGFkZGluZyA9IF9hLnBhZGRpbmc7XHJcbiAgICAgICAgY3R4LmZvbnQgPSBmb250U2l6ZSArIFwicHggXCIgKyBmb250U3R5bGU7XHJcbiAgICAgICAgdmFyIG1heFRleHRXaWR0aCA9IHRoaXMubWVhc3VyZVdpZHRoKGN0eCk7XHJcbiAgICAgICAgdmFyIHRleHRIZWlnaHQgPSB0aGlzLm1lYXN1cmVIZWlnaHQoKTtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgIHZhciB1cHBlckxlZnQgPSB0aGlzLmdldFVwcGVyTGVmdChjdHgsIGNhbnZhcyk7XHJcbiAgICAgICAgY3R4LmZpbGxSZWN0KHVwcGVyTGVmdC54LCB1cHBlckxlZnQueSwgbWF4VGV4dFdpZHRoLCB0ZXh0SGVpZ2h0KTtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZm9udENvbG9yO1xyXG4gICAgICAgIHRoaXMudGV4dC5mb3JFYWNoKGZ1bmN0aW9uICh0ZXh0TGluZSwgaSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IHBhZGRpbmcgKyB1cHBlckxlZnQueDtcclxuICAgICAgICAgICAgdmFyIHkgPSBwYWRkaW5nICsgdXBwZXJMZWZ0LnkgKyAoKGkgKyAxKSAqIGZvbnRTaXplKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRleHRMaW5lLCB4LCB5KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRHJhd1RleHRGaWVsZDtcclxufSgpKTtcclxuZXhwb3J0IHsgRHJhd1RleHRGaWVsZCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EcmF3VGV4dEZpZWxkLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBkcmF3Q29udG91cihjdHgsIHBvaW50cywgaXNDbG9zZWQpIHtcclxuICAgIGlmIChpc0Nsb3NlZCA9PT0gdm9pZCAwKSB7IGlzQ2xvc2VkID0gZmFsc2U7IH1cclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIHBvaW50cy5zbGljZSgxKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSwgcHJldklkeCkge1xyXG4gICAgICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnk7XHJcbiAgICAgICAgdmFyIGZyb20gPSBwb2ludHNbcHJldklkeF07XHJcbiAgICAgICAgY3R4Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGlzQ2xvc2VkKSB7XHJcbiAgICAgICAgdmFyIGZyb20gPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHZhciB0byA9IHBvaW50c1swXTtcclxuICAgICAgICBpZiAoIWZyb20gfHwgIXRvKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh0by54LCB0by55KTtcclxuICAgIH1cclxuICAgIGN0eC5zdHJva2UoKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmF3Q29udG91ci5qcy5tYXAiLCJpbXBvcnQgeyBCb3ggfSBmcm9tICcuLi9jbGFzc2VzJztcclxuaW1wb3J0IHsgRmFjZURldGVjdGlvbiB9IGZyb20gJy4uL2NsYXNzZXMvRmFjZURldGVjdGlvbic7XHJcbmltcG9ydCB7IGlzV2l0aEZhY2VEZXRlY3Rpb24gfSBmcm9tICcuLi9mYWN0b3JpZXMvV2l0aEZhY2VEZXRlY3Rpb24nO1xyXG5pbXBvcnQgeyByb3VuZCB9IGZyb20gJy4uL3V0aWxzJztcclxuaW1wb3J0IHsgRHJhd0JveCB9IGZyb20gJy4vRHJhd0JveCc7XHJcbmV4cG9ydCBmdW5jdGlvbiBkcmF3RGV0ZWN0aW9ucyhjYW52YXNBcmcsIGRldGVjdGlvbnMpIHtcclxuICAgIHZhciBkZXRlY3Rpb25zQXJyYXkgPSBBcnJheS5pc0FycmF5KGRldGVjdGlvbnMpID8gZGV0ZWN0aW9ucyA6IFtkZXRlY3Rpb25zXTtcclxuICAgIGRldGVjdGlvbnNBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChkZXQpIHtcclxuICAgICAgICB2YXIgc2NvcmUgPSBkZXQgaW5zdGFuY2VvZiBGYWNlRGV0ZWN0aW9uXHJcbiAgICAgICAgICAgID8gZGV0LnNjb3JlXHJcbiAgICAgICAgICAgIDogKGlzV2l0aEZhY2VEZXRlY3Rpb24oZGV0KSA/IGRldC5kZXRlY3Rpb24uc2NvcmUgOiB1bmRlZmluZWQpO1xyXG4gICAgICAgIHZhciBib3ggPSBkZXQgaW5zdGFuY2VvZiBGYWNlRGV0ZWN0aW9uXHJcbiAgICAgICAgICAgID8gZGV0LmJveFxyXG4gICAgICAgICAgICA6IChpc1dpdGhGYWNlRGV0ZWN0aW9uKGRldCkgPyBkZXQuZGV0ZWN0aW9uLmJveCA6IG5ldyBCb3goZGV0KSk7XHJcbiAgICAgICAgdmFyIGxhYmVsID0gc2NvcmUgPyBcIlwiICsgcm91bmQoc2NvcmUpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIG5ldyBEcmF3Qm94KGJveCwgeyBsYWJlbDogbGFiZWwgfSkuZHJhdyhjYW52YXNBcmcpO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJhd0RldGVjdGlvbnMuanMubWFwIiwiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi9jbGFzc2VzJztcclxuaW1wb3J0IHsgRmFjZUV4cHJlc3Npb25zIH0gZnJvbSAnLi4vZmFjZUV4cHJlc3Npb25OZXQnO1xyXG5pbXBvcnQgeyBpc1dpdGhGYWNlRGV0ZWN0aW9uIH0gZnJvbSAnLi4vZmFjdG9yaWVzL1dpdGhGYWNlRGV0ZWN0aW9uJztcclxuaW1wb3J0IHsgaXNXaXRoRmFjZUV4cHJlc3Npb25zIH0gZnJvbSAnLi4vZmFjdG9yaWVzL1dpdGhGYWNlRXhwcmVzc2lvbnMnO1xyXG5pbXBvcnQgeyByb3VuZCB9IGZyb20gJy4uL3V0aWxzJztcclxuaW1wb3J0IHsgRHJhd1RleHRGaWVsZCB9IGZyb20gJy4vRHJhd1RleHRGaWVsZCc7XHJcbmV4cG9ydCBmdW5jdGlvbiBkcmF3RmFjZUV4cHJlc3Npb25zKGNhbnZhc0FyZywgZmFjZUV4cHJlc3Npb25zLCBtaW5Db25maWRlbmNlLCB0ZXh0RmllbGRBbmNob3IpIHtcclxuICAgIGlmIChtaW5Db25maWRlbmNlID09PSB2b2lkIDApIHsgbWluQ29uZmlkZW5jZSA9IDAuMTsgfVxyXG4gICAgdmFyIGZhY2VFeHByZXNzaW9uc0FycmF5ID0gQXJyYXkuaXNBcnJheShmYWNlRXhwcmVzc2lvbnMpID8gZmFjZUV4cHJlc3Npb25zIDogW2ZhY2VFeHByZXNzaW9uc107XHJcbiAgICBmYWNlRXhwcmVzc2lvbnNBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIGV4cHIgPSBlIGluc3RhbmNlb2YgRmFjZUV4cHJlc3Npb25zXHJcbiAgICAgICAgICAgID8gZVxyXG4gICAgICAgICAgICA6IChpc1dpdGhGYWNlRXhwcmVzc2lvbnMoZSkgPyBlLmV4cHJlc3Npb25zIDogdW5kZWZpbmVkKTtcclxuICAgICAgICBpZiAoIWV4cHIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmF3RmFjZUV4cHJlc3Npb25zIC0gZXhwZWN0ZWQgZmFjZUV4cHJlc3Npb25zIHRvIGJlIEZhY2VFeHByZXNzaW9ucyB8IFdpdGhGYWNlRXhwcmVzc2lvbnM8e30+IG9yIGFycmF5IHRoZXJlb2YnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNvcnRlZCA9IGV4cHIuYXNTb3J0ZWRBcnJheSgpO1xyXG4gICAgICAgIHZhciByZXN1bHRzVG9EaXNwbGF5ID0gc29ydGVkLmZpbHRlcihmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci5wcm9iYWJpbGl0eSA+IG1pbkNvbmZpZGVuY2U7IH0pO1xyXG4gICAgICAgIHZhciBhbmNob3IgPSBpc1dpdGhGYWNlRGV0ZWN0aW9uKGUpXHJcbiAgICAgICAgICAgID8gZS5kZXRlY3Rpb24uYm94LmJvdHRvbUxlZnRcclxuICAgICAgICAgICAgOiAodGV4dEZpZWxkQW5jaG9yIHx8IG5ldyBQb2ludCgwLCAwKSk7XHJcbiAgICAgICAgdmFyIGRyYXdUZXh0RmllbGQgPSBuZXcgRHJhd1RleHRGaWVsZChyZXN1bHRzVG9EaXNwbGF5Lm1hcChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci5leHByZXNzaW9uICsgXCIgKFwiICsgcm91bmQoZXhwci5wcm9iYWJpbGl0eSkgKyBcIilcIjsgfSksIGFuY2hvcik7XHJcbiAgICAgICAgZHJhd1RleHRGaWVsZC5kcmF3KGNhbnZhc0FyZyk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmF3RmFjZUV4cHJlc3Npb25zLmpzLm1hcCIsImV4cG9ydCAqIGZyb20gJy4vZHJhd0NvbnRvdXInO1xyXG5leHBvcnQgKiBmcm9tICcuL2RyYXdEZXRlY3Rpb25zJztcclxuZXhwb3J0ICogZnJvbSAnLi9kcmF3RmFjZUV4cHJlc3Npb25zJztcclxuZXhwb3J0ICogZnJvbSAnLi9EcmF3Qm94JztcclxuZXhwb3J0ICogZnJvbSAnLi9EcmF3RmFjZUxhbmRtYXJrcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vRHJhd1RleHRGaWVsZCc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCcm93c2VyRW52KCkge1xyXG4gICAgdmFyIGZldGNoID0gd2luZG93WydmZXRjaCddIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZldGNoIC0gbWlzc2luZyBmZXRjaCBpbXBsZW1lbnRhdGlvbiBmb3IgYnJvd3NlciBlbnZpcm9ubWVudCcpO1xyXG4gICAgfTtcclxuICAgIHZhciByZWFkRmlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlYWRGaWxlIC0gZmlsZXN5c3RlbSBub3QgYXZhaWxhYmxlIGZvciBicm93c2VyIGVudmlyb25tZW50Jyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxyXG4gICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxyXG4gICAgICAgIEltYWdlOiBIVE1MSW1hZ2VFbGVtZW50LFxyXG4gICAgICAgIEltYWdlRGF0YTogSW1hZ2VEYXRhLFxyXG4gICAgICAgIFZpZGVvOiBIVE1MVmlkZW9FbGVtZW50LFxyXG4gICAgICAgIGNyZWF0ZUNhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyB9LFxyXG4gICAgICAgIGNyZWF0ZUltYWdlRWxlbWVudDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7IH0sXHJcbiAgICAgICAgZmV0Y2g6IGZldGNoLFxyXG4gICAgICAgIHJlYWRGaWxlOiByZWFkRmlsZVxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVCcm93c2VyRW52LmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWxlU3lzdGVtKGZzKSB7XHJcbiAgICB2YXIgcmVxdWlyZUZzRXJyb3IgPSAnJztcclxuICAgIGlmICghZnMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmcyA9IHJlcXVpcmUoJ2ZzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgcmVxdWlyZUZzRXJyb3IgPSBlcnIudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgcmVhZEZpbGUgPSBmc1xyXG4gICAgICAgID8gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcclxuICAgICAgICAgICAgICAgIGZzLnJlYWRGaWxlKGZpbGVQYXRoLCBmdW5jdGlvbiAoZXJyLCBidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyID8gcmVqKGVycikgOiByZXMoYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlYWRGaWxlIC0gZmFpbGVkIHRvIHJlcXVpcmUgZnMgaW4gbm9kZWpzIGVudmlyb25tZW50IHdpdGggZXJyb3I6IFwiICsgcmVxdWlyZUZzRXJyb3IpO1xyXG4gICAgICAgIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlYWRGaWxlOiByZWFkRmlsZVxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVGaWxlU3lzdGVtLmpzLm1hcCIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IGNyZWF0ZUZpbGVTeXN0ZW0gfSBmcm9tICcuL2NyZWF0ZUZpbGVTeXN0ZW0nO1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTm9kZWpzRW52KCkge1xyXG4gICAgdmFyIENhbnZhcyA9IGdsb2JhbFsnQ2FudmFzJ10gfHwgZ2xvYmFsWydIVE1MQ2FudmFzRWxlbWVudCddO1xyXG4gICAgdmFyIEltYWdlID0gZ2xvYmFsWydJbWFnZSddIHx8IGdsb2JhbFsnSFRNTEltYWdlRWxlbWVudCddO1xyXG4gICAgdmFyIGNyZWF0ZUNhbnZhc0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKENhbnZhcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbnZhcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZUNhbnZhc0VsZW1lbnQgLSBtaXNzaW5nIENhbnZhcyBpbXBsZW1lbnRhdGlvbiBmb3Igbm9kZWpzIGVudmlyb25tZW50Jyk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGNyZWF0ZUltYWdlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoSW1hZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZUltYWdlRWxlbWVudCAtIG1pc3NpbmcgSW1hZ2UgaW1wbGVtZW50YXRpb24gZm9yIG5vZGVqcyBlbnZpcm9ubWVudCcpO1xyXG4gICAgfTtcclxuICAgIHZhciBmZXRjaCA9IGdsb2JhbFsnZmV0Y2gnXSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmZXRjaCAtIG1pc3NpbmcgZmV0Y2ggaW1wbGVtZW50YXRpb24gZm9yIG5vZGVqcyBlbnZpcm9ubWVudCcpO1xyXG4gICAgfTtcclxuICAgIHZhciBmaWxlU3lzdGVtID0gY3JlYXRlRmlsZVN5c3RlbSgpO1xyXG4gICAgcmV0dXJuIF9fYXNzaWduKHsgQ2FudmFzOiBDYW52YXMgfHwgLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDYW52YXMoKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIENhbnZhcztcclxuICAgICAgICB9KCkpLCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ6IGdsb2JhbFsnQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEJ10gfHwgLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgICAgIH0oKSksIEltYWdlOiBJbWFnZSB8fCAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEltYWdlKCkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBJbWFnZTtcclxuICAgICAgICB9KCkpLCBJbWFnZURhdGE6IGdsb2JhbFsnSW1hZ2VEYXRhJ10gfHwgLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18yKCkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjbGFzc18yO1xyXG4gICAgICAgIH0oKSksIFZpZGVvOiBnbG9iYWxbJ0hUTUxWaWRlb0VsZW1lbnQnXSB8fCAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzMoKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzXzM7XHJcbiAgICAgICAgfSgpKSwgY3JlYXRlQ2FudmFzRWxlbWVudDogY3JlYXRlQ2FudmFzRWxlbWVudCxcclxuICAgICAgICBjcmVhdGVJbWFnZUVsZW1lbnQ6IGNyZWF0ZUltYWdlRWxlbWVudCxcclxuICAgICAgICBmZXRjaDogZmV0Y2ggfSwgZmlsZVN5c3RlbSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlTm9kZWpzRW52LmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUJyb3dzZXJFbnYgfSBmcm9tICcuL2NyZWF0ZUJyb3dzZXJFbnYnO1xyXG5pbXBvcnQgeyBjcmVhdGVGaWxlU3lzdGVtIH0gZnJvbSAnLi9jcmVhdGVGaWxlU3lzdGVtJztcclxuaW1wb3J0IHsgY3JlYXRlTm9kZWpzRW52IH0gZnJvbSAnLi9jcmVhdGVOb2RlanNFbnYnO1xyXG5pbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tICcuL2lzQnJvd3Nlcic7XHJcbmltcG9ydCB7IGlzTm9kZWpzIH0gZnJvbSAnLi9pc05vZGVqcyc7XHJcbnZhciBlbnZpcm9ubWVudDtcclxuZnVuY3Rpb24gZ2V0RW52KCkge1xyXG4gICAgaWYgKCFlbnZpcm9ubWVudCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0RW52IC0gZW52aXJvbm1lbnQgaXMgbm90IGRlZmluZWQsIGNoZWNrIGlzTm9kZWpzKCkgYW5kIGlzQnJvd3NlcigpJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW52aXJvbm1lbnQ7XHJcbn1cclxuZnVuY3Rpb24gc2V0RW52KGVudikge1xyXG4gICAgZW52aXJvbm1lbnQgPSBlbnY7XHJcbn1cclxuZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcclxuICAgIC8vIGNoZWNrIGZvciBpc0Jyb3dzZXIoKSBmaXJzdCB0byBwcmV2ZW50IGVsZWN0cm9uIHJlbmRlcmVyIHByb2Nlc3NcclxuICAgIC8vIHRvIGJlIGluaXRpYWxpemVkIHdpdGggd3JvbmcgZW52aXJvbm1lbnQgZHVlIHRvIGlzTm9kZWpzKCkgcmV0dXJuaW5nIHRydWVcclxuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xyXG4gICAgICAgIHNldEVudihjcmVhdGVCcm93c2VyRW52KCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzTm9kZWpzKCkpIHtcclxuICAgICAgICBzZXRFbnYoY3JlYXRlTm9kZWpzRW52KCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1vbmtleVBhdGNoKGVudikge1xyXG4gICAgaWYgKCFlbnZpcm9ubWVudCkge1xyXG4gICAgICAgIGluaXRpYWxpemUoKTtcclxuICAgIH1cclxuICAgIGlmICghZW52aXJvbm1lbnQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vbmtleVBhdGNoIC0gZW52aXJvbm1lbnQgaXMgbm90IGRlZmluZWQsIGNoZWNrIGlzTm9kZWpzKCkgYW5kIGlzQnJvd3NlcigpJyk7XHJcbiAgICB9XHJcbiAgICB2YXIgX2EgPSBlbnYuQ2FudmFzLCBDYW52YXMgPSBfYSA9PT0gdm9pZCAwID8gZW52aXJvbm1lbnQuQ2FudmFzIDogX2EsIF9iID0gZW52LkltYWdlLCBJbWFnZSA9IF9iID09PSB2b2lkIDAgPyBlbnZpcm9ubWVudC5JbWFnZSA6IF9iO1xyXG4gICAgZW52aXJvbm1lbnQuQ2FudmFzID0gQ2FudmFzO1xyXG4gICAgZW52aXJvbm1lbnQuSW1hZ2UgPSBJbWFnZTtcclxuICAgIGVudmlyb25tZW50LmNyZWF0ZUNhbnZhc0VsZW1lbnQgPSBlbnYuY3JlYXRlQ2FudmFzRWxlbWVudCB8fCAoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IENhbnZhcygpOyB9KTtcclxuICAgIGVudmlyb25tZW50LmNyZWF0ZUltYWdlRWxlbWVudCA9IGVudi5jcmVhdGVJbWFnZUVsZW1lbnQgfHwgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJbWFnZSgpOyB9KTtcclxuICAgIGVudmlyb25tZW50LkltYWdlRGF0YSA9IGVudi5JbWFnZURhdGEgfHwgZW52aXJvbm1lbnQuSW1hZ2VEYXRhO1xyXG4gICAgZW52aXJvbm1lbnQuVmlkZW8gPSBlbnYuVmlkZW8gfHwgZW52aXJvbm1lbnQuVmlkZW87XHJcbiAgICBlbnZpcm9ubWVudC5mZXRjaCA9IGVudi5mZXRjaCB8fCBlbnZpcm9ubWVudC5mZXRjaDtcclxuICAgIGVudmlyb25tZW50LnJlYWRGaWxlID0gZW52LnJlYWRGaWxlIHx8IGVudmlyb25tZW50LnJlYWRGaWxlO1xyXG59XHJcbmV4cG9ydCB2YXIgZW52ID0ge1xyXG4gICAgZ2V0RW52OiBnZXRFbnYsXHJcbiAgICBzZXRFbnY6IHNldEVudixcclxuICAgIGluaXRpYWxpemU6IGluaXRpYWxpemUsXHJcbiAgICBjcmVhdGVCcm93c2VyRW52OiBjcmVhdGVCcm93c2VyRW52LFxyXG4gICAgY3JlYXRlRmlsZVN5c3RlbTogY3JlYXRlRmlsZVN5c3RlbSxcclxuICAgIGNyZWF0ZU5vZGVqc0VudjogY3JlYXRlTm9kZWpzRW52LFxyXG4gICAgbW9ua2V5UGF0Y2g6IG1vbmtleVBhdGNoLFxyXG4gICAgaXNCcm93c2VyOiBpc0Jyb3dzZXIsXHJcbiAgICBpc05vZGVqczogaXNOb2RlanNcclxufTtcclxuaW5pdGlhbGl6ZSgpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gaXNCcm93c2VyKCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnXHJcbiAgICAgICAgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICYmIHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICYmIHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAmJiB0eXBlb2YgSFRNTFZpZGVvRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAmJiB0eXBlb2YgSW1hZ2VEYXRhICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICYmIHR5cGVvZiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgIT09ICd1bmRlZmluZWQnO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQnJvd3Nlci5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gaXNOb2RlanMoKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCdcclxuICAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgLy8gaXNzdWVzIHdpdGggZ2F0c2J5LmpzOiBtb2R1bGUuZXhwb3J0cyBpcyB1bmRlZmluZWRcclxuICAgICAgICAvLyAmJiAhIW1vZHVsZS5leHBvcnRzXHJcbiAgICAgICAgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICEhcHJvY2Vzcy52ZXJzaW9uO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzTm9kZWpzLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBldWNsaWRlYW5EaXN0YW5jZShhcnIxLCBhcnIyKSB7XHJcbiAgICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXVjbGlkZWFuRGlzdGFuY2U6IGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCcpO1xyXG4gICAgdmFyIGRlc2MxID0gQXJyYXkuZnJvbShhcnIxKTtcclxuICAgIHZhciBkZXNjMiA9IEFycmF5LmZyb20oYXJyMik7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGRlc2MxXHJcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodmFsLCBpKSB7IHJldHVybiB2YWwgLSBkZXNjMltpXTsgfSlcclxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGRpZmYpIHsgcmV0dXJuIHJlcyArIE1hdGgucG93KGRpZmYsIDIpOyB9LCAwKSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXVjbGlkZWFuRGlzdGFuY2UuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2V4dGVuZHMsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IHRvTmV0SW5wdXQgfSBmcm9tICcuLi9kb20nO1xyXG5pbXBvcnQgeyBGYWNlRmVhdHVyZUV4dHJhY3RvciB9IGZyb20gJy4uL2ZhY2VGZWF0dXJlRXh0cmFjdG9yL0ZhY2VGZWF0dXJlRXh0cmFjdG9yJztcclxuaW1wb3J0IHsgRmFjZVByb2Nlc3NvciB9IGZyb20gJy4uL2ZhY2VQcm9jZXNzb3IvRmFjZVByb2Nlc3Nvcic7XHJcbmltcG9ydCB7IEZhY2VFeHByZXNzaW9ucyB9IGZyb20gJy4vRmFjZUV4cHJlc3Npb25zJztcclxudmFyIEZhY2VFeHByZXNzaW9uTmV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEZhY2VFeHByZXNzaW9uTmV0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRmFjZUV4cHJlc3Npb25OZXQoZmFjZUZlYXR1cmVFeHRyYWN0b3IpIHtcclxuICAgICAgICBpZiAoZmFjZUZlYXR1cmVFeHRyYWN0b3IgPT09IHZvaWQgMCkgeyBmYWNlRmVhdHVyZUV4dHJhY3RvciA9IG5ldyBGYWNlRmVhdHVyZUV4dHJhY3RvcigpOyB9XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdGYWNlRXhwcmVzc2lvbk5ldCcsIGZhY2VGZWF0dXJlRXh0cmFjdG9yKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRmFjZUV4cHJlc3Npb25OZXQucHJvdG90eXBlLmZvcndhcmRJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGYuc29mdG1heChfdGhpcy5ydW5OZXQoaW5wdXQpKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUV4cHJlc3Npb25OZXQucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLmZvcndhcmRJbnB1dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdG9OZXRJbnB1dChpbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHRoaXMsIFtfYi5zZW50KCldKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEZhY2VFeHByZXNzaW9uTmV0LnByb3RvdHlwZS5wcmVkaWN0RXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXRJbnB1dCwgb3V0LCBwcm9iYWJpbGl0ZXNCeUJhdGNoLCBwcmVkaWN0aW9uc0J5QmF0Y2g7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRvTmV0SW5wdXQoaW5wdXQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldElucHV0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZvcndhcmRJbnB1dChuZXRJbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbCh0Zi51bnN0YWNrKG91dCkubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHQuZGF0YSgpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0pKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9iYWJpbGl0ZXNCeUJhdGNoID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWN0aW9uc0J5QmF0Y2ggPSBwcm9iYWJpbGl0ZXNCeUJhdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwcm9iYWJpbGl0ZXMpIHsgcmV0dXJuIG5ldyBGYWNlRXhwcmVzc2lvbnMocHJvYmFiaWxpdGVzKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXRJbnB1dC5pc0JhdGNoSW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHByZWRpY3Rpb25zQnlCYXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcHJlZGljdGlvbnNCeUJhdGNoWzBdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUV4cHJlc3Npb25OZXQucHJvdG90eXBlLmdldERlZmF1bHRNb2RlbE5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICdmYWNlX2V4cHJlc3Npb25fbW9kZWwnO1xyXG4gICAgfTtcclxuICAgIEZhY2VFeHByZXNzaW9uTmV0LnByb3RvdHlwZS5nZXRDbGFzc2lmaWVyQ2hhbm5lbHNJbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gMjU2O1xyXG4gICAgfTtcclxuICAgIEZhY2VFeHByZXNzaW9uTmV0LnByb3RvdHlwZS5nZXRDbGFzc2lmaWVyQ2hhbm5lbHNPdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIDc7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZhY2VFeHByZXNzaW9uTmV0O1xyXG59KEZhY2VQcm9jZXNzb3IpKTtcclxuZXhwb3J0IHsgRmFjZUV4cHJlc3Npb25OZXQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmFjZUV4cHJlc3Npb25OZXQuanMubWFwIiwiZXhwb3J0IHZhciBGQUNFX0VYUFJFU1NJT05fTEFCRUxTID0gWyduZXV0cmFsJywgJ2hhcHB5JywgJ3NhZCcsICdhbmdyeScsICdmZWFyZnVsJywgJ2Rpc2d1c3RlZCcsICdzdXJwcmlzZWQnXTtcclxudmFyIEZhY2VFeHByZXNzaW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZhY2VFeHByZXNzaW9ucyhwcm9iYWJpbGl0aWVzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAocHJvYmFiaWxpdGllcy5sZW5ndGggIT09IDcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFjZUV4cHJlc3Npb25zLmNvbnN0cnVjdG9yIC0gZXhwZWN0ZWQgcHJvYmFiaWxpdGllcy5sZW5ndGggdG8gYmUgNywgaGF2ZTogXCIgKyBwcm9iYWJpbGl0aWVzLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEZBQ0VfRVhQUkVTU0lPTl9MQUJFTFMuZm9yRWFjaChmdW5jdGlvbiAoZXhwcmVzc2lvbiwgaWR4KSB7XHJcbiAgICAgICAgICAgIF90aGlzW2V4cHJlc3Npb25dID0gcHJvYmFiaWxpdGllc1tpZHhdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgRmFjZUV4cHJlc3Npb25zLnByb3RvdHlwZS5hc1NvcnRlZEFycmF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIEZBQ0VfRVhQUkVTU0lPTl9MQUJFTFNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZXhwcmVzc2lvbikgeyByZXR1cm4gKHsgZXhwcmVzc2lvbjogZXhwcmVzc2lvbiwgcHJvYmFiaWxpdHk6IF90aGlzW2V4cHJlc3Npb25dIH0pOyB9KVxyXG4gICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoZTAsIGUxKSB7IHJldHVybiBlMS5wcm9iYWJpbGl0eSAtIGUwLnByb2JhYmlsaXR5OyB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmFjZUV4cHJlc3Npb25zO1xyXG59KCkpO1xyXG5leHBvcnQgeyBGYWNlRXhwcmVzc2lvbnMgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmFjZUV4cHJlc3Npb25zLmpzLm1hcCIsImV4cG9ydCAqIGZyb20gJy4vRmFjZUV4cHJlc3Npb25OZXQnO1xyXG5leHBvcnQgKiBmcm9tICcuL0ZhY2VFeHByZXNzaW9ucyc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19leHRlbmRzLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyB0b05ldElucHV0IH0gZnJvbSAnLi4vZG9tJztcclxuaW1wb3J0IHsgTmV1cmFsTmV0d29yayB9IGZyb20gJy4uL05ldXJhbE5ldHdvcmsnO1xyXG5pbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuLi9vcHMnO1xyXG5pbXBvcnQgeyBkZW5zZUJsb2NrNCB9IGZyb20gJy4vZGVuc2VCbG9jayc7XHJcbmltcG9ydCB7IGV4dHJhY3RQYXJhbXMgfSBmcm9tICcuL2V4dHJhY3RQYXJhbXMnO1xyXG5pbXBvcnQgeyBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCB9IGZyb20gJy4vZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAnO1xyXG52YXIgRmFjZUZlYXR1cmVFeHRyYWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmFjZUZlYXR1cmVFeHRyYWN0b3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGYWNlRmVhdHVyZUV4dHJhY3RvcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ0ZhY2VGZWF0dXJlRXh0cmFjdG9yJykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEZhY2VGZWF0dXJlRXh0cmFjdG9yLnByb3RvdHlwZS5mb3J3YXJkSW5wdXQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWNlRmVhdHVyZUV4dHJhY3RvciAtIGxvYWQgbW9kZWwgYmVmb3JlIGluZmVyZW5jZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBiYXRjaFRlbnNvciA9IGlucHV0LnRvQmF0Y2hUZW5zb3IoMTEyLCB0cnVlKTtcclxuICAgICAgICAgICAgdmFyIG1lYW5SZ2IgPSBbMTIyLjc4MiwgMTE3LjAwMSwgMTA0LjI5OF07XHJcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplKGJhdGNoVGVuc29yLCBtZWFuUmdiKS5kaXYodGYuc2NhbGFyKDI1NSkpO1xyXG4gICAgICAgICAgICB2YXIgb3V0ID0gZGVuc2VCbG9jazQobm9ybWFsaXplZCwgcGFyYW1zLmRlbnNlMCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIG91dCA9IGRlbnNlQmxvY2s0KG91dCwgcGFyYW1zLmRlbnNlMSk7XHJcbiAgICAgICAgICAgIG91dCA9IGRlbnNlQmxvY2s0KG91dCwgcGFyYW1zLmRlbnNlMik7XHJcbiAgICAgICAgICAgIG91dCA9IGRlbnNlQmxvY2s0KG91dCwgcGFyYW1zLmRlbnNlMyk7XHJcbiAgICAgICAgICAgIG91dCA9IHRmLmF2Z1Bvb2wob3V0LCBbNywgN10sIFsyLCAyXSwgJ3ZhbGlkJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUZlYXR1cmVFeHRyYWN0b3IucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLmZvcndhcmRJbnB1dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdG9OZXRJbnB1dChpbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHRoaXMsIFtfYi5zZW50KCldKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEZhY2VGZWF0dXJlRXh0cmFjdG9yLnByb3RvdHlwZS5nZXREZWZhdWx0TW9kZWxOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnZmFjZV9mZWF0dXJlX2V4dHJhY3Rvcl9tb2RlbCc7XHJcbiAgICB9O1xyXG4gICAgRmFjZUZlYXR1cmVFeHRyYWN0b3IucHJvdG90eXBlLmV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwID0gZnVuY3Rpb24gKHdlaWdodE1hcCkge1xyXG4gICAgICAgIHJldHVybiBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCh3ZWlnaHRNYXApO1xyXG4gICAgfTtcclxuICAgIEZhY2VGZWF0dXJlRXh0cmFjdG9yLnByb3RvdHlwZS5leHRyYWN0UGFyYW1zID0gZnVuY3Rpb24gKHdlaWdodHMpIHtcclxuICAgICAgICByZXR1cm4gZXh0cmFjdFBhcmFtcyh3ZWlnaHRzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmFjZUZlYXR1cmVFeHRyYWN0b3I7XHJcbn0oTmV1cmFsTmV0d29yaykpO1xyXG5leHBvcnQgeyBGYWNlRmVhdHVyZUV4dHJhY3RvciB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYWNlRmVhdHVyZUV4dHJhY3Rvci5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZXh0ZW5kcywgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgdG9OZXRJbnB1dCB9IGZyb20gJy4uL2RvbSc7XHJcbmltcG9ydCB7IE5ldXJhbE5ldHdvcmsgfSBmcm9tICcuLi9OZXVyYWxOZXR3b3JrJztcclxuaW1wb3J0IHsgbm9ybWFsaXplIH0gZnJvbSAnLi4vb3BzJztcclxuaW1wb3J0IHsgZGVuc2VCbG9jazMgfSBmcm9tICcuL2RlbnNlQmxvY2snO1xyXG5pbXBvcnQgeyBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcFRpbnkgfSBmcm9tICcuL2V4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwVGlueSc7XHJcbmltcG9ydCB7IGV4dHJhY3RQYXJhbXNUaW55IH0gZnJvbSAnLi9leHRyYWN0UGFyYW1zVGlueSc7XHJcbnZhciBUaW55RmFjZUZlYXR1cmVFeHRyYWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAnVGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yJykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFRpbnlGYWNlRmVhdHVyZUV4dHJhY3Rvci5wcm90b3R5cGUuZm9yd2FyZElucHV0ID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yIC0gbG9hZCBtb2RlbCBiZWZvcmUgaW5mZXJlbmNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJhdGNoVGVuc29yID0gaW5wdXQudG9CYXRjaFRlbnNvcigxMTIsIHRydWUpO1xyXG4gICAgICAgICAgICB2YXIgbWVhblJnYiA9IFsxMjIuNzgyLCAxMTcuMDAxLCAxMDQuMjk4XTtcclxuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemUoYmF0Y2hUZW5zb3IsIG1lYW5SZ2IpLmRpdih0Zi5zY2FsYXIoMjU1KSk7XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSBkZW5zZUJsb2NrMyhub3JtYWxpemVkLCBwYXJhbXMuZGVuc2UwLCB0cnVlKTtcclxuICAgICAgICAgICAgb3V0ID0gZGVuc2VCbG9jazMob3V0LCBwYXJhbXMuZGVuc2UxKTtcclxuICAgICAgICAgICAgb3V0ID0gZGVuc2VCbG9jazMob3V0LCBwYXJhbXMuZGVuc2UyKTtcclxuICAgICAgICAgICAgb3V0ID0gdGYuYXZnUG9vbChvdXQsIFsxNCwgMTRdLCBbMiwgMl0sICd2YWxpZCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFRpbnlGYWNlRmVhdHVyZUV4dHJhY3Rvci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMuZm9yd2FyZElucHV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0b05ldElucHV0KGlucHV0KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2EuYXBwbHkodGhpcywgW19iLnNlbnQoKV0pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yLnByb3RvdHlwZS5nZXREZWZhdWx0TW9kZWxOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnZmFjZV9mZWF0dXJlX2V4dHJhY3Rvcl90aW55X21vZGVsJztcclxuICAgIH07XHJcbiAgICBUaW55RmFjZUZlYXR1cmVFeHRyYWN0b3IucHJvdG90eXBlLmV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwID0gZnVuY3Rpb24gKHdlaWdodE1hcCkge1xyXG4gICAgICAgIHJldHVybiBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcFRpbnkod2VpZ2h0TWFwKTtcclxuICAgIH07XHJcbiAgICBUaW55RmFjZUZlYXR1cmVFeHRyYWN0b3IucHJvdG90eXBlLmV4dHJhY3RQYXJhbXMgPSBmdW5jdGlvbiAod2VpZ2h0cykge1xyXG4gICAgICAgIHJldHVybiBleHRyYWN0UGFyYW1zVGlueSh3ZWlnaHRzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yO1xyXG59KE5ldXJhbE5ldHdvcmspKTtcclxuZXhwb3J0IHsgVGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbnlGYWNlRmVhdHVyZUV4dHJhY3Rvci5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBkZXB0aHdpc2VTZXBhcmFibGVDb252IH0gZnJvbSAnLi4vY29tbW9uL2RlcHRod2lzZVNlcGFyYWJsZUNvbnYnO1xyXG5leHBvcnQgZnVuY3Rpb24gZGVuc2VCbG9jazMoeCwgZGVuc2VCbG9ja1BhcmFtcywgaXNGaXJzdExheWVyKSB7XHJcbiAgICBpZiAoaXNGaXJzdExheWVyID09PSB2b2lkIDApIHsgaXNGaXJzdExheWVyID0gZmFsc2U7IH1cclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3V0MSA9IHRmLnJlbHUoaXNGaXJzdExheWVyXHJcbiAgICAgICAgICAgID8gdGYuYWRkKHRmLmNvbnYyZCh4LCBkZW5zZUJsb2NrUGFyYW1zLmNvbnYwLmZpbHRlcnMsIFsyLCAyXSwgJ3NhbWUnKSwgZGVuc2VCbG9ja1BhcmFtcy5jb252MC5iaWFzKVxyXG4gICAgICAgICAgICA6IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYoeCwgZGVuc2VCbG9ja1BhcmFtcy5jb252MCwgWzIsIDJdKSk7XHJcbiAgICAgICAgdmFyIG91dDIgPSBkZXB0aHdpc2VTZXBhcmFibGVDb252KG91dDEsIGRlbnNlQmxvY2tQYXJhbXMuY29udjEsIFsxLCAxXSk7XHJcbiAgICAgICAgdmFyIGluMyA9IHRmLnJlbHUodGYuYWRkKG91dDEsIG91dDIpKTtcclxuICAgICAgICB2YXIgb3V0MyA9IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYoaW4zLCBkZW5zZUJsb2NrUGFyYW1zLmNvbnYyLCBbMSwgMV0pO1xyXG4gICAgICAgIHJldHVybiB0Zi5yZWx1KHRmLmFkZChvdXQxLCB0Zi5hZGQob3V0Miwgb3V0MykpKTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBkZW5zZUJsb2NrNCh4LCBkZW5zZUJsb2NrUGFyYW1zLCBpc0ZpcnN0TGF5ZXIsIGlzU2NhbGVEb3duKSB7XHJcbiAgICBpZiAoaXNGaXJzdExheWVyID09PSB2b2lkIDApIHsgaXNGaXJzdExheWVyID0gZmFsc2U7IH1cclxuICAgIGlmIChpc1NjYWxlRG93biA9PT0gdm9pZCAwKSB7IGlzU2NhbGVEb3duID0gdHJ1ZTsgfVxyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvdXQxID0gdGYucmVsdShpc0ZpcnN0TGF5ZXJcclxuICAgICAgICAgICAgPyB0Zi5hZGQodGYuY29udjJkKHgsIGRlbnNlQmxvY2tQYXJhbXMuY29udjAuZmlsdGVycywgaXNTY2FsZURvd24gPyBbMiwgMl0gOiBbMSwgMV0sICdzYW1lJyksIGRlbnNlQmxvY2tQYXJhbXMuY29udjAuYmlhcylcclxuICAgICAgICAgICAgOiBkZXB0aHdpc2VTZXBhcmFibGVDb252KHgsIGRlbnNlQmxvY2tQYXJhbXMuY29udjAsIGlzU2NhbGVEb3duID8gWzIsIDJdIDogWzEsIDFdKSk7XHJcbiAgICAgICAgdmFyIG91dDIgPSBkZXB0aHdpc2VTZXBhcmFibGVDb252KG91dDEsIGRlbnNlQmxvY2tQYXJhbXMuY29udjEsIFsxLCAxXSk7XHJcbiAgICAgICAgdmFyIGluMyA9IHRmLnJlbHUodGYuYWRkKG91dDEsIG91dDIpKTtcclxuICAgICAgICB2YXIgb3V0MyA9IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYoaW4zLCBkZW5zZUJsb2NrUGFyYW1zLmNvbnYyLCBbMSwgMV0pO1xyXG4gICAgICAgIHZhciBpbjQgPSB0Zi5yZWx1KHRmLmFkZChvdXQxLCB0Zi5hZGQob3V0Miwgb3V0MykpKTtcclxuICAgICAgICB2YXIgb3V0NCA9IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYoaW40LCBkZW5zZUJsb2NrUGFyYW1zLmNvbnYzLCBbMSwgMV0pO1xyXG4gICAgICAgIHJldHVybiB0Zi5yZWx1KHRmLmFkZChvdXQxLCB0Zi5hZGQob3V0MiwgdGYuYWRkKG91dDMsIG91dDQpKSkpO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVuc2VCbG9jay5qcy5tYXAiLCJpbXBvcnQgeyBleHRyYWN0V2VpZ2h0c0ZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBleHRyYWN0b3JzRmFjdG9yeSB9IGZyb20gJy4vZXh0cmFjdG9yc0ZhY3RvcnknO1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtcyh3ZWlnaHRzKSB7XHJcbiAgICB2YXIgcGFyYW1NYXBwaW5ncyA9IFtdO1xyXG4gICAgdmFyIF9hID0gZXh0cmFjdFdlaWdodHNGYWN0b3J5KHdlaWdodHMpLCBleHRyYWN0V2VpZ2h0cyA9IF9hLmV4dHJhY3RXZWlnaHRzLCBnZXRSZW1haW5pbmdXZWlnaHRzID0gX2EuZ2V0UmVtYWluaW5nV2VpZ2h0cztcclxuICAgIHZhciBleHRyYWN0RGVuc2VCbG9jazRQYXJhbXMgPSBleHRyYWN0b3JzRmFjdG9yeShleHRyYWN0V2VpZ2h0cywgcGFyYW1NYXBwaW5ncykuZXh0cmFjdERlbnNlQmxvY2s0UGFyYW1zO1xyXG4gICAgdmFyIGRlbnNlMCA9IGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtcygzLCAzMiwgJ2RlbnNlMCcsIHRydWUpO1xyXG4gICAgdmFyIGRlbnNlMSA9IGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtcygzMiwgNjQsICdkZW5zZTEnKTtcclxuICAgIHZhciBkZW5zZTIgPSBleHRyYWN0RGVuc2VCbG9jazRQYXJhbXMoNjQsIDEyOCwgJ2RlbnNlMicpO1xyXG4gICAgdmFyIGRlbnNlMyA9IGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtcygxMjgsIDI1NiwgJ2RlbnNlMycpO1xyXG4gICAgaWYgKGdldFJlbWFpbmluZ1dlaWdodHMoKS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWlnaHRzIHJlbWFpbmcgYWZ0ZXIgZXh0cmFjdDogXCIgKyBnZXRSZW1haW5pbmdXZWlnaHRzKCkubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcGFyYW1NYXBwaW5nczogcGFyYW1NYXBwaW5ncyxcclxuICAgICAgICBwYXJhbXM6IHsgZGVuc2UwOiBkZW5zZTAsIGRlbnNlMTogZGVuc2UxLCBkZW5zZTI6IGRlbnNlMiwgZGVuc2UzOiBkZW5zZTMgfVxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0UGFyYW1zLmpzLm1hcCIsImltcG9ydCB7IGRpc3Bvc2VVbnVzZWRXZWlnaHRUZW5zb3JzIH0gZnJvbSAnLi4vY29tbW9uJztcclxuaW1wb3J0IHsgbG9hZFBhcmFtc0ZhY3RvcnkgfSBmcm9tICcuL2xvYWRQYXJhbXNGYWN0b3J5JztcclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwKHdlaWdodE1hcCkge1xyXG4gICAgdmFyIHBhcmFtTWFwcGluZ3MgPSBbXTtcclxuICAgIHZhciBleHRyYWN0RGVuc2VCbG9jazRQYXJhbXMgPSBsb2FkUGFyYW1zRmFjdG9yeSh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpLmV4dHJhY3REZW5zZUJsb2NrNFBhcmFtcztcclxuICAgIHZhciBwYXJhbXMgPSB7XHJcbiAgICAgICAgZGVuc2UwOiBleHRyYWN0RGVuc2VCbG9jazRQYXJhbXMoJ2RlbnNlMCcsIHRydWUpLFxyXG4gICAgICAgIGRlbnNlMTogZXh0cmFjdERlbnNlQmxvY2s0UGFyYW1zKCdkZW5zZTEnKSxcclxuICAgICAgICBkZW5zZTI6IGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtcygnZGVuc2UyJyksXHJcbiAgICAgICAgZGVuc2UzOiBleHRyYWN0RGVuc2VCbG9jazRQYXJhbXMoJ2RlbnNlMycpXHJcbiAgICB9O1xyXG4gICAgZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIHJldHVybiB7IHBhcmFtczogcGFyYW1zLCBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuanMubWFwIiwiaW1wb3J0IHsgZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBsb2FkUGFyYW1zRmFjdG9yeSB9IGZyb20gJy4vbG9hZFBhcmFtc0ZhY3RvcnknO1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXBUaW55KHdlaWdodE1hcCkge1xyXG4gICAgdmFyIHBhcmFtTWFwcGluZ3MgPSBbXTtcclxuICAgIHZhciBleHRyYWN0RGVuc2VCbG9jazNQYXJhbXMgPSBsb2FkUGFyYW1zRmFjdG9yeSh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpLmV4dHJhY3REZW5zZUJsb2NrM1BhcmFtcztcclxuICAgIHZhciBwYXJhbXMgPSB7XHJcbiAgICAgICAgZGVuc2UwOiBleHRyYWN0RGVuc2VCbG9jazNQYXJhbXMoJ2RlbnNlMCcsIHRydWUpLFxyXG4gICAgICAgIGRlbnNlMTogZXh0cmFjdERlbnNlQmxvY2szUGFyYW1zKCdkZW5zZTEnKSxcclxuICAgICAgICBkZW5zZTI6IGV4dHJhY3REZW5zZUJsb2NrM1BhcmFtcygnZGVuc2UyJylcclxuICAgIH07XHJcbiAgICBkaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycyh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgcmV0dXJuIHsgcGFyYW1zOiBwYXJhbXMsIHBhcmFtTWFwcGluZ3M6IHBhcmFtTWFwcGluZ3MgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcFRpbnkuanMubWFwIiwiaW1wb3J0IHsgZXh0cmFjdFdlaWdodHNGYWN0b3J5IH0gZnJvbSAnLi4vY29tbW9uJztcclxuaW1wb3J0IHsgZXh0cmFjdG9yc0ZhY3RvcnkgfSBmcm9tICcuL2V4dHJhY3RvcnNGYWN0b3J5JztcclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQYXJhbXNUaW55KHdlaWdodHMpIHtcclxuICAgIHZhciBwYXJhbU1hcHBpbmdzID0gW107XHJcbiAgICB2YXIgX2EgPSBleHRyYWN0V2VpZ2h0c0ZhY3Rvcnkod2VpZ2h0cyksIGV4dHJhY3RXZWlnaHRzID0gX2EuZXh0cmFjdFdlaWdodHMsIGdldFJlbWFpbmluZ1dlaWdodHMgPSBfYS5nZXRSZW1haW5pbmdXZWlnaHRzO1xyXG4gICAgdmFyIGV4dHJhY3REZW5zZUJsb2NrM1BhcmFtcyA9IGV4dHJhY3RvcnNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKS5leHRyYWN0RGVuc2VCbG9jazNQYXJhbXM7XHJcbiAgICB2YXIgZGVuc2UwID0gZXh0cmFjdERlbnNlQmxvY2szUGFyYW1zKDMsIDMyLCAnZGVuc2UwJywgdHJ1ZSk7XHJcbiAgICB2YXIgZGVuc2UxID0gZXh0cmFjdERlbnNlQmxvY2szUGFyYW1zKDMyLCA2NCwgJ2RlbnNlMScpO1xyXG4gICAgdmFyIGRlbnNlMiA9IGV4dHJhY3REZW5zZUJsb2NrM1BhcmFtcyg2NCwgMTI4LCAnZGVuc2UyJyk7XHJcbiAgICBpZiAoZ2V0UmVtYWluaW5nV2VpZ2h0cygpLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIndlaWdodHMgcmVtYWluZyBhZnRlciBleHRyYWN0OiBcIiArIGdldFJlbWFpbmluZ1dlaWdodHMoKS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzLFxyXG4gICAgICAgIHBhcmFtczogeyBkZW5zZTA6IGRlbnNlMCwgZGVuc2UxOiBkZW5zZTEsIGRlbnNlMjogZGVuc2UyIH1cclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFBhcmFtc1RpbnkuanMubWFwIiwiaW1wb3J0IHsgZXh0cmFjdENvbnZQYXJhbXNGYWN0b3J5LCBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnksIH0gZnJvbSAnLi4vY29tbW9uJztcclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RvcnNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKSB7XHJcbiAgICB2YXIgZXh0cmFjdENvbnZQYXJhbXMgPSBleHRyYWN0Q29udlBhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgdmFyIGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3REZW5zZUJsb2NrM1BhcmFtcyhjaGFubmVsc0luLCBjaGFubmVsc091dCwgbWFwcGVkUHJlZml4LCBpc0ZpcnN0TGF5ZXIpIHtcclxuICAgICAgICBpZiAoaXNGaXJzdExheWVyID09PSB2b2lkIDApIHsgaXNGaXJzdExheWVyID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgY29udjAgPSBpc0ZpcnN0TGF5ZXJcclxuICAgICAgICAgICAgPyBleHRyYWN0Q29udlBhcmFtcyhjaGFubmVsc0luLCBjaGFubmVsc091dCwgMywgbWFwcGVkUHJlZml4ICsgXCIvY29udjBcIilcclxuICAgICAgICAgICAgOiBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhjaGFubmVsc0luLCBjaGFubmVsc091dCwgbWFwcGVkUHJlZml4ICsgXCIvY29udjBcIik7XHJcbiAgICAgICAgdmFyIGNvbnYxID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoY2hhbm5lbHNPdXQsIGNoYW5uZWxzT3V0LCBtYXBwZWRQcmVmaXggKyBcIi9jb252MVwiKTtcclxuICAgICAgICB2YXIgY29udjIgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhjaGFubmVsc091dCwgY2hhbm5lbHNPdXQsIG1hcHBlZFByZWZpeCArIFwiL2NvbnYyXCIpO1xyXG4gICAgICAgIHJldHVybiB7IGNvbnYwOiBjb252MCwgY29udjE6IGNvbnYxLCBjb252MjogY29udjIgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtcyhjaGFubmVsc0luLCBjaGFubmVsc091dCwgbWFwcGVkUHJlZml4LCBpc0ZpcnN0TGF5ZXIpIHtcclxuICAgICAgICBpZiAoaXNGaXJzdExheWVyID09PSB2b2lkIDApIHsgaXNGaXJzdExheWVyID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgX2EgPSBleHRyYWN0RGVuc2VCbG9jazNQYXJhbXMoY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXQsIG1hcHBlZFByZWZpeCwgaXNGaXJzdExheWVyKSwgY29udjAgPSBfYS5jb252MCwgY29udjEgPSBfYS5jb252MSwgY29udjIgPSBfYS5jb252MjtcclxuICAgICAgICB2YXIgY29udjMgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhjaGFubmVsc091dCwgY2hhbm5lbHNPdXQsIG1hcHBlZFByZWZpeCArIFwiL2NvbnYzXCIpO1xyXG4gICAgICAgIHJldHVybiB7IGNvbnYwOiBjb252MCwgY29udjE6IGNvbnYxLCBjb252MjogY29udjIsIGNvbnYzOiBjb252MyB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBleHRyYWN0RGVuc2VCbG9jazNQYXJhbXM6IGV4dHJhY3REZW5zZUJsb2NrM1BhcmFtcyxcclxuICAgICAgICBleHRyYWN0RGVuc2VCbG9jazRQYXJhbXM6IGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtc1xyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0b3JzRmFjdG9yeS5qcy5tYXAiLCJpbXBvcnQgeyBleHRyYWN0V2VpZ2h0RW50cnlGYWN0b3J5LCBsb2FkU2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBsb2FkQ29udlBhcmFtc0ZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24vbG9hZENvbnZQYXJhbXNGYWN0b3J5JztcclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRQYXJhbXNGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncykge1xyXG4gICAgdmFyIGV4dHJhY3RXZWlnaHRFbnRyeSA9IGV4dHJhY3RXZWlnaHRFbnRyeUZhY3Rvcnkod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIHZhciBleHRyYWN0Q29udlBhcmFtcyA9IGxvYWRDb252UGFyYW1zRmFjdG9yeShleHRyYWN0V2VpZ2h0RW50cnkpO1xyXG4gICAgdmFyIGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zID0gbG9hZFNlcGFyYWJsZUNvbnZQYXJhbXNGYWN0b3J5KGV4dHJhY3RXZWlnaHRFbnRyeSk7XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0RGVuc2VCbG9jazNQYXJhbXMocHJlZml4LCBpc0ZpcnN0TGF5ZXIpIHtcclxuICAgICAgICBpZiAoaXNGaXJzdExheWVyID09PSB2b2lkIDApIHsgaXNGaXJzdExheWVyID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgY29udjAgPSBpc0ZpcnN0TGF5ZXJcclxuICAgICAgICAgICAgPyBleHRyYWN0Q29udlBhcmFtcyhwcmVmaXggKyBcIi9jb252MFwiKVxyXG4gICAgICAgICAgICA6IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKHByZWZpeCArIFwiL2NvbnYwXCIpO1xyXG4gICAgICAgIHZhciBjb252MSA9IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKHByZWZpeCArIFwiL2NvbnYxXCIpO1xyXG4gICAgICAgIHZhciBjb252MiA9IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKHByZWZpeCArIFwiL2NvbnYyXCIpO1xyXG4gICAgICAgIHJldHVybiB7IGNvbnYwOiBjb252MCwgY29udjE6IGNvbnYxLCBjb252MjogY29udjIgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtcyhwcmVmaXgsIGlzRmlyc3RMYXllcikge1xyXG4gICAgICAgIGlmIChpc0ZpcnN0TGF5ZXIgPT09IHZvaWQgMCkgeyBpc0ZpcnN0TGF5ZXIgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBjb252MCA9IGlzRmlyc3RMYXllclxyXG4gICAgICAgICAgICA/IGV4dHJhY3RDb252UGFyYW1zKHByZWZpeCArIFwiL2NvbnYwXCIpXHJcbiAgICAgICAgICAgIDogZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMocHJlZml4ICsgXCIvY29udjBcIik7XHJcbiAgICAgICAgdmFyIGNvbnYxID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMocHJlZml4ICsgXCIvY29udjFcIik7XHJcbiAgICAgICAgdmFyIGNvbnYyID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMocHJlZml4ICsgXCIvY29udjJcIik7XHJcbiAgICAgICAgdmFyIGNvbnYzID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMocHJlZml4ICsgXCIvY29udjNcIik7XHJcbiAgICAgICAgcmV0dXJuIHsgY29udjA6IGNvbnYwLCBjb252MTogY29udjEsIGNvbnYyOiBjb252MiwgY29udjM6IGNvbnYzIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4dHJhY3REZW5zZUJsb2NrM1BhcmFtczogZXh0cmFjdERlbnNlQmxvY2szUGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtczogZXh0cmFjdERlbnNlQmxvY2s0UGFyYW1zXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRQYXJhbXNGYWN0b3J5LmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBGYWNlRmVhdHVyZUV4dHJhY3RvciB9IGZyb20gJy4uL2ZhY2VGZWF0dXJlRXh0cmFjdG9yL0ZhY2VGZWF0dXJlRXh0cmFjdG9yJztcclxuaW1wb3J0IHsgRmFjZUxhbmRtYXJrNjhOZXRCYXNlIH0gZnJvbSAnLi9GYWNlTGFuZG1hcms2OE5ldEJhc2UnO1xyXG52YXIgRmFjZUxhbmRtYXJrNjhOZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmFjZUxhbmRtYXJrNjhOZXQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGYWNlTGFuZG1hcms2OE5ldChmYWNlRmVhdHVyZUV4dHJhY3Rvcikge1xyXG4gICAgICAgIGlmIChmYWNlRmVhdHVyZUV4dHJhY3RvciA9PT0gdm9pZCAwKSB7IGZhY2VGZWF0dXJlRXh0cmFjdG9yID0gbmV3IEZhY2VGZWF0dXJlRXh0cmFjdG9yKCk7IH1cclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ0ZhY2VMYW5kbWFyazY4TmV0JywgZmFjZUZlYXR1cmVFeHRyYWN0b3IpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBGYWNlTGFuZG1hcms2OE5ldC5wcm90b3R5cGUuZ2V0RGVmYXVsdE1vZGVsTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ2ZhY2VfbGFuZG1hcmtfNjhfbW9kZWwnO1xyXG4gICAgfTtcclxuICAgIEZhY2VMYW5kbWFyazY4TmV0LnByb3RvdHlwZS5nZXRDbGFzc2lmaWVyQ2hhbm5lbHNJbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gMjU2O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGYWNlTGFuZG1hcms2OE5ldDtcclxufShGYWNlTGFuZG1hcms2OE5ldEJhc2UpKTtcclxuZXhwb3J0IHsgRmFjZUxhbmRtYXJrNjhOZXQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmFjZUxhbmRtYXJrNjhOZXQuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2V4dGVuZHMsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vY2xhc3Nlcyc7XHJcbmltcG9ydCB7IEZhY2VMYW5kbWFya3M2OCB9IGZyb20gJy4uL2NsYXNzZXMvRmFjZUxhbmRtYXJrczY4JztcclxuaW1wb3J0IHsgdG9OZXRJbnB1dCB9IGZyb20gJy4uL2RvbSc7XHJcbmltcG9ydCB7IEZhY2VQcm9jZXNzb3IgfSBmcm9tICcuLi9mYWNlUHJvY2Vzc29yL0ZhY2VQcm9jZXNzb3InO1xyXG5pbXBvcnQgeyBpc0V2ZW4gfSBmcm9tICcuLi91dGlscyc7XHJcbnZhciBGYWNlTGFuZG1hcms2OE5ldEJhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmFjZUxhbmRtYXJrNjhOZXRCYXNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRmFjZUxhbmRtYXJrNjhOZXRCYXNlKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEZhY2VMYW5kbWFyazY4TmV0QmFzZS5wcm90b3R5cGUucG9zdFByb2Nlc3MgPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dFNpemUsIG9yaWdpbmFsRGltZW5zaW9ucykge1xyXG4gICAgICAgIHZhciBpbnB1dERpbWVuc2lvbnMgPSBvcmlnaW5hbERpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBpbnB1dFNpemUgLyBNYXRoLm1heChoZWlnaHQsIHdpZHRoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCAqIHNjYWxlLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKiBzY2FsZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBpbnB1dERpbWVuc2lvbnMubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNyZWF0ZUludGVybGVhdmVkVGVuc29yID0gZnVuY3Rpb24gKGZpbGxYLCBmaWxsWSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmLnN0YWNrKFtcclxuICAgICAgICAgICAgICAgICAgICB0Zi5maWxsKFs2OF0sIGZpbGxYKSxcclxuICAgICAgICAgICAgICAgICAgICB0Zi5maWxsKFs2OF0sIGZpbGxZKVxyXG4gICAgICAgICAgICAgICAgXSwgMSkuYXMyRCgxLCAxMzYpLmFzMUQoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGdldFBhZGRpbmcgPSBmdW5jdGlvbiAoYmF0Y2hJZHgsIGNvbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSA9IGlucHV0RGltZW5zaW9uc1tiYXRjaElkeF0sIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb25kKHdpZHRoLCBoZWlnaHQpID8gTWF0aC5hYnMod2lkdGggLSBoZWlnaHQpIC8gMiA6IDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBnZXRQYWRkaW5nWCA9IGZ1bmN0aW9uIChiYXRjaElkeCkgeyByZXR1cm4gZ2V0UGFkZGluZyhiYXRjaElkeCwgZnVuY3Rpb24gKHcsIGgpIHsgcmV0dXJuIHcgPCBoOyB9KTsgfTtcclxuICAgICAgICAgICAgdmFyIGdldFBhZGRpbmdZID0gZnVuY3Rpb24gKGJhdGNoSWR4KSB7IHJldHVybiBnZXRQYWRkaW5nKGJhdGNoSWR4LCBmdW5jdGlvbiAodywgaCkgeyByZXR1cm4gaCA8IHc7IH0pOyB9O1xyXG4gICAgICAgICAgICB2YXIgbGFuZG1hcmtUZW5zb3JzID0gb3V0cHV0XHJcbiAgICAgICAgICAgICAgICAubXVsKHRmLmZpbGwoW2JhdGNoU2l6ZSwgMTM2XSwgaW5wdXRTaXplKSlcclxuICAgICAgICAgICAgICAgIC5zdWIodGYuc3RhY2soQXJyYXkuZnJvbShBcnJheShiYXRjaFNpemUpLCBmdW5jdGlvbiAoXywgYmF0Y2hJZHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnRlcmxlYXZlZFRlbnNvcihnZXRQYWRkaW5nWChiYXRjaElkeCksIGdldFBhZGRpbmdZKGJhdGNoSWR4KSk7XHJcbiAgICAgICAgICAgIH0pKSlcclxuICAgICAgICAgICAgICAgIC5kaXYodGYuc3RhY2soQXJyYXkuZnJvbShBcnJheShiYXRjaFNpemUpLCBmdW5jdGlvbiAoXywgYmF0Y2hJZHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnRlcmxlYXZlZFRlbnNvcihpbnB1dERpbWVuc2lvbnNbYmF0Y2hJZHhdLndpZHRoLCBpbnB1dERpbWVuc2lvbnNbYmF0Y2hJZHhdLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH0pKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5kbWFya1RlbnNvcnM7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUxhbmRtYXJrNjhOZXRCYXNlLnByb3RvdHlwZS5mb3J3YXJkSW5wdXQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG91dCA9IF90aGlzLnJ1bk5ldChpbnB1dCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5wb3N0UHJvY2VzcyhvdXQsIGlucHV0LmlucHV0U2l6ZSwgaW5wdXQuaW5wdXREaW1lbnNpb25zLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBfYVswXSwgd2lkdGggPSBfYVsxXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoeyBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRoIH0pO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUxhbmRtYXJrNjhOZXRCYXNlLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcy5mb3J3YXJkSW5wdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRvTmV0SW5wdXQoaW5wdXQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5hcHBseSh0aGlzLCBbX2Iuc2VudCgpXSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBGYWNlTGFuZG1hcms2OE5ldEJhc2UucHJvdG90eXBlLmRldGVjdExhbmRtYXJrcyA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5ldElucHV0LCBsYW5kbWFya1RlbnNvcnMsIGxhbmRtYXJrc0ZvckJhdGNoO1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0b05ldElucHV0KGlucHV0KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRJbnB1dCA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZG1hcmtUZW5zb3JzID0gdGYudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiB0Zi51bnN0YWNrKF90aGlzLmZvcndhcmRJbnB1dChuZXRJbnB1dCkpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwobGFuZG1hcmtUZW5zb3JzLm1hcChmdW5jdGlvbiAobGFuZG1hcmtUZW5zb3IsIGJhdGNoSWR4KSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmRtYXJrc0FycmF5LCBfYSwgX2IsIHhDb29yZHMsIHlDb29yZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSBBcnJheSkuZnJvbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsYW5kbWFya1RlbnNvci5kYXRhKCldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmRtYXJrc0FycmF5ID0gX2IuYXBwbHkoX2EsIFtfYy5zZW50KCldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Q29vcmRzID0gbGFuZG1hcmtzQXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiBpc0V2ZW4oaSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlDb29yZHMgPSBsYW5kbWFya3NBcnJheS5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuICFpc0V2ZW4oaSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgRmFjZUxhbmRtYXJrczY4KEFycmF5KDY4KS5maWxsKDApLm1hcChmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gbmV3IFBvaW50KHhDb29yZHNbaV0sIHlDb29yZHNbaV0pOyB9KSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXRJbnB1dC5nZXRJbnB1dEhlaWdodChiYXRjaElkeCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbmV0SW5wdXQuZ2V0SW5wdXRXaWR0aChiYXRjaElkeCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0pKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5kbWFya3NGb3JCYXRjaCA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZG1hcmtUZW5zb3JzLmZvckVhY2goZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuZGlzcG9zZSgpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldElucHV0LmlzQmF0Y2hJbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbGFuZG1hcmtzRm9yQmF0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxhbmRtYXJrc0ZvckJhdGNoWzBdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZUxhbmRtYXJrNjhOZXRCYXNlLnByb3RvdHlwZS5nZXRDbGFzc2lmaWVyQ2hhbm5lbHNPdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIDEzNjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmFjZUxhbmRtYXJrNjhOZXRCYXNlO1xyXG59KEZhY2VQcm9jZXNzb3IpKTtcclxuZXhwb3J0IHsgRmFjZUxhbmRtYXJrNjhOZXRCYXNlIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZhY2VMYW5kbWFyazY4TmV0QmFzZS5qcy5tYXAiLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgVGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yIH0gZnJvbSAnLi4vZmFjZUZlYXR1cmVFeHRyYWN0b3IvVGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yJztcclxuaW1wb3J0IHsgRmFjZUxhbmRtYXJrNjhOZXRCYXNlIH0gZnJvbSAnLi9GYWNlTGFuZG1hcms2OE5ldEJhc2UnO1xyXG52YXIgRmFjZUxhbmRtYXJrNjhUaW55TmV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEZhY2VMYW5kbWFyazY4VGlueU5ldCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZhY2VMYW5kbWFyazY4VGlueU5ldChmYWNlRmVhdHVyZUV4dHJhY3Rvcikge1xyXG4gICAgICAgIGlmIChmYWNlRmVhdHVyZUV4dHJhY3RvciA9PT0gdm9pZCAwKSB7IGZhY2VGZWF0dXJlRXh0cmFjdG9yID0gbmV3IFRpbnlGYWNlRmVhdHVyZUV4dHJhY3RvcigpOyB9XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdGYWNlTGFuZG1hcms2OFRpbnlOZXQnLCBmYWNlRmVhdHVyZUV4dHJhY3RvcikgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEZhY2VMYW5kbWFyazY4VGlueU5ldC5wcm90b3R5cGUuZ2V0RGVmYXVsdE1vZGVsTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ2ZhY2VfbGFuZG1hcmtfNjhfdGlueV9tb2RlbCc7XHJcbiAgICB9O1xyXG4gICAgRmFjZUxhbmRtYXJrNjhUaW55TmV0LnByb3RvdHlwZS5nZXRDbGFzc2lmaWVyQ2hhbm5lbHNJbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gMTI4O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGYWNlTGFuZG1hcms2OFRpbnlOZXQ7XHJcbn0oRmFjZUxhbmRtYXJrNjhOZXRCYXNlKSk7XHJcbmV4cG9ydCB7IEZhY2VMYW5kbWFyazY4VGlueU5ldCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYWNlTGFuZG1hcms2OFRpbnlOZXQuanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IEZhY2VMYW5kbWFyazY4TmV0IH0gZnJvbSAnLi9GYWNlTGFuZG1hcms2OE5ldCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vRmFjZUxhbmRtYXJrNjhOZXQnO1xyXG5leHBvcnQgKiBmcm9tICcuL0ZhY2VMYW5kbWFyazY4VGlueU5ldCc7XHJcbnZhciBGYWNlTGFuZG1hcmtOZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmFjZUxhbmRtYXJrTmV0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRmFjZUxhbmRtYXJrTmV0KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBGYWNlTGFuZG1hcmtOZXQ7XHJcbn0oRmFjZUxhbmRtYXJrNjhOZXQpKTtcclxuZXhwb3J0IHsgRmFjZUxhbmRtYXJrTmV0IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBmdWxseUNvbm5lY3RlZExheWVyIH0gZnJvbSAnLi4vY29tbW9uL2Z1bGx5Q29ubmVjdGVkTGF5ZXInO1xyXG5pbXBvcnQgeyBOZXRJbnB1dCB9IGZyb20gJy4uL2RvbSc7XHJcbmltcG9ydCB7IE5ldXJhbE5ldHdvcmsgfSBmcm9tICcuLi9OZXVyYWxOZXR3b3JrJztcclxuaW1wb3J0IHsgZXh0cmFjdFBhcmFtcyB9IGZyb20gJy4vZXh0cmFjdFBhcmFtcyc7XHJcbmltcG9ydCB7IGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwIH0gZnJvbSAnLi9leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCc7XHJcbmltcG9ydCB7IHNlcGVyYXRlV2VpZ2h0TWFwcyB9IGZyb20gJy4vdXRpbCc7XHJcbnZhciBGYWNlUHJvY2Vzc29yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEZhY2VQcm9jZXNzb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGYWNlUHJvY2Vzc29yKF9uYW1lLCBmYWNlRmVhdHVyZUV4dHJhY3Rvcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9uYW1lKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl9mYWNlRmVhdHVyZUV4dHJhY3RvciA9IGZhY2VGZWF0dXJlRXh0cmFjdG9yO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWNlUHJvY2Vzc29yLnByb3RvdHlwZSwgXCJmYWNlRmVhdHVyZUV4dHJhY3RvclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYWNlRmVhdHVyZUV4dHJhY3RvcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEZhY2VQcm9jZXNzb3IucHJvdG90eXBlLnJ1bk5ldCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9uYW1lICsgXCIgLSBsb2FkIG1vZGVsIGJlZm9yZSBpbmZlcmVuY2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJvdHRsZW5lY2tGZWF0dXJlcyA9IGlucHV0IGluc3RhbmNlb2YgTmV0SW5wdXRcclxuICAgICAgICAgICAgICAgID8gX3RoaXMuZmFjZUZlYXR1cmVFeHRyYWN0b3IuZm9yd2FyZElucHV0KGlucHV0KVxyXG4gICAgICAgICAgICAgICAgOiBpbnB1dDtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bGx5Q29ubmVjdGVkTGF5ZXIoYm90dGxlbmVja0ZlYXR1cmVzLmFzMkQoYm90dGxlbmVja0ZlYXR1cmVzLnNoYXBlWzBdLCAtMSksIHBhcmFtcy5mYyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZVByb2Nlc3Nvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICh0aHJvd09uUmVkaXNwb3NlKSB7XHJcbiAgICAgICAgaWYgKHRocm93T25SZWRpc3Bvc2UgPT09IHZvaWQgMCkgeyB0aHJvd09uUmVkaXNwb3NlID0gdHJ1ZTsgfVxyXG4gICAgICAgIHRoaXMuZmFjZUZlYXR1cmVFeHRyYWN0b3IuZGlzcG9zZSh0aHJvd09uUmVkaXNwb3NlKTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzLCB0aHJvd09uUmVkaXNwb3NlKTtcclxuICAgIH07XHJcbiAgICBGYWNlUHJvY2Vzc29yLnByb3RvdHlwZS5sb2FkQ2xhc3NpZmllclBhcmFtcyA9IGZ1bmN0aW9uICh3ZWlnaHRzKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5leHRyYWN0Q2xhc3NpZmllclBhcmFtcyh3ZWlnaHRzKSwgcGFyYW1zID0gX2EucGFyYW1zLCBwYXJhbU1hcHBpbmdzID0gX2EucGFyYW1NYXBwaW5ncztcclxuICAgICAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICAgICAgdGhpcy5fcGFyYW1NYXBwaW5ncyA9IHBhcmFtTWFwcGluZ3M7XHJcbiAgICB9O1xyXG4gICAgRmFjZVByb2Nlc3Nvci5wcm90b3R5cGUuZXh0cmFjdENsYXNzaWZpZXJQYXJhbXMgPSBmdW5jdGlvbiAod2VpZ2h0cykge1xyXG4gICAgICAgIHJldHVybiBleHRyYWN0UGFyYW1zKHdlaWdodHMsIHRoaXMuZ2V0Q2xhc3NpZmllckNoYW5uZWxzSW4oKSwgdGhpcy5nZXRDbGFzc2lmaWVyQ2hhbm5lbHNPdXQoKSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZVByb2Nlc3Nvci5wcm90b3R5cGUuZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAgPSBmdW5jdGlvbiAod2VpZ2h0TWFwKSB7XHJcbiAgICAgICAgdmFyIF9hID0gc2VwZXJhdGVXZWlnaHRNYXBzKHdlaWdodE1hcCksIGZlYXR1cmVFeHRyYWN0b3JNYXAgPSBfYS5mZWF0dXJlRXh0cmFjdG9yTWFwLCBjbGFzc2lmaWVyTWFwID0gX2EuY2xhc3NpZmllck1hcDtcclxuICAgICAgICB0aGlzLmZhY2VGZWF0dXJlRXh0cmFjdG9yLmxvYWRGcm9tV2VpZ2h0TWFwKGZlYXR1cmVFeHRyYWN0b3JNYXApO1xyXG4gICAgICAgIHJldHVybiBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcChjbGFzc2lmaWVyTWFwKTtcclxuICAgIH07XHJcbiAgICBGYWNlUHJvY2Vzc29yLnByb3RvdHlwZS5leHRyYWN0UGFyYW1zID0gZnVuY3Rpb24gKHdlaWdodHMpIHtcclxuICAgICAgICB2YXIgY0luID0gdGhpcy5nZXRDbGFzc2lmaWVyQ2hhbm5lbHNJbigpO1xyXG4gICAgICAgIHZhciBjT3V0ID0gdGhpcy5nZXRDbGFzc2lmaWVyQ2hhbm5lbHNPdXQoKTtcclxuICAgICAgICB2YXIgY2xhc3NpZmllcldlaWdodFNpemUgPSAoY091dCAqIGNJbikgKyBjT3V0O1xyXG4gICAgICAgIHZhciBmZWF0dXJlRXh0cmFjdG9yV2VpZ2h0cyA9IHdlaWdodHMuc2xpY2UoMCwgd2VpZ2h0cy5sZW5ndGggLSBjbGFzc2lmaWVyV2VpZ2h0U2l6ZSk7XHJcbiAgICAgICAgdmFyIGNsYXNzaWZpZXJXZWlnaHRzID0gd2VpZ2h0cy5zbGljZSh3ZWlnaHRzLmxlbmd0aCAtIGNsYXNzaWZpZXJXZWlnaHRTaXplKTtcclxuICAgICAgICB0aGlzLmZhY2VGZWF0dXJlRXh0cmFjdG9yLmV4dHJhY3RXZWlnaHRzKGZlYXR1cmVFeHRyYWN0b3JXZWlnaHRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0Q2xhc3NpZmllclBhcmFtcyhjbGFzc2lmaWVyV2VpZ2h0cyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZhY2VQcm9jZXNzb3I7XHJcbn0oTmV1cmFsTmV0d29yaykpO1xyXG5leHBvcnQgeyBGYWNlUHJvY2Vzc29yIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZhY2VQcm9jZXNzb3IuanMubWFwIiwiaW1wb3J0IHsgZXh0cmFjdEZDUGFyYW1zRmFjdG9yeSwgZXh0cmFjdFdlaWdodHNGYWN0b3J5IH0gZnJvbSAnLi4vY29tbW9uJztcclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQYXJhbXMod2VpZ2h0cywgY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXQpIHtcclxuICAgIHZhciBwYXJhbU1hcHBpbmdzID0gW107XHJcbiAgICB2YXIgX2EgPSBleHRyYWN0V2VpZ2h0c0ZhY3Rvcnkod2VpZ2h0cyksIGV4dHJhY3RXZWlnaHRzID0gX2EuZXh0cmFjdFdlaWdodHMsIGdldFJlbWFpbmluZ1dlaWdodHMgPSBfYS5nZXRSZW1haW5pbmdXZWlnaHRzO1xyXG4gICAgdmFyIGV4dHJhY3RGQ1BhcmFtcyA9IGV4dHJhY3RGQ1BhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgdmFyIGZjID0gZXh0cmFjdEZDUGFyYW1zKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCAnZmMnKTtcclxuICAgIGlmIChnZXRSZW1haW5pbmdXZWlnaHRzKCkubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2VpZ2h0cyByZW1haW5nIGFmdGVyIGV4dHJhY3Q6IFwiICsgZ2V0UmVtYWluaW5nV2VpZ2h0cygpLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHBhcmFtTWFwcGluZ3M6IHBhcmFtTWFwcGluZ3MsXHJcbiAgICAgICAgcGFyYW1zOiB7IGZjOiBmYyB9XHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RQYXJhbXMuanMubWFwIiwiaW1wb3J0IHsgZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMsIGV4dHJhY3RXZWlnaHRFbnRyeUZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24nO1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAod2VpZ2h0TWFwKSB7XHJcbiAgICB2YXIgcGFyYW1NYXBwaW5ncyA9IFtdO1xyXG4gICAgdmFyIGV4dHJhY3RXZWlnaHRFbnRyeSA9IGV4dHJhY3RXZWlnaHRFbnRyeUZhY3Rvcnkod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RGY1BhcmFtcyhwcmVmaXgpIHtcclxuICAgICAgICB2YXIgd2VpZ2h0cyA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi93ZWlnaHRzXCIsIDIpO1xyXG4gICAgICAgIHZhciBiaWFzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL2JpYXNcIiwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHsgd2VpZ2h0czogd2VpZ2h0cywgYmlhczogYmlhcyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIHBhcmFtcyA9IHtcclxuICAgICAgICBmYzogZXh0cmFjdEZjUGFyYW1zKCdmYycpXHJcbiAgICB9O1xyXG4gICAgZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIHJldHVybiB7IHBhcmFtczogcGFyYW1zLCBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIHNlcGVyYXRlV2VpZ2h0TWFwcyh3ZWlnaHRNYXApIHtcclxuICAgIHZhciBmZWF0dXJlRXh0cmFjdG9yTWFwID0ge307XHJcbiAgICB2YXIgY2xhc3NpZmllck1hcCA9IHt9O1xyXG4gICAgT2JqZWN0LmtleXMod2VpZ2h0TWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgbWFwID0ga2V5LnN0YXJ0c1dpdGgoJ2ZjJykgPyBjbGFzc2lmaWVyTWFwIDogZmVhdHVyZUV4dHJhY3Rvck1hcDtcclxuICAgICAgICBtYXBba2V5XSA9IHdlaWdodE1hcFtrZXldO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4geyBmZWF0dXJlRXh0cmFjdG9yTWFwOiBmZWF0dXJlRXh0cmFjdG9yTWFwLCBjbGFzc2lmaWVyTWFwOiBjbGFzc2lmaWVyTWFwIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZXh0ZW5kcywgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgdG9OZXRJbnB1dCB9IGZyb20gJy4uL2RvbSc7XHJcbmltcG9ydCB7IE5ldXJhbE5ldHdvcmsgfSBmcm9tICcuLi9OZXVyYWxOZXR3b3JrJztcclxuaW1wb3J0IHsgbm9ybWFsaXplIH0gZnJvbSAnLi4vb3BzJztcclxuaW1wb3J0IHsgY29udkRvd24gfSBmcm9tICcuL2NvbnZMYXllcic7XHJcbmltcG9ydCB7IGV4dHJhY3RQYXJhbXMgfSBmcm9tICcuL2V4dHJhY3RQYXJhbXMnO1xyXG5pbXBvcnQgeyBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCB9IGZyb20gJy4vZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAnO1xyXG5pbXBvcnQgeyByZXNpZHVhbCwgcmVzaWR1YWxEb3duIH0gZnJvbSAnLi9yZXNpZHVhbExheWVyJztcclxudmFyIEZhY2VSZWNvZ25pdGlvbk5ldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGYWNlUmVjb2duaXRpb25OZXQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGYWNlUmVjb2duaXRpb25OZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdGYWNlUmVjb2duaXRpb25OZXQnKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRmFjZVJlY29nbml0aW9uTmV0LnByb3RvdHlwZS5mb3J3YXJkSW5wdXQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWNlUmVjb2duaXRpb25OZXQgLSBsb2FkIG1vZGVsIGJlZm9yZSBpbmZlcmVuY2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYmF0Y2hUZW5zb3IgPSBpbnB1dC50b0JhdGNoVGVuc29yKDE1MCwgdHJ1ZSkudG9GbG9hdCgpO1xyXG4gICAgICAgICAgICB2YXIgbWVhblJnYiA9IFsxMjIuNzgyLCAxMTcuMDAxLCAxMDQuMjk4XTtcclxuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemUoYmF0Y2hUZW5zb3IsIG1lYW5SZ2IpLmRpdih0Zi5zY2FsYXIoMjU2KSk7XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSBjb252RG93bihub3JtYWxpemVkLCBwYXJhbXMuY29udjMyX2Rvd24pO1xyXG4gICAgICAgICAgICBvdXQgPSB0Zi5tYXhQb29sKG91dCwgMywgMiwgJ3ZhbGlkJyk7XHJcbiAgICAgICAgICAgIG91dCA9IHJlc2lkdWFsKG91dCwgcGFyYW1zLmNvbnYzMl8xKTtcclxuICAgICAgICAgICAgb3V0ID0gcmVzaWR1YWwob3V0LCBwYXJhbXMuY29udjMyXzIpO1xyXG4gICAgICAgICAgICBvdXQgPSByZXNpZHVhbChvdXQsIHBhcmFtcy5jb252MzJfMyk7XHJcbiAgICAgICAgICAgIG91dCA9IHJlc2lkdWFsRG93bihvdXQsIHBhcmFtcy5jb252NjRfZG93bik7XHJcbiAgICAgICAgICAgIG91dCA9IHJlc2lkdWFsKG91dCwgcGFyYW1zLmNvbnY2NF8xKTtcclxuICAgICAgICAgICAgb3V0ID0gcmVzaWR1YWwob3V0LCBwYXJhbXMuY29udjY0XzIpO1xyXG4gICAgICAgICAgICBvdXQgPSByZXNpZHVhbChvdXQsIHBhcmFtcy5jb252NjRfMyk7XHJcbiAgICAgICAgICAgIG91dCA9IHJlc2lkdWFsRG93bihvdXQsIHBhcmFtcy5jb252MTI4X2Rvd24pO1xyXG4gICAgICAgICAgICBvdXQgPSByZXNpZHVhbChvdXQsIHBhcmFtcy5jb252MTI4XzEpO1xyXG4gICAgICAgICAgICBvdXQgPSByZXNpZHVhbChvdXQsIHBhcmFtcy5jb252MTI4XzIpO1xyXG4gICAgICAgICAgICBvdXQgPSByZXNpZHVhbERvd24ob3V0LCBwYXJhbXMuY29udjI1Nl9kb3duKTtcclxuICAgICAgICAgICAgb3V0ID0gcmVzaWR1YWwob3V0LCBwYXJhbXMuY29udjI1Nl8xKTtcclxuICAgICAgICAgICAgb3V0ID0gcmVzaWR1YWwob3V0LCBwYXJhbXMuY29udjI1Nl8yKTtcclxuICAgICAgICAgICAgb3V0ID0gcmVzaWR1YWxEb3duKG91dCwgcGFyYW1zLmNvbnYyNTZfZG93bl9vdXQpO1xyXG4gICAgICAgICAgICB2YXIgZ2xvYmFsQXZnID0gb3V0Lm1lYW4oWzEsIDJdKTtcclxuICAgICAgICAgICAgdmFyIGZ1bGx5Q29ubmVjdGVkID0gdGYubWF0TXVsKGdsb2JhbEF2ZywgcGFyYW1zLmZjKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bGx5Q29ubmVjdGVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEZhY2VSZWNvZ25pdGlvbk5ldC5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMuZm9yd2FyZElucHV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0b05ldElucHV0KGlucHV0KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2EuYXBwbHkodGhpcywgW19iLnNlbnQoKV0pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZVJlY29nbml0aW9uTmV0LnByb3RvdHlwZS5jb21wdXRlRmFjZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXRJbnB1dCwgZmFjZURlc2NyaXB0b3JUZW5zb3JzLCBmYWNlRGVzY3JpcHRvcnNGb3JCYXRjaDtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdG9OZXRJbnB1dChpbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0SW5wdXQgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VEZXNjcmlwdG9yVGVuc29ycyA9IHRmLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGYudW5zdGFjayhfdGhpcy5mb3J3YXJkSW5wdXQobmV0SW5wdXQpKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKGZhY2VEZXNjcmlwdG9yVGVuc29ycy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuZGF0YSgpOyB9KSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZURlc2NyaXB0b3JzRm9yQmF0Y2ggPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VEZXNjcmlwdG9yVGVuc29ycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmRpc3Bvc2UoKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXRJbnB1dC5pc0JhdGNoSW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGZhY2VEZXNjcmlwdG9yc0ZvckJhdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWNlRGVzY3JpcHRvcnNGb3JCYXRjaFswXV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEZhY2VSZWNvZ25pdGlvbk5ldC5wcm90b3R5cGUuZ2V0RGVmYXVsdE1vZGVsTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ2ZhY2VfcmVjb2duaXRpb25fbW9kZWwnO1xyXG4gICAgfTtcclxuICAgIEZhY2VSZWNvZ25pdGlvbk5ldC5wcm90b3R5cGUuZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAgPSBmdW5jdGlvbiAod2VpZ2h0TWFwKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwKHdlaWdodE1hcCk7XHJcbiAgICB9O1xyXG4gICAgRmFjZVJlY29nbml0aW9uTmV0LnByb3RvdHlwZS5leHRyYWN0UGFyYW1zID0gZnVuY3Rpb24gKHdlaWdodHMpIHtcclxuICAgICAgICByZXR1cm4gZXh0cmFjdFBhcmFtcyh3ZWlnaHRzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmFjZVJlY29nbml0aW9uTmV0O1xyXG59KE5ldXJhbE5ldHdvcmspKTtcclxuZXhwb3J0IHsgRmFjZVJlY29nbml0aW9uTmV0IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZhY2VSZWNvZ25pdGlvbk5ldC5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBzY2FsZSB9IGZyb20gJy4vc2NhbGVMYXllcic7XHJcbmZ1bmN0aW9uIGNvbnZMYXllcih4LCBwYXJhbXMsIHN0cmlkZXMsIHdpdGhSZWx1LCBwYWRkaW5nKSB7XHJcbiAgICBpZiAocGFkZGluZyA9PT0gdm9pZCAwKSB7IHBhZGRpbmcgPSAnc2FtZSc7IH1cclxuICAgIHZhciBfYSA9IHBhcmFtcy5jb252LCBmaWx0ZXJzID0gX2EuZmlsdGVycywgYmlhcyA9IF9hLmJpYXM7XHJcbiAgICB2YXIgb3V0ID0gdGYuY29udjJkKHgsIGZpbHRlcnMsIHN0cmlkZXMsIHBhZGRpbmcpO1xyXG4gICAgb3V0ID0gdGYuYWRkKG91dCwgYmlhcyk7XHJcbiAgICBvdXQgPSBzY2FsZShvdXQsIHBhcmFtcy5zY2FsZSk7XHJcbiAgICByZXR1cm4gd2l0aFJlbHUgPyB0Zi5yZWx1KG91dCkgOiBvdXQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnYoeCwgcGFyYW1zKSB7XHJcbiAgICByZXR1cm4gY29udkxheWVyKHgsIHBhcmFtcywgWzEsIDFdLCB0cnVlKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29udk5vUmVsdSh4LCBwYXJhbXMpIHtcclxuICAgIHJldHVybiBjb252TGF5ZXIoeCwgcGFyYW1zLCBbMSwgMV0sIGZhbHNlKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29udkRvd24oeCwgcGFyYW1zKSB7XHJcbiAgICByZXR1cm4gY29udkxheWVyKHgsIHBhcmFtcywgWzIsIDJdLCB0cnVlLCAndmFsaWQnKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252TGF5ZXIuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgZXh0cmFjdFdlaWdodHNGYWN0b3J5IH0gZnJvbSAnLi4vY29tbW9uJztcclxuaW1wb3J0IHsgaXNGbG9hdCB9IGZyb20gJy4uL3V0aWxzJztcclxuZnVuY3Rpb24gZXh0cmFjdG9yc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpIHtcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RGaWx0ZXJWYWx1ZXMobnVtRmlsdGVyVmFsdWVzLCBudW1GaWx0ZXJzLCBmaWx0ZXJTaXplKSB7XHJcbiAgICAgICAgdmFyIHdlaWdodHMgPSBleHRyYWN0V2VpZ2h0cyhudW1GaWx0ZXJWYWx1ZXMpO1xyXG4gICAgICAgIHZhciBkZXB0aCA9IHdlaWdodHMubGVuZ3RoIC8gKG51bUZpbHRlcnMgKiBmaWx0ZXJTaXplICogZmlsdGVyU2l6ZSk7XHJcbiAgICAgICAgaWYgKGlzRmxvYXQoZGVwdGgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRlcHRoIGhhcyB0byBiZSBhbiBpbnRlZ2VyOiBcIiArIGRlcHRoICsgXCIsIHdlaWdodHMubGVuZ3RoOiBcIiArIHdlaWdodHMubGVuZ3RoICsgXCIsIG51bUZpbHRlcnM6IFwiICsgbnVtRmlsdGVycyArIFwiLCBmaWx0ZXJTaXplOiBcIiArIGZpbHRlclNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiB0Zi50cmFuc3Bvc2UodGYudGVuc29yNGQod2VpZ2h0cywgW251bUZpbHRlcnMsIGRlcHRoLCBmaWx0ZXJTaXplLCBmaWx0ZXJTaXplXSksIFsyLCAzLCAxLCAwXSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdENvbnZQYXJhbXMobnVtRmlsdGVyVmFsdWVzLCBudW1GaWx0ZXJzLCBmaWx0ZXJTaXplLCBtYXBwZWRQcmVmaXgpIHtcclxuICAgICAgICB2YXIgZmlsdGVycyA9IGV4dHJhY3RGaWx0ZXJWYWx1ZXMobnVtRmlsdGVyVmFsdWVzLCBudW1GaWx0ZXJzLCBmaWx0ZXJTaXplKTtcclxuICAgICAgICB2YXIgYmlhcyA9IHRmLnRlbnNvcjFkKGV4dHJhY3RXZWlnaHRzKG51bUZpbHRlcnMpKTtcclxuICAgICAgICBwYXJhbU1hcHBpbmdzLnB1c2goeyBwYXJhbVBhdGg6IG1hcHBlZFByZWZpeCArIFwiL2ZpbHRlcnNcIiB9LCB7IHBhcmFtUGF0aDogbWFwcGVkUHJlZml4ICsgXCIvYmlhc1wiIH0pO1xyXG4gICAgICAgIHJldHVybiB7IGZpbHRlcnM6IGZpbHRlcnMsIGJpYXM6IGJpYXMgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RTY2FsZUxheWVyUGFyYW1zKG51bVdlaWdodHMsIG1hcHBlZFByZWZpeCkge1xyXG4gICAgICAgIHZhciB3ZWlnaHRzID0gdGYudGVuc29yMWQoZXh0cmFjdFdlaWdodHMobnVtV2VpZ2h0cykpO1xyXG4gICAgICAgIHZhciBiaWFzZXMgPSB0Zi50ZW5zb3IxZChleHRyYWN0V2VpZ2h0cyhudW1XZWlnaHRzKSk7XHJcbiAgICAgICAgcGFyYW1NYXBwaW5ncy5wdXNoKHsgcGFyYW1QYXRoOiBtYXBwZWRQcmVmaXggKyBcIi93ZWlnaHRzXCIgfSwgeyBwYXJhbVBhdGg6IG1hcHBlZFByZWZpeCArIFwiL2JpYXNlc1wiIH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHdlaWdodHM6IHdlaWdodHMsXHJcbiAgICAgICAgICAgIGJpYXNlczogYmlhc2VzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RDb252TGF5ZXJQYXJhbXMobnVtRmlsdGVyVmFsdWVzLCBudW1GaWx0ZXJzLCBmaWx0ZXJTaXplLCBtYXBwZWRQcmVmaXgpIHtcclxuICAgICAgICB2YXIgY29udiA9IGV4dHJhY3RDb252UGFyYW1zKG51bUZpbHRlclZhbHVlcywgbnVtRmlsdGVycywgZmlsdGVyU2l6ZSwgbWFwcGVkUHJlZml4ICsgXCIvY29udlwiKTtcclxuICAgICAgICB2YXIgc2NhbGUgPSBleHRyYWN0U2NhbGVMYXllclBhcmFtcyhudW1GaWx0ZXJzLCBtYXBwZWRQcmVmaXggKyBcIi9zY2FsZVwiKTtcclxuICAgICAgICByZXR1cm4geyBjb252OiBjb252LCBzY2FsZTogc2NhbGUgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKG51bUZpbHRlclZhbHVlcywgbnVtRmlsdGVycywgZmlsdGVyU2l6ZSwgbWFwcGVkUHJlZml4LCBpc0Rvd24pIHtcclxuICAgICAgICBpZiAoaXNEb3duID09PSB2b2lkIDApIHsgaXNEb3duID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgY29udjEgPSBleHRyYWN0Q29udkxheWVyUGFyYW1zKChpc0Rvd24gPyAwLjUgOiAxKSAqIG51bUZpbHRlclZhbHVlcywgbnVtRmlsdGVycywgZmlsdGVyU2l6ZSwgbWFwcGVkUHJlZml4ICsgXCIvY29udjFcIik7XHJcbiAgICAgICAgdmFyIGNvbnYyID0gZXh0cmFjdENvbnZMYXllclBhcmFtcyhudW1GaWx0ZXJWYWx1ZXMsIG51bUZpbHRlcnMsIGZpbHRlclNpemUsIG1hcHBlZFByZWZpeCArIFwiL2NvbnYyXCIpO1xyXG4gICAgICAgIHJldHVybiB7IGNvbnYxOiBjb252MSwgY29udjI6IGNvbnYyIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4dHJhY3RDb252TGF5ZXJQYXJhbXM6IGV4dHJhY3RDb252TGF5ZXJQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXM6IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGFyYW1zKHdlaWdodHMpIHtcclxuICAgIHZhciBfYSA9IGV4dHJhY3RXZWlnaHRzRmFjdG9yeSh3ZWlnaHRzKSwgZXh0cmFjdFdlaWdodHMgPSBfYS5leHRyYWN0V2VpZ2h0cywgZ2V0UmVtYWluaW5nV2VpZ2h0cyA9IF9hLmdldFJlbWFpbmluZ1dlaWdodHM7XHJcbiAgICB2YXIgcGFyYW1NYXBwaW5ncyA9IFtdO1xyXG4gICAgdmFyIF9iID0gZXh0cmFjdG9yc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpLCBleHRyYWN0Q29udkxheWVyUGFyYW1zID0gX2IuZXh0cmFjdENvbnZMYXllclBhcmFtcywgZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMgPSBfYi5leHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcztcclxuICAgIHZhciBjb252MzJfZG93biA9IGV4dHJhY3RDb252TGF5ZXJQYXJhbXMoNDcwNCwgMzIsIDcsICdjb252MzJfZG93bicpO1xyXG4gICAgdmFyIGNvbnYzMl8xID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoOTIxNiwgMzIsIDMsICdjb252MzJfMScpO1xyXG4gICAgdmFyIGNvbnYzMl8yID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoOTIxNiwgMzIsIDMsICdjb252MzJfMicpO1xyXG4gICAgdmFyIGNvbnYzMl8zID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoOTIxNiwgMzIsIDMsICdjb252MzJfMycpO1xyXG4gICAgdmFyIGNvbnY2NF9kb3duID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoMzY4NjQsIDY0LCAzLCAnY29udjY0X2Rvd24nLCB0cnVlKTtcclxuICAgIHZhciBjb252NjRfMSA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKDM2ODY0LCA2NCwgMywgJ2NvbnY2NF8xJyk7XHJcbiAgICB2YXIgY29udjY0XzIgPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcygzNjg2NCwgNjQsIDMsICdjb252NjRfMicpO1xyXG4gICAgdmFyIGNvbnY2NF8zID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoMzY4NjQsIDY0LCAzLCAnY29udjY0XzMnKTtcclxuICAgIHZhciBjb252MTI4X2Rvd24gPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcygxNDc0NTYsIDEyOCwgMywgJ2NvbnYxMjhfZG93bicsIHRydWUpO1xyXG4gICAgdmFyIGNvbnYxMjhfMSA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKDE0NzQ1NiwgMTI4LCAzLCAnY29udjEyOF8xJyk7XHJcbiAgICB2YXIgY29udjEyOF8yID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoMTQ3NDU2LCAxMjgsIDMsICdjb252MTI4XzInKTtcclxuICAgIHZhciBjb252MjU2X2Rvd24gPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcyg1ODk4MjQsIDI1NiwgMywgJ2NvbnYyNTZfZG93bicsIHRydWUpO1xyXG4gICAgdmFyIGNvbnYyNTZfMSA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKDU4OTgyNCwgMjU2LCAzLCAnY29udjI1Nl8xJyk7XHJcbiAgICB2YXIgY29udjI1Nl8yID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoNTg5ODI0LCAyNTYsIDMsICdjb252MjU2XzInKTtcclxuICAgIHZhciBjb252MjU2X2Rvd25fb3V0ID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoNTg5ODI0LCAyNTYsIDMsICdjb252MjU2X2Rvd25fb3V0Jyk7XHJcbiAgICB2YXIgZmMgPSB0Zi50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRmLnRyYW5zcG9zZSh0Zi50ZW5zb3IyZChleHRyYWN0V2VpZ2h0cygyNTYgKiAxMjgpLCBbMTI4LCAyNTZdKSwgWzEsIDBdKTsgfSk7XHJcbiAgICBwYXJhbU1hcHBpbmdzLnB1c2goeyBwYXJhbVBhdGg6IFwiZmNcIiB9KTtcclxuICAgIGlmIChnZXRSZW1haW5pbmdXZWlnaHRzKCkubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2VpZ2h0cyByZW1haW5nIGFmdGVyIGV4dHJhY3Q6IFwiICsgZ2V0UmVtYWluaW5nV2VpZ2h0cygpLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICB2YXIgcGFyYW1zID0ge1xyXG4gICAgICAgIGNvbnYzMl9kb3duOiBjb252MzJfZG93bixcclxuICAgICAgICBjb252MzJfMTogY29udjMyXzEsXHJcbiAgICAgICAgY29udjMyXzI6IGNvbnYzMl8yLFxyXG4gICAgICAgIGNvbnYzMl8zOiBjb252MzJfMyxcclxuICAgICAgICBjb252NjRfZG93bjogY29udjY0X2Rvd24sXHJcbiAgICAgICAgY29udjY0XzE6IGNvbnY2NF8xLFxyXG4gICAgICAgIGNvbnY2NF8yOiBjb252NjRfMixcclxuICAgICAgICBjb252NjRfMzogY29udjY0XzMsXHJcbiAgICAgICAgY29udjEyOF9kb3duOiBjb252MTI4X2Rvd24sXHJcbiAgICAgICAgY29udjEyOF8xOiBjb252MTI4XzEsXHJcbiAgICAgICAgY29udjEyOF8yOiBjb252MTI4XzIsXHJcbiAgICAgICAgY29udjI1Nl9kb3duOiBjb252MjU2X2Rvd24sXHJcbiAgICAgICAgY29udjI1Nl8xOiBjb252MjU2XzEsXHJcbiAgICAgICAgY29udjI1Nl8yOiBjb252MjU2XzIsXHJcbiAgICAgICAgY29udjI1Nl9kb3duX291dDogY29udjI1Nl9kb3duX291dCxcclxuICAgICAgICBmYzogZmNcclxuICAgIH07XHJcbiAgICByZXR1cm4geyBwYXJhbXM6IHBhcmFtcywgcGFyYW1NYXBwaW5nczogcGFyYW1NYXBwaW5ncyB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RQYXJhbXMuanMubWFwIiwiaW1wb3J0IHsgZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMsIGV4dHJhY3RXZWlnaHRFbnRyeUZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBpc1RlbnNvcjJEIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5mdW5jdGlvbiBleHRyYWN0b3JzRmFjdG9yeSh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpIHtcclxuICAgIHZhciBleHRyYWN0V2VpZ2h0RW50cnkgPSBleHRyYWN0V2VpZ2h0RW50cnlGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0U2NhbGVMYXllclBhcmFtcyhwcmVmaXgpIHtcclxuICAgICAgICB2YXIgd2VpZ2h0cyA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi9zY2FsZS93ZWlnaHRzXCIsIDEpO1xyXG4gICAgICAgIHZhciBiaWFzZXMgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvc2NhbGUvYmlhc2VzXCIsIDEpO1xyXG4gICAgICAgIHJldHVybiB7IHdlaWdodHM6IHdlaWdodHMsIGJpYXNlczogYmlhc2VzIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0Q29udkxheWVyUGFyYW1zKHByZWZpeCkge1xyXG4gICAgICAgIHZhciBmaWx0ZXJzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL2NvbnYvZmlsdGVyc1wiLCA0KTtcclxuICAgICAgICB2YXIgYmlhcyA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi9jb252L2JpYXNcIiwgMSk7XHJcbiAgICAgICAgdmFyIHNjYWxlID0gZXh0cmFjdFNjYWxlTGF5ZXJQYXJhbXMocHJlZml4KTtcclxuICAgICAgICByZXR1cm4geyBjb252OiB7IGZpbHRlcnM6IGZpbHRlcnMsIGJpYXM6IGJpYXMgfSwgc2NhbGU6IHNjYWxlIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcyhwcmVmaXgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb252MTogZXh0cmFjdENvbnZMYXllclBhcmFtcyhwcmVmaXggKyBcIi9jb252MVwiKSxcclxuICAgICAgICAgICAgY29udjI6IGV4dHJhY3RDb252TGF5ZXJQYXJhbXMocHJlZml4ICsgXCIvY29udjJcIilcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBleHRyYWN0Q29udkxheWVyUGFyYW1zOiBleHRyYWN0Q29udkxheWVyUGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zOiBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtc1xyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAod2VpZ2h0TWFwKSB7XHJcbiAgICB2YXIgcGFyYW1NYXBwaW5ncyA9IFtdO1xyXG4gICAgdmFyIF9hID0gZXh0cmFjdG9yc0ZhY3Rvcnkod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKSwgZXh0cmFjdENvbnZMYXllclBhcmFtcyA9IF9hLmV4dHJhY3RDb252TGF5ZXJQYXJhbXMsIGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zID0gX2EuZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXM7XHJcbiAgICB2YXIgY29udjMyX2Rvd24gPSBleHRyYWN0Q29udkxheWVyUGFyYW1zKCdjb252MzJfZG93bicpO1xyXG4gICAgdmFyIGNvbnYzMl8xID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoJ2NvbnYzMl8xJyk7XHJcbiAgICB2YXIgY29udjMyXzIgPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcygnY29udjMyXzInKTtcclxuICAgIHZhciBjb252MzJfMyA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKCdjb252MzJfMycpO1xyXG4gICAgdmFyIGNvbnY2NF9kb3duID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoJ2NvbnY2NF9kb3duJyk7XHJcbiAgICB2YXIgY29udjY0XzEgPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcygnY29udjY0XzEnKTtcclxuICAgIHZhciBjb252NjRfMiA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKCdjb252NjRfMicpO1xyXG4gICAgdmFyIGNvbnY2NF8zID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoJ2NvbnY2NF8zJyk7XHJcbiAgICB2YXIgY29udjEyOF9kb3duID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoJ2NvbnYxMjhfZG93bicpO1xyXG4gICAgdmFyIGNvbnYxMjhfMSA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKCdjb252MTI4XzEnKTtcclxuICAgIHZhciBjb252MTI4XzIgPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcygnY29udjEyOF8yJyk7XHJcbiAgICB2YXIgY29udjI1Nl9kb3duID0gZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXMoJ2NvbnYyNTZfZG93bicpO1xyXG4gICAgdmFyIGNvbnYyNTZfMSA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKCdjb252MjU2XzEnKTtcclxuICAgIHZhciBjb252MjU2XzIgPSBleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtcygnY29udjI1Nl8yJyk7XHJcbiAgICB2YXIgY29udjI1Nl9kb3duX291dCA9IGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zKCdjb252MjU2X2Rvd25fb3V0Jyk7XHJcbiAgICB2YXIgZmMgPSB3ZWlnaHRNYXBbJ2ZjJ107XHJcbiAgICBwYXJhbU1hcHBpbmdzLnB1c2goeyBvcmlnaW5hbFBhdGg6ICdmYycsIHBhcmFtUGF0aDogJ2ZjJyB9KTtcclxuICAgIGlmICghaXNUZW5zb3IyRChmYykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCB3ZWlnaHRNYXBbZmNdIHRvIGJlIGEgVGVuc29yMkQsIGluc3RlYWQgaGF2ZSBcIiArIGZjKTtcclxuICAgIH1cclxuICAgIHZhciBwYXJhbXMgPSB7XHJcbiAgICAgICAgY29udjMyX2Rvd246IGNvbnYzMl9kb3duLFxyXG4gICAgICAgIGNvbnYzMl8xOiBjb252MzJfMSxcclxuICAgICAgICBjb252MzJfMjogY29udjMyXzIsXHJcbiAgICAgICAgY29udjMyXzM6IGNvbnYzMl8zLFxyXG4gICAgICAgIGNvbnY2NF9kb3duOiBjb252NjRfZG93bixcclxuICAgICAgICBjb252NjRfMTogY29udjY0XzEsXHJcbiAgICAgICAgY29udjY0XzI6IGNvbnY2NF8yLFxyXG4gICAgICAgIGNvbnY2NF8zOiBjb252NjRfMyxcclxuICAgICAgICBjb252MTI4X2Rvd246IGNvbnYxMjhfZG93bixcclxuICAgICAgICBjb252MTI4XzE6IGNvbnYxMjhfMSxcclxuICAgICAgICBjb252MTI4XzI6IGNvbnYxMjhfMixcclxuICAgICAgICBjb252MjU2X2Rvd246IGNvbnYyNTZfZG93bixcclxuICAgICAgICBjb252MjU2XzE6IGNvbnYyNTZfMSxcclxuICAgICAgICBjb252MjU2XzI6IGNvbnYyNTZfMixcclxuICAgICAgICBjb252MjU2X2Rvd25fb3V0OiBjb252MjU2X2Rvd25fb3V0LFxyXG4gICAgICAgIGZjOiBmY1xyXG4gICAgfTtcclxuICAgIGRpc3Bvc2VVbnVzZWRXZWlnaHRUZW5zb3JzKHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICByZXR1cm4geyBwYXJhbXM6IHBhcmFtcywgcGFyYW1NYXBwaW5nczogcGFyYW1NYXBwaW5ncyB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwLmpzLm1hcCIsImltcG9ydCB7IEZhY2VSZWNvZ25pdGlvbk5ldCB9IGZyb20gJy4vRmFjZVJlY29nbml0aW9uTmV0JztcclxuZXhwb3J0ICogZnJvbSAnLi9GYWNlUmVjb2duaXRpb25OZXQnO1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRmFjZVJlY29nbml0aW9uTmV0KHdlaWdodHMpIHtcclxuICAgIHZhciBuZXQgPSBuZXcgRmFjZVJlY29nbml0aW9uTmV0KCk7XHJcbiAgICBuZXQuZXh0cmFjdFdlaWdodHMod2VpZ2h0cyk7XHJcbiAgICByZXR1cm4gbmV0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IF9fc3ByZWFkQXJyYXlzIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGNvbnYsIGNvbnZEb3duLCBjb252Tm9SZWx1IH0gZnJvbSAnLi9jb252TGF5ZXInO1xyXG5leHBvcnQgZnVuY3Rpb24gcmVzaWR1YWwoeCwgcGFyYW1zKSB7XHJcbiAgICB2YXIgb3V0ID0gY29udih4LCBwYXJhbXMuY29udjEpO1xyXG4gICAgb3V0ID0gY29udk5vUmVsdShvdXQsIHBhcmFtcy5jb252Mik7XHJcbiAgICBvdXQgPSB0Zi5hZGQob3V0LCB4KTtcclxuICAgIG91dCA9IHRmLnJlbHUob3V0KTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc2lkdWFsRG93bih4LCBwYXJhbXMpIHtcclxuICAgIHZhciBvdXQgPSBjb252RG93bih4LCBwYXJhbXMuY29udjEpO1xyXG4gICAgb3V0ID0gY29udk5vUmVsdShvdXQsIHBhcmFtcy5jb252Mik7XHJcbiAgICB2YXIgcG9vbGVkID0gdGYuYXZnUG9vbCh4LCAyLCAyLCAndmFsaWQnKTtcclxuICAgIHZhciB6ZXJvcyA9IHRmLnplcm9zKHBvb2xlZC5zaGFwZSk7XHJcbiAgICB2YXIgaXNQYWQgPSBwb29sZWQuc2hhcGVbM10gIT09IG91dC5zaGFwZVszXTtcclxuICAgIHZhciBpc0FkanVzdFNoYXBlID0gcG9vbGVkLnNoYXBlWzFdICE9PSBvdXQuc2hhcGVbMV0gfHwgcG9vbGVkLnNoYXBlWzJdICE9PSBvdXQuc2hhcGVbMl07XHJcbiAgICBpZiAoaXNBZGp1c3RTaGFwZSkge1xyXG4gICAgICAgIHZhciBwYWRTaGFwZVggPSBfX3NwcmVhZEFycmF5cyhvdXQuc2hhcGUpO1xyXG4gICAgICAgIHBhZFNoYXBlWFsxXSA9IDE7XHJcbiAgICAgICAgdmFyIHplcm9zVyA9IHRmLnplcm9zKHBhZFNoYXBlWCk7XHJcbiAgICAgICAgb3V0ID0gdGYuY29uY2F0KFtvdXQsIHplcm9zV10sIDEpO1xyXG4gICAgICAgIHZhciBwYWRTaGFwZVkgPSBfX3NwcmVhZEFycmF5cyhvdXQuc2hhcGUpO1xyXG4gICAgICAgIHBhZFNoYXBlWVsyXSA9IDE7XHJcbiAgICAgICAgdmFyIHplcm9zSCA9IHRmLnplcm9zKHBhZFNoYXBlWSk7XHJcbiAgICAgICAgb3V0ID0gdGYuY29uY2F0KFtvdXQsIHplcm9zSF0sIDIpO1xyXG4gICAgfVxyXG4gICAgcG9vbGVkID0gaXNQYWQgPyB0Zi5jb25jYXQoW3Bvb2xlZCwgemVyb3NdLCAzKSA6IHBvb2xlZDtcclxuICAgIG91dCA9IHRmLmFkZChwb29sZWQsIG91dCk7XHJcbiAgICBvdXQgPSB0Zi5yZWx1KG91dCk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc2lkdWFsTGF5ZXIuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKHgsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIHRmLmFkZCh0Zi5tdWwoeCwgcGFyYW1zLndlaWdodHMpLCBwYXJhbXMuYmlhc2VzKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2FsZUxheWVyLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBpc1dpdGhBZ2Uob2JqKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG9ialsnYWdlJ10gPT09ICdudW1iZXInO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRXaXRoQWdlKHNvdXJjZU9iaiwgYWdlKSB7XHJcbiAgICB2YXIgZXh0ZW5zaW9uID0geyBhZ2U6IGFnZSB9O1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZU9iaiwgZXh0ZW5zaW9uKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1XaXRoQWdlLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBleHRlbmRXaXRoRmFjZURlc2NyaXB0b3Ioc291cmNlT2JqLCBkZXNjcmlwdG9yKSB7XHJcbiAgICB2YXIgZXh0ZW5zaW9uID0geyBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yIH07XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlT2JqLCBleHRlbnNpb24pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdpdGhGYWNlRGVzY3JpcHRvci5qcy5tYXAiLCJpbXBvcnQgeyBGYWNlRGV0ZWN0aW9uIH0gZnJvbSAnLi4vY2xhc3Nlcy9GYWNlRGV0ZWN0aW9uJztcclxuZXhwb3J0IGZ1bmN0aW9uIGlzV2l0aEZhY2VEZXRlY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqWydkZXRlY3Rpb24nXSBpbnN0YW5jZW9mIEZhY2VEZXRlY3Rpb247XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9uKHNvdXJjZU9iaiwgZGV0ZWN0aW9uKSB7XHJcbiAgICB2YXIgZXh0ZW5zaW9uID0geyBkZXRlY3Rpb246IGRldGVjdGlvbiB9O1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZU9iaiwgZXh0ZW5zaW9uKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1XaXRoRmFjZURldGVjdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBGYWNlRXhwcmVzc2lvbnMgfSBmcm9tICcuLi9mYWNlRXhwcmVzc2lvbk5ldC9GYWNlRXhwcmVzc2lvbnMnO1xyXG5leHBvcnQgZnVuY3Rpb24gaXNXaXRoRmFjZUV4cHJlc3Npb25zKG9iaikge1xyXG4gICAgcmV0dXJuIG9ialsnZXhwcmVzc2lvbnMnXSBpbnN0YW5jZW9mIEZhY2VFeHByZXNzaW9ucztcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kV2l0aEZhY2VFeHByZXNzaW9ucyhzb3VyY2VPYmosIGV4cHJlc3Npb25zKSB7XHJcbiAgICB2YXIgZXh0ZW5zaW9uID0geyBleHByZXNzaW9uczogZXhwcmVzc2lvbnMgfTtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2VPYmosIGV4dGVuc2lvbik7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2l0aEZhY2VFeHByZXNzaW9ucy5qcy5tYXAiLCJpbXBvcnQgeyBGYWNlRGV0ZWN0aW9uIH0gZnJvbSAnLi4vY2xhc3Nlcy9GYWNlRGV0ZWN0aW9uJztcclxuaW1wb3J0IHsgRmFjZUxhbmRtYXJrcyB9IGZyb20gJy4uL2NsYXNzZXMvRmFjZUxhbmRtYXJrcyc7XHJcbmltcG9ydCB7IGlzV2l0aEZhY2VEZXRlY3Rpb24gfSBmcm9tICcuL1dpdGhGYWNlRGV0ZWN0aW9uJztcclxuZXhwb3J0IGZ1bmN0aW9uIGlzV2l0aEZhY2VMYW5kbWFya3Mob2JqKSB7XHJcbiAgICByZXR1cm4gaXNXaXRoRmFjZURldGVjdGlvbihvYmopXHJcbiAgICAgICAgJiYgb2JqWydsYW5kbWFya3MnXSBpbnN0YW5jZW9mIEZhY2VMYW5kbWFya3NcclxuICAgICAgICAmJiBvYmpbJ3Vuc2hpZnRlZExhbmRtYXJrcyddIGluc3RhbmNlb2YgRmFjZUxhbmRtYXJrc1xyXG4gICAgICAgICYmIG9ialsnYWxpZ25lZFJlY3QnXSBpbnN0YW5jZW9mIEZhY2VEZXRlY3Rpb247XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFdpdGhGYWNlTGFuZG1hcmtzKHNvdXJjZU9iaiwgdW5zaGlmdGVkTGFuZG1hcmtzKSB7XHJcbiAgICB2YXIgc2hpZnQgPSBzb3VyY2VPYmouZGV0ZWN0aW9uLmJveDtcclxuICAgIHZhciBsYW5kbWFya3MgPSB1bnNoaWZ0ZWRMYW5kbWFya3Muc2hpZnRCeShzaGlmdC54LCBzaGlmdC55KTtcclxuICAgIHZhciByZWN0ID0gbGFuZG1hcmtzLmFsaWduKCk7XHJcbiAgICB2YXIgaW1hZ2VEaW1zID0gc291cmNlT2JqLmRldGVjdGlvbi5pbWFnZURpbXM7XHJcbiAgICB2YXIgYWxpZ25lZFJlY3QgPSBuZXcgRmFjZURldGVjdGlvbihzb3VyY2VPYmouZGV0ZWN0aW9uLnNjb3JlLCByZWN0LnJlc2NhbGUoaW1hZ2VEaW1zLnJldmVyc2UoKSksIGltYWdlRGltcyk7XHJcbiAgICB2YXIgZXh0ZW5zaW9uID0ge1xyXG4gICAgICAgIGxhbmRtYXJrczogbGFuZG1hcmtzLFxyXG4gICAgICAgIHVuc2hpZnRlZExhbmRtYXJrczogdW5zaGlmdGVkTGFuZG1hcmtzLFxyXG4gICAgICAgIGFsaWduZWRSZWN0OiBhbGlnbmVkUmVjdFxyXG4gICAgfTtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2VPYmosIGV4dGVuc2lvbik7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2l0aEZhY2VMYW5kbWFya3MuanMubWFwIiwiaW1wb3J0IHsgR2VuZGVyIH0gZnJvbSAnLi4vYWdlR2VuZGVyTmV0L3R5cGVzJztcclxuaW1wb3J0IHsgaXNWYWxpZFByb2JhYmxpdGl5IH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5leHBvcnQgZnVuY3Rpb24gaXNXaXRoR2VuZGVyKG9iaikge1xyXG4gICAgcmV0dXJuIChvYmpbJ2dlbmRlciddID09PSBHZW5kZXIuTUFMRSB8fCBvYmpbJ2dlbmRlciddID09PSBHZW5kZXIuRkVNQUxFKVxyXG4gICAgICAgICYmIGlzVmFsaWRQcm9iYWJsaXRpeShvYmpbJ2dlbmRlclByb2JhYmlsaXR5J10pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRXaXRoR2VuZGVyKHNvdXJjZU9iaiwgZ2VuZGVyLCBnZW5kZXJQcm9iYWJpbGl0eSkge1xyXG4gICAgdmFyIGV4dGVuc2lvbiA9IHsgZ2VuZGVyOiBnZW5kZXIsIGdlbmRlclByb2JhYmlsaXR5OiBnZW5kZXJQcm9iYWJpbGl0eSB9O1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZU9iaiwgZXh0ZW5zaW9uKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1XaXRoR2VuZGVyLmpzLm1hcCIsImV4cG9ydCAqIGZyb20gJy4vV2l0aEZhY2VEZXNjcmlwdG9yJztcclxuZXhwb3J0ICogZnJvbSAnLi9XaXRoRmFjZURldGVjdGlvbic7XHJcbmV4cG9ydCAqIGZyb20gJy4vV2l0aEZhY2VFeHByZXNzaW9ucyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vV2l0aEZhY2VMYW5kbWFya3MnO1xyXG5leHBvcnQgKiBmcm9tICcuL1dpdGhBZ2UnO1xyXG5leHBvcnQgKiBmcm9tICcuL1dpdGhHZW5kZXInO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbnZhciBDb21wb3NhYmxlVGFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbXBvc2FibGVUYXNrKCkge1xyXG4gICAgfVxyXG4gICAgQ29tcG9zYWJsZVRhc2sucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25mdWxmaWxsZWQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBvbmZ1bGZpbGxlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5ydW4oKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2EuYXBwbHkodm9pZCAwLCBbX2Iuc2VudCgpXSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDb21wb3NhYmxlVGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wb3NhYmxlVGFzayAtIHJ1biBpcyBub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbXBvc2FibGVUYXNrO1xyXG59KCkpO1xyXG5leHBvcnQgeyBDb21wb3NhYmxlVGFzayB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21wb3NhYmxlVGFzay5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZXh0ZW5kcywgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgZXh0ZW5kV2l0aEZhY2VEZXNjcmlwdG9yIH0gZnJvbSAnLi4vZmFjdG9yaWVzL1dpdGhGYWNlRGVzY3JpcHRvcic7XHJcbmltcG9ydCB7IENvbXBvc2FibGVUYXNrIH0gZnJvbSAnLi9Db21wb3NhYmxlVGFzayc7XHJcbmltcG9ydCB7IGV4dHJhY3RBbGxGYWNlc0FuZENvbXB1dGVSZXN1bHRzLCBleHRyYWN0U2luZ2xlRmFjZUFuZENvbXB1dGVSZXN1bHQgfSBmcm9tICcuL2V4dHJhY3RGYWNlc0FuZENvbXB1dGVSZXN1bHRzJztcclxuaW1wb3J0IHsgbmV0cyB9IGZyb20gJy4vbmV0cyc7XHJcbmltcG9ydCB7IFByZWRpY3RBbGxBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2ssIFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2ssIH0gZnJvbSAnLi9QcmVkaWN0QWdlQW5kR2VuZGVyVGFzayc7XHJcbmltcG9ydCB7IFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2ssIFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2ssIH0gZnJvbSAnLi9QcmVkaWN0RmFjZUV4cHJlc3Npb25zVGFzayc7XHJcbnZhciBDb21wdXRlRmFjZURlc2NyaXB0b3JzVGFza0Jhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ29tcHV0ZUZhY2VEZXNjcmlwdG9yc1Rhc2tCYXNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29tcHV0ZUZhY2VEZXNjcmlwdG9yc1Rhc2tCYXNlKHBhcmVudFRhc2ssIGlucHV0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5wYXJlbnRUYXNrID0gcGFyZW50VGFzaztcclxuICAgICAgICBfdGhpcy5pbnB1dCA9IGlucHV0O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBDb21wdXRlRmFjZURlc2NyaXB0b3JzVGFza0Jhc2U7XHJcbn0oQ29tcG9zYWJsZVRhc2spKTtcclxuZXhwb3J0IHsgQ29tcHV0ZUZhY2VEZXNjcmlwdG9yc1Rhc2tCYXNlIH07XHJcbnZhciBDb21wdXRlQWxsRmFjZURlc2NyaXB0b3JzVGFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb21wdXRlQWxsRmFjZURlc2NyaXB0b3JzVGFzaywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvbXB1dGVBbGxGYWNlRGVzY3JpcHRvcnNUYXNrKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIENvbXB1dGVBbGxGYWNlRGVzY3JpcHRvcnNUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50UmVzdWx0cywgZGVzY3JpcHRvcnM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGFyZW50VGFza107XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZXN1bHRzID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleHRyYWN0QWxsRmFjZXNBbmRDb21wdXRlUmVzdWx0cyhwYXJlbnRSZXN1bHRzLCB0aGlzLmlucHV0LCBmdW5jdGlvbiAoZmFjZXMpIHsgcmV0dXJuIFByb21pc2UuYWxsKGZhY2VzLm1hcChmdW5jdGlvbiAoZmFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXRzLmZhY2VSZWNvZ25pdGlvbk5ldC5jb21wdXRlRmFjZURlc2NyaXB0b3IoZmFjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7IH0sIG51bGwsIGZ1bmN0aW9uIChwYXJlbnRSZXN1bHQpIHsgcmV0dXJuIHBhcmVudFJlc3VsdC5sYW5kbWFya3MuYWxpZ24obnVsbCwgeyB1c2VEbGliQWxpZ25tZW50OiB0cnVlIH0pOyB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9ycyA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRlc2NyaXB0b3JzLm1hcChmdW5jdGlvbiAoZGVzY3JpcHRvciwgaSkgeyByZXR1cm4gZXh0ZW5kV2l0aEZhY2VEZXNjcmlwdG9yKHBhcmVudFJlc3VsdHNbaV0sIGRlc2NyaXB0b3IpOyB9KV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENvbXB1dGVBbGxGYWNlRGVzY3JpcHRvcnNUYXNrLnByb3RvdHlwZS53aXRoRmFjZUV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICBDb21wdXRlQWxsRmFjZURlc2NyaXB0b3JzVGFzay5wcm90b3R5cGUud2l0aEFnZUFuZEdlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZWRpY3RBbGxBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2sodGhpcywgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbXB1dGVBbGxGYWNlRGVzY3JpcHRvcnNUYXNrO1xyXG59KENvbXB1dGVGYWNlRGVzY3JpcHRvcnNUYXNrQmFzZSkpO1xyXG5leHBvcnQgeyBDb21wdXRlQWxsRmFjZURlc2NyaXB0b3JzVGFzayB9O1xyXG52YXIgQ29tcHV0ZVNpbmdsZUZhY2VEZXNjcmlwdG9yVGFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb21wdXRlU2luZ2xlRmFjZURlc2NyaXB0b3JUYXNrLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29tcHV0ZVNpbmdsZUZhY2VEZXNjcmlwdG9yVGFzaygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBDb21wdXRlU2luZ2xlRmFjZURlc2NyaXB0b3JUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50UmVzdWx0LCBkZXNjcmlwdG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBhcmVudFRhc2tdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVzdWx0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4dHJhY3RTaW5nbGVGYWNlQW5kQ29tcHV0ZVJlc3VsdChwYXJlbnRSZXN1bHQsIHRoaXMuaW5wdXQsIGZ1bmN0aW9uIChmYWNlKSB7IHJldHVybiBuZXRzLmZhY2VSZWNvZ25pdGlvbk5ldC5jb21wdXRlRmFjZURlc2NyaXB0b3IoZmFjZSk7IH0sIG51bGwsIGZ1bmN0aW9uIChwYXJlbnRSZXN1bHQpIHsgcmV0dXJuIHBhcmVudFJlc3VsdC5sYW5kbWFya3MuYWxpZ24obnVsbCwgeyB1c2VEbGliQWxpZ25tZW50OiB0cnVlIH0pOyB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZXh0ZW5kV2l0aEZhY2VEZXNjcmlwdG9yKHBhcmVudFJlc3VsdCwgZGVzY3JpcHRvcildO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDb21wdXRlU2luZ2xlRmFjZURlc2NyaXB0b3JUYXNrLnByb3RvdHlwZS53aXRoRmFjZUV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICBDb21wdXRlU2luZ2xlRmFjZURlc2NyaXB0b3JUYXNrLnByb3RvdHlwZS53aXRoQWdlQW5kR2VuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29tcHV0ZVNpbmdsZUZhY2VEZXNjcmlwdG9yVGFzaztcclxufShDb21wdXRlRmFjZURlc2NyaXB0b3JzVGFza0Jhc2UpKTtcclxuZXhwb3J0IHsgQ29tcHV0ZVNpbmdsZUZhY2VEZXNjcmlwdG9yVGFzayB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21wdXRlRmFjZURlc2NyaXB0b3JzVGFza3MuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2V4dGVuZHMsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGV4dHJhY3RGYWNlcywgZXh0cmFjdEZhY2VUZW5zb3JzIH0gZnJvbSAnLi4vZG9tJztcclxuaW1wb3J0IHsgZXh0ZW5kV2l0aEZhY2VMYW5kbWFya3MgfSBmcm9tICcuLi9mYWN0b3JpZXMvV2l0aEZhY2VMYW5kbWFya3MnO1xyXG5pbXBvcnQgeyBDb21wb3NhYmxlVGFzayB9IGZyb20gJy4vQ29tcG9zYWJsZVRhc2snO1xyXG5pbXBvcnQgeyBDb21wdXRlQWxsRmFjZURlc2NyaXB0b3JzVGFzaywgQ29tcHV0ZVNpbmdsZUZhY2VEZXNjcmlwdG9yVGFzayB9IGZyb20gJy4vQ29tcHV0ZUZhY2VEZXNjcmlwdG9yc1Rhc2tzJztcclxuaW1wb3J0IHsgbmV0cyB9IGZyb20gJy4vbmV0cyc7XHJcbmltcG9ydCB7IFByZWRpY3RBbGxBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2ssIFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2ssIH0gZnJvbSAnLi9QcmVkaWN0QWdlQW5kR2VuZGVyVGFzayc7XHJcbmltcG9ydCB7IFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2ssIFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2ssIH0gZnJvbSAnLi9QcmVkaWN0RmFjZUV4cHJlc3Npb25zVGFzayc7XHJcbnZhciBEZXRlY3RGYWNlTGFuZG1hcmtzVGFza0Jhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGV0ZWN0RmFjZUxhbmRtYXJrc1Rhc2tCYXNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGV0ZWN0RmFjZUxhbmRtYXJrc1Rhc2tCYXNlKHBhcmVudFRhc2ssIGlucHV0LCB1c2VUaW55TGFuZG1hcmtOZXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnBhcmVudFRhc2sgPSBwYXJlbnRUYXNrO1xyXG4gICAgICAgIF90aGlzLmlucHV0ID0gaW5wdXQ7XHJcbiAgICAgICAgX3RoaXMudXNlVGlueUxhbmRtYXJrTmV0ID0gdXNlVGlueUxhbmRtYXJrTmV0O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZXRlY3RGYWNlTGFuZG1hcmtzVGFza0Jhc2UucHJvdG90eXBlLCBcImxhbmRtYXJrTmV0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlVGlueUxhbmRtYXJrTmV0XHJcbiAgICAgICAgICAgICAgICA/IG5ldHMuZmFjZUxhbmRtYXJrNjhUaW55TmV0XHJcbiAgICAgICAgICAgICAgICA6IG5ldHMuZmFjZUxhbmRtYXJrNjhOZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gRGV0ZWN0RmFjZUxhbmRtYXJrc1Rhc2tCYXNlO1xyXG59KENvbXBvc2FibGVUYXNrKSk7XHJcbmV4cG9ydCB7IERldGVjdEZhY2VMYW5kbWFya3NUYXNrQmFzZSB9O1xyXG52YXIgRGV0ZWN0QWxsRmFjZUxhbmRtYXJrc1Rhc2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGV0ZWN0QWxsRmFjZUxhbmRtYXJrc1Rhc2ssIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEZXRlY3RBbGxGYWNlTGFuZG1hcmtzVGFzaygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBEZXRlY3RBbGxGYWNlTGFuZG1hcmtzVGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudFJlc3VsdHMsIGRldGVjdGlvbnMsIGZhY2VzLCBfYSwgZmFjZUxhbmRtYXJrc0J5RmFjZTtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wYXJlbnRUYXNrXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJlc3VsdHMgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGVjdGlvbnMgPSBwYXJlbnRSZXN1bHRzLm1hcChmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMuZGV0ZWN0aW9uOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5pbnB1dCBpbnN0YW5jZW9mIHRmLlRlbnNvcikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleHRyYWN0RmFjZVRlbnNvcnModGhpcy5pbnB1dCwgZGV0ZWN0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgZXh0cmFjdEZhY2VzKHRoaXMuaW5wdXQsIGRldGVjdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlcyA9IF9hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChmYWNlcy5tYXAoZnVuY3Rpb24gKGZhY2UpIHsgcmV0dXJuIF90aGlzLmxhbmRtYXJrTmV0LmRldGVjdExhbmRtYXJrcyhmYWNlKTsgfSkpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VMYW5kbWFya3NCeUZhY2UgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VzLmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYgaW5zdGFuY2VvZiB0Zi5UZW5zb3IgJiYgZi5kaXNwb3NlKCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcGFyZW50UmVzdWx0cy5tYXAoZnVuY3Rpb24gKHBhcmVudFJlc3VsdCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHRlbmRXaXRoRmFjZUxhbmRtYXJrcyhwYXJlbnRSZXN1bHQsIGZhY2VMYW5kbWFya3NCeUZhY2VbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEZXRlY3RBbGxGYWNlTGFuZG1hcmtzVGFzay5wcm90b3R5cGUud2l0aEZhY2VFeHByZXNzaW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2sodGhpcywgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0QWxsRmFjZUxhbmRtYXJrc1Rhc2sucHJvdG90eXBlLndpdGhBZ2VBbmRHZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrKHRoaXMsIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIERldGVjdEFsbEZhY2VMYW5kbWFya3NUYXNrLnByb3RvdHlwZS53aXRoRmFjZURlc2NyaXB0b3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcHV0ZUFsbEZhY2VEZXNjcmlwdG9yc1Rhc2sodGhpcywgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERldGVjdEFsbEZhY2VMYW5kbWFya3NUYXNrO1xyXG59KERldGVjdEZhY2VMYW5kbWFya3NUYXNrQmFzZSkpO1xyXG5leHBvcnQgeyBEZXRlY3RBbGxGYWNlTGFuZG1hcmtzVGFzayB9O1xyXG52YXIgRGV0ZWN0U2luZ2xlRmFjZUxhbmRtYXJrc1Rhc2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGV0ZWN0U2luZ2xlRmFjZUxhbmRtYXJrc1Rhc2ssIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEZXRlY3RTaW5nbGVGYWNlTGFuZG1hcmtzVGFzaygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBEZXRlY3RTaW5nbGVGYWNlTGFuZG1hcmtzVGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudFJlc3VsdCwgZGV0ZWN0aW9uLCBmYWNlcywgX2EsIGxhbmRtYXJrcztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wYXJlbnRUYXNrXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJlc3VsdCA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3Rpb24gPSBwYXJlbnRSZXN1bHQuZGV0ZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLmlucHV0IGluc3RhbmNlb2YgdGYuVGVuc29yKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4dHJhY3RGYWNlVGVuc29ycyh0aGlzLmlucHV0LCBbZGV0ZWN0aW9uXSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgZXh0cmFjdEZhY2VzKHRoaXMuaW5wdXQsIFtkZXRlY3Rpb25dKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZXMgPSBfYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5sYW5kbWFya05ldC5kZXRlY3RMYW5kbWFya3MoZmFjZXNbMF0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmRtYXJrcyA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZXMuZm9yRWFjaChmdW5jdGlvbiAoZikgeyByZXR1cm4gZiBpbnN0YW5jZW9mIHRmLlRlbnNvciAmJiBmLmRpc3Bvc2UoKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBleHRlbmRXaXRoRmFjZUxhbmRtYXJrcyhwYXJlbnRSZXN1bHQsIGxhbmRtYXJrcyldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEZXRlY3RTaW5nbGVGYWNlTGFuZG1hcmtzVGFzay5wcm90b3R5cGUud2l0aEZhY2VFeHByZXNzaW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2sodGhpcywgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0U2luZ2xlRmFjZUxhbmRtYXJrc1Rhc2sucHJvdG90eXBlLndpdGhBZ2VBbmRHZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrKHRoaXMsIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIERldGVjdFNpbmdsZUZhY2VMYW5kbWFya3NUYXNrLnByb3RvdHlwZS53aXRoRmFjZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wdXRlU2luZ2xlRmFjZURlc2NyaXB0b3JUYXNrKHRoaXMsIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEZXRlY3RTaW5nbGVGYWNlTGFuZG1hcmtzVGFzaztcclxufShEZXRlY3RGYWNlTGFuZG1hcmtzVGFza0Jhc2UpKTtcclxuZXhwb3J0IHsgRGV0ZWN0U2luZ2xlRmFjZUxhbmRtYXJrc1Rhc2sgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGV0ZWN0RmFjZUxhbmRtYXJrc1Rhc2tzLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19leHRlbmRzLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBleHRlbmRXaXRoRmFjZURldGVjdGlvbiB9IGZyb20gJy4uL2ZhY3Rvcmllcy9XaXRoRmFjZURldGVjdGlvbic7XHJcbmltcG9ydCB7IE10Y25uT3B0aW9ucyB9IGZyb20gJy4uL210Y25uL010Y25uT3B0aW9ucyc7XHJcbmltcG9ydCB7IFNzZE1vYmlsZW5ldHYxT3B0aW9ucyB9IGZyb20gJy4uL3NzZE1vYmlsZW5ldHYxL1NzZE1vYmlsZW5ldHYxT3B0aW9ucyc7XHJcbmltcG9ydCB7IFRpbnlGYWNlRGV0ZWN0b3JPcHRpb25zIH0gZnJvbSAnLi4vdGlueUZhY2VEZXRlY3Rvci9UaW55RmFjZURldGVjdG9yT3B0aW9ucyc7XHJcbmltcG9ydCB7IFRpbnlZb2xvdjJPcHRpb25zIH0gZnJvbSAnLi4vdGlueVlvbG92Mic7XHJcbmltcG9ydCB7IENvbXBvc2FibGVUYXNrIH0gZnJvbSAnLi9Db21wb3NhYmxlVGFzayc7XHJcbmltcG9ydCB7IERldGVjdEFsbEZhY2VMYW5kbWFya3NUYXNrLCBEZXRlY3RTaW5nbGVGYWNlTGFuZG1hcmtzVGFzayB9IGZyb20gJy4vRGV0ZWN0RmFjZUxhbmRtYXJrc1Rhc2tzJztcclxuaW1wb3J0IHsgbmV0cyB9IGZyb20gJy4vbmV0cyc7XHJcbmltcG9ydCB7IFByZWRpY3RBbGxBZ2VBbmRHZW5kZXJUYXNrLCBQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyVGFzayB9IGZyb20gJy4vUHJlZGljdEFnZUFuZEdlbmRlclRhc2snO1xyXG5pbXBvcnQgeyBQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zVGFzaywgUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1Rhc2sgfSBmcm9tICcuL1ByZWRpY3RGYWNlRXhwcmVzc2lvbnNUYXNrJztcclxudmFyIERldGVjdEZhY2VzVGFza0Jhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGV0ZWN0RmFjZXNUYXNrQmFzZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERldGVjdEZhY2VzVGFza0Jhc2UoaW5wdXQsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBuZXcgU3NkTW9iaWxlbmV0djFPcHRpb25zKCk7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmlucHV0ID0gaW5wdXQ7XHJcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIERldGVjdEZhY2VzVGFza0Jhc2U7XHJcbn0oQ29tcG9zYWJsZVRhc2spKTtcclxuZXhwb3J0IHsgRGV0ZWN0RmFjZXNUYXNrQmFzZSB9O1xyXG52YXIgRGV0ZWN0QWxsRmFjZXNUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERldGVjdEFsbEZhY2VzVGFzaywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERldGVjdEFsbEZhY2VzVGFzaygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBEZXRlY3RBbGxGYWNlc1Rhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgaW5wdXQsIG9wdGlvbnMsIGZhY2VEZXRlY3Rpb25GdW5jdGlvbjtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLCBpbnB1dCA9IF9hLmlucHV0LCBvcHRpb25zID0gX2Eub3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEob3B0aW9ucyBpbnN0YW5jZW9mIE10Y25uT3B0aW9ucykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXRzLm10Y25uLmZvcndhcmQoaW5wdXQsIG9wdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Iuc2VudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQuZGV0ZWN0aW9uOyB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlRGV0ZWN0aW9uRnVuY3Rpb24gPSBvcHRpb25zIGluc3RhbmNlb2YgVGlueUZhY2VEZXRlY3Rvck9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBuZXRzLnRpbnlGYWNlRGV0ZWN0b3IubG9jYXRlRmFjZXMoaW5wdXQsIG9wdGlvbnMpOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChvcHRpb25zIGluc3RhbmNlb2YgU3NkTW9iaWxlbmV0djFPcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG5ldHMuc3NkTW9iaWxlbmV0djEubG9jYXRlRmFjZXMoaW5wdXQsIG9wdGlvbnMpOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAob3B0aW9ucyBpbnN0YW5jZW9mIFRpbnlZb2xvdjJPcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBuZXRzLnRpbnlZb2xvdjIubG9jYXRlRmFjZXMoaW5wdXQsIG9wdGlvbnMpOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZhY2VEZXRlY3Rpb25GdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXRlY3RGYWNlcyAtIGV4cGVjdGVkIG9wdGlvbnMgdG8gYmUgaW5zdGFuY2Ugb2YgVGlueUZhY2VEZXRlY3Rvck9wdGlvbnMgfCBTc2RNb2JpbGVuZXR2MU9wdGlvbnMgfCBNdGNubk9wdGlvbnMgfCBUaW55WW9sb3YyT3B0aW9ucycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWNlRGV0ZWN0aW9uRnVuY3Rpb24oaW5wdXQpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0QWxsRmFjZXNUYXNrLnByb3RvdHlwZS5ydW5BbmRFeHRlbmRXaXRoRmFjZURldGVjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGV0ZWN0aW9ucztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5ydW4oKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3Rpb25zID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzKGRldGVjdGlvbnMubWFwKGZ1bmN0aW9uIChkZXRlY3Rpb24pIHsgcmV0dXJuIGV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9uKHt9LCBkZXRlY3Rpb24pOyB9KSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0QWxsRmFjZXNUYXNrLnByb3RvdHlwZS53aXRoRmFjZUxhbmRtYXJrcyA9IGZ1bmN0aW9uICh1c2VUaW55TGFuZG1hcmtOZXQpIHtcclxuICAgICAgICBpZiAodXNlVGlueUxhbmRtYXJrTmV0ID09PSB2b2lkIDApIHsgdXNlVGlueUxhbmRtYXJrTmV0ID0gZmFsc2U7IH1cclxuICAgICAgICByZXR1cm4gbmV3IERldGVjdEFsbEZhY2VMYW5kbWFya3NUYXNrKHRoaXMucnVuQW5kRXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb25zKCksIHRoaXMuaW5wdXQsIHVzZVRpbnlMYW5kbWFya05ldCk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0QWxsRmFjZXNUYXNrLnByb3RvdHlwZS53aXRoRmFjZUV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1Rhc2sodGhpcy5ydW5BbmRFeHRlbmRXaXRoRmFjZURldGVjdGlvbnMoKSwgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0QWxsRmFjZXNUYXNrLnByb3RvdHlwZS53aXRoQWdlQW5kR2VuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdEFsbEFnZUFuZEdlbmRlclRhc2sodGhpcy5ydW5BbmRFeHRlbmRXaXRoRmFjZURldGVjdGlvbnMoKSwgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERldGVjdEFsbEZhY2VzVGFzaztcclxufShEZXRlY3RGYWNlc1Rhc2tCYXNlKSk7XHJcbmV4cG9ydCB7IERldGVjdEFsbEZhY2VzVGFzayB9O1xyXG52YXIgRGV0ZWN0U2luZ2xlRmFjZVRhc2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGV0ZWN0U2luZ2xlRmFjZVRhc2ssIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEZXRlY3RTaW5nbGVGYWNlVGFzaygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBEZXRlY3RTaW5nbGVGYWNlVGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGZhY2VEZXRlY3Rpb25zLCBmYWNlRGV0ZWN0aW9uV2l0aEhpZ2hlc3RTY29yZTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3IERldGVjdEFsbEZhY2VzVGFzayh0aGlzLmlucHV0LCB0aGlzLm9wdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VEZXRlY3Rpb25zID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlRGV0ZWN0aW9uV2l0aEhpZ2hlc3RTY29yZSA9IGZhY2VEZXRlY3Rpb25zWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlRGV0ZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChmYWNlRGV0ZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFjZURldGVjdGlvbi5zY29yZSA+IGZhY2VEZXRlY3Rpb25XaXRoSGlnaGVzdFNjb3JlLnNjb3JlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZURldGVjdGlvbldpdGhIaWdoZXN0U2NvcmUgPSBmYWNlRGV0ZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhY2VEZXRlY3Rpb25XaXRoSGlnaGVzdFNjb3JlXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0U2luZ2xlRmFjZVRhc2sucHJvdG90eXBlLnJ1bkFuZEV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRldGVjdGlvbjtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5ydW4oKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3Rpb24gPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXMoZGV0ZWN0aW9uID8gZXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24oe30sIGRldGVjdGlvbikgOiB1bmRlZmluZWQpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7IH0pO1xyXG4gICAgfTtcclxuICAgIERldGVjdFNpbmdsZUZhY2VUYXNrLnByb3RvdHlwZS53aXRoRmFjZUxhbmRtYXJrcyA9IGZ1bmN0aW9uICh1c2VUaW55TGFuZG1hcmtOZXQpIHtcclxuICAgICAgICBpZiAodXNlVGlueUxhbmRtYXJrTmV0ID09PSB2b2lkIDApIHsgdXNlVGlueUxhbmRtYXJrTmV0ID0gZmFsc2U7IH1cclxuICAgICAgICByZXR1cm4gbmV3IERldGVjdFNpbmdsZUZhY2VMYW5kbWFya3NUYXNrKHRoaXMucnVuQW5kRXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24oKSwgdGhpcy5pbnB1dCwgdXNlVGlueUxhbmRtYXJrTmV0KTtcclxuICAgIH07XHJcbiAgICBEZXRlY3RTaW5nbGVGYWNlVGFzay5wcm90b3R5cGUud2l0aEZhY2VFeHByZXNzaW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNUYXNrKHRoaXMucnVuQW5kRXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24oKSwgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0U2luZ2xlRmFjZVRhc2sucHJvdG90eXBlLndpdGhBZ2VBbmRHZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyVGFzayh0aGlzLnJ1bkFuZEV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9uKCksIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEZXRlY3RTaW5nbGVGYWNlVGFzaztcclxufShEZXRlY3RGYWNlc1Rhc2tCYXNlKSk7XHJcbmV4cG9ydCB7IERldGVjdFNpbmdsZUZhY2VUYXNrIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURldGVjdEZhY2VzVGFza3MuanMubWFwIiwiaW1wb3J0IHsgRmFjZU1hdGNoIH0gZnJvbSAnLi4vY2xhc3Nlcy9GYWNlTWF0Y2gnO1xyXG5pbXBvcnQgeyBMYWJlbGVkRmFjZURlc2NyaXB0b3JzIH0gZnJvbSAnLi4vY2xhc3Nlcy9MYWJlbGVkRmFjZURlc2NyaXB0b3JzJztcclxuaW1wb3J0IHsgZXVjbGlkZWFuRGlzdGFuY2UgfSBmcm9tICcuLi9ldWNsaWRlYW5EaXN0YW5jZSc7XHJcbnZhciBGYWNlTWF0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZhY2VNYXRjaGVyKGlucHV0cywgZGlzdGFuY2VUaHJlc2hvbGQpIHtcclxuICAgICAgICBpZiAoZGlzdGFuY2VUaHJlc2hvbGQgPT09IHZvaWQgMCkgeyBkaXN0YW5jZVRocmVzaG9sZCA9IDAuNjsgfVxyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlVGhyZXNob2xkID0gZGlzdGFuY2VUaHJlc2hvbGQ7XHJcbiAgICAgICAgdmFyIGlucHV0QXJyYXkgPSBBcnJheS5pc0FycmF5KGlucHV0cykgPyBpbnB1dHMgOiBbaW5wdXRzXTtcclxuICAgICAgICBpZiAoIWlucHV0QXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhY2VSZWNvZ25pemVyLmNvbnN0cnVjdG9yIC0gZXhwZWN0ZWQgYXRsZWFzdCBvbmUgaW5wdXRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb3VudCA9IDE7XHJcbiAgICAgICAgdmFyIGNyZWF0ZVVuaXF1ZUxhYmVsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJwZXJzb24gXCIgKyBjb3VudCsrOyB9O1xyXG4gICAgICAgIHRoaXMuX2xhYmVsZWREZXNjcmlwdG9ycyA9IGlucHV0QXJyYXkubWFwKGZ1bmN0aW9uIChkZXNjKSB7XHJcbiAgICAgICAgICAgIGlmIChkZXNjIGluc3RhbmNlb2YgTGFiZWxlZEZhY2VEZXNjcmlwdG9ycykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRlc2MgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGFiZWxlZEZhY2VEZXNjcmlwdG9ycyhjcmVhdGVVbmlxdWVMYWJlbCgpLCBbZGVzY10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkZXNjLmRlc2NyaXB0b3IgJiYgZGVzYy5kZXNjcmlwdG9yIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExhYmVsZWRGYWNlRGVzY3JpcHRvcnMoY3JlYXRlVW5pcXVlTGFiZWwoKSwgW2Rlc2MuZGVzY3JpcHRvcl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhY2VSZWNvZ25pemVyLmNvbnN0cnVjdG9yIC0gZXhwZWN0ZWQgaW5wdXRzIHRvIGJlIG9mIHR5cGUgTGFiZWxlZEZhY2VEZXNjcmlwdG9ycyB8IFdpdGhGYWNlRGVzY3JpcHRvcjxhbnk+IHwgRmxvYXQzMkFycmF5IHwgQXJyYXk8TGFiZWxlZEZhY2VEZXNjcmlwdG9ycyB8IFdpdGhGYWNlRGVzY3JpcHRvcjxhbnk+IHwgRmxvYXQzMkFycmF5PlwiKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWNlTWF0Y2hlci5wcm90b3R5cGUsIFwibGFiZWxlZERlc2NyaXB0b3JzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xhYmVsZWREZXNjcmlwdG9yczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFjZU1hdGNoZXIucHJvdG90eXBlLCBcImRpc3RhbmNlVGhyZXNob2xkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVGhyZXNob2xkOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEZhY2VNYXRjaGVyLnByb3RvdHlwZS5jb21wdXRlTWVhbkRpc3RhbmNlID0gZnVuY3Rpb24gKHF1ZXJ5RGVzY3JpcHRvciwgZGVzY3JpcHRvcnMpIHtcclxuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcnNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZXVjbGlkZWFuRGlzdGFuY2UoZCwgcXVlcnlEZXNjcmlwdG9yKTsgfSlcclxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoZDEsIGQyKSB7IHJldHVybiBkMSArIGQyOyB9LCAwKVxyXG4gICAgICAgICAgICAvIChkZXNjcmlwdG9ycy5sZW5ndGggfHwgMSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZU1hdGNoZXIucHJvdG90eXBlLm1hdGNoRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChxdWVyeURlc2NyaXB0b3IpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsZWREZXNjcmlwdG9yc1xyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvcnMgPSBfYS5kZXNjcmlwdG9ycywgbGFiZWwgPSBfYS5sYWJlbDtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWNlTWF0Y2gobGFiZWwsIF90aGlzLmNvbXB1dGVNZWFuRGlzdGFuY2UocXVlcnlEZXNjcmlwdG9yLCBkZXNjcmlwdG9ycykpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGJlc3QsIGN1cnIpIHsgcmV0dXJuIGJlc3QuZGlzdGFuY2UgPCBjdXJyLmRpc3RhbmNlID8gYmVzdCA6IGN1cnI7IH0pO1xyXG4gICAgfTtcclxuICAgIEZhY2VNYXRjaGVyLnByb3RvdHlwZS5maW5kQmVzdE1hdGNoID0gZnVuY3Rpb24gKHF1ZXJ5RGVzY3JpcHRvcikge1xyXG4gICAgICAgIHZhciBiZXN0TWF0Y2ggPSB0aGlzLm1hdGNoRGVzY3JpcHRvcihxdWVyeURlc2NyaXB0b3IpO1xyXG4gICAgICAgIHJldHVybiBiZXN0TWF0Y2guZGlzdGFuY2UgPCB0aGlzLmRpc3RhbmNlVGhyZXNob2xkXHJcbiAgICAgICAgICAgID8gYmVzdE1hdGNoXHJcbiAgICAgICAgICAgIDogbmV3IEZhY2VNYXRjaCgndW5rbm93bicsIGJlc3RNYXRjaC5kaXN0YW5jZSk7XHJcbiAgICB9O1xyXG4gICAgRmFjZU1hdGNoZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkaXN0YW5jZVRocmVzaG9sZDogdGhpcy5kaXN0YW5jZVRocmVzaG9sZCxcclxuICAgICAgICAgICAgbGFiZWxlZERlc2NyaXB0b3JzOiB0aGlzLmxhYmVsZWREZXNjcmlwdG9ycy5tYXAoZnVuY3Rpb24gKGxkKSB7IHJldHVybiBsZC50b0pTT04oKTsgfSlcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIEZhY2VNYXRjaGVyLmZyb21KU09OID0gZnVuY3Rpb24gKGpzb24pIHtcclxuICAgICAgICB2YXIgbGFiZWxlZERlc2NyaXB0b3JzID0ganNvbi5sYWJlbGVkRGVzY3JpcHRvcnNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGQpIHsgcmV0dXJuIExhYmVsZWRGYWNlRGVzY3JpcHRvcnMuZnJvbUpTT04obGQpOyB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IEZhY2VNYXRjaGVyKGxhYmVsZWREZXNjcmlwdG9ycywganNvbi5kaXN0YW5jZVRocmVzaG9sZCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZhY2VNYXRjaGVyO1xyXG59KCkpO1xyXG5leHBvcnQgeyBGYWNlTWF0Y2hlciB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYWNlTWF0Y2hlci5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZXh0ZW5kcywgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgZXh0ZW5kV2l0aEFnZSB9IGZyb20gJy4uL2ZhY3Rvcmllcy9XaXRoQWdlJztcclxuaW1wb3J0IHsgZXh0ZW5kV2l0aEdlbmRlciB9IGZyb20gJy4uL2ZhY3Rvcmllcy9XaXRoR2VuZGVyJztcclxuaW1wb3J0IHsgQ29tcG9zYWJsZVRhc2sgfSBmcm9tICcuL0NvbXBvc2FibGVUYXNrJztcclxuaW1wb3J0IHsgQ29tcHV0ZUFsbEZhY2VEZXNjcmlwdG9yc1Rhc2ssIENvbXB1dGVTaW5nbGVGYWNlRGVzY3JpcHRvclRhc2sgfSBmcm9tICcuL0NvbXB1dGVGYWNlRGVzY3JpcHRvcnNUYXNrcyc7XHJcbmltcG9ydCB7IGV4dHJhY3RBbGxGYWNlc0FuZENvbXB1dGVSZXN1bHRzLCBleHRyYWN0U2luZ2xlRmFjZUFuZENvbXB1dGVSZXN1bHQgfSBmcm9tICcuL2V4dHJhY3RGYWNlc0FuZENvbXB1dGVSZXN1bHRzJztcclxuaW1wb3J0IHsgbmV0cyB9IGZyb20gJy4vbmV0cyc7XHJcbmltcG9ydCB7IFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNUYXNrLCBQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrLCBQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zVGFzaywgUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzaywgfSBmcm9tICcuL1ByZWRpY3RGYWNlRXhwcmVzc2lvbnNUYXNrJztcclxudmFyIFByZWRpY3RBZ2VBbmRHZW5kZXJUYXNrQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcmVkaWN0QWdlQW5kR2VuZGVyVGFza0Jhc2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQcmVkaWN0QWdlQW5kR2VuZGVyVGFza0Jhc2UocGFyZW50VGFzaywgaW5wdXQsIGV4dHJhY3RlZEZhY2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5wYXJlbnRUYXNrID0gcGFyZW50VGFzaztcclxuICAgICAgICBfdGhpcy5pbnB1dCA9IGlucHV0O1xyXG4gICAgICAgIF90aGlzLmV4dHJhY3RlZEZhY2VzID0gZXh0cmFjdGVkRmFjZXM7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByZWRpY3RBZ2VBbmRHZW5kZXJUYXNrQmFzZTtcclxufShDb21wb3NhYmxlVGFzaykpO1xyXG5leHBvcnQgeyBQcmVkaWN0QWdlQW5kR2VuZGVyVGFza0Jhc2UgfTtcclxudmFyIFByZWRpY3RBbGxBZ2VBbmRHZW5kZXJUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFByZWRpY3RBbGxBZ2VBbmRHZW5kZXJUYXNrLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUHJlZGljdEFsbEFnZUFuZEdlbmRlclRhc2soKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgUHJlZGljdEFsbEFnZUFuZEdlbmRlclRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRSZXN1bHRzLCBhZ2VBbmRHZW5kZXJCeUZhY2U7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGFyZW50VGFza107XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZXN1bHRzID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleHRyYWN0QWxsRmFjZXNBbmRDb21wdXRlUmVzdWx0cyhwYXJlbnRSZXN1bHRzLCB0aGlzLmlucHV0LCBmdW5jdGlvbiAoZmFjZXMpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoZmFjZXMubWFwKGZ1bmN0aW9uIChmYWNlKSB7IHJldHVybiBuZXRzLmFnZUdlbmRlck5ldC5wcmVkaWN0QWdlQW5kR2VuZGVyKGZhY2UpOyB9KSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0sIHRoaXMuZXh0cmFjdGVkRmFjZXMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZUFuZEdlbmRlckJ5RmFjZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHBhcmVudFJlc3VsdHMubWFwKGZ1bmN0aW9uIChwYXJlbnRSZXN1bHQsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBhZ2VBbmRHZW5kZXJCeUZhY2VbaV0sIGFnZSA9IF9hLmFnZSwgZ2VuZGVyID0gX2EuZ2VuZGVyLCBnZW5kZXJQcm9iYWJpbGl0eSA9IF9hLmdlbmRlclByb2JhYmlsaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHRlbmRXaXRoQWdlKGV4dGVuZFdpdGhHZW5kZXIocGFyZW50UmVzdWx0LCBnZW5kZXIsIGdlbmRlclByb2JhYmlsaXR5KSwgYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUHJlZGljdEFsbEFnZUFuZEdlbmRlclRhc2sucHJvdG90eXBlLndpdGhGYWNlRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zVGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJlZGljdEFsbEFnZUFuZEdlbmRlclRhc2s7XHJcbn0oUHJlZGljdEFnZUFuZEdlbmRlclRhc2tCYXNlKSk7XHJcbmV4cG9ydCB7IFByZWRpY3RBbGxBZ2VBbmRHZW5kZXJUYXNrIH07XHJcbnZhciBQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyVGFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyVGFzaywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJUYXNrKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50UmVzdWx0LCBfYSwgYWdlLCBnZW5kZXIsIGdlbmRlclByb2JhYmlsaXR5O1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBhcmVudFRhc2tdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVzdWx0ID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4dHJhY3RTaW5nbGVGYWNlQW5kQ29tcHV0ZVJlc3VsdChwYXJlbnRSZXN1bHQsIHRoaXMuaW5wdXQsIGZ1bmN0aW9uIChmYWNlKSB7IHJldHVybiBuZXRzLmFnZUdlbmRlck5ldC5wcmVkaWN0QWdlQW5kR2VuZGVyKGZhY2UpOyB9LCB0aGlzLmV4dHJhY3RlZEZhY2VzKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9iLnNlbnQoKSwgYWdlID0gX2EuYWdlLCBnZW5kZXIgPSBfYS5nZW5kZXIsIGdlbmRlclByb2JhYmlsaXR5ID0gX2EuZ2VuZGVyUHJvYmFiaWxpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBleHRlbmRXaXRoQWdlKGV4dGVuZFdpdGhHZW5kZXIocGFyZW50UmVzdWx0LCBnZW5kZXIsIGdlbmRlclByb2JhYmlsaXR5KSwgYWdlKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJUYXNrLnByb3RvdHlwZS53aXRoRmFjZUV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1Rhc2sodGhpcywgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJUYXNrO1xyXG59KFByZWRpY3RBZ2VBbmRHZW5kZXJUYXNrQmFzZSkpO1xyXG5leHBvcnQgeyBQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyVGFzayB9O1xyXG52YXIgUHJlZGljdEFsbEFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcmVkaWN0QWxsQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUHJlZGljdEFsbEFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzaygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrLnByb3RvdHlwZS53aXRoRmFjZUV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrLnByb3RvdHlwZS53aXRoRmFjZURlc2NyaXB0b3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcHV0ZUFsbEZhY2VEZXNjcmlwdG9yc1Rhc2sodGhpcywgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByZWRpY3RBbGxBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2s7XHJcbn0oUHJlZGljdEFsbEFnZUFuZEdlbmRlclRhc2spKTtcclxuZXhwb3J0IHsgUHJlZGljdEFsbEFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzayB9O1xyXG52YXIgUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzaygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrLnByb3RvdHlwZS53aXRoRmFjZUV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICBQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrLnByb3RvdHlwZS53aXRoRmFjZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wdXRlU2luZ2xlRmFjZURlc2NyaXB0b3JUYXNrKHRoaXMsIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcmVkaWN0U2luZ2xlQWdlQW5kR2VuZGVyV2l0aEZhY2VBbGlnbm1lbnRUYXNrO1xyXG59KFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJUYXNrKSk7XHJcbmV4cG9ydCB7IFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2sgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJlZGljdEFnZUFuZEdlbmRlclRhc2suanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2V4dGVuZHMsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IGV4dGVuZFdpdGhGYWNlRXhwcmVzc2lvbnMgfSBmcm9tICcuLi9mYWN0b3JpZXMvV2l0aEZhY2VFeHByZXNzaW9ucyc7XHJcbmltcG9ydCB7IENvbXBvc2FibGVUYXNrIH0gZnJvbSAnLi9Db21wb3NhYmxlVGFzayc7XHJcbmltcG9ydCB7IENvbXB1dGVBbGxGYWNlRGVzY3JpcHRvcnNUYXNrLCBDb21wdXRlU2luZ2xlRmFjZURlc2NyaXB0b3JUYXNrIH0gZnJvbSAnLi9Db21wdXRlRmFjZURlc2NyaXB0b3JzVGFza3MnO1xyXG5pbXBvcnQgeyBleHRyYWN0QWxsRmFjZXNBbmRDb21wdXRlUmVzdWx0cywgZXh0cmFjdFNpbmdsZUZhY2VBbmRDb21wdXRlUmVzdWx0IH0gZnJvbSAnLi9leHRyYWN0RmFjZXNBbmRDb21wdXRlUmVzdWx0cyc7XHJcbmltcG9ydCB7IG5ldHMgfSBmcm9tICcuL25ldHMnO1xyXG5pbXBvcnQgeyBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyVGFzaywgUHJlZGljdEFsbEFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzaywgUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlclRhc2ssIFByZWRpY3RTaW5nbGVBZ2VBbmRHZW5kZXJXaXRoRmFjZUFsaWdubWVudFRhc2ssIH0gZnJvbSAnLi9QcmVkaWN0QWdlQW5kR2VuZGVyVGFzayc7XHJcbnZhciBQcmVkaWN0RmFjZUV4cHJlc3Npb25zVGFza0Jhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUHJlZGljdEZhY2VFeHByZXNzaW9uc1Rhc2tCYXNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUHJlZGljdEZhY2VFeHByZXNzaW9uc1Rhc2tCYXNlKHBhcmVudFRhc2ssIGlucHV0LCBleHRyYWN0ZWRGYWNlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMucGFyZW50VGFzayA9IHBhcmVudFRhc2s7XHJcbiAgICAgICAgX3RoaXMuaW5wdXQgPSBpbnB1dDtcclxuICAgICAgICBfdGhpcy5leHRyYWN0ZWRGYWNlcyA9IGV4dHJhY3RlZEZhY2VzO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBQcmVkaWN0RmFjZUV4cHJlc3Npb25zVGFza0Jhc2U7XHJcbn0oQ29tcG9zYWJsZVRhc2spKTtcclxuZXhwb3J0IHsgUHJlZGljdEZhY2VFeHByZXNzaW9uc1Rhc2tCYXNlIH07XHJcbnZhciBQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zVGFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zVGFzaywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNUYXNrKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50UmVzdWx0cywgZmFjZUV4cHJlc3Npb25zQnlGYWNlO1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBhcmVudFRhc2tdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVzdWx0cyA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXh0cmFjdEFsbEZhY2VzQW5kQ29tcHV0ZVJlc3VsdHMocGFyZW50UmVzdWx0cywgdGhpcy5pbnB1dCwgZnVuY3Rpb24gKGZhY2VzKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKGZhY2VzLm1hcChmdW5jdGlvbiAoZmFjZSkgeyByZXR1cm4gbmV0cy5mYWNlRXhwcmVzc2lvbk5ldC5wcmVkaWN0RXhwcmVzc2lvbnMoZmFjZSk7IH0pKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSwgdGhpcy5leHRyYWN0ZWRGYWNlcyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUV4cHJlc3Npb25zQnlGYWNlID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcGFyZW50UmVzdWx0cy5tYXAoZnVuY3Rpb24gKHBhcmVudFJlc3VsdCwgaSkgeyByZXR1cm4gZXh0ZW5kV2l0aEZhY2VFeHByZXNzaW9ucyhwYXJlbnRSZXN1bHQsIGZhY2VFeHByZXNzaW9uc0J5RmFjZVtpXSk7IH0pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1Rhc2sucHJvdG90eXBlLndpdGhBZ2VBbmRHZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWN0QWxsQWdlQW5kR2VuZGVyVGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1Rhc2s7XHJcbn0oUHJlZGljdEZhY2VFeHByZXNzaW9uc1Rhc2tCYXNlKSk7XHJcbmV4cG9ydCB7IFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNUYXNrIH07XHJcbnZhciBQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zVGFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zVGFzaywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNUYXNrKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50UmVzdWx0LCBmYWNlRXhwcmVzc2lvbnM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGFyZW50VGFza107XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZXN1bHQgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50UmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXh0cmFjdFNpbmdsZUZhY2VBbmRDb21wdXRlUmVzdWx0KHBhcmVudFJlc3VsdCwgdGhpcy5pbnB1dCwgZnVuY3Rpb24gKGZhY2UpIHsgcmV0dXJuIG5ldHMuZmFjZUV4cHJlc3Npb25OZXQucHJlZGljdEV4cHJlc3Npb25zKGZhY2UpOyB9LCB0aGlzLmV4dHJhY3RlZEZhY2VzKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlRXhwcmVzc2lvbnMgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBleHRlbmRXaXRoRmFjZUV4cHJlc3Npb25zKHBhcmVudFJlc3VsdCwgZmFjZUV4cHJlc3Npb25zKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNUYXNrLnByb3RvdHlwZS53aXRoQWdlQW5kR2VuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlclRhc2sodGhpcywgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNUYXNrO1xyXG59KFByZWRpY3RGYWNlRXhwcmVzc2lvbnNUYXNrQmFzZSkpO1xyXG5leHBvcnQgeyBQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zVGFzayB9O1xyXG52YXIgUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzaygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrLnByb3RvdHlwZS53aXRoQWdlQW5kR2VuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdEFsbEFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICBQcmVkaWN0QWxsRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrLnByb3RvdHlwZS53aXRoRmFjZURlc2NyaXB0b3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcHV0ZUFsbEZhY2VEZXNjcmlwdG9yc1Rhc2sodGhpcywgdGhpcy5pbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByZWRpY3RBbGxGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2s7XHJcbn0oUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1Rhc2spKTtcclxuZXhwb3J0IHsgUHJlZGljdEFsbEZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzayB9O1xyXG52YXIgUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUHJlZGljdFNpbmdsZUZhY2VFeHByZXNzaW9uc1dpdGhGYWNlQWxpZ25tZW50VGFzaygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrLnByb3RvdHlwZS53aXRoQWdlQW5kR2VuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlZGljdFNpbmdsZUFnZUFuZEdlbmRlcldpdGhGYWNlQWxpZ25tZW50VGFzayh0aGlzLCB0aGlzLmlucHV0KTtcclxuICAgIH07XHJcbiAgICBQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrLnByb3RvdHlwZS53aXRoRmFjZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wdXRlU2luZ2xlRmFjZURlc2NyaXB0b3JUYXNrKHRoaXMsIHRoaXMuaW5wdXQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcmVkaWN0U2luZ2xlRmFjZUV4cHJlc3Npb25zV2l0aEZhY2VBbGlnbm1lbnRUYXNrO1xyXG59KFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNUYXNrKSk7XHJcbmV4cG9ydCB7IFByZWRpY3RTaW5nbGVGYWNlRXhwcmVzc2lvbnNXaXRoRmFjZUFsaWdubWVudFRhc2sgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJlZGljdEZhY2VFeHByZXNzaW9uc1Rhc2suanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBNdGNubk9wdGlvbnMgfSBmcm9tICcuLi9tdGNubi9NdGNubk9wdGlvbnMnO1xyXG5pbXBvcnQgeyBTc2RNb2JpbGVuZXR2MU9wdGlvbnMgfSBmcm9tICcuLi9zc2RNb2JpbGVuZXR2MSc7XHJcbmltcG9ydCB7IFRpbnlZb2xvdjJPcHRpb25zIH0gZnJvbSAnLi4vdGlueVlvbG92Mic7XHJcbmltcG9ydCB7IGRldGVjdEFsbEZhY2VzIH0gZnJvbSAnLi9kZXRlY3RGYWNlcyc7XHJcbi8vIGV4cG9ydCBhbGxGYWNlcyBBUEkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuZXhwb3J0IGZ1bmN0aW9uIGFsbEZhY2VzU3NkTW9iaWxlbmV0djEoaW5wdXQsIG1pbkNvbmZpZGVuY2UpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FsbEZhY2VzU3NkTW9iaWxlbmV0djEgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIHNvb24sIHVzZSB0aGUgaGlnaCBsZXZlbCBhcGkgaW5zdGVhZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGRldGVjdEFsbEZhY2VzKGlucHV0LCBuZXcgU3NkTW9iaWxlbmV0djFPcHRpb25zKG1pbkNvbmZpZGVuY2UgPyB7IG1pbkNvbmZpZGVuY2U6IG1pbkNvbmZpZGVuY2UgfSA6IHt9KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoRmFjZUxhbmRtYXJrcygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aEZhY2VEZXNjcmlwdG9ycygpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBhbGxGYWNlc1RpbnlZb2xvdjIoaW5wdXQsIGZvcndhcmRQYXJhbXMpIHtcclxuICAgIGlmIChmb3J3YXJkUGFyYW1zID09PSB2b2lkIDApIHsgZm9yd2FyZFBhcmFtcyA9IHt9OyB9XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhbGxGYWNlc1RpbnlZb2xvdjIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIHNvb24sIHVzZSB0aGUgaGlnaCBsZXZlbCBhcGkgaW5zdGVhZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGRldGVjdEFsbEZhY2VzKGlucHV0LCBuZXcgVGlueVlvbG92Mk9wdGlvbnMoZm9yd2FyZFBhcmFtcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAud2l0aEZhY2VMYW5kbWFya3MoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhGYWNlRGVzY3JpcHRvcnMoKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gYWxsRmFjZXNNdGNubihpbnB1dCwgZm9yd2FyZFBhcmFtcykge1xyXG4gICAgaWYgKGZvcndhcmRQYXJhbXMgPT09IHZvaWQgMCkgeyBmb3J3YXJkUGFyYW1zID0ge307IH1cclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FsbEZhY2VzTXRjbm4gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIHNvb24sIHVzZSB0aGUgaGlnaCBsZXZlbCBhcGkgaW5zdGVhZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGRldGVjdEFsbEZhY2VzKGlucHV0LCBuZXcgTXRjbm5PcHRpb25zKGZvcndhcmRQYXJhbXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhGYWNlTGFuZG1hcmtzKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoRmFjZURlc2NyaXB0b3JzKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0IHZhciBhbGxGYWNlcyA9IGFsbEZhY2VzU3NkTW9iaWxlbmV0djE7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsbEZhY2VzLmpzLm1hcCIsImltcG9ydCB7IFNzZE1vYmlsZW5ldHYxT3B0aW9ucyB9IGZyb20gJy4uL3NzZE1vYmlsZW5ldHYxL1NzZE1vYmlsZW5ldHYxT3B0aW9ucyc7XHJcbmltcG9ydCB7IERldGVjdEFsbEZhY2VzVGFzaywgRGV0ZWN0U2luZ2xlRmFjZVRhc2sgfSBmcm9tICcuL0RldGVjdEZhY2VzVGFza3MnO1xyXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0U2luZ2xlRmFjZShpbnB1dCwgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gbmV3IFNzZE1vYmlsZW5ldHYxT3B0aW9ucygpOyB9XHJcbiAgICByZXR1cm4gbmV3IERldGVjdFNpbmdsZUZhY2VUYXNrKGlucHV0LCBvcHRpb25zKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0QWxsRmFjZXMoaW5wdXQsIG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG5ldyBTc2RNb2JpbGVuZXR2MU9wdGlvbnMoKTsgfVxyXG4gICAgcmV0dXJuIG5ldyBEZXRlY3RBbGxGYWNlc1Rhc2soaW5wdXQsIG9wdGlvbnMpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdEZhY2VzLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgZXh0cmFjdEZhY2VzLCBleHRyYWN0RmFjZVRlbnNvcnMgfSBmcm9tICcuLi9kb20nO1xyXG5pbXBvcnQgeyBpc1dpdGhGYWNlTGFuZG1hcmtzIH0gZnJvbSAnLi4vZmFjdG9yaWVzL1dpdGhGYWNlTGFuZG1hcmtzJztcclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RBbGxGYWNlc0FuZENvbXB1dGVSZXN1bHRzKHBhcmVudFJlc3VsdHMsIGlucHV0LCBjb21wdXRlUmVzdWx0cywgZXh0cmFjdGVkRmFjZXMsIGdldFJlY3RGb3JBbGlnbm1lbnQpIHtcclxuICAgIGlmIChnZXRSZWN0Rm9yQWxpZ25tZW50ID09PSB2b2lkIDApIHsgZ2V0UmVjdEZvckFsaWdubWVudCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBhbGlnbmVkUmVjdCA9IF9hLmFsaWduZWRSZWN0O1xyXG4gICAgICAgIHJldHVybiBhbGlnbmVkUmVjdDtcclxuICAgIH07IH1cclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZmFjZUJveGVzLCBmYWNlcywgX2EsIF9iLCByZXN1bHRzO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGZhY2VCb3hlcyA9IHBhcmVudFJlc3VsdHMubWFwKGZ1bmN0aW9uIChwYXJlbnRSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzV2l0aEZhY2VMYW5kbWFya3MocGFyZW50UmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXRSZWN0Rm9yQWxpZ25tZW50KHBhcmVudFJlc3VsdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyZW50UmVzdWx0LmRldGVjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBfYSA9IGV4dHJhY3RlZEZhY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfYSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiB0Zi5UZW5zb3IpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleHRyYWN0RmFjZVRlbnNvcnMoaW5wdXQsIGZhY2VCb3hlcyldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9iID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleHRyYWN0RmFjZXMoaW5wdXQsIGZhY2VCb3hlcyldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIF9iID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gNDtcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICBfYSA9IChfYik7XHJcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA1O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIGZhY2VzID0gX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY29tcHV0ZVJlc3VsdHMoZmFjZXMpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY2VzLmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYgaW5zdGFuY2VvZiB0Zi5UZW5zb3IgJiYgZi5kaXNwb3NlKCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRzXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RTaW5nbGVGYWNlQW5kQ29tcHV0ZVJlc3VsdChwYXJlbnRSZXN1bHQsIGlucHV0LCBjb21wdXRlUmVzdWx0LCBleHRyYWN0ZWRGYWNlcywgZ2V0UmVjdEZvckFsaWdubWVudCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZXh0cmFjdEFsbEZhY2VzQW5kQ29tcHV0ZVJlc3VsdHMoW3BhcmVudFJlc3VsdF0sIGlucHV0LCBmdW5jdGlvbiAoZmFjZXMpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjb21wdXRlUmVzdWx0KGZhY2VzWzBdKV07XHJcbiAgICAgICAgICAgICAgICB9KTsgfSk7IH0sIGV4dHJhY3RlZEZhY2VzLCBnZXRSZWN0Rm9yQWxpZ25tZW50KV07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0RmFjZXNBbmRDb21wdXRlUmVzdWx0cy5qcy5tYXAiLCJleHBvcnQgKiBmcm9tICcuL2FsbEZhY2VzJztcclxuZXhwb3J0ICogZnJvbSAnLi9Db21wb3NhYmxlVGFzayc7XHJcbmV4cG9ydCAqIGZyb20gJy4vQ29tcHV0ZUZhY2VEZXNjcmlwdG9yc1Rhc2tzJztcclxuZXhwb3J0ICogZnJvbSAnLi9kZXRlY3RGYWNlcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vRGV0ZWN0RmFjZXNUYXNrcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vRGV0ZWN0RmFjZUxhbmRtYXJrc1Rhc2tzJztcclxuZXhwb3J0ICogZnJvbSAnLi9GYWNlTWF0Y2hlcic7XHJcbmV4cG9ydCAqIGZyb20gJy4vbmV0cyc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IEFnZUdlbmRlck5ldCB9IGZyb20gJy4uL2FnZUdlbmRlck5ldC9BZ2VHZW5kZXJOZXQnO1xyXG5pbXBvcnQgeyBGYWNlRXhwcmVzc2lvbk5ldCB9IGZyb20gJy4uL2ZhY2VFeHByZXNzaW9uTmV0L0ZhY2VFeHByZXNzaW9uTmV0JztcclxuaW1wb3J0IHsgRmFjZUxhbmRtYXJrNjhOZXQgfSBmcm9tICcuLi9mYWNlTGFuZG1hcmtOZXQvRmFjZUxhbmRtYXJrNjhOZXQnO1xyXG5pbXBvcnQgeyBGYWNlTGFuZG1hcms2OFRpbnlOZXQgfSBmcm9tICcuLi9mYWNlTGFuZG1hcmtOZXQvRmFjZUxhbmRtYXJrNjhUaW55TmV0JztcclxuaW1wb3J0IHsgRmFjZVJlY29nbml0aW9uTmV0IH0gZnJvbSAnLi4vZmFjZVJlY29nbml0aW9uTmV0L0ZhY2VSZWNvZ25pdGlvbk5ldCc7XHJcbmltcG9ydCB7IE10Y25uIH0gZnJvbSAnLi4vbXRjbm4vTXRjbm4nO1xyXG5pbXBvcnQgeyBTc2RNb2JpbGVuZXR2MSB9IGZyb20gJy4uL3NzZE1vYmlsZW5ldHYxL1NzZE1vYmlsZW5ldHYxJztcclxuaW1wb3J0IHsgVGlueUZhY2VEZXRlY3RvciB9IGZyb20gJy4uL3RpbnlGYWNlRGV0ZWN0b3IvVGlueUZhY2VEZXRlY3Rvcic7XHJcbmltcG9ydCB7IFRpbnlZb2xvdjIgfSBmcm9tICcuLi90aW55WW9sb3YyJztcclxuZXhwb3J0IHZhciBuZXRzID0ge1xyXG4gICAgc3NkTW9iaWxlbmV0djE6IG5ldyBTc2RNb2JpbGVuZXR2MSgpLFxyXG4gICAgdGlueUZhY2VEZXRlY3RvcjogbmV3IFRpbnlGYWNlRGV0ZWN0b3IoKSxcclxuICAgIHRpbnlZb2xvdjI6IG5ldyBUaW55WW9sb3YyKCksXHJcbiAgICBtdGNubjogbmV3IE10Y25uKCksXHJcbiAgICBmYWNlTGFuZG1hcms2OE5ldDogbmV3IEZhY2VMYW5kbWFyazY4TmV0KCksXHJcbiAgICBmYWNlTGFuZG1hcms2OFRpbnlOZXQ6IG5ldyBGYWNlTGFuZG1hcms2OFRpbnlOZXQoKSxcclxuICAgIGZhY2VSZWNvZ25pdGlvbk5ldDogbmV3IEZhY2VSZWNvZ25pdGlvbk5ldCgpLFxyXG4gICAgZmFjZUV4cHJlc3Npb25OZXQ6IG5ldyBGYWNlRXhwcmVzc2lvbk5ldCgpLFxyXG4gICAgYWdlR2VuZGVyTmV0OiBuZXcgQWdlR2VuZGVyTmV0KClcclxufTtcclxuLyoqXHJcbiAqIEF0dGVtcHRzIHRvIGRldGVjdCBhbGwgZmFjZXMgaW4gYW4gaW1hZ2UgdXNpbmcgU1NEIE1vYmlsZW5ldHYxIE5ldHdvcmsuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgaW1hZ2UuXHJcbiAqIEBwYXJhbSBvcHRpb25zIChvcHRpb25hbCwgZGVmYXVsdDogc2VlIFNzZE1vYmlsZW5ldHYxT3B0aW9ucyBjb25zdHJ1Y3RvciBmb3IgZGVmYXVsdCBwYXJhbWV0ZXJzKS5cclxuICogQHJldHVybnMgQm91bmRpbmcgYm94IG9mIGVhY2ggZmFjZSB3aXRoIHNjb3JlLlxyXG4gKi9cclxuZXhwb3J0IHZhciBzc2RNb2JpbGVuZXR2MSA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldHMuc3NkTW9iaWxlbmV0djEubG9jYXRlRmFjZXMoaW5wdXQsIG9wdGlvbnMpO1xyXG59O1xyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gZGV0ZWN0IGFsbCBmYWNlcyBpbiBhbiBpbWFnZSB1c2luZyB0aGUgVGlueSBGYWNlIERldGVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IGltYWdlLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyAob3B0aW9uYWwsIGRlZmF1bHQ6IHNlZSBUaW55RmFjZURldGVjdG9yT3B0aW9ucyBjb25zdHJ1Y3RvciBmb3IgZGVmYXVsdCBwYXJhbWV0ZXJzKS5cclxuICogQHJldHVybnMgQm91bmRpbmcgYm94IG9mIGVhY2ggZmFjZSB3aXRoIHNjb3JlLlxyXG4gKi9cclxuZXhwb3J0IHZhciB0aW55RmFjZURldGVjdG9yID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV0cy50aW55RmFjZURldGVjdG9yLmxvY2F0ZUZhY2VzKGlucHV0LCBvcHRpb25zKTtcclxufTtcclxuLyoqXHJcbiAqIEF0dGVtcHRzIHRvIGRldGVjdCBhbGwgZmFjZXMgaW4gYW4gaW1hZ2UgdXNpbmcgdGhlIFRpbnkgWW9sb3YyIE5ldHdvcmsuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgaW1hZ2UuXHJcbiAqIEBwYXJhbSBvcHRpb25zIChvcHRpb25hbCwgZGVmYXVsdDogc2VlIFRpbnlZb2xvdjJPcHRpb25zIGNvbnN0cnVjdG9yIGZvciBkZWZhdWx0IHBhcmFtZXRlcnMpLlxyXG4gKiBAcmV0dXJucyBCb3VuZGluZyBib3ggb2YgZWFjaCBmYWNlIHdpdGggc2NvcmUuXHJcbiAqL1xyXG5leHBvcnQgdmFyIHRpbnlZb2xvdjIgPSBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBuZXRzLnRpbnlZb2xvdjIubG9jYXRlRmFjZXMoaW5wdXQsIG9wdGlvbnMpO1xyXG59O1xyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gZGV0ZWN0IGFsbCBmYWNlcyBpbiBhbiBpbWFnZSBhbmQgdGhlIDUgcG9pbnQgZmFjZSBsYW5kbWFya3NcclxuICogb2YgZWFjaCBkZXRlY3RlZCBmYWNlIHVzaW5nIHRoZSBNVENOTiBOZXR3b3JrLlxyXG4gKlxyXG4gKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IGltYWdlLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyAob3B0aW9uYWwsIGRlZmF1bHQ6IHNlZSBNdGNubk9wdGlvbnMgY29uc3RydWN0b3IgZm9yIGRlZmF1bHQgcGFyYW1ldGVycykuXHJcbiAqIEByZXR1cm5zIEJvdW5kaW5nIGJveCBvZiBlYWNoIGZhY2Ugd2l0aCBzY29yZSBhbmQgNSBwb2ludCBmYWNlIGxhbmRtYXJrcy5cclxuICovXHJcbmV4cG9ydCB2YXIgbXRjbm4gPSBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBuZXRzLm10Y25uLmZvcndhcmQoaW5wdXQsIG9wdGlvbnMpO1xyXG59O1xyXG4vKipcclxuICogRGV0ZWN0cyB0aGUgNjggcG9pbnQgZmFjZSBsYW5kbWFyayBwb3NpdGlvbnMgb2YgdGhlIGZhY2Ugc2hvd24gaW4gYW4gaW1hZ2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dHMgVGhlIGZhY2UgaW1hZ2UgZXh0cmFjdGVkIGZyb20gdGhlIGJvdW5kaW5nIGJveCBvZiBhIGZhY2UuIENhblxyXG4gKiBhbHNvIGJlIGFuIGFycmF5IG9mIGlucHV0IGltYWdlcywgd2hpY2ggd2lsbCBiZSBiYXRjaCBwcm9jZXNzZWQuXHJcbiAqIEByZXR1cm5zIDY4IHBvaW50IGZhY2UgbGFuZG1hcmtzIG9yIGFycmF5IHRoZXJlb2YgaW4gY2FzZSBvZiBiYXRjaCBpbnB1dC5cclxuICovXHJcbmV4cG9ydCB2YXIgZGV0ZWN0RmFjZUxhbmRtYXJrcyA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgcmV0dXJuIG5ldHMuZmFjZUxhbmRtYXJrNjhOZXQuZGV0ZWN0TGFuZG1hcmtzKGlucHV0KTtcclxufTtcclxuLyoqXHJcbiAqIERldGVjdHMgdGhlIDY4IHBvaW50IGZhY2UgbGFuZG1hcmsgcG9zaXRpb25zIG9mIHRoZSBmYWNlIHNob3duIGluIGFuIGltYWdlXHJcbiAqIHVzaW5nIGEgdGluaWVyIHZlcnNpb24gb2YgdGhlIDY4IHBvaW50IGZhY2UgbGFuZG1hcmsgbW9kZWwsIHdoaWNoIGlzIHNsaWdodGx5XHJcbiAqIGZhc3RlciBhdCBpbmZlcmVuY2UsIGJ1dCBhbHNvIHNsaWdodGx5IGxlc3MgYWNjdXJhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dHMgVGhlIGZhY2UgaW1hZ2UgZXh0cmFjdGVkIGZyb20gdGhlIGJvdW5kaW5nIGJveCBvZiBhIGZhY2UuIENhblxyXG4gKiBhbHNvIGJlIGFuIGFycmF5IG9mIGlucHV0IGltYWdlcywgd2hpY2ggd2lsbCBiZSBiYXRjaCBwcm9jZXNzZWQuXHJcbiAqIEByZXR1cm5zIDY4IHBvaW50IGZhY2UgbGFuZG1hcmtzIG9yIGFycmF5IHRoZXJlb2YgaW4gY2FzZSBvZiBiYXRjaCBpbnB1dC5cclxuICovXHJcbmV4cG9ydCB2YXIgZGV0ZWN0RmFjZUxhbmRtYXJrc1RpbnkgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgIHJldHVybiBuZXRzLmZhY2VMYW5kbWFyazY4VGlueU5ldC5kZXRlY3RMYW5kbWFya3MoaW5wdXQpO1xyXG59O1xyXG4vKipcclxuICogQ29tcHV0ZXMgYSAxMjggZW50cnkgdmVjdG9yIChmYWNlIGRlc2NyaXB0b3IgLyBmYWNlIGVtYmVkZGluZ3MpIGZyb20gdGhlIGZhY2Ugc2hvd24gaW4gYW4gaW1hZ2UsXHJcbiAqIHdoaWNoIHVuaXF1ZWx5IHJlcHJlc2VudHMgdGhlIGZlYXR1cmVzIG9mIHRoYXQgcGVyc29ucyBmYWNlLiBUaGUgY29tcHV0ZWQgZmFjZSBkZXNjcmlwdG9yIGNhblxyXG4gKiBiZSB1c2VkIHRvIG1lYXN1cmUgdGhlIHNpbWlsYXJpdHkgYmV0d2VlbiBmYWNlcywgYnkgY29tcHV0aW5nIHRoZSBldWNsaWRlYW4gZGlzdGFuY2Ugb2YgdHdvXHJcbiAqIGZhY2UgZGVzY3JpcHRvcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dHMgVGhlIGZhY2UgaW1hZ2UgZXh0cmFjdGVkIGZyb20gdGhlIGFsaWduZWQgYm91bmRpbmcgYm94IG9mIGEgZmFjZS4gQ2FuXHJcbiAqIGFsc28gYmUgYW4gYXJyYXkgb2YgaW5wdXQgaW1hZ2VzLCB3aGljaCB3aWxsIGJlIGJhdGNoIHByb2Nlc3NlZC5cclxuICogQHJldHVybnMgRmFjZSBkZXNjcmlwdG9yIHdpdGggMTI4IGVudHJpZXMgb3IgYXJyYXkgdGhlcmVvZiBpbiBjYXNlIG9mIGJhdGNoIGlucHV0LlxyXG4gKi9cclxuZXhwb3J0IHZhciBjb21wdXRlRmFjZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgIHJldHVybiBuZXRzLmZhY2VSZWNvZ25pdGlvbk5ldC5jb21wdXRlRmFjZURlc2NyaXB0b3IoaW5wdXQpO1xyXG59O1xyXG4vKipcclxuICogUmVjb2duaXplcyB0aGUgZmFjaWFsIGV4cHJlc3Npb25zIGZyb20gYSBmYWNlIGltYWdlLlxyXG4gKlxyXG4gKiBAcGFyYW0gaW5wdXRzIFRoZSBmYWNlIGltYWdlIGV4dHJhY3RlZCBmcm9tIHRoZSBib3VuZGluZyBib3ggb2YgYSBmYWNlLiBDYW5cclxuICogYWxzbyBiZSBhbiBhcnJheSBvZiBpbnB1dCBpbWFnZXMsIHdoaWNoIHdpbGwgYmUgYmF0Y2ggcHJvY2Vzc2VkLlxyXG4gKiBAcmV0dXJucyBGYWNpYWwgZXhwcmVzc2lvbnMgd2l0aCBjb3JyZXNwb25kaW5nIHByb2JhYmlsaXRpZXMgb3IgYXJyYXkgdGhlcmVvZiBpbiBjYXNlIG9mIGJhdGNoIGlucHV0LlxyXG4gKi9cclxuZXhwb3J0IHZhciByZWNvZ25pemVGYWNlRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgIHJldHVybiBuZXRzLmZhY2VFeHByZXNzaW9uTmV0LnByZWRpY3RFeHByZXNzaW9ucyhpbnB1dCk7XHJcbn07XHJcbi8qKlxyXG4gKiBQcmVkaWN0cyBhZ2UgYW5kIGdlbmRlciBmcm9tIGEgZmFjZSBpbWFnZS5cclxuICpcclxuICogQHBhcmFtIGlucHV0cyBUaGUgZmFjZSBpbWFnZSBleHRyYWN0ZWQgZnJvbSB0aGUgYm91bmRpbmcgYm94IG9mIGEgZmFjZS4gQ2FuXHJcbiAqIGFsc28gYmUgYW4gYXJyYXkgb2YgaW5wdXQgaW1hZ2VzLCB3aGljaCB3aWxsIGJlIGJhdGNoIHByb2Nlc3NlZC5cclxuICogQHJldHVybnMgUHJlZGljdGlvbnMgd2l0aCBhZ2UsIGdlbmRlciBhbmQgZ2VuZGVyIHByb2JhYmlsaXR5IG9yIGFycmF5IHRoZXJlb2YgaW4gY2FzZSBvZiBiYXRjaCBpbnB1dC5cclxuICovXHJcbmV4cG9ydCB2YXIgcHJlZGljdEFnZUFuZEdlbmRlciA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgcmV0dXJuIG5ldHMuYWdlR2VuZGVyTmV0LnByZWRpY3RBZ2VBbmRHZW5kZXIoaW5wdXQpO1xyXG59O1xyXG5leHBvcnQgdmFyIGxvYWRTc2RNb2JpbGVuZXR2MU1vZGVsID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gbmV0cy5zc2RNb2JpbGVuZXR2MS5sb2FkKHVybCk7IH07XHJcbmV4cG9ydCB2YXIgbG9hZFRpbnlGYWNlRGV0ZWN0b3JNb2RlbCA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIG5ldHMudGlueUZhY2VEZXRlY3Rvci5sb2FkKHVybCk7IH07XHJcbmV4cG9ydCB2YXIgbG9hZE10Y25uTW9kZWwgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBuZXRzLm10Y25uLmxvYWQodXJsKTsgfTtcclxuZXhwb3J0IHZhciBsb2FkVGlueVlvbG92Mk1vZGVsID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gbmV0cy50aW55WW9sb3YyLmxvYWQodXJsKTsgfTtcclxuZXhwb3J0IHZhciBsb2FkRmFjZUxhbmRtYXJrTW9kZWwgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBuZXRzLmZhY2VMYW5kbWFyazY4TmV0LmxvYWQodXJsKTsgfTtcclxuZXhwb3J0IHZhciBsb2FkRmFjZUxhbmRtYXJrVGlueU1vZGVsID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gbmV0cy5mYWNlTGFuZG1hcms2OFRpbnlOZXQubG9hZCh1cmwpOyB9O1xyXG5leHBvcnQgdmFyIGxvYWRGYWNlUmVjb2duaXRpb25Nb2RlbCA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIG5ldHMuZmFjZVJlY29nbml0aW9uTmV0LmxvYWQodXJsKTsgfTtcclxuZXhwb3J0IHZhciBsb2FkRmFjZUV4cHJlc3Npb25Nb2RlbCA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIG5ldHMuZmFjZUV4cHJlc3Npb25OZXQubG9hZCh1cmwpOyB9O1xyXG5leHBvcnQgdmFyIGxvYWRBZ2VHZW5kZXJNb2RlbCA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIG5ldHMuYWdlR2VuZGVyTmV0LmxvYWQodXJsKTsgfTtcclxuLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG5leHBvcnQgdmFyIGxvYWRGYWNlRGV0ZWN0aW9uTW9kZWwgPSBsb2FkU3NkTW9iaWxlbmV0djFNb2RlbDtcclxuZXhwb3J0IHZhciBsb2NhdGVGYWNlcyA9IHNzZE1vYmlsZW5ldHYxO1xyXG5leHBvcnQgdmFyIGRldGVjdExhbmRtYXJrcyA9IGRldGVjdEZhY2VMYW5kbWFya3M7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHMuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0ICogYXMgZHJhdyBmcm9tICcuL2RyYXcnO1xyXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzJztcclxuZXhwb3J0IHsgZHJhdywgdXRpbHMsIHRmIH07XHJcbmV4cG9ydCAqIGZyb20gJy4vYWdlR2VuZGVyTmV0L2luZGV4JztcclxuZXhwb3J0ICogZnJvbSAnLi9jbGFzc2VzL2luZGV4JztcclxuZXhwb3J0ICogZnJvbSAnLi9kb20vaW5kZXgnO1xyXG5leHBvcnQgKiBmcm9tICcuL2Vudi9pbmRleCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZmFjZUV4cHJlc3Npb25OZXQvaW5kZXgnO1xyXG5leHBvcnQgKiBmcm9tICcuL2ZhY2VMYW5kbWFya05ldC9pbmRleCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZmFjZVJlY29nbml0aW9uTmV0L2luZGV4JztcclxuZXhwb3J0ICogZnJvbSAnLi9mYWN0b3JpZXMvaW5kZXgnO1xyXG5leHBvcnQgKiBmcm9tICcuL2dsb2JhbEFwaS9pbmRleCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vbXRjbm4vaW5kZXgnO1xyXG5leHBvcnQgKiBmcm9tICcuL29wcy9pbmRleCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vc3NkTW9iaWxlbmV0djEvaW5kZXgnO1xyXG5leHBvcnQgKiBmcm9tICcuL3RpbnlGYWNlRGV0ZWN0b3IvaW5kZXgnO1xyXG5leHBvcnQgKiBmcm9tICcuL3RpbnlZb2xvdjIvaW5kZXgnO1xyXG5leHBvcnQgKiBmcm9tICcuL2V1Y2xpZGVhbkRpc3RhbmNlJztcclxuZXhwb3J0ICogZnJvbSAnLi9OZXVyYWxOZXR3b3JrJztcclxuZXhwb3J0ICogZnJvbSAnLi9yZXNpemVSZXN1bHRzJztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2V4dGVuZHMsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IFBvaW50LCBSZWN0IH0gZnJvbSAnLi4vY2xhc3Nlcyc7XHJcbmltcG9ydCB7IEZhY2VEZXRlY3Rpb24gfSBmcm9tICcuLi9jbGFzc2VzL0ZhY2VEZXRlY3Rpb24nO1xyXG5pbXBvcnQgeyBGYWNlTGFuZG1hcmtzNSB9IGZyb20gJy4uL2NsYXNzZXMvRmFjZUxhbmRtYXJrczUnO1xyXG5pbXBvcnQgeyB0b05ldElucHV0IH0gZnJvbSAnLi4vZG9tJztcclxuaW1wb3J0IHsgZXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24sIGV4dGVuZFdpdGhGYWNlTGFuZG1hcmtzIH0gZnJvbSAnLi4vZmFjdG9yaWVzJztcclxuaW1wb3J0IHsgTmV1cmFsTmV0d29yayB9IGZyb20gJy4uL05ldXJhbE5ldHdvcmsnO1xyXG5pbXBvcnQgeyBiZ3JUb1JnYlRlbnNvciB9IGZyb20gJy4vYmdyVG9SZ2JUZW5zb3InO1xyXG5pbXBvcnQgeyBDRUxMX1NJWkUgfSBmcm9tICcuL2NvbmZpZyc7XHJcbmltcG9ydCB7IGV4dHJhY3RQYXJhbXMgfSBmcm9tICcuL2V4dHJhY3RQYXJhbXMnO1xyXG5pbXBvcnQgeyBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCB9IGZyb20gJy4vZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAnO1xyXG5pbXBvcnQgeyBnZXRTaXplc0ZvclNjYWxlIH0gZnJvbSAnLi9nZXRTaXplc0ZvclNjYWxlJztcclxuaW1wb3J0IHsgTXRjbm5PcHRpb25zIH0gZnJvbSAnLi9NdGNubk9wdGlvbnMnO1xyXG5pbXBvcnQgeyBweXJhbWlkRG93biB9IGZyb20gJy4vcHlyYW1pZERvd24nO1xyXG5pbXBvcnQgeyBzdGFnZTEgfSBmcm9tICcuL3N0YWdlMSc7XHJcbmltcG9ydCB7IHN0YWdlMiB9IGZyb20gJy4vc3RhZ2UyJztcclxuaW1wb3J0IHsgc3RhZ2UzIH0gZnJvbSAnLi9zdGFnZTMnO1xyXG52YXIgTXRjbm4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTXRjbm4sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNdGNubigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ010Y25uJykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIE10Y25uLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHdlaWdodHNPclVybCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdtdGNubiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgc29vbicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9zdXBlci5wcm90b3R5cGUubG9hZC5jYWxsKHRoaXMsIHdlaWdodHNPclVybCldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNdGNubi5wcm90b3R5cGUubG9hZEZyb21EaXNrID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ210Y25uIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBzb29uJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgX3N1cGVyLnByb3RvdHlwZS5sb2FkRnJvbURpc2suY2FsbCh0aGlzLCBmaWxlUGF0aCldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNdGNubi5wcm90b3R5cGUuZm9yd2FyZElucHV0ID0gZnVuY3Rpb24gKGlucHV0LCBmb3J3YXJkUGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKGZvcndhcmRQYXJhbXMgPT09IHZvaWQgMCkgeyBmb3J3YXJkUGFyYW1zID0ge307IH1cclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMsIGlucHV0Q2FudmFzLCBzdGF0cywgdHNUb3RhbCwgaW1nVGVuc29yLCBvblJldHVybiwgX2EsIGhlaWdodCwgd2lkdGgsIF9iLCBtaW5GYWNlU2l6ZSwgc2NhbGVGYWN0b3IsIG1heE51bVNjYWxlcywgc2NvcmVUaHJlc2hvbGRzLCBzY2FsZVN0ZXBzLCBzY2FsZXMsIHRzLCBvdXQxLCBvdXQyLCBvdXQzLCByZXN1bHRzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB0aGlzLnBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXRjbm4gLSBsb2FkIG1vZGVsIGJlZm9yZSBpbmZlcmVuY2UnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dENhbnZhcyA9IGlucHV0LmNhbnZhc2VzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0Q2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ010Y25uIC0gaW5wdXRDYW52YXMgaXMgbm90IGRlZmluZWQsIG5vdGUgdGhhdCBwYXNzaW5nIHRlbnNvcnMgaW50byBNdGNubi5mb3J3YXJkSW5wdXQgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHNUb3RhbCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1RlbnNvciA9IHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJnclRvUmdiVGVuc29yKHRmLmV4cGFuZERpbXModGYuYnJvd3Nlci5mcm9tUGl4ZWxzKGlucHV0Q2FudmFzKSkudG9GbG9hdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUmV0dXJuID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc3Bvc2UgdGVuc29ycyBvbiByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZ1RlbnNvci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy50b3RhbCA9IERhdGUubm93KCkgLSB0c1RvdGFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gaW1nVGVuc29yLnNoYXBlLnNsaWNlKDEpLCBoZWlnaHQgPSBfYVswXSwgd2lkdGggPSBfYVsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSBuZXcgTXRjbm5PcHRpb25zKGZvcndhcmRQYXJhbXMpLCBtaW5GYWNlU2l6ZSA9IF9iLm1pbkZhY2VTaXplLCBzY2FsZUZhY3RvciA9IF9iLnNjYWxlRmFjdG9yLCBtYXhOdW1TY2FsZXMgPSBfYi5tYXhOdW1TY2FsZXMsIHNjb3JlVGhyZXNob2xkcyA9IF9iLnNjb3JlVGhyZXNob2xkcywgc2NhbGVTdGVwcyA9IF9iLnNjYWxlU3RlcHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlcyA9IChzY2FsZVN0ZXBzIHx8IHB5cmFtaWREb3duKG1pbkZhY2VTaXplLCBzY2FsZUZhY3RvciwgW2hlaWdodCwgd2lkdGhdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZXMgPSBnZXRTaXplc0ZvclNjYWxlKHNjYWxlLCBbaGVpZ2h0LCB3aWR0aF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHNpemVzLndpZHRoLCBzaXplcy5oZWlnaHQpID4gQ0VMTF9TSVpFO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIG1heE51bVNjYWxlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLnNjYWxlcyA9IHNjYWxlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMucHlyYW1pZCA9IHNjYWxlcy5tYXAoZnVuY3Rpb24gKHNjYWxlKSB7IHJldHVybiBnZXRTaXplc0ZvclNjYWxlKHNjYWxlLCBbaGVpZ2h0LCB3aWR0aF0pOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHMgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzdGFnZTEoaW1nVGVuc29yLCBzY2FsZXMsIHNjb3JlVGhyZXNob2xkc1swXSwgcGFyYW1zLnBuZXQsIHN0YXRzKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQxID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy50b3RhbF9zdGFnZTEgPSBEYXRlLm5vdygpIC0gdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3V0MS5ib3hlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBvblJldHVybih7IHJlc3VsdHM6IFtdLCBzdGF0czogc3RhdHMgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLnN0YWdlMl9udW1JbnB1dEJveGVzID0gb3V0MS5ib3hlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIHRoZSBpbnB1dENhbnZhcyB0byBleHRyYWN0IGFuZCByZXNpemUgdGhlIGltYWdlIHBhdGNoZXMsIHNpbmNlIGl0IGlzIGZhc3RlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGFuIGRvaW5nIHRoaXMgb24gdGhlIGdwdVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN0YWdlMihpbnB1dENhbnZhcywgb3V0MS5ib3hlcywgc2NvcmVUaHJlc2hvbGRzWzFdLCBwYXJhbXMucm5ldCwgc3RhdHMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDIgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLnRvdGFsX3N0YWdlMiA9IERhdGUubm93KCkgLSB0cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdXQyLmJveGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG9uUmV0dXJuKHsgcmVzdWx0czogW10sIHN0YXRzOiBzdGF0cyB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMuc3RhZ2UzX251bUlucHV0Qm94ZXMgPSBvdXQyLmJveGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHMgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzdGFnZTMoaW5wdXRDYW52YXMsIG91dDIuYm94ZXMsIHNjb3JlVGhyZXNob2xkc1syXSwgcGFyYW1zLm9uZXQsIHN0YXRzKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQzID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy50b3RhbF9zdGFnZTMgPSBEYXRlLm5vdygpIC0gdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBvdXQzLmJveGVzLm1hcChmdW5jdGlvbiAoYm94LCBpZHgpIHsgcmV0dXJuIGV4dGVuZFdpdGhGYWNlTGFuZG1hcmtzKGV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9uKHt9LCBuZXcgRmFjZURldGVjdGlvbihvdXQzLnNjb3Jlc1tpZHhdLCBuZXcgUmVjdChib3gubGVmdCAvIHdpZHRoLCBib3gudG9wIC8gaGVpZ2h0LCBib3gud2lkdGggLyB3aWR0aCwgYm94LmhlaWdodCAvIGhlaWdodCksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgbmV3IEZhY2VMYW5kbWFya3M1KG91dDMucG9pbnRzW2lkeF0ubWFwKGZ1bmN0aW9uIChwdCkgeyByZXR1cm4gcHQuc3ViKG5ldyBQb2ludChib3gubGVmdCwgYm94LnRvcCkpLmRpdihuZXcgUG9pbnQoYm94LndpZHRoLCBib3guaGVpZ2h0KSk7IH0pLCB7IHdpZHRoOiBib3gud2lkdGgsIGhlaWdodDogYm94LmhlaWdodCB9KSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgb25SZXR1cm4oeyByZXN1bHRzOiByZXN1bHRzLCBzdGF0czogc3RhdHMgfSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNdGNubi5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIChpbnB1dCwgZm9yd2FyZFBhcmFtcykge1xyXG4gICAgICAgIGlmIChmb3J3YXJkUGFyYW1zID09PSB2b2lkIDApIHsgZm9yd2FyZFBhcmFtcyA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcy5mb3J3YXJkSW5wdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRvTmV0SW5wdXQoaW5wdXQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLmFwcGx5KHRoaXMsIFtfYi5zZW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkUGFyYW1zXSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYi5zZW50KCkpLnJlc3VsdHNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNdGNubi5wcm90b3R5cGUuZm9yd2FyZFdpdGhTdGF0cyA9IGZ1bmN0aW9uIChpbnB1dCwgZm9yd2FyZFBhcmFtcykge1xyXG4gICAgICAgIGlmIChmb3J3YXJkUGFyYW1zID09PSB2b2lkIDApIHsgZm9yd2FyZFBhcmFtcyA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcy5mb3J3YXJkSW5wdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRvTmV0SW5wdXQoaW5wdXQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5hcHBseSh0aGlzLCBbX2Iuc2VudCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZFBhcmFtc10pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTXRjbm4ucHJvdG90eXBlLmdldERlZmF1bHRNb2RlbE5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICdtdGNubl9tb2RlbCc7XHJcbiAgICB9O1xyXG4gICAgTXRjbm4ucHJvdG90eXBlLmV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwID0gZnVuY3Rpb24gKHdlaWdodE1hcCkge1xyXG4gICAgICAgIHJldHVybiBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCh3ZWlnaHRNYXApO1xyXG4gICAgfTtcclxuICAgIE10Y25uLnByb3RvdHlwZS5leHRyYWN0UGFyYW1zID0gZnVuY3Rpb24gKHdlaWdodHMpIHtcclxuICAgICAgICByZXR1cm4gZXh0cmFjdFBhcmFtcyh3ZWlnaHRzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTXRjbm47XHJcbn0oTmV1cmFsTmV0d29yaykpO1xyXG5leHBvcnQgeyBNdGNubiB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NdGNubi5qcy5tYXAiLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgQm94IH0gZnJvbSAnLi4vY2xhc3Nlcyc7XHJcbnZhciBNdGNubkJveCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNdGNubkJveCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE10Y25uQm94KGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wLCByaWdodDogcmlnaHQsIGJvdHRvbTogYm90dG9tIH0sIHRydWUpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTXRjbm5Cb3g7XHJcbn0oQm94KSk7XHJcbmV4cG9ydCB7IE10Y25uQm94IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU10Y25uQm94LmpzLm1hcCIsInZhciBNdGNubk9wdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNdGNubk9wdGlvbnMoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWluRmFjZVNpemUgPSBfYi5taW5GYWNlU2l6ZSwgc2NhbGVGYWN0b3IgPSBfYi5zY2FsZUZhY3RvciwgbWF4TnVtU2NhbGVzID0gX2IubWF4TnVtU2NhbGVzLCBzY29yZVRocmVzaG9sZHMgPSBfYi5zY29yZVRocmVzaG9sZHMsIHNjYWxlU3RlcHMgPSBfYi5zY2FsZVN0ZXBzO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSAnTXRjbm5PcHRpb25zJztcclxuICAgICAgICB0aGlzLl9taW5GYWNlU2l6ZSA9IG1pbkZhY2VTaXplIHx8IDIwO1xyXG4gICAgICAgIHRoaXMuX3NjYWxlRmFjdG9yID0gc2NhbGVGYWN0b3IgfHwgMC43MDk7XHJcbiAgICAgICAgdGhpcy5fbWF4TnVtU2NhbGVzID0gbWF4TnVtU2NhbGVzIHx8IDEwO1xyXG4gICAgICAgIHRoaXMuX3Njb3JlVGhyZXNob2xkcyA9IHNjb3JlVGhyZXNob2xkcyB8fCBbMC42LCAwLjcsIDAuN107XHJcbiAgICAgICAgdGhpcy5fc2NhbGVTdGVwcyA9IHNjYWxlU3RlcHM7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9taW5GYWNlU2l6ZSAhPT0gJ251bWJlcicgfHwgdGhpcy5fbWluRmFjZVNpemUgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9uYW1lICsgXCIgLSBleHBlY3RlZCBtaW5GYWNlU2l6ZSB0byBiZSBhIG51bWJlciA+IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fc2NhbGVGYWN0b3IgIT09ICdudW1iZXInIHx8IHRoaXMuX3NjYWxlRmFjdG9yIDw9IDAgfHwgdGhpcy5fc2NhbGVGYWN0b3IgPj0gMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fbmFtZSArIFwiIC0gZXhwZWN0ZWQgc2NhbGVGYWN0b3IgdG8gYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX21heE51bVNjYWxlcyAhPT0gJ251bWJlcicgfHwgdGhpcy5fbWF4TnVtU2NhbGVzIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fbmFtZSArIFwiIC0gZXhwZWN0ZWQgbWF4TnVtU2NhbGVzIHRvIGJlIGEgbnVtYmVyID4gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuX3Njb3JlVGhyZXNob2xkcylcclxuICAgICAgICAgICAgfHwgdGhpcy5fc2NvcmVUaHJlc2hvbGRzLmxlbmd0aCAhPT0gM1xyXG4gICAgICAgICAgICB8fCB0aGlzLl9zY29yZVRocmVzaG9sZHMuc29tZShmdW5jdGlvbiAodGgpIHsgcmV0dXJuIHR5cGVvZiB0aCAhPT0gJ251bWJlcic7IH0pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9uYW1lICsgXCIgLSBleHBlY3RlZCBzY29yZVRocmVzaG9sZHMgdG8gYmUgYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBsZW5ndGggM1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlU3RlcHNcclxuICAgICAgICAgICAgJiYgKCFBcnJheS5pc0FycmF5KHRoaXMuX3NjYWxlU3RlcHMpIHx8IHRoaXMuX3NjYWxlU3RlcHMuc29tZShmdW5jdGlvbiAodGgpIHsgcmV0dXJuIHR5cGVvZiB0aCAhPT0gJ251bWJlcic7IH0pKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fbmFtZSArIFwiIC0gZXhwZWN0ZWQgc2NhbGVTdGVwcyB0byBiZSBhbiBhcnJheSBvZiBudW1iZXJzXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNdGNubk9wdGlvbnMucHJvdG90eXBlLCBcIm1pbkZhY2VTaXplXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21pbkZhY2VTaXplOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNdGNubk9wdGlvbnMucHJvdG90eXBlLCBcInNjYWxlRmFjdG9yXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NjYWxlRmFjdG9yOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNdGNubk9wdGlvbnMucHJvdG90eXBlLCBcIm1heE51bVNjYWxlc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXhOdW1TY2FsZXM7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE10Y25uT3B0aW9ucy5wcm90b3R5cGUsIFwic2NvcmVUaHJlc2hvbGRzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Njb3JlVGhyZXNob2xkczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTXRjbm5PcHRpb25zLnByb3RvdHlwZSwgXCJzY2FsZVN0ZXBzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NjYWxlU3RlcHM7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIE10Y25uT3B0aW9ucztcclxufSgpKTtcclxuZXhwb3J0IHsgTXRjbm5PcHRpb25zIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU10Y25uT3B0aW9ucy5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBjb252TGF5ZXIgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBmdWxseUNvbm5lY3RlZExheWVyIH0gZnJvbSAnLi4vY29tbW9uL2Z1bGx5Q29ubmVjdGVkTGF5ZXInO1xyXG5pbXBvcnQgeyBwcmVsdSB9IGZyb20gJy4vcHJlbHUnO1xyXG5pbXBvcnQgeyBzaGFyZWRMYXllciB9IGZyb20gJy4vc2hhcmVkTGF5ZXJzJztcclxuZXhwb3J0IGZ1bmN0aW9uIE9OZXQoeCwgcGFyYW1zKSB7XHJcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG91dCA9IHNoYXJlZExheWVyKHgsIHBhcmFtcyk7XHJcbiAgICAgICAgb3V0ID0gdGYubWF4UG9vbChvdXQsIFsyLCAyXSwgWzIsIDJdLCAnc2FtZScpO1xyXG4gICAgICAgIG91dCA9IGNvbnZMYXllcihvdXQsIHBhcmFtcy5jb252NCwgJ3ZhbGlkJyk7XHJcbiAgICAgICAgb3V0ID0gcHJlbHUob3V0LCBwYXJhbXMucHJlbHU0X2FscGhhKTtcclxuICAgICAgICB2YXIgdmVjdG9yaXplZCA9IHRmLnJlc2hhcGUob3V0LCBbb3V0LnNoYXBlWzBdLCBwYXJhbXMuZmMxLndlaWdodHMuc2hhcGVbMF1dKTtcclxuICAgICAgICB2YXIgZmMxID0gZnVsbHlDb25uZWN0ZWRMYXllcih2ZWN0b3JpemVkLCBwYXJhbXMuZmMxKTtcclxuICAgICAgICB2YXIgcHJlbHU1ID0gcHJlbHUoZmMxLCBwYXJhbXMucHJlbHU1X2FscGhhKTtcclxuICAgICAgICB2YXIgZmMyXzEgPSBmdWxseUNvbm5lY3RlZExheWVyKHByZWx1NSwgcGFyYW1zLmZjMl8xKTtcclxuICAgICAgICB2YXIgbWF4ID0gdGYuZXhwYW5kRGltcyh0Zi5tYXgoZmMyXzEsIDEpLCAxKTtcclxuICAgICAgICB2YXIgcHJvYiA9IHRmLnNvZnRtYXgodGYuc3ViKGZjMl8xLCBtYXgpLCAxKTtcclxuICAgICAgICB2YXIgcmVnaW9ucyA9IGZ1bGx5Q29ubmVjdGVkTGF5ZXIocHJlbHU1LCBwYXJhbXMuZmMyXzIpO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBmdWxseUNvbm5lY3RlZExheWVyKHByZWx1NSwgcGFyYW1zLmZjMl8zKTtcclxuICAgICAgICB2YXIgc2NvcmVzID0gdGYudW5zdGFjayhwcm9iLCAxKVsxXTtcclxuICAgICAgICByZXR1cm4geyBzY29yZXM6IHNjb3JlcywgcmVnaW9uczogcmVnaW9ucywgcG9pbnRzOiBwb2ludHMgfTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9OZXQuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgY29udkxheWVyIH0gZnJvbSAnLi4vY29tbW9uJztcclxuaW1wb3J0IHsgc2hhcmVkTGF5ZXIgfSBmcm9tICcuL3NoYXJlZExheWVycyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBQTmV0KHgsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvdXQgPSBzaGFyZWRMYXllcih4LCBwYXJhbXMsIHRydWUpO1xyXG4gICAgICAgIHZhciBjb252ID0gY29udkxheWVyKG91dCwgcGFyYW1zLmNvbnY0XzEsICd2YWxpZCcpO1xyXG4gICAgICAgIHZhciBtYXggPSB0Zi5leHBhbmREaW1zKHRmLm1heChjb252LCAzKSwgMyk7XHJcbiAgICAgICAgdmFyIHByb2IgPSB0Zi5zb2Z0bWF4KHRmLnN1Yihjb252LCBtYXgpLCAzKTtcclxuICAgICAgICB2YXIgcmVnaW9ucyA9IGNvbnZMYXllcihvdXQsIHBhcmFtcy5jb252NF8yLCAndmFsaWQnKTtcclxuICAgICAgICByZXR1cm4geyBwcm9iOiBwcm9iLCByZWdpb25zOiByZWdpb25zIH07XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QTmV0LmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGZ1bGx5Q29ubmVjdGVkTGF5ZXIgfSBmcm9tICcuLi9jb21tb24vZnVsbHlDb25uZWN0ZWRMYXllcic7XHJcbmltcG9ydCB7IHByZWx1IH0gZnJvbSAnLi9wcmVsdSc7XHJcbmltcG9ydCB7IHNoYXJlZExheWVyIH0gZnJvbSAnLi9zaGFyZWRMYXllcnMnO1xyXG5leHBvcnQgZnVuY3Rpb24gUk5ldCh4LCBwYXJhbXMpIHtcclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY29udk91dCA9IHNoYXJlZExheWVyKHgsIHBhcmFtcyk7XHJcbiAgICAgICAgdmFyIHZlY3Rvcml6ZWQgPSB0Zi5yZXNoYXBlKGNvbnZPdXQsIFtjb252T3V0LnNoYXBlWzBdLCBwYXJhbXMuZmMxLndlaWdodHMuc2hhcGVbMF1dKTtcclxuICAgICAgICB2YXIgZmMxID0gZnVsbHlDb25uZWN0ZWRMYXllcih2ZWN0b3JpemVkLCBwYXJhbXMuZmMxKTtcclxuICAgICAgICB2YXIgcHJlbHU0ID0gcHJlbHUoZmMxLCBwYXJhbXMucHJlbHU0X2FscGhhKTtcclxuICAgICAgICB2YXIgZmMyXzEgPSBmdWxseUNvbm5lY3RlZExheWVyKHByZWx1NCwgcGFyYW1zLmZjMl8xKTtcclxuICAgICAgICB2YXIgbWF4ID0gdGYuZXhwYW5kRGltcyh0Zi5tYXgoZmMyXzEsIDEpLCAxKTtcclxuICAgICAgICB2YXIgcHJvYiA9IHRmLnNvZnRtYXgodGYuc3ViKGZjMl8xLCBtYXgpLCAxKTtcclxuICAgICAgICB2YXIgcmVnaW9ucyA9IGZ1bGx5Q29ubmVjdGVkTGF5ZXIocHJlbHU0LCBwYXJhbXMuZmMyXzIpO1xyXG4gICAgICAgIHZhciBzY29yZXMgPSB0Zi51bnN0YWNrKHByb2IsIDEpWzFdO1xyXG4gICAgICAgIHJldHVybiB7IHNjb3Jlczogc2NvcmVzLCByZWdpb25zOiByZWdpb25zIH07XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1STmV0LmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBiZ3JUb1JnYlRlbnNvcih0ZW5zb3IpIHtcclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRmLnN0YWNrKHRmLnVuc3RhY2sodGVuc29yLCAzKS5yZXZlcnNlKCksIDMpOyB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZ3JUb1JnYlRlbnNvci5qcy5tYXAiLCJleHBvcnQgdmFyIENFTExfU1RSSURFID0gMjtcclxuZXhwb3J0IHZhciBDRUxMX1NJWkUgPSAxMjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlnLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgY3JlYXRlQ2FudmFzLCBjcmVhdGVDYW52YXNGcm9tTWVkaWEsIGdldENvbnRleHQyZE9yVGhyb3cgfSBmcm9tICcuLi9kb20nO1xyXG5pbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYnO1xyXG5pbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuL25vcm1hbGl6ZSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0SW1hZ2VQYXRjaGVzKGltZywgYm94ZXMsIF9hKSB7XHJcbiAgICB2YXIgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbWdDdHgsIGJpdG1hcHMsIGltYWdlUGF0Y2hlc0RhdGFzO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgaW1nQ3R4ID0gZ2V0Q29udGV4dDJkT3JUaHJvdyhpbWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKGJveGVzLm1hcChmdW5jdGlvbiAoYm94KSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIHksIGV5LCB4LCBleCwgZnJvbVgsIGZyb21ZLCBpbWdEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gYm94LnBhZEF0Qm9yZGVycyhpbWcuaGVpZ2h0LCBpbWcud2lkdGgpLCB5ID0gX2EueSwgZXkgPSBfYS5leSwgeCA9IF9hLngsIGV4ID0gX2EuZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVggPSB4IC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tWSA9IHkgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZ0RhdGEgPSBpbWdDdHguZ2V0SW1hZ2VEYXRhKGZyb21YLCBmcm9tWSwgKGV4IC0gZnJvbVgpLCAoZXkgLSBmcm9tWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBlbnYuaXNOb2RlanMoKSA/IGNyZWF0ZUNhbnZhc0Zyb21NZWRpYShpbWdEYXRhKSA6IGNyZWF0ZUltYWdlQml0bWFwKGltZ0RhdGEpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSkpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBiaXRtYXBzID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlUGF0Y2hlc0RhdGFzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgYml0bWFwcy5mb3JFYWNoKGZ1bmN0aW9uIChibXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGNoID0gY3JlYXRlQ2FudmFzKHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGNoQ3R4ID0gZ2V0Q29udGV4dDJkT3JUaHJvdyhwYXRjaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoQ3R4LmRyYXdJbWFnZShibXAsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHBhdGNoQ3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyckRhdGEgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUkdCQSAtPiBCR1JcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyRGF0YS5wdXNoKGRhdGFbaSArIDJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJEYXRhLnB1c2goZGF0YVtpICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckRhdGEucHVzaChkYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVBhdGNoZXNEYXRhcy5wdXNoKGN1cnJEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgaW1hZ2VQYXRjaGVzRGF0YXMubWFwKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVBhdGNoVGVuc29yID0gdGYudHJhbnNwb3NlKHRmLnRlbnNvcjRkKGRhdGEsIFsxLCB3aWR0aCwgaGVpZ2h0LCAzXSksIFswLCAyLCAxLCAzXSkudG9GbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUoaW1hZ2VQYXRjaFRlbnNvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RJbWFnZVBhdGNoZXMuanMubWFwIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgZXh0cmFjdENvbnZQYXJhbXNGYWN0b3J5LCBleHRyYWN0RkNQYXJhbXNGYWN0b3J5LCBleHRyYWN0V2VpZ2h0c0ZhY3RvcnksIH0gZnJvbSAnLi4vY29tbW9uJztcclxuZnVuY3Rpb24gZXh0cmFjdG9yc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpIHtcclxuICAgIHZhciBleHRyYWN0Q29udlBhcmFtcyA9IGV4dHJhY3RDb252UGFyYW1zRmFjdG9yeShleHRyYWN0V2VpZ2h0cywgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICB2YXIgZXh0cmFjdEZDUGFyYW1zID0gZXh0cmFjdEZDUGFyYW1zRmFjdG9yeShleHRyYWN0V2VpZ2h0cywgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0UFJlbHVQYXJhbXMoc2l6ZSwgcGFyYW1QYXRoKSB7XHJcbiAgICAgICAgdmFyIGFscGhhID0gdGYudGVuc29yMWQoZXh0cmFjdFdlaWdodHMoc2l6ZSkpO1xyXG4gICAgICAgIHBhcmFtTWFwcGluZ3MucHVzaCh7IHBhcmFtUGF0aDogcGFyYW1QYXRoIH0pO1xyXG4gICAgICAgIHJldHVybiBhbHBoYTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RTaGFyZWRQYXJhbXMobnVtRmlsdGVycywgbWFwcGVkUHJlZml4LCBpc1JuZXQpIHtcclxuICAgICAgICBpZiAoaXNSbmV0ID09PSB2b2lkIDApIHsgaXNSbmV0ID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgY29udjEgPSBleHRyYWN0Q29udlBhcmFtcyhudW1GaWx0ZXJzWzBdLCBudW1GaWx0ZXJzWzFdLCAzLCBtYXBwZWRQcmVmaXggKyBcIi9jb252MVwiKTtcclxuICAgICAgICB2YXIgcHJlbHUxX2FscGhhID0gZXh0cmFjdFBSZWx1UGFyYW1zKG51bUZpbHRlcnNbMV0sIG1hcHBlZFByZWZpeCArIFwiL3ByZWx1MV9hbHBoYVwiKTtcclxuICAgICAgICB2YXIgY29udjIgPSBleHRyYWN0Q29udlBhcmFtcyhudW1GaWx0ZXJzWzFdLCBudW1GaWx0ZXJzWzJdLCAzLCBtYXBwZWRQcmVmaXggKyBcIi9jb252MlwiKTtcclxuICAgICAgICB2YXIgcHJlbHUyX2FscGhhID0gZXh0cmFjdFBSZWx1UGFyYW1zKG51bUZpbHRlcnNbMl0sIG1hcHBlZFByZWZpeCArIFwiL3ByZWx1Ml9hbHBoYVwiKTtcclxuICAgICAgICB2YXIgY29udjMgPSBleHRyYWN0Q29udlBhcmFtcyhudW1GaWx0ZXJzWzJdLCBudW1GaWx0ZXJzWzNdLCBpc1JuZXQgPyAyIDogMywgbWFwcGVkUHJlZml4ICsgXCIvY29udjNcIik7XHJcbiAgICAgICAgdmFyIHByZWx1M19hbHBoYSA9IGV4dHJhY3RQUmVsdVBhcmFtcyhudW1GaWx0ZXJzWzNdLCBtYXBwZWRQcmVmaXggKyBcIi9wcmVsdTNfYWxwaGFcIik7XHJcbiAgICAgICAgcmV0dXJuIHsgY29udjE6IGNvbnYxLCBwcmVsdTFfYWxwaGE6IHByZWx1MV9hbHBoYSwgY29udjI6IGNvbnYyLCBwcmVsdTJfYWxwaGE6IHByZWx1Ml9hbHBoYSwgY29udjM6IGNvbnYzLCBwcmVsdTNfYWxwaGE6IHByZWx1M19hbHBoYSB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdFBOZXRQYXJhbXMoKSB7XHJcbiAgICAgICAgdmFyIHNoYXJlZFBhcmFtcyA9IGV4dHJhY3RTaGFyZWRQYXJhbXMoWzMsIDEwLCAxNiwgMzJdLCAncG5ldCcpO1xyXG4gICAgICAgIHZhciBjb252NF8xID0gZXh0cmFjdENvbnZQYXJhbXMoMzIsIDIsIDEsICdwbmV0L2NvbnY0XzEnKTtcclxuICAgICAgICB2YXIgY29udjRfMiA9IGV4dHJhY3RDb252UGFyYW1zKDMyLCA0LCAxLCAncG5ldC9jb252NF8yJyk7XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzaGFyZWRQYXJhbXMpLCB7IGNvbnY0XzE6IGNvbnY0XzEsIGNvbnY0XzI6IGNvbnY0XzIgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0Uk5ldFBhcmFtcygpIHtcclxuICAgICAgICB2YXIgc2hhcmVkUGFyYW1zID0gZXh0cmFjdFNoYXJlZFBhcmFtcyhbMywgMjgsIDQ4LCA2NF0sICdybmV0JywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGZjMSA9IGV4dHJhY3RGQ1BhcmFtcyg1NzYsIDEyOCwgJ3JuZXQvZmMxJyk7XHJcbiAgICAgICAgdmFyIHByZWx1NF9hbHBoYSA9IGV4dHJhY3RQUmVsdVBhcmFtcygxMjgsICdybmV0L3ByZWx1NF9hbHBoYScpO1xyXG4gICAgICAgIHZhciBmYzJfMSA9IGV4dHJhY3RGQ1BhcmFtcygxMjgsIDIsICdybmV0L2ZjMl8xJyk7XHJcbiAgICAgICAgdmFyIGZjMl8yID0gZXh0cmFjdEZDUGFyYW1zKDEyOCwgNCwgJ3JuZXQvZmMyXzInKTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHNoYXJlZFBhcmFtcyksIHsgZmMxOiBmYzEsIHByZWx1NF9hbHBoYTogcHJlbHU0X2FscGhhLCBmYzJfMTogZmMyXzEsIGZjMl8yOiBmYzJfMiB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RPTmV0UGFyYW1zKCkge1xyXG4gICAgICAgIHZhciBzaGFyZWRQYXJhbXMgPSBleHRyYWN0U2hhcmVkUGFyYW1zKFszLCAzMiwgNjQsIDY0XSwgJ29uZXQnKTtcclxuICAgICAgICB2YXIgY29udjQgPSBleHRyYWN0Q29udlBhcmFtcyg2NCwgMTI4LCAyLCAnb25ldC9jb252NCcpO1xyXG4gICAgICAgIHZhciBwcmVsdTRfYWxwaGEgPSBleHRyYWN0UFJlbHVQYXJhbXMoMTI4LCAnb25ldC9wcmVsdTRfYWxwaGEnKTtcclxuICAgICAgICB2YXIgZmMxID0gZXh0cmFjdEZDUGFyYW1zKDExNTIsIDI1NiwgJ29uZXQvZmMxJyk7XHJcbiAgICAgICAgdmFyIHByZWx1NV9hbHBoYSA9IGV4dHJhY3RQUmVsdVBhcmFtcygyNTYsICdvbmV0L3ByZWx1NV9hbHBoYScpO1xyXG4gICAgICAgIHZhciBmYzJfMSA9IGV4dHJhY3RGQ1BhcmFtcygyNTYsIDIsICdvbmV0L2ZjMl8xJyk7XHJcbiAgICAgICAgdmFyIGZjMl8yID0gZXh0cmFjdEZDUGFyYW1zKDI1NiwgNCwgJ29uZXQvZmMyXzInKTtcclxuICAgICAgICB2YXIgZmMyXzMgPSBleHRyYWN0RkNQYXJhbXMoMjU2LCAxMCwgJ29uZXQvZmMyXzMnKTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHNoYXJlZFBhcmFtcyksIHsgY29udjQ6IGNvbnY0LCBwcmVsdTRfYWxwaGE6IHByZWx1NF9hbHBoYSwgZmMxOiBmYzEsIHByZWx1NV9hbHBoYTogcHJlbHU1X2FscGhhLCBmYzJfMTogZmMyXzEsIGZjMl8yOiBmYzJfMiwgZmMyXzM6IGZjMl8zIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBleHRyYWN0UE5ldFBhcmFtczogZXh0cmFjdFBOZXRQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdFJOZXRQYXJhbXM6IGV4dHJhY3RSTmV0UGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3RPTmV0UGFyYW1zOiBleHRyYWN0T05ldFBhcmFtc1xyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtcyh3ZWlnaHRzKSB7XHJcbiAgICB2YXIgX2EgPSBleHRyYWN0V2VpZ2h0c0ZhY3Rvcnkod2VpZ2h0cyksIGV4dHJhY3RXZWlnaHRzID0gX2EuZXh0cmFjdFdlaWdodHMsIGdldFJlbWFpbmluZ1dlaWdodHMgPSBfYS5nZXRSZW1haW5pbmdXZWlnaHRzO1xyXG4gICAgdmFyIHBhcmFtTWFwcGluZ3MgPSBbXTtcclxuICAgIHZhciBfYiA9IGV4dHJhY3RvcnNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKSwgZXh0cmFjdFBOZXRQYXJhbXMgPSBfYi5leHRyYWN0UE5ldFBhcmFtcywgZXh0cmFjdFJOZXRQYXJhbXMgPSBfYi5leHRyYWN0Uk5ldFBhcmFtcywgZXh0cmFjdE9OZXRQYXJhbXMgPSBfYi5leHRyYWN0T05ldFBhcmFtcztcclxuICAgIHZhciBwbmV0ID0gZXh0cmFjdFBOZXRQYXJhbXMoKTtcclxuICAgIHZhciBybmV0ID0gZXh0cmFjdFJOZXRQYXJhbXMoKTtcclxuICAgIHZhciBvbmV0ID0gZXh0cmFjdE9OZXRQYXJhbXMoKTtcclxuICAgIGlmIChnZXRSZW1haW5pbmdXZWlnaHRzKCkubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2VpZ2h0cyByZW1haW5nIGFmdGVyIGV4dHJhY3Q6IFwiICsgZ2V0UmVtYWluaW5nV2VpZ2h0cygpLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBwYXJhbXM6IHsgcG5ldDogcG5ldCwgcm5ldDogcm5ldCwgb25ldDogb25ldCB9LCBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFBhcmFtcy5qcy5tYXAiLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBkaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycywgZXh0cmFjdFdlaWdodEVudHJ5RmFjdG9yeSB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmZ1bmN0aW9uIGV4dHJhY3RvcnNGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncykge1xyXG4gICAgdmFyIGV4dHJhY3RXZWlnaHRFbnRyeSA9IGV4dHJhY3RXZWlnaHRFbnRyeUZhY3Rvcnkod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RDb252UGFyYW1zKHByZWZpeCkge1xyXG4gICAgICAgIHZhciBmaWx0ZXJzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL3dlaWdodHNcIiwgNCwgcHJlZml4ICsgXCIvZmlsdGVyc1wiKTtcclxuICAgICAgICB2YXIgYmlhcyA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi9iaWFzXCIsIDEpO1xyXG4gICAgICAgIHJldHVybiB7IGZpbHRlcnM6IGZpbHRlcnMsIGJpYXM6IGJpYXMgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RGQ1BhcmFtcyhwcmVmaXgpIHtcclxuICAgICAgICB2YXIgd2VpZ2h0cyA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi93ZWlnaHRzXCIsIDIpO1xyXG4gICAgICAgIHZhciBiaWFzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL2JpYXNcIiwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHsgd2VpZ2h0czogd2VpZ2h0cywgYmlhczogYmlhcyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdFBSZWx1UGFyYW1zKHBhcmFtUGF0aCkge1xyXG4gICAgICAgIHJldHVybiBleHRyYWN0V2VpZ2h0RW50cnkocGFyYW1QYXRoLCAxKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RTaGFyZWRQYXJhbXMocHJlZml4KSB7XHJcbiAgICAgICAgdmFyIGNvbnYxID0gZXh0cmFjdENvbnZQYXJhbXMocHJlZml4ICsgXCIvY29udjFcIik7XHJcbiAgICAgICAgdmFyIHByZWx1MV9hbHBoYSA9IGV4dHJhY3RQUmVsdVBhcmFtcyhwcmVmaXggKyBcIi9wcmVsdTFfYWxwaGFcIik7XHJcbiAgICAgICAgdmFyIGNvbnYyID0gZXh0cmFjdENvbnZQYXJhbXMocHJlZml4ICsgXCIvY29udjJcIik7XHJcbiAgICAgICAgdmFyIHByZWx1Ml9hbHBoYSA9IGV4dHJhY3RQUmVsdVBhcmFtcyhwcmVmaXggKyBcIi9wcmVsdTJfYWxwaGFcIik7XHJcbiAgICAgICAgdmFyIGNvbnYzID0gZXh0cmFjdENvbnZQYXJhbXMocHJlZml4ICsgXCIvY29udjNcIik7XHJcbiAgICAgICAgdmFyIHByZWx1M19hbHBoYSA9IGV4dHJhY3RQUmVsdVBhcmFtcyhwcmVmaXggKyBcIi9wcmVsdTNfYWxwaGFcIik7XHJcbiAgICAgICAgcmV0dXJuIHsgY29udjE6IGNvbnYxLCBwcmVsdTFfYWxwaGE6IHByZWx1MV9hbHBoYSwgY29udjI6IGNvbnYyLCBwcmVsdTJfYWxwaGE6IHByZWx1Ml9hbHBoYSwgY29udjM6IGNvbnYzLCBwcmVsdTNfYWxwaGE6IHByZWx1M19hbHBoYSB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdFBOZXRQYXJhbXMoKSB7XHJcbiAgICAgICAgdmFyIHNoYXJlZFBhcmFtcyA9IGV4dHJhY3RTaGFyZWRQYXJhbXMoJ3BuZXQnKTtcclxuICAgICAgICB2YXIgY29udjRfMSA9IGV4dHJhY3RDb252UGFyYW1zKCdwbmV0L2NvbnY0XzEnKTtcclxuICAgICAgICB2YXIgY29udjRfMiA9IGV4dHJhY3RDb252UGFyYW1zKCdwbmV0L2NvbnY0XzInKTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHNoYXJlZFBhcmFtcyksIHsgY29udjRfMTogY29udjRfMSwgY29udjRfMjogY29udjRfMiB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RSTmV0UGFyYW1zKCkge1xyXG4gICAgICAgIHZhciBzaGFyZWRQYXJhbXMgPSBleHRyYWN0U2hhcmVkUGFyYW1zKCdybmV0Jyk7XHJcbiAgICAgICAgdmFyIGZjMSA9IGV4dHJhY3RGQ1BhcmFtcygncm5ldC9mYzEnKTtcclxuICAgICAgICB2YXIgcHJlbHU0X2FscGhhID0gZXh0cmFjdFBSZWx1UGFyYW1zKCdybmV0L3ByZWx1NF9hbHBoYScpO1xyXG4gICAgICAgIHZhciBmYzJfMSA9IGV4dHJhY3RGQ1BhcmFtcygncm5ldC9mYzJfMScpO1xyXG4gICAgICAgIHZhciBmYzJfMiA9IGV4dHJhY3RGQ1BhcmFtcygncm5ldC9mYzJfMicpO1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2hhcmVkUGFyYW1zKSwgeyBmYzE6IGZjMSwgcHJlbHU0X2FscGhhOiBwcmVsdTRfYWxwaGEsIGZjMl8xOiBmYzJfMSwgZmMyXzI6IGZjMl8yIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdE9OZXRQYXJhbXMoKSB7XHJcbiAgICAgICAgdmFyIHNoYXJlZFBhcmFtcyA9IGV4dHJhY3RTaGFyZWRQYXJhbXMoJ29uZXQnKTtcclxuICAgICAgICB2YXIgY29udjQgPSBleHRyYWN0Q29udlBhcmFtcygnb25ldC9jb252NCcpO1xyXG4gICAgICAgIHZhciBwcmVsdTRfYWxwaGEgPSBleHRyYWN0UFJlbHVQYXJhbXMoJ29uZXQvcHJlbHU0X2FscGhhJyk7XHJcbiAgICAgICAgdmFyIGZjMSA9IGV4dHJhY3RGQ1BhcmFtcygnb25ldC9mYzEnKTtcclxuICAgICAgICB2YXIgcHJlbHU1X2FscGhhID0gZXh0cmFjdFBSZWx1UGFyYW1zKCdvbmV0L3ByZWx1NV9hbHBoYScpO1xyXG4gICAgICAgIHZhciBmYzJfMSA9IGV4dHJhY3RGQ1BhcmFtcygnb25ldC9mYzJfMScpO1xyXG4gICAgICAgIHZhciBmYzJfMiA9IGV4dHJhY3RGQ1BhcmFtcygnb25ldC9mYzJfMicpO1xyXG4gICAgICAgIHZhciBmYzJfMyA9IGV4dHJhY3RGQ1BhcmFtcygnb25ldC9mYzJfMycpO1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2hhcmVkUGFyYW1zKSwgeyBjb252NDogY29udjQsIHByZWx1NF9hbHBoYTogcHJlbHU0X2FscGhhLCBmYzE6IGZjMSwgcHJlbHU1X2FscGhhOiBwcmVsdTVfYWxwaGEsIGZjMl8xOiBmYzJfMSwgZmMyXzI6IGZjMl8yLCBmYzJfMzogZmMyXzMgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4dHJhY3RQTmV0UGFyYW1zOiBleHRyYWN0UE5ldFBhcmFtcyxcclxuICAgICAgICBleHRyYWN0Uk5ldFBhcmFtczogZXh0cmFjdFJOZXRQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdE9OZXRQYXJhbXM6IGV4dHJhY3RPTmV0UGFyYW1zXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCh3ZWlnaHRNYXApIHtcclxuICAgIHZhciBwYXJhbU1hcHBpbmdzID0gW107XHJcbiAgICB2YXIgX2EgPSBleHRyYWN0b3JzRmFjdG9yeSh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpLCBleHRyYWN0UE5ldFBhcmFtcyA9IF9hLmV4dHJhY3RQTmV0UGFyYW1zLCBleHRyYWN0Uk5ldFBhcmFtcyA9IF9hLmV4dHJhY3RSTmV0UGFyYW1zLCBleHRyYWN0T05ldFBhcmFtcyA9IF9hLmV4dHJhY3RPTmV0UGFyYW1zO1xyXG4gICAgdmFyIHBuZXQgPSBleHRyYWN0UE5ldFBhcmFtcygpO1xyXG4gICAgdmFyIHJuZXQgPSBleHRyYWN0Uk5ldFBhcmFtcygpO1xyXG4gICAgdmFyIG9uZXQgPSBleHRyYWN0T05ldFBhcmFtcygpO1xyXG4gICAgZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIHJldHVybiB7IHBhcmFtczogeyBwbmV0OiBwbmV0LCBybmV0OiBybmV0LCBvbmV0OiBvbmV0IH0sIHBhcmFtTWFwcGluZ3M6IHBhcmFtTWFwcGluZ3MgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gZ2V0U2l6ZXNGb3JTY2FsZShzY2FsZSwgX2EpIHtcclxuICAgIHZhciBoZWlnaHQgPSBfYVswXSwgd2lkdGggPSBfYVsxXTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaGVpZ2h0OiBNYXRoLmZsb29yKGhlaWdodCAqIHNjYWxlKSxcclxuICAgICAgICB3aWR0aDogTWF0aC5mbG9vcih3aWR0aCAqIHNjYWxlKVxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRTaXplc0ZvclNjYWxlLmpzLm1hcCIsImltcG9ydCB7IE10Y25uIH0gZnJvbSAnLi9NdGNubic7XHJcbmV4cG9ydCAqIGZyb20gJy4vTXRjbm4nO1xyXG5leHBvcnQgKiBmcm9tICcuL010Y25uT3B0aW9ucyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNdGNubih3ZWlnaHRzKSB7XHJcbiAgICB2YXIgbmV0ID0gbmV3IE10Y25uKCk7XHJcbiAgICBuZXQuZXh0cmFjdFdlaWdodHMod2VpZ2h0cyk7XHJcbiAgICByZXR1cm4gbmV0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUoeCkge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGYubXVsKHRmLnN1Yih4LCB0Zi5zY2FsYXIoMTI3LjUpKSwgdGYuc2NhbGFyKDAuMDA3ODEyNSkpOyB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3JtYWxpemUuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuZXhwb3J0IGZ1bmN0aW9uIHByZWx1KHgsIGFscGhhKSB7XHJcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRmLmFkZCh0Zi5yZWx1KHgpLCB0Zi5tdWwoYWxwaGEsIHRmLm5lZyh0Zi5yZWx1KHRmLm5lZyh4KSkpKSk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVsdS5qcy5tYXAiLCJpbXBvcnQgeyBDRUxMX1NJWkUgfSBmcm9tICcuL2NvbmZpZyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBweXJhbWlkRG93bihtaW5GYWNlU2l6ZSwgc2NhbGVGYWN0b3IsIGRpbXMpIHtcclxuICAgIHZhciBoZWlnaHQgPSBkaW1zWzBdLCB3aWR0aCA9IGRpbXNbMV07XHJcbiAgICB2YXIgbSA9IENFTExfU0laRSAvIG1pbkZhY2VTaXplO1xyXG4gICAgdmFyIHNjYWxlcyA9IFtdO1xyXG4gICAgdmFyIG1pbkxheWVyID0gTWF0aC5taW4oaGVpZ2h0LCB3aWR0aCkgKiBtO1xyXG4gICAgdmFyIGV4cCA9IDA7XHJcbiAgICB3aGlsZSAobWluTGF5ZXIgPj0gMTIpIHtcclxuICAgICAgICBzY2FsZXMucHVzaChtICogTWF0aC5wb3coc2NhbGVGYWN0b3IsIGV4cCkpO1xyXG4gICAgICAgIG1pbkxheWVyID0gbWluTGF5ZXIgKiBzY2FsZUZhY3RvcjtcclxuICAgICAgICBleHAgKz0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiBzY2FsZXM7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHlyYW1pZERvd24uanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgY29udkxheWVyIH0gZnJvbSAnLi4vY29tbW9uJztcclxuaW1wb3J0IHsgcHJlbHUgfSBmcm9tICcuL3ByZWx1JztcclxuZXhwb3J0IGZ1bmN0aW9uIHNoYXJlZExheWVyKHgsIHBhcmFtcywgaXNQbmV0KSB7XHJcbiAgICBpZiAoaXNQbmV0ID09PSB2b2lkIDApIHsgaXNQbmV0ID0gZmFsc2U7IH1cclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3V0ID0gY29udkxheWVyKHgsIHBhcmFtcy5jb252MSwgJ3ZhbGlkJyk7XHJcbiAgICAgICAgb3V0ID0gcHJlbHUob3V0LCBwYXJhbXMucHJlbHUxX2FscGhhKTtcclxuICAgICAgICBvdXQgPSB0Zi5tYXhQb29sKG91dCwgaXNQbmV0ID8gWzIsIDJdIDogWzMsIDNdLCBbMiwgMl0sICdzYW1lJyk7XHJcbiAgICAgICAgb3V0ID0gY29udkxheWVyKG91dCwgcGFyYW1zLmNvbnYyLCAndmFsaWQnKTtcclxuICAgICAgICBvdXQgPSBwcmVsdShvdXQsIHBhcmFtcy5wcmVsdTJfYWxwaGEpO1xyXG4gICAgICAgIG91dCA9IGlzUG5ldCA/IG91dCA6IHRmLm1heFBvb2wob3V0LCBbMywgM10sIFsyLCAyXSwgJ3ZhbGlkJyk7XHJcbiAgICAgICAgb3V0ID0gY29udkxheWVyKG91dCwgcGFyYW1zLmNvbnYzLCAndmFsaWQnKTtcclxuICAgICAgICBvdXQgPSBwcmVsdShvdXQsIHBhcmFtcy5wcmVsdTNfYWxwaGEpO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZWRMYXllcnMuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgQm91bmRpbmdCb3gsIFBvaW50IH0gZnJvbSAnLi4vY2xhc3Nlcyc7XHJcbmltcG9ydCB7IG5vbk1heFN1cHByZXNzaW9uIH0gZnJvbSAnLi4vb3BzJztcclxuaW1wb3J0IHsgQ0VMTF9TSVpFLCBDRUxMX1NUUklERSB9IGZyb20gJy4vY29uZmlnJztcclxuaW1wb3J0IHsgZ2V0U2l6ZXNGb3JTY2FsZSB9IGZyb20gJy4vZ2V0U2l6ZXNGb3JTY2FsZSc7XHJcbmltcG9ydCB7IE10Y25uQm94IH0gZnJvbSAnLi9NdGNubkJveCc7XHJcbmltcG9ydCB7IG5vcm1hbGl6ZSB9IGZyb20gJy4vbm9ybWFsaXplJztcclxuaW1wb3J0IHsgUE5ldCB9IGZyb20gJy4vUE5ldCc7XHJcbmZ1bmN0aW9uIHJlc2NhbGVBbmROb3JtYWxpemUoeCwgc2NhbGUpIHtcclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSBnZXRTaXplc0ZvclNjYWxlKHNjYWxlLCB4LnNoYXBlLnNsaWNlKDEpKSwgaGVpZ2h0ID0gX2EuaGVpZ2h0LCB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgICAgIHZhciByZXNpemVkID0gdGYuaW1hZ2UucmVzaXplQmlsaW5lYXIoeCwgW2hlaWdodCwgd2lkdGhdKTtcclxuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZShyZXNpemVkKTtcclxuICAgICAgICByZXR1cm4gdGYudHJhbnNwb3NlKG5vcm1hbGl6ZWQsIFswLCAyLCAxLCAzXSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0Qm91bmRpbmdCb3hlcyhzY29yZXNUZW5zb3IsIHJlZ2lvbnNUZW5zb3IsIHNjYWxlLCBzY29yZVRocmVzaG9sZCkge1xyXG4gICAgLy8gVE9ETzogZml4IHRoaXMhLCBtYXliZSBiZXR0ZXIgdG8gdXNlIHRmLmdhdGhlciBoZXJlXHJcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xyXG4gICAgdmFyIHNjb3Jlc0RhdGEgPSBzY29yZXNUZW5zb3IuYXJyYXlTeW5jKCk7XHJcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHNjb3Jlc1RlbnNvci5zaGFwZVswXTsgeSsrKSB7XHJcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzY29yZXNUZW5zb3Iuc2hhcGVbMV07IHgrKykge1xyXG4gICAgICAgICAgICBpZiAoc2NvcmVzRGF0YVt5XVt4XSA+PSBzY29yZVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKG5ldyBQb2ludCh4LCB5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgYm91bmRpbmdCb3hlcyA9IGluZGljZXMubWFwKGZ1bmN0aW9uIChpZHgpIHtcclxuICAgICAgICB2YXIgY2VsbCA9IG5ldyBCb3VuZGluZ0JveChNYXRoLnJvdW5kKChpZHgueSAqIENFTExfU1RSSURFICsgMSkgLyBzY2FsZSksIE1hdGgucm91bmQoKGlkeC54ICogQ0VMTF9TVFJJREUgKyAxKSAvIHNjYWxlKSwgTWF0aC5yb3VuZCgoaWR4LnkgKiBDRUxMX1NUUklERSArIENFTExfU0laRSkgLyBzY2FsZSksIE1hdGgucm91bmQoKGlkeC54ICogQ0VMTF9TVFJJREUgKyBDRUxMX1NJWkUpIC8gc2NhbGUpKTtcclxuICAgICAgICB2YXIgc2NvcmUgPSBzY29yZXNEYXRhW2lkeC55XVtpZHgueF07XHJcbiAgICAgICAgdmFyIHJlZ2lvbnNEYXRhID0gcmVnaW9uc1RlbnNvci5hcnJheVN5bmMoKTtcclxuICAgICAgICB2YXIgcmVnaW9uID0gbmV3IE10Y25uQm94KHJlZ2lvbnNEYXRhW2lkeC55XVtpZHgueF1bMF0sIHJlZ2lvbnNEYXRhW2lkeC55XVtpZHgueF1bMV0sIHJlZ2lvbnNEYXRhW2lkeC55XVtpZHgueF1bMl0sIHJlZ2lvbnNEYXRhW2lkeC55XVtpZHgueF1bM10pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNlbGw6IGNlbGwsXHJcbiAgICAgICAgICAgIHNjb3JlOiBzY29yZSxcclxuICAgICAgICAgICAgcmVnaW9uOiByZWdpb25cclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYm91bmRpbmdCb3hlcztcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gc3RhZ2UxKGltZ1RlbnNvciwgc2NhbGVzLCBzY29yZVRocmVzaG9sZCwgcGFyYW1zLCBzdGF0cykge1xyXG4gICAgc3RhdHMuc3RhZ2UxID0gW107XHJcbiAgICB2YXIgcG5ldE91dHB1dHMgPSBzY2FsZXMubWFwKGZ1bmN0aW9uIChzY2FsZSkgeyByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN0YXRzRm9yU2NhbGUgPSB7IHNjYWxlOiBzY2FsZSB9O1xyXG4gICAgICAgIHZhciByZXNpemVkID0gcmVzY2FsZUFuZE5vcm1hbGl6ZShpbWdUZW5zb3IsIHNjYWxlKTtcclxuICAgICAgICB2YXIgdHMgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHZhciBfYSA9IFBOZXQocmVzaXplZCwgcGFyYW1zKSwgcHJvYiA9IF9hLnByb2IsIHJlZ2lvbnMgPSBfYS5yZWdpb25zO1xyXG4gICAgICAgIHN0YXRzRm9yU2NhbGUucG5ldCA9IERhdGUubm93KCkgLSB0cztcclxuICAgICAgICB2YXIgc2NvcmVzVGVuc29yID0gdGYudW5zdGFjayh0Zi51bnN0YWNrKHByb2IsIDMpWzFdKVswXTtcclxuICAgICAgICB2YXIgcmVnaW9uc1RlbnNvciA9IHRmLnVuc3RhY2socmVnaW9ucylbMF07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2NvcmVzVGVuc29yOiBzY29yZXNUZW5zb3IsXHJcbiAgICAgICAgICAgIHJlZ2lvbnNUZW5zb3I6IHJlZ2lvbnNUZW5zb3IsXHJcbiAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcclxuICAgICAgICAgICAgc3RhdHNGb3JTY2FsZTogc3RhdHNGb3JTY2FsZVxyXG4gICAgICAgIH07XHJcbiAgICB9KTsgfSk7XHJcbiAgICB2YXIgYm94ZXNGb3JTY2FsZSA9IHBuZXRPdXRwdXRzLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgc2NvcmVzVGVuc29yID0gX2Euc2NvcmVzVGVuc29yLCByZWdpb25zVGVuc29yID0gX2EucmVnaW9uc1RlbnNvciwgc2NhbGUgPSBfYS5zY2FsZSwgc3RhdHNGb3JTY2FsZSA9IF9hLnN0YXRzRm9yU2NhbGU7XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nQm94ZXMgPSBleHRyYWN0Qm91bmRpbmdCb3hlcyhzY29yZXNUZW5zb3IsIHJlZ2lvbnNUZW5zb3IsIHNjYWxlLCBzY29yZVRocmVzaG9sZCk7XHJcbiAgICAgICAgc2NvcmVzVGVuc29yLmRpc3Bvc2UoKTtcclxuICAgICAgICByZWdpb25zVGVuc29yLmRpc3Bvc2UoKTtcclxuICAgICAgICBpZiAoIWJvdW5kaW5nQm94ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHN0YXRzLnN0YWdlMS5wdXNoKHN0YXRzRm9yU2NhbGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0cyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBub25NYXhTdXBwcmVzc2lvbihib3VuZGluZ0JveGVzLm1hcChmdW5jdGlvbiAoYmJveCkgeyByZXR1cm4gYmJveC5jZWxsOyB9KSwgYm91bmRpbmdCb3hlcy5tYXAoZnVuY3Rpb24gKGJib3gpIHsgcmV0dXJuIGJib3guc2NvcmU7IH0pLCAwLjUpO1xyXG4gICAgICAgIHN0YXRzRm9yU2NhbGUubm1zID0gRGF0ZS5ub3coKSAtIHRzO1xyXG4gICAgICAgIHN0YXRzRm9yU2NhbGUubnVtQm94ZXMgPSBpbmRpY2VzLmxlbmd0aDtcclxuICAgICAgICBzdGF0cy5zdGFnZTEucHVzaChzdGF0c0ZvclNjYWxlKTtcclxuICAgICAgICByZXR1cm4gaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGJveElkeCkgeyByZXR1cm4gYm91bmRpbmdCb3hlc1tib3hJZHhdOyB9KTtcclxuICAgIH0pO1xyXG4gICAgdmFyIGFsbEJveGVzID0gYm94ZXNGb3JTY2FsZS5yZWR1Y2UoZnVuY3Rpb24gKGFsbCwgYm94ZXMpIHsgcmV0dXJuIGFsbC5jb25jYXQoYm94ZXMpOyB9LCBbXSk7XHJcbiAgICB2YXIgZmluYWxCb3hlcyA9IFtdO1xyXG4gICAgdmFyIGZpbmFsU2NvcmVzID0gW107XHJcbiAgICBpZiAoYWxsQm94ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhciB0cyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBub25NYXhTdXBwcmVzc2lvbihhbGxCb3hlcy5tYXAoZnVuY3Rpb24gKGJib3gpIHsgcmV0dXJuIGJib3guY2VsbDsgfSksIGFsbEJveGVzLm1hcChmdW5jdGlvbiAoYmJveCkgeyByZXR1cm4gYmJveC5zY29yZTsgfSksIDAuNyk7XHJcbiAgICAgICAgc3RhdHMuc3RhZ2UxX25tcyA9IERhdGUubm93KCkgLSB0cztcclxuICAgICAgICBmaW5hbFNjb3JlcyA9IGluZGljZXMubWFwKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIGFsbEJveGVzW2lkeF0uc2NvcmU7IH0pO1xyXG4gICAgICAgIGZpbmFsQm94ZXMgPSBpbmRpY2VzXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gYWxsQm94ZXNbaWR4XTsgfSlcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIGNlbGwgPSBfYS5jZWxsLCByZWdpb24gPSBfYS5yZWdpb247XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goY2VsbC5sZWZ0ICsgKHJlZ2lvbi5sZWZ0ICogY2VsbC53aWR0aCksIGNlbGwudG9wICsgKHJlZ2lvbi50b3AgKiBjZWxsLmhlaWdodCksIGNlbGwucmlnaHQgKyAocmVnaW9uLnJpZ2h0ICogY2VsbC53aWR0aCksIGNlbGwuYm90dG9tICsgKHJlZ2lvbi5ib3R0b20gKiBjZWxsLmhlaWdodCkpLnRvU3F1YXJlKCkucm91bmQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYm94ZXM6IGZpbmFsQm94ZXMsXHJcbiAgICAgICAgc2NvcmVzOiBmaW5hbFNjb3Jlc1xyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFnZTEuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBub25NYXhTdXBwcmVzc2lvbiB9IGZyb20gJy4uL29wcyc7XHJcbmltcG9ydCB7IGV4dHJhY3RJbWFnZVBhdGNoZXMgfSBmcm9tICcuL2V4dHJhY3RJbWFnZVBhdGNoZXMnO1xyXG5pbXBvcnQgeyBNdGNubkJveCB9IGZyb20gJy4vTXRjbm5Cb3gnO1xyXG5pbXBvcnQgeyBSTmV0IH0gZnJvbSAnLi9STmV0JztcclxuZXhwb3J0IGZ1bmN0aW9uIHN0YWdlMihpbWcsIGlucHV0Qm94ZXMsIHNjb3JlVGhyZXNob2xkLCBwYXJhbXMsIHN0YXRzKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRzLCBybmV0SW5wdXRzLCBybmV0T3V0cywgc2NvcmVzVGVuc29yLCBzY29yZXMsIF9hLCBfYiwgaW5kaWNlcywgZmlsdGVyZWRCb3hlcywgZmlsdGVyZWRTY29yZXMsIGZpbmFsQm94ZXMsIGZpbmFsU2NvcmVzLCBpbmRpY2VzTm1zLCByZWdpb25zXzE7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgdHMgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4dHJhY3RJbWFnZVBhdGNoZXMoaW1nLCBpbnB1dEJveGVzLCB7IHdpZHRoOiAyNCwgaGVpZ2h0OiAyNCB9KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcm5ldElucHV0cyA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5zdGFnZTJfZXh0cmFjdEltYWdlUGF0Y2hlcyA9IERhdGUubm93KCkgLSB0cztcclxuICAgICAgICAgICAgICAgICAgICB0cyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcm5ldE91dHMgPSBybmV0SW5wdXRzLm1hcChmdW5jdGlvbiAocm5ldElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBSTmV0KHJuZXRJbnB1dCwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm5ldElucHV0LmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5zdGFnZTJfcm5ldCA9IERhdGUubm93KCkgLSB0cztcclxuICAgICAgICAgICAgICAgICAgICBzY29yZXNUZW5zb3IgPSBybmV0T3V0cy5sZW5ndGggPiAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGYuY29uY2F0KHJuZXRPdXRzLm1hcChmdW5jdGlvbiAob3V0KSB7IHJldHVybiBvdXQuc2NvcmVzOyB9KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBybmV0T3V0c1swXS5zY29yZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSBBcnJheSkuZnJvbTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzY29yZXNUZW5zb3IuZGF0YSgpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBzY29yZXMgPSBfYi5hcHBseShfYSwgW19jLnNlbnQoKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3Jlc1RlbnNvci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyA9IHNjb3Jlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzY29yZSwgaWR4KSB7IHJldHVybiAoeyBzY29yZTogc2NvcmUsIGlkeDogaWR4IH0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNjb3JlID4gc2NvcmVUaHJlc2hvbGQ7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBfYS5pZHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRCb3hlcyA9IGluZGljZXMubWFwKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIGlucHV0Qm94ZXNbaWR4XTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRTY29yZXMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBzY29yZXNbaWR4XTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxCb3hlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsU2NvcmVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkQm94ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXNObXMgPSBub25NYXhTdXBwcmVzc2lvbihmaWx0ZXJlZEJveGVzLCBmaWx0ZXJlZFNjb3JlcywgMC43KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMuc3RhZ2UyX25tcyA9IERhdGUubm93KCkgLSB0cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uc18xID0gaW5kaWNlc05tcy5tYXAoZnVuY3Rpb24gKGlkeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2lvbnNEYXRhID0gcm5ldE91dHNbaW5kaWNlc1tpZHhdXS5yZWdpb25zLmFycmF5U3luYygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNdGNubkJveChyZWdpb25zRGF0YVswXVswXSwgcmVnaW9uc0RhdGFbMF1bMV0sIHJlZ2lvbnNEYXRhWzBdWzJdLCByZWdpb25zRGF0YVswXVszXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFNjb3JlcyA9IGluZGljZXNObXMubWFwKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIGZpbHRlcmVkU2NvcmVzW2lkeF07IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEJveGVzID0gaW5kaWNlc05tcy5tYXAoZnVuY3Rpb24gKGlkeCwgaSkgeyByZXR1cm4gZmlsdGVyZWRCb3hlc1tpZHhdLmNhbGlicmF0ZShyZWdpb25zXzFbaV0pOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcm5ldE91dHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0LnJlZ2lvbnMuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0LnNjb3Jlcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveGVzOiBmaW5hbEJveGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVzOiBmaW5hbFNjb3Jlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhZ2UyLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi9jbGFzc2VzJztcclxuaW1wb3J0IHsgbm9uTWF4U3VwcHJlc3Npb24gfSBmcm9tICcuLi9vcHMnO1xyXG5pbXBvcnQgeyBleHRyYWN0SW1hZ2VQYXRjaGVzIH0gZnJvbSAnLi9leHRyYWN0SW1hZ2VQYXRjaGVzJztcclxuaW1wb3J0IHsgTXRjbm5Cb3ggfSBmcm9tICcuL010Y25uQm94JztcclxuaW1wb3J0IHsgT05ldCB9IGZyb20gJy4vT05ldCc7XHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFnZTMoaW1nLCBpbnB1dEJveGVzLCBzY29yZVRocmVzaG9sZCwgcGFyYW1zLCBzdGF0cykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0cywgb25ldElucHV0cywgb25ldE91dHMsIHNjb3Jlc1RlbnNvciwgc2NvcmVzLCBfYSwgX2IsIGluZGljZXMsIGZpbHRlcmVkUmVnaW9ucywgZmlsdGVyZWRCb3hlcywgZmlsdGVyZWRTY29yZXMsIGZpbmFsQm94ZXMsIGZpbmFsU2NvcmVzLCBwb2ludHMsIGluZGljZXNObXM7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgdHMgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4dHJhY3RJbWFnZVBhdGNoZXMoaW1nLCBpbnB1dEJveGVzLCB7IHdpZHRoOiA0OCwgaGVpZ2h0OiA0OCB9KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgb25ldElucHV0cyA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5zdGFnZTNfZXh0cmFjdEltYWdlUGF0Y2hlcyA9IERhdGUubm93KCkgLSB0cztcclxuICAgICAgICAgICAgICAgICAgICB0cyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb25ldE91dHMgPSBvbmV0SW5wdXRzLm1hcChmdW5jdGlvbiAob25ldElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBPTmV0KG9uZXRJbnB1dCwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25ldElucHV0LmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5zdGFnZTNfb25ldCA9IERhdGUubm93KCkgLSB0cztcclxuICAgICAgICAgICAgICAgICAgICBzY29yZXNUZW5zb3IgPSBvbmV0T3V0cy5sZW5ndGggPiAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGYuY29uY2F0KG9uZXRPdXRzLm1hcChmdW5jdGlvbiAob3V0KSB7IHJldHVybiBvdXQuc2NvcmVzOyB9KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvbmV0T3V0c1swXS5zY29yZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSBBcnJheSkuZnJvbTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzY29yZXNUZW5zb3IuZGF0YSgpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBzY29yZXMgPSBfYi5hcHBseShfYSwgW19jLnNlbnQoKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3Jlc1RlbnNvci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyA9IHNjb3Jlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzY29yZSwgaWR4KSB7IHJldHVybiAoeyBzY29yZTogc2NvcmUsIGlkeDogaWR4IH0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNjb3JlID4gc2NvcmVUaHJlc2hvbGQ7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBfYS5pZHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRSZWdpb25zID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGlkeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9uc0RhdGEgPSBvbmV0T3V0c1tpZHhdLnJlZ2lvbnMuYXJyYXlTeW5jKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXRjbm5Cb3gocmVnaW9uc0RhdGFbMF1bMF0sIHJlZ2lvbnNEYXRhWzBdWzFdLCByZWdpb25zRGF0YVswXVsyXSwgcmVnaW9uc0RhdGFbMF1bM10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkQm94ZXMgPSBpbmRpY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGlkeCwgaSkgeyByZXR1cm4gaW5wdXRCb3hlc1tpZHhdLmNhbGlicmF0ZShmaWx0ZXJlZFJlZ2lvbnNbaV0pOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZFNjb3JlcyA9IGluZGljZXMubWFwKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIHNjb3Jlc1tpZHhdOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbEJveGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxTY29yZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWRCb3hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRzID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlc05tcyA9IG5vbk1heFN1cHByZXNzaW9uKGZpbHRlcmVkQm94ZXMsIGZpbHRlcmVkU2NvcmVzLCAwLjcsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMuc3RhZ2UzX25tcyA9IERhdGUubm93KCkgLSB0cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxCb3hlcyA9IGluZGljZXNObXMubWFwKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIGZpbHRlcmVkQm94ZXNbaWR4XTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsU2NvcmVzID0gaW5kaWNlc05tcy5tYXAoZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gZmlsdGVyZWRTY29yZXNbaWR4XTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IGluZGljZXNObXMubWFwKGZ1bmN0aW9uIChpZHgsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheSg1KS5maWxsKDApLm1hcChmdW5jdGlvbiAoXywgcHRJZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzRGF0YSA9IG9uZXRPdXRzW2lkeF0ucG9pbnRzLmFycmF5U3luYygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoKChwb2ludHNEYXRhWzBdW3B0SWR4XSAqIChmaW5hbEJveGVzW2ldLndpZHRoICsgMSkpICsgZmluYWxCb3hlc1tpXS5sZWZ0KSwgKChwb2ludHNEYXRhWzBdW3B0SWR4ICsgNV0gKiAoZmluYWxCb3hlc1tpXS5oZWlnaHQgKyAxKSkgKyBmaW5hbEJveGVzW2ldLnRvcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvbmV0T3V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQucmVnaW9ucy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuc2NvcmVzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5wb2ludHMuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3hlczogZmluYWxCb3hlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlczogZmluYWxTY29yZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhZ2UzLmpzLm1hcCIsImV4cG9ydCAqIGZyb20gJy4vaW91JztcclxuZXhwb3J0ICogZnJvbSAnLi9taW5CYm94JztcclxuZXhwb3J0ICogZnJvbSAnLi9ub25NYXhTdXBwcmVzc2lvbic7XHJcbmV4cG9ydCAqIGZyb20gJy4vbm9ybWFsaXplJztcclxuZXhwb3J0ICogZnJvbSAnLi9wYWRUb1NxdWFyZSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vc2h1ZmZsZUFycmF5JztcclxuZXhwb3J0IGZ1bmN0aW9uIHNpZ21vaWQoeCkge1xyXG4gICAgcmV0dXJuIDEgLyAoMSArIE1hdGguZXhwKC14KSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2VTaWdtb2lkKHgpIHtcclxuICAgIHJldHVybiBNYXRoLmxvZyh4IC8gKDEgLSB4KSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGlvdShib3gxLCBib3gyLCBpc0lPVSkge1xyXG4gICAgaWYgKGlzSU9VID09PSB2b2lkIDApIHsgaXNJT1UgPSB0cnVlOyB9XHJcbiAgICB2YXIgd2lkdGggPSBNYXRoLm1heCgwLjAsIE1hdGgubWluKGJveDEucmlnaHQsIGJveDIucmlnaHQpIC0gTWF0aC5tYXgoYm94MS5sZWZ0LCBib3gyLmxlZnQpKTtcclxuICAgIHZhciBoZWlnaHQgPSBNYXRoLm1heCgwLjAsIE1hdGgubWluKGJveDEuYm90dG9tLCBib3gyLmJvdHRvbSkgLSBNYXRoLm1heChib3gxLnRvcCwgYm94Mi50b3ApKTtcclxuICAgIHZhciBpbnRlclNlY3Rpb24gPSB3aWR0aCAqIGhlaWdodDtcclxuICAgIHJldHVybiBpc0lPVVxyXG4gICAgICAgID8gaW50ZXJTZWN0aW9uIC8gKGJveDEuYXJlYSArIGJveDIuYXJlYSAtIGludGVyU2VjdGlvbilcclxuICAgICAgICA6IGludGVyU2VjdGlvbiAvIE1hdGgubWluKGJveDEuYXJlYSwgYm94Mi5hcmVhKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pb3UuanMubWFwIiwiaW1wb3J0IHsgQm91bmRpbmdCb3ggfSBmcm9tICcuLi9jbGFzc2VzJztcclxuZXhwb3J0IGZ1bmN0aW9uIG1pbkJib3gocHRzKSB7XHJcbiAgICB2YXIgeHMgPSBwdHMubWFwKGZ1bmN0aW9uIChwdCkgeyByZXR1cm4gcHQueDsgfSk7XHJcbiAgICB2YXIgeXMgPSBwdHMubWFwKGZ1bmN0aW9uIChwdCkgeyByZXR1cm4gcHQueTsgfSk7XHJcbiAgICB2YXIgbWluWCA9IHhzLnJlZHVjZShmdW5jdGlvbiAobWluLCB4KSB7IHJldHVybiB4IDwgbWluID8geCA6IG1pbjsgfSwgSW5maW5pdHkpO1xyXG4gICAgdmFyIG1pblkgPSB5cy5yZWR1Y2UoZnVuY3Rpb24gKG1pbiwgeSkgeyByZXR1cm4geSA8IG1pbiA/IHkgOiBtaW47IH0sIEluZmluaXR5KTtcclxuICAgIHZhciBtYXhYID0geHMucmVkdWNlKGZ1bmN0aW9uIChtYXgsIHgpIHsgcmV0dXJuIG1heCA8IHggPyB4IDogbWF4OyB9LCAwKTtcclxuICAgIHZhciBtYXhZID0geXMucmVkdWNlKGZ1bmN0aW9uIChtYXgsIHkpIHsgcmV0dXJuIG1heCA8IHkgPyB5IDogbWF4OyB9LCAwKTtcclxuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3gobWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWluQmJveC5qcy5tYXAiLCJpbXBvcnQgeyBpb3UgfSBmcm9tICcuL2lvdSc7XHJcbmV4cG9ydCBmdW5jdGlvbiBub25NYXhTdXBwcmVzc2lvbihib3hlcywgc2NvcmVzLCBpb3VUaHJlc2hvbGQsIGlzSU9VKSB7XHJcbiAgICBpZiAoaXNJT1UgPT09IHZvaWQgMCkgeyBpc0lPVSA9IHRydWU7IH1cclxuICAgIHZhciBpbmRpY2VzU29ydGVkQnlTY29yZSA9IHNjb3Jlc1xyXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHNjb3JlLCBib3hJbmRleCkgeyByZXR1cm4gKHsgc2NvcmU6IHNjb3JlLCBib3hJbmRleDogYm94SW5kZXggfSk7IH0pXHJcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGMxLCBjMikgeyByZXR1cm4gYzEuc2NvcmUgLSBjMi5zY29yZTsgfSlcclxuICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmJveEluZGV4OyB9KTtcclxuICAgIHZhciBwaWNrID0gW107XHJcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY3VyciA9IGluZGljZXNTb3J0ZWRCeVNjb3JlLnBvcCgpO1xyXG4gICAgICAgIHBpY2sucHVzaChjdXJyKTtcclxuICAgICAgICB2YXIgaW5kaWNlcyA9IGluZGljZXNTb3J0ZWRCeVNjb3JlO1xyXG4gICAgICAgIHZhciBvdXRwdXRzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpZHggPSBpbmRpY2VzW2ldO1xyXG4gICAgICAgICAgICB2YXIgY3VyckJveCA9IGJveGVzW2N1cnJdO1xyXG4gICAgICAgICAgICB2YXIgaWR4Qm94ID0gYm94ZXNbaWR4XTtcclxuICAgICAgICAgICAgb3V0cHV0cy5wdXNoKGlvdShjdXJyQm94LCBpZHhCb3gsIGlzSU9VKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGljZXNTb3J0ZWRCeVNjb3JlID0gaW5kaWNlc1NvcnRlZEJ5U2NvcmUuZmlsdGVyKGZ1bmN0aW9uIChfLCBqKSB7IHJldHVybiBvdXRwdXRzW2pdIDw9IGlvdVRocmVzaG9sZDsgfSk7XHJcbiAgICB9O1xyXG4gICAgd2hpbGUgKGluZGljZXNTb3J0ZWRCeVNjb3JlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBfbG9vcF8xKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGljaztcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub25NYXhTdXBwcmVzc2lvbi5qcy5tYXAiLCJpbXBvcnQgeyBfX3NwcmVhZEFycmF5cyB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHgsIG1lYW5SZ2IpIHtcclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgciA9IG1lYW5SZ2JbMF0sIGcgPSBtZWFuUmdiWzFdLCBiID0gbWVhblJnYlsyXTtcclxuICAgICAgICB2YXIgYXZnX3IgPSB0Zi5maWxsKF9fc3ByZWFkQXJyYXlzKHguc2hhcGUuc2xpY2UoMCwgMyksIFsxXSksIHIpO1xyXG4gICAgICAgIHZhciBhdmdfZyA9IHRmLmZpbGwoX19zcHJlYWRBcnJheXMoeC5zaGFwZS5zbGljZSgwLCAzKSwgWzFdKSwgZyk7XHJcbiAgICAgICAgdmFyIGF2Z19iID0gdGYuZmlsbChfX3NwcmVhZEFycmF5cyh4LnNoYXBlLnNsaWNlKDAsIDMpLCBbMV0pLCBiKTtcclxuICAgICAgICB2YXIgYXZnX3JnYiA9IHRmLmNvbmNhdChbYXZnX3IsIGF2Z19nLCBhdmdfYl0sIDMpO1xyXG4gICAgICAgIHJldHVybiB0Zi5zdWIoeCwgYXZnX3JnYik7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3JtYWxpemUuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuLyoqXHJcbiAqIFBhZHMgdGhlIHNtYWxsZXIgZGltZW5zaW9uIG9mIGFuIGltYWdlIHRlbnNvciB3aXRoIHplcm9zLCBzdWNoIHRoYXQgd2lkdGggPT09IGhlaWdodC5cclxuICpcclxuICogQHBhcmFtIGltZ1RlbnNvciBUaGUgaW1hZ2UgdGVuc29yLlxyXG4gKiBAcGFyYW0gaXNDZW50ZXJJbWFnZSAob3B0aW9uYWwsIGRlZmF1bHQ6IGZhbHNlKSBJZiB0cnVlLCBhZGQgYW4gZXF1YWwgYW1vdW50IG9mIHBhZGRpbmcgb25cclxuICogYm90aCBzaWRlcyBvZiB0aGUgbWlub3IgZGltZW5zaW9uIG9vZiB0aGUgaW1hZ2UuXHJcbiAqIEByZXR1cm5zIFRoZSBwYWRkZWQgdGVuc29yIHdpdGggd2lkdGggPT09IGhlaWdodC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYWRUb1NxdWFyZShpbWdUZW5zb3IsIGlzQ2VudGVySW1hZ2UpIHtcclxuICAgIGlmIChpc0NlbnRlckltYWdlID09PSB2b2lkIDApIHsgaXNDZW50ZXJJbWFnZSA9IGZhbHNlOyB9XHJcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hID0gaW1nVGVuc29yLnNoYXBlLnNsaWNlKDEpLCBoZWlnaHQgPSBfYVswXSwgd2lkdGggPSBfYVsxXTtcclxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB3aWR0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW1nVGVuc29yO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGltRGlmZiA9IE1hdGguYWJzKGhlaWdodCAtIHdpZHRoKTtcclxuICAgICAgICB2YXIgcGFkZGluZ0Ftb3VudCA9IE1hdGgucm91bmQoZGltRGlmZiAqIChpc0NlbnRlckltYWdlID8gMC41IDogMSkpO1xyXG4gICAgICAgIHZhciBwYWRkaW5nQXhpcyA9IGhlaWdodCA+IHdpZHRoID8gMiA6IDE7XHJcbiAgICAgICAgdmFyIGNyZWF0ZVBhZGRpbmdUZW5zb3IgPSBmdW5jdGlvbiAocGFkZGluZ0Ftb3VudCkge1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZ1RlbnNvclNoYXBlID0gaW1nVGVuc29yLnNoYXBlLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIHBhZGRpbmdUZW5zb3JTaGFwZVtwYWRkaW5nQXhpc10gPSBwYWRkaW5nQW1vdW50O1xyXG4gICAgICAgICAgICByZXR1cm4gdGYuZmlsbChwYWRkaW5nVGVuc29yU2hhcGUsIDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHBhZGRpbmdUZW5zb3JBcHBlbmQgPSBjcmVhdGVQYWRkaW5nVGVuc29yKHBhZGRpbmdBbW91bnQpO1xyXG4gICAgICAgIHZhciByZW1haW5pbmdQYWRkaW5nQW1vdW50ID0gZGltRGlmZiAtIHBhZGRpbmdUZW5zb3JBcHBlbmQuc2hhcGVbcGFkZGluZ0F4aXNdO1xyXG4gICAgICAgIHZhciBwYWRkaW5nVGVuc29yUHJlcGVuZCA9IGlzQ2VudGVySW1hZ2UgJiYgcmVtYWluaW5nUGFkZGluZ0Ftb3VudFxyXG4gICAgICAgICAgICA/IGNyZWF0ZVBhZGRpbmdUZW5zb3IocmVtYWluaW5nUGFkZGluZ0Ftb3VudClcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIHZhciB0ZW5zb3JzVG9TdGFjayA9IFtcclxuICAgICAgICAgICAgcGFkZGluZ1RlbnNvclByZXBlbmQsXHJcbiAgICAgICAgICAgIGltZ1RlbnNvcixcclxuICAgICAgICAgICAgcGFkZGluZ1RlbnNvckFwcGVuZFxyXG4gICAgICAgIF1cclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gISF0OyB9KVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnRvRmxvYXQoKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRmLmNvbmNhdCh0ZW5zb3JzVG9TdGFjaywgcGFkZGluZ0F4aXMpO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFkVG9TcXVhcmUuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIHNodWZmbGVBcnJheShpbnB1dEFycmF5KSB7XHJcbiAgICB2YXIgYXJyYXkgPSBpbnB1dEFycmF5LnNsaWNlKCk7XHJcbiAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xyXG4gICAgICAgIHZhciBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XHJcbiAgICAgICAgdmFyIHggPSBhcnJheVtpXTtcclxuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xyXG4gICAgICAgIGFycmF5W2pdID0geDtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaHVmZmxlQXJyYXkuanMubWFwIiwiaW1wb3J0IHsgRGltZW5zaW9ucyB9IGZyb20gJy4vY2xhc3Nlcyc7XHJcbmltcG9ydCB7IEZhY2VEZXRlY3Rpb24gfSBmcm9tICcuL2NsYXNzZXMvRmFjZURldGVjdGlvbic7XHJcbmltcG9ydCB7IEZhY2VMYW5kbWFya3MgfSBmcm9tICcuL2NsYXNzZXMvRmFjZUxhbmRtYXJrcyc7XHJcbmltcG9ydCB7IGV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9uLCBpc1dpdGhGYWNlRGV0ZWN0aW9uIH0gZnJvbSAnLi9mYWN0b3JpZXMvV2l0aEZhY2VEZXRlY3Rpb24nO1xyXG5pbXBvcnQgeyBleHRlbmRXaXRoRmFjZUxhbmRtYXJrcywgaXNXaXRoRmFjZUxhbmRtYXJrcyB9IGZyb20gJy4vZmFjdG9yaWVzL1dpdGhGYWNlTGFuZG1hcmtzJztcclxuZXhwb3J0IGZ1bmN0aW9uIHJlc2l6ZVJlc3VsdHMocmVzdWx0cywgZGltZW5zaW9ucykge1xyXG4gICAgdmFyIF9hID0gbmV3IERpbWVuc2lvbnMoZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlc2l6ZVJlc3VsdHMgLSBpbnZhbGlkIGRpbWVuc2lvbnM6IFwiICsgSlNPTi5zdHJpbmdpZnkoeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pKTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMubWFwKGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHJlc2l6ZVJlc3VsdHMob2JqLCB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7IH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzV2l0aEZhY2VMYW5kbWFya3MocmVzdWx0cykpIHtcclxuICAgICAgICB2YXIgcmVzaXplZERldGVjdGlvbiA9IHJlc3VsdHMuZGV0ZWN0aW9uLmZvclNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdmFyIHJlc2l6ZWRMYW5kbWFya3MgPSByZXN1bHRzLnVuc2hpZnRlZExhbmRtYXJrcy5mb3JTaXplKHJlc2l6ZWREZXRlY3Rpb24uYm94LndpZHRoLCByZXNpemVkRGV0ZWN0aW9uLmJveC5oZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiBleHRlbmRXaXRoRmFjZUxhbmRtYXJrcyhleHRlbmRXaXRoRmFjZURldGVjdGlvbihyZXN1bHRzLCByZXNpemVkRGV0ZWN0aW9uKSwgcmVzaXplZExhbmRtYXJrcyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNXaXRoRmFjZURldGVjdGlvbihyZXN1bHRzKSkge1xyXG4gICAgICAgIHJldHVybiBleHRlbmRXaXRoRmFjZURldGVjdGlvbihyZXN1bHRzLCByZXN1bHRzLmRldGVjdGlvbi5mb3JTaXplKHdpZHRoLCBoZWlnaHQpKTtcclxuICAgIH1cclxuICAgIGlmIChyZXN1bHRzIGluc3RhbmNlb2YgRmFjZUxhbmRtYXJrcyB8fCByZXN1bHRzIGluc3RhbmNlb2YgRmFjZURldGVjdGlvbikge1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzLmZvclNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNpemVSZXN1bHRzLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19leHRlbmRzLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBSZWN0IH0gZnJvbSAnLi4vY2xhc3Nlcyc7XHJcbmltcG9ydCB7IEZhY2VEZXRlY3Rpb24gfSBmcm9tICcuLi9jbGFzc2VzL0ZhY2VEZXRlY3Rpb24nO1xyXG5pbXBvcnQgeyB0b05ldElucHV0IH0gZnJvbSAnLi4vZG9tJztcclxuaW1wb3J0IHsgTmV1cmFsTmV0d29yayB9IGZyb20gJy4uL05ldXJhbE5ldHdvcmsnO1xyXG5pbXBvcnQgeyBleHRyYWN0UGFyYW1zIH0gZnJvbSAnLi9leHRyYWN0UGFyYW1zJztcclxuaW1wb3J0IHsgZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAgfSBmcm9tICcuL2V4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwJztcclxuaW1wb3J0IHsgbW9iaWxlTmV0VjEgfSBmcm9tICcuL21vYmlsZU5ldFYxJztcclxuaW1wb3J0IHsgbm9uTWF4U3VwcHJlc3Npb24gfSBmcm9tICcuL25vbk1heFN1cHByZXNzaW9uJztcclxuaW1wb3J0IHsgb3V0cHV0TGF5ZXIgfSBmcm9tICcuL291dHB1dExheWVyJztcclxuaW1wb3J0IHsgcHJlZGljdGlvbkxheWVyIH0gZnJvbSAnLi9wcmVkaWN0aW9uTGF5ZXInO1xyXG5pbXBvcnQgeyBTc2RNb2JpbGVuZXR2MU9wdGlvbnMgfSBmcm9tICcuL1NzZE1vYmlsZW5ldHYxT3B0aW9ucyc7XHJcbnZhciBTc2RNb2JpbGVuZXR2MSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTc2RNb2JpbGVuZXR2MSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNzZE1vYmlsZW5ldHYxKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAnU3NkTW9iaWxlbmV0djEnKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgU3NkTW9iaWxlbmV0djEucHJvdG90eXBlLmZvcndhcmRJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcztcclxuICAgICAgICBpZiAoIXBhcmFtcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NzZE1vYmlsZW5ldHYxIC0gbG9hZCBtb2RlbCBiZWZvcmUgaW5mZXJlbmNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJhdGNoVGVuc29yID0gaW5wdXQudG9CYXRjaFRlbnNvcig1MTIsIGZhbHNlKS50b0Zsb2F0KCk7XHJcbiAgICAgICAgICAgIHZhciB4ID0gdGYuc3ViKHRmLm11bChiYXRjaFRlbnNvciwgdGYuc2NhbGFyKDAuMDA3ODQzMTM3NzE4NzM3MTI1KSksIHRmLnNjYWxhcigxKSk7XHJcbiAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IG1vYmlsZU5ldFYxKHgsIHBhcmFtcy5tb2JpbGVuZXR2MSk7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHByZWRpY3Rpb25MYXllcihmZWF0dXJlcy5vdXQsIGZlYXR1cmVzLmNvbnYxMSwgcGFyYW1zLnByZWRpY3Rpb25fbGF5ZXIpLCBib3hQcmVkaWN0aW9ucyA9IF9hLmJveFByZWRpY3Rpb25zLCBjbGFzc1ByZWRpY3Rpb25zID0gX2EuY2xhc3NQcmVkaWN0aW9ucztcclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dExheWVyKGJveFByZWRpY3Rpb25zLCBjbGFzc1ByZWRpY3Rpb25zLCBwYXJhbXMub3V0cHV0X2xheWVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTc2RNb2JpbGVuZXR2MS5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMuZm9yd2FyZElucHV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0b05ldElucHV0KGlucHV0KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2EuYXBwbHkodGhpcywgW19iLnNlbnQoKV0pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3NkTW9iaWxlbmV0djEucHJvdG90eXBlLmxvY2F0ZUZhY2VzID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgbWF4UmVzdWx0cywgbWluQ29uZmlkZW5jZSwgbmV0SW5wdXQsIF9iLCBfYm94ZXMsIF9zY29yZXMsIGJveGVzLCBzY29yZXMsIGksIHNjb3Jlc0RhdGEsIF9jLCBfZCwgaW91VGhyZXNob2xkLCBpbmRpY2VzLCByZXNoYXBlZERpbXMsIGlucHV0U2l6ZSwgcGFkWCwgcGFkWSwgYm94ZXNEYXRhLCByZXN1bHRzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IG5ldyBTc2RNb2JpbGVuZXR2MU9wdGlvbnMob3B0aW9ucyksIG1heFJlc3VsdHMgPSBfYS5tYXhSZXN1bHRzLCBtaW5Db25maWRlbmNlID0gX2EubWluQ29uZmlkZW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdG9OZXRJbnB1dChpbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0SW5wdXQgPSBfZS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gdGhpcy5mb3J3YXJkSW5wdXQobmV0SW5wdXQpLCBfYm94ZXMgPSBfYi5ib3hlcywgX3Njb3JlcyA9IF9iLnNjb3JlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm94ZXMgPSBfYm94ZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlcyA9IF9zY29yZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBfYm94ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ib3hlc1tpXS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2NvcmVzW2ldLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZCA9IChfYyA9IEFycmF5KS5mcm9tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzY29yZXMuZGF0YSgpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3Jlc0RhdGEgPSBfZC5hcHBseShfYywgW19lLnNlbnQoKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpb3VUaHJlc2hvbGQgPSAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXMgPSBub25NYXhTdXBwcmVzc2lvbihib3hlcywgc2NvcmVzRGF0YSwgbWF4UmVzdWx0cywgaW91VGhyZXNob2xkLCBtaW5Db25maWRlbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaGFwZWREaW1zID0gbmV0SW5wdXQuZ2V0UmVzaGFwZWRJbnB1dERpbWVuc2lvbnMoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0U2l6ZSA9IG5ldElucHV0LmlucHV0U2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkWCA9IGlucHV0U2l6ZSAvIHJlc2hhcGVkRGltcy53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkWSA9IGlucHV0U2l6ZSAvIHJlc2hhcGVkRGltcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveGVzRGF0YSA9IGJveGVzLmFycmF5U3luYygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gaW5kaWNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaWR4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgYm94ZXNEYXRhW2lkeF1bMF0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKDEuMCwgYm94ZXNEYXRhW2lkeF1bMl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwgKiBwYWRZOyB9KSwgdG9wID0gX2FbMF0sIGJvdHRvbSA9IF9hWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDAsIGJveGVzRGF0YVtpZHhdWzFdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbigxLjAsIGJveGVzRGF0YVtpZHhdWzNdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsICogcGFkWDsgfSksIGxlZnQgPSBfYlswXSwgcmlnaHQgPSBfYlsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFjZURldGVjdGlvbihzY29yZXNEYXRhW2lkeF0sIG5ldyBSZWN0KGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXRJbnB1dC5nZXRJbnB1dEhlaWdodCgwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbmV0SW5wdXQuZ2V0SW5wdXRXaWR0aCgwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hlcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3Jlcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRzXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3NkTW9iaWxlbmV0djEucHJvdG90eXBlLmdldERlZmF1bHRNb2RlbE5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICdzc2RfbW9iaWxlbmV0djFfbW9kZWwnO1xyXG4gICAgfTtcclxuICAgIFNzZE1vYmlsZW5ldHYxLnByb3RvdHlwZS5leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCA9IGZ1bmN0aW9uICh3ZWlnaHRNYXApIHtcclxuICAgICAgICByZXR1cm4gZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAod2VpZ2h0TWFwKTtcclxuICAgIH07XHJcbiAgICBTc2RNb2JpbGVuZXR2MS5wcm90b3R5cGUuZXh0cmFjdFBhcmFtcyA9IGZ1bmN0aW9uICh3ZWlnaHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RQYXJhbXMod2VpZ2h0cyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNzZE1vYmlsZW5ldHYxO1xyXG59KE5ldXJhbE5ldHdvcmspKTtcclxuZXhwb3J0IHsgU3NkTW9iaWxlbmV0djEgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3NkTW9iaWxlbmV0djEuanMubWFwIiwidmFyIFNzZE1vYmlsZW5ldHYxT3B0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNzZE1vYmlsZW5ldHYxT3B0aW9ucyhfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtaW5Db25maWRlbmNlID0gX2IubWluQ29uZmlkZW5jZSwgbWF4UmVzdWx0cyA9IF9iLm1heFJlc3VsdHM7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9ICdTc2RNb2JpbGVuZXR2MU9wdGlvbnMnO1xyXG4gICAgICAgIHRoaXMuX21pbkNvbmZpZGVuY2UgPSBtaW5Db25maWRlbmNlIHx8IDAuNTtcclxuICAgICAgICB0aGlzLl9tYXhSZXN1bHRzID0gbWF4UmVzdWx0cyB8fCAxMDA7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9taW5Db25maWRlbmNlICE9PSAnbnVtYmVyJyB8fCB0aGlzLl9taW5Db25maWRlbmNlIDw9IDAgfHwgdGhpcy5fbWluQ29uZmlkZW5jZSA+PSAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9uYW1lICsgXCIgLSBleHBlY3RlZCBtaW5Db25maWRlbmNlIHRvIGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9tYXhSZXN1bHRzICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fbmFtZSArIFwiIC0gZXhwZWN0ZWQgbWF4UmVzdWx0cyB0byBiZSBhIG51bWJlclwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3NkTW9iaWxlbmV0djFPcHRpb25zLnByb3RvdHlwZSwgXCJtaW5Db25maWRlbmNlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21pbkNvbmZpZGVuY2U7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNzZE1vYmlsZW5ldHYxT3B0aW9ucy5wcm90b3R5cGUsIFwibWF4UmVzdWx0c1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXhSZXN1bHRzOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBTc2RNb2JpbGVuZXR2MU9wdGlvbnM7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IFNzZE1vYmlsZW5ldHYxT3B0aW9ucyB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Tc2RNb2JpbGVuZXR2MU9wdGlvbnMuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgY29udkxheWVyIH0gZnJvbSAnLi4vY29tbW9uJztcclxuZXhwb3J0IGZ1bmN0aW9uIGJveFByZWRpY3Rpb25MYXllcih4LCBwYXJhbXMpIHtcclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYmF0Y2hTaXplID0geC5zaGFwZVswXTtcclxuICAgICAgICB2YXIgYm94UHJlZGljdGlvbkVuY29kaW5nID0gdGYucmVzaGFwZShjb252TGF5ZXIoeCwgcGFyYW1zLmJveF9lbmNvZGluZ19wcmVkaWN0b3IpLCBbYmF0Y2hTaXplLCAtMSwgMSwgNF0pO1xyXG4gICAgICAgIHZhciBjbGFzc1ByZWRpY3Rpb24gPSB0Zi5yZXNoYXBlKGNvbnZMYXllcih4LCBwYXJhbXMuY2xhc3NfcHJlZGljdG9yKSwgW2JhdGNoU2l6ZSwgLTEsIDNdKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBib3hQcmVkaWN0aW9uRW5jb2Rpbmc6IGJveFByZWRpY3Rpb25FbmNvZGluZyxcclxuICAgICAgICAgICAgY2xhc3NQcmVkaWN0aW9uOiBjbGFzc1ByZWRpY3Rpb25cclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym94UHJlZGljdGlvbkxheWVyLmpzLm1hcCIsImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XHJcbmltcG9ydCB7IGV4dHJhY3RXZWlnaHRzRmFjdG9yeSB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmZ1bmN0aW9uIGV4dHJhY3RvcnNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKSB7XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0RGVwdGh3aXNlQ29udlBhcmFtcyhudW1DaGFubmVscywgbWFwcGVkUHJlZml4KSB7XHJcbiAgICAgICAgdmFyIGZpbHRlcnMgPSB0Zi50ZW5zb3I0ZChleHRyYWN0V2VpZ2h0cygzICogMyAqIG51bUNoYW5uZWxzKSwgWzMsIDMsIG51bUNoYW5uZWxzLCAxXSk7XHJcbiAgICAgICAgdmFyIGJhdGNoX25vcm1fc2NhbGUgPSB0Zi50ZW5zb3IxZChleHRyYWN0V2VpZ2h0cyhudW1DaGFubmVscykpO1xyXG4gICAgICAgIHZhciBiYXRjaF9ub3JtX29mZnNldCA9IHRmLnRlbnNvcjFkKGV4dHJhY3RXZWlnaHRzKG51bUNoYW5uZWxzKSk7XHJcbiAgICAgICAgdmFyIGJhdGNoX25vcm1fbWVhbiA9IHRmLnRlbnNvcjFkKGV4dHJhY3RXZWlnaHRzKG51bUNoYW5uZWxzKSk7XHJcbiAgICAgICAgdmFyIGJhdGNoX25vcm1fdmFyaWFuY2UgPSB0Zi50ZW5zb3IxZChleHRyYWN0V2VpZ2h0cyhudW1DaGFubmVscykpO1xyXG4gICAgICAgIHBhcmFtTWFwcGluZ3MucHVzaCh7IHBhcmFtUGF0aDogbWFwcGVkUHJlZml4ICsgXCIvZmlsdGVyc1wiIH0sIHsgcGFyYW1QYXRoOiBtYXBwZWRQcmVmaXggKyBcIi9iYXRjaF9ub3JtX3NjYWxlXCIgfSwgeyBwYXJhbVBhdGg6IG1hcHBlZFByZWZpeCArIFwiL2JhdGNoX25vcm1fb2Zmc2V0XCIgfSwgeyBwYXJhbVBhdGg6IG1hcHBlZFByZWZpeCArIFwiL2JhdGNoX25vcm1fbWVhblwiIH0sIHsgcGFyYW1QYXRoOiBtYXBwZWRQcmVmaXggKyBcIi9iYXRjaF9ub3JtX3ZhcmlhbmNlXCIgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsdGVyczogZmlsdGVycyxcclxuICAgICAgICAgICAgYmF0Y2hfbm9ybV9zY2FsZTogYmF0Y2hfbm9ybV9zY2FsZSxcclxuICAgICAgICAgICAgYmF0Y2hfbm9ybV9vZmZzZXQ6IGJhdGNoX25vcm1fb2Zmc2V0LFxyXG4gICAgICAgICAgICBiYXRjaF9ub3JtX21lYW46IGJhdGNoX25vcm1fbWVhbixcclxuICAgICAgICAgICAgYmF0Y2hfbm9ybV92YXJpYW5jZTogYmF0Y2hfbm9ybV92YXJpYW5jZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0Q29udlBhcmFtcyhjaGFubmVsc0luLCBjaGFubmVsc091dCwgZmlsdGVyU2l6ZSwgbWFwcGVkUHJlZml4LCBpc1BvaW50d2lzZUNvbnYpIHtcclxuICAgICAgICB2YXIgZmlsdGVycyA9IHRmLnRlbnNvcjRkKGV4dHJhY3RXZWlnaHRzKGNoYW5uZWxzSW4gKiBjaGFubmVsc091dCAqIGZpbHRlclNpemUgKiBmaWx0ZXJTaXplKSwgW2ZpbHRlclNpemUsIGZpbHRlclNpemUsIGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0XSk7XHJcbiAgICAgICAgdmFyIGJpYXMgPSB0Zi50ZW5zb3IxZChleHRyYWN0V2VpZ2h0cyhjaGFubmVsc091dCkpO1xyXG4gICAgICAgIHBhcmFtTWFwcGluZ3MucHVzaCh7IHBhcmFtUGF0aDogbWFwcGVkUHJlZml4ICsgXCIvZmlsdGVyc1wiIH0sIHsgcGFyYW1QYXRoOiBtYXBwZWRQcmVmaXggKyBcIi9cIiArIChpc1BvaW50d2lzZUNvbnYgPyAnYmF0Y2hfbm9ybV9vZmZzZXQnIDogJ2JpYXMnKSB9KTtcclxuICAgICAgICByZXR1cm4geyBmaWx0ZXJzOiBmaWx0ZXJzLCBiaWFzOiBiaWFzIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcyhjaGFubmVsc0luLCBjaGFubmVsc091dCwgZmlsdGVyU2l6ZSwgbWFwcGVkUHJlZml4KSB7XHJcbiAgICAgICAgdmFyIF9hID0gZXh0cmFjdENvbnZQYXJhbXMoY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXQsIGZpbHRlclNpemUsIG1hcHBlZFByZWZpeCwgdHJ1ZSksIGZpbHRlcnMgPSBfYS5maWx0ZXJzLCBiaWFzID0gX2EuYmlhcztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxyXG4gICAgICAgICAgICBiYXRjaF9ub3JtX29mZnNldDogYmlhc1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0Q29udlBhaXJQYXJhbXMoY2hhbm5lbHNJbiwgY2hhbm5lbHNPdXQsIG1hcHBlZFByZWZpeCkge1xyXG4gICAgICAgIHZhciBkZXB0aHdpc2VfY29udiA9IGV4dHJhY3REZXB0aHdpc2VDb252UGFyYW1zKGNoYW5uZWxzSW4sIG1hcHBlZFByZWZpeCArIFwiL2RlcHRod2lzZV9jb252XCIpO1xyXG4gICAgICAgIHZhciBwb2ludHdpc2VfY29udiA9IGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCAxLCBtYXBwZWRQcmVmaXggKyBcIi9wb2ludHdpc2VfY29udlwiKTtcclxuICAgICAgICByZXR1cm4geyBkZXB0aHdpc2VfY29udjogZGVwdGh3aXNlX2NvbnYsIHBvaW50d2lzZV9jb252OiBwb2ludHdpc2VfY29udiB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdE1vYmlsZW5ldFYxUGFyYW1zKCkge1xyXG4gICAgICAgIHZhciBjb252XzAgPSBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcygzLCAzMiwgMywgJ21vYmlsZW5ldHYxL2NvbnZfMCcpO1xyXG4gICAgICAgIHZhciBjb252XzEgPSBleHRyYWN0Q29udlBhaXJQYXJhbXMoMzIsIDY0LCAnbW9iaWxlbmV0djEvY29udl8xJyk7XHJcbiAgICAgICAgdmFyIGNvbnZfMiA9IGV4dHJhY3RDb252UGFpclBhcmFtcyg2NCwgMTI4LCAnbW9iaWxlbmV0djEvY29udl8yJyk7XHJcbiAgICAgICAgdmFyIGNvbnZfMyA9IGV4dHJhY3RDb252UGFpclBhcmFtcygxMjgsIDEyOCwgJ21vYmlsZW5ldHYxL2NvbnZfMycpO1xyXG4gICAgICAgIHZhciBjb252XzQgPSBleHRyYWN0Q29udlBhaXJQYXJhbXMoMTI4LCAyNTYsICdtb2JpbGVuZXR2MS9jb252XzQnKTtcclxuICAgICAgICB2YXIgY29udl81ID0gZXh0cmFjdENvbnZQYWlyUGFyYW1zKDI1NiwgMjU2LCAnbW9iaWxlbmV0djEvY29udl81Jyk7XHJcbiAgICAgICAgdmFyIGNvbnZfNiA9IGV4dHJhY3RDb252UGFpclBhcmFtcygyNTYsIDUxMiwgJ21vYmlsZW5ldHYxL2NvbnZfNicpO1xyXG4gICAgICAgIHZhciBjb252XzcgPSBleHRyYWN0Q29udlBhaXJQYXJhbXMoNTEyLCA1MTIsICdtb2JpbGVuZXR2MS9jb252XzcnKTtcclxuICAgICAgICB2YXIgY29udl84ID0gZXh0cmFjdENvbnZQYWlyUGFyYW1zKDUxMiwgNTEyLCAnbW9iaWxlbmV0djEvY29udl84Jyk7XHJcbiAgICAgICAgdmFyIGNvbnZfOSA9IGV4dHJhY3RDb252UGFpclBhcmFtcyg1MTIsIDUxMiwgJ21vYmlsZW5ldHYxL2NvbnZfOScpO1xyXG4gICAgICAgIHZhciBjb252XzEwID0gZXh0cmFjdENvbnZQYWlyUGFyYW1zKDUxMiwgNTEyLCAnbW9iaWxlbmV0djEvY29udl8xMCcpO1xyXG4gICAgICAgIHZhciBjb252XzExID0gZXh0cmFjdENvbnZQYWlyUGFyYW1zKDUxMiwgNTEyLCAnbW9iaWxlbmV0djEvY29udl8xMScpO1xyXG4gICAgICAgIHZhciBjb252XzEyID0gZXh0cmFjdENvbnZQYWlyUGFyYW1zKDUxMiwgMTAyNCwgJ21vYmlsZW5ldHYxL2NvbnZfMTInKTtcclxuICAgICAgICB2YXIgY29udl8xMyA9IGV4dHJhY3RDb252UGFpclBhcmFtcygxMDI0LCAxMDI0LCAnbW9iaWxlbmV0djEvY29udl8xMycpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbnZfMDogY29udl8wLFxyXG4gICAgICAgICAgICBjb252XzE6IGNvbnZfMSxcclxuICAgICAgICAgICAgY29udl8yOiBjb252XzIsXHJcbiAgICAgICAgICAgIGNvbnZfMzogY29udl8zLFxyXG4gICAgICAgICAgICBjb252XzQ6IGNvbnZfNCxcclxuICAgICAgICAgICAgY29udl81OiBjb252XzUsXHJcbiAgICAgICAgICAgIGNvbnZfNjogY29udl82LFxyXG4gICAgICAgICAgICBjb252Xzc6IGNvbnZfNyxcclxuICAgICAgICAgICAgY29udl84OiBjb252XzgsXHJcbiAgICAgICAgICAgIGNvbnZfOTogY29udl85LFxyXG4gICAgICAgICAgICBjb252XzEwOiBjb252XzEwLFxyXG4gICAgICAgICAgICBjb252XzExOiBjb252XzExLFxyXG4gICAgICAgICAgICBjb252XzEyOiBjb252XzEyLFxyXG4gICAgICAgICAgICBjb252XzEzOiBjb252XzEzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RQcmVkaWN0aW9uTGF5ZXJQYXJhbXMoKSB7XHJcbiAgICAgICAgdmFyIGNvbnZfMCA9IGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKDEwMjQsIDI1NiwgMSwgJ3ByZWRpY3Rpb25fbGF5ZXIvY29udl8wJyk7XHJcbiAgICAgICAgdmFyIGNvbnZfMSA9IGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKDI1NiwgNTEyLCAzLCAncHJlZGljdGlvbl9sYXllci9jb252XzEnKTtcclxuICAgICAgICB2YXIgY29udl8yID0gZXh0cmFjdFBvaW50d2lzZUNvbnZQYXJhbXMoNTEyLCAxMjgsIDEsICdwcmVkaWN0aW9uX2xheWVyL2NvbnZfMicpO1xyXG4gICAgICAgIHZhciBjb252XzMgPSBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcygxMjgsIDI1NiwgMywgJ3ByZWRpY3Rpb25fbGF5ZXIvY29udl8zJyk7XHJcbiAgICAgICAgdmFyIGNvbnZfNCA9IGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKDI1NiwgMTI4LCAxLCAncHJlZGljdGlvbl9sYXllci9jb252XzQnKTtcclxuICAgICAgICB2YXIgY29udl81ID0gZXh0cmFjdFBvaW50d2lzZUNvbnZQYXJhbXMoMTI4LCAyNTYsIDMsICdwcmVkaWN0aW9uX2xheWVyL2NvbnZfNScpO1xyXG4gICAgICAgIHZhciBjb252XzYgPSBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcygyNTYsIDY0LCAxLCAncHJlZGljdGlvbl9sYXllci9jb252XzYnKTtcclxuICAgICAgICB2YXIgY29udl83ID0gZXh0cmFjdFBvaW50d2lzZUNvbnZQYXJhbXMoNjQsIDEyOCwgMywgJ3ByZWRpY3Rpb25fbGF5ZXIvY29udl83Jyk7XHJcbiAgICAgICAgdmFyIGJveF9lbmNvZGluZ18wX3ByZWRpY3RvciA9IGV4dHJhY3RDb252UGFyYW1zKDUxMiwgMTIsIDEsICdwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfMC9ib3hfZW5jb2RpbmdfcHJlZGljdG9yJyk7XHJcbiAgICAgICAgdmFyIGNsYXNzX3ByZWRpY3Rvcl8wID0gZXh0cmFjdENvbnZQYXJhbXMoNTEyLCA5LCAxLCAncHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzAvY2xhc3NfcHJlZGljdG9yJyk7XHJcbiAgICAgICAgdmFyIGJveF9lbmNvZGluZ18xX3ByZWRpY3RvciA9IGV4dHJhY3RDb252UGFyYW1zKDEwMjQsIDI0LCAxLCAncHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzEvYm94X2VuY29kaW5nX3ByZWRpY3RvcicpO1xyXG4gICAgICAgIHZhciBjbGFzc19wcmVkaWN0b3JfMSA9IGV4dHJhY3RDb252UGFyYW1zKDEwMjQsIDE4LCAxLCAncHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzEvY2xhc3NfcHJlZGljdG9yJyk7XHJcbiAgICAgICAgdmFyIGJveF9lbmNvZGluZ18yX3ByZWRpY3RvciA9IGV4dHJhY3RDb252UGFyYW1zKDUxMiwgMjQsIDEsICdwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfMi9ib3hfZW5jb2RpbmdfcHJlZGljdG9yJyk7XHJcbiAgICAgICAgdmFyIGNsYXNzX3ByZWRpY3Rvcl8yID0gZXh0cmFjdENvbnZQYXJhbXMoNTEyLCAxOCwgMSwgJ3ByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl8yL2NsYXNzX3ByZWRpY3RvcicpO1xyXG4gICAgICAgIHZhciBib3hfZW5jb2RpbmdfM19wcmVkaWN0b3IgPSBleHRyYWN0Q29udlBhcmFtcygyNTYsIDI0LCAxLCAncHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzMvYm94X2VuY29kaW5nX3ByZWRpY3RvcicpO1xyXG4gICAgICAgIHZhciBjbGFzc19wcmVkaWN0b3JfMyA9IGV4dHJhY3RDb252UGFyYW1zKDI1NiwgMTgsIDEsICdwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfMy9jbGFzc19wcmVkaWN0b3InKTtcclxuICAgICAgICB2YXIgYm94X2VuY29kaW5nXzRfcHJlZGljdG9yID0gZXh0cmFjdENvbnZQYXJhbXMoMjU2LCAyNCwgMSwgJ3ByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl80L2JveF9lbmNvZGluZ19wcmVkaWN0b3InKTtcclxuICAgICAgICB2YXIgY2xhc3NfcHJlZGljdG9yXzQgPSBleHRyYWN0Q29udlBhcmFtcygyNTYsIDE4LCAxLCAncHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzQvY2xhc3NfcHJlZGljdG9yJyk7XHJcbiAgICAgICAgdmFyIGJveF9lbmNvZGluZ181X3ByZWRpY3RvciA9IGV4dHJhY3RDb252UGFyYW1zKDEyOCwgMjQsIDEsICdwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfNS9ib3hfZW5jb2RpbmdfcHJlZGljdG9yJyk7XHJcbiAgICAgICAgdmFyIGNsYXNzX3ByZWRpY3Rvcl81ID0gZXh0cmFjdENvbnZQYXJhbXMoMTI4LCAxOCwgMSwgJ3ByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl81L2NsYXNzX3ByZWRpY3RvcicpO1xyXG4gICAgICAgIHZhciBib3hfcHJlZGljdG9yXzAgPSB7XHJcbiAgICAgICAgICAgIGJveF9lbmNvZGluZ19wcmVkaWN0b3I6IGJveF9lbmNvZGluZ18wX3ByZWRpY3RvcixcclxuICAgICAgICAgICAgY2xhc3NfcHJlZGljdG9yOiBjbGFzc19wcmVkaWN0b3JfMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGJveF9wcmVkaWN0b3JfMSA9IHtcclxuICAgICAgICAgICAgYm94X2VuY29kaW5nX3ByZWRpY3RvcjogYm94X2VuY29kaW5nXzFfcHJlZGljdG9yLFxyXG4gICAgICAgICAgICBjbGFzc19wcmVkaWN0b3I6IGNsYXNzX3ByZWRpY3Rvcl8xXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgYm94X3ByZWRpY3Rvcl8yID0ge1xyXG4gICAgICAgICAgICBib3hfZW5jb2RpbmdfcHJlZGljdG9yOiBib3hfZW5jb2RpbmdfMl9wcmVkaWN0b3IsXHJcbiAgICAgICAgICAgIGNsYXNzX3ByZWRpY3RvcjogY2xhc3NfcHJlZGljdG9yXzJcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBib3hfcHJlZGljdG9yXzMgPSB7XHJcbiAgICAgICAgICAgIGJveF9lbmNvZGluZ19wcmVkaWN0b3I6IGJveF9lbmNvZGluZ18zX3ByZWRpY3RvcixcclxuICAgICAgICAgICAgY2xhc3NfcHJlZGljdG9yOiBjbGFzc19wcmVkaWN0b3JfM1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGJveF9wcmVkaWN0b3JfNCA9IHtcclxuICAgICAgICAgICAgYm94X2VuY29kaW5nX3ByZWRpY3RvcjogYm94X2VuY29kaW5nXzRfcHJlZGljdG9yLFxyXG4gICAgICAgICAgICBjbGFzc19wcmVkaWN0b3I6IGNsYXNzX3ByZWRpY3Rvcl80XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgYm94X3ByZWRpY3Rvcl81ID0ge1xyXG4gICAgICAgICAgICBib3hfZW5jb2RpbmdfcHJlZGljdG9yOiBib3hfZW5jb2RpbmdfNV9wcmVkaWN0b3IsXHJcbiAgICAgICAgICAgIGNsYXNzX3ByZWRpY3RvcjogY2xhc3NfcHJlZGljdG9yXzVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbnZfMDogY29udl8wLFxyXG4gICAgICAgICAgICBjb252XzE6IGNvbnZfMSxcclxuICAgICAgICAgICAgY29udl8yOiBjb252XzIsXHJcbiAgICAgICAgICAgIGNvbnZfMzogY29udl8zLFxyXG4gICAgICAgICAgICBjb252XzQ6IGNvbnZfNCxcclxuICAgICAgICAgICAgY29udl81OiBjb252XzUsXHJcbiAgICAgICAgICAgIGNvbnZfNjogY29udl82LFxyXG4gICAgICAgICAgICBjb252Xzc6IGNvbnZfNyxcclxuICAgICAgICAgICAgYm94X3ByZWRpY3Rvcl8wOiBib3hfcHJlZGljdG9yXzAsXHJcbiAgICAgICAgICAgIGJveF9wcmVkaWN0b3JfMTogYm94X3ByZWRpY3Rvcl8xLFxyXG4gICAgICAgICAgICBib3hfcHJlZGljdG9yXzI6IGJveF9wcmVkaWN0b3JfMixcclxuICAgICAgICAgICAgYm94X3ByZWRpY3Rvcl8zOiBib3hfcHJlZGljdG9yXzMsXHJcbiAgICAgICAgICAgIGJveF9wcmVkaWN0b3JfNDogYm94X3ByZWRpY3Rvcl80LFxyXG4gICAgICAgICAgICBib3hfcHJlZGljdG9yXzU6IGJveF9wcmVkaWN0b3JfNVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4dHJhY3RNb2JpbGVuZXRWMVBhcmFtczogZXh0cmFjdE1vYmlsZW5ldFYxUGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3RQcmVkaWN0aW9uTGF5ZXJQYXJhbXM6IGV4dHJhY3RQcmVkaWN0aW9uTGF5ZXJQYXJhbXNcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQYXJhbXMod2VpZ2h0cykge1xyXG4gICAgdmFyIHBhcmFtTWFwcGluZ3MgPSBbXTtcclxuICAgIHZhciBfYSA9IGV4dHJhY3RXZWlnaHRzRmFjdG9yeSh3ZWlnaHRzKSwgZXh0cmFjdFdlaWdodHMgPSBfYS5leHRyYWN0V2VpZ2h0cywgZ2V0UmVtYWluaW5nV2VpZ2h0cyA9IF9hLmdldFJlbWFpbmluZ1dlaWdodHM7XHJcbiAgICB2YXIgX2IgPSBleHRyYWN0b3JzRmFjdG9yeShleHRyYWN0V2VpZ2h0cywgcGFyYW1NYXBwaW5ncyksIGV4dHJhY3RNb2JpbGVuZXRWMVBhcmFtcyA9IF9iLmV4dHJhY3RNb2JpbGVuZXRWMVBhcmFtcywgZXh0cmFjdFByZWRpY3Rpb25MYXllclBhcmFtcyA9IF9iLmV4dHJhY3RQcmVkaWN0aW9uTGF5ZXJQYXJhbXM7XHJcbiAgICB2YXIgbW9iaWxlbmV0djEgPSBleHRyYWN0TW9iaWxlbmV0VjFQYXJhbXMoKTtcclxuICAgIHZhciBwcmVkaWN0aW9uX2xheWVyID0gZXh0cmFjdFByZWRpY3Rpb25MYXllclBhcmFtcygpO1xyXG4gICAgdmFyIGV4dHJhX2RpbSA9IHRmLnRlbnNvcjNkKGV4dHJhY3RXZWlnaHRzKDUxMTggKiA0KSwgWzEsIDUxMTgsIDRdKTtcclxuICAgIHZhciBvdXRwdXRfbGF5ZXIgPSB7XHJcbiAgICAgICAgZXh0cmFfZGltOiBleHRyYV9kaW1cclxuICAgIH07XHJcbiAgICBwYXJhbU1hcHBpbmdzLnB1c2goeyBwYXJhbVBhdGg6ICdvdXRwdXRfbGF5ZXIvZXh0cmFfZGltJyB9KTtcclxuICAgIGlmIChnZXRSZW1haW5pbmdXZWlnaHRzKCkubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2VpZ2h0cyByZW1haW5nIGFmdGVyIGV4dHJhY3Q6IFwiICsgZ2V0UmVtYWluaW5nV2VpZ2h0cygpLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHBhcmFtczoge1xyXG4gICAgICAgICAgICBtb2JpbGVuZXR2MTogbW9iaWxlbmV0djEsXHJcbiAgICAgICAgICAgIHByZWRpY3Rpb25fbGF5ZXI6IHByZWRpY3Rpb25fbGF5ZXIsXHJcbiAgICAgICAgICAgIG91dHB1dF9sYXllcjogb3V0cHV0X2xheWVyXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzXHJcbiAgICB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RQYXJhbXMuanMubWFwIiwiaW1wb3J0IHsgZGlzcG9zZVVudXNlZFdlaWdodFRlbnNvcnMsIGV4dHJhY3RXZWlnaHRFbnRyeUZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBpc1RlbnNvcjNEIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5mdW5jdGlvbiBleHRyYWN0b3JzRmFjdG9yeSh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpIHtcclxuICAgIHZhciBleHRyYWN0V2VpZ2h0RW50cnkgPSBleHRyYWN0V2VpZ2h0RW50cnlGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcyhwcmVmaXgsIGlkeCwgbWFwcGVkUHJlZml4KSB7XHJcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvQ29udjJkX1wiICsgaWR4ICsgXCJfcG9pbnR3aXNlL3dlaWdodHNcIiwgNCwgbWFwcGVkUHJlZml4ICsgXCIvZmlsdGVyc1wiKTtcclxuICAgICAgICB2YXIgYmF0Y2hfbm9ybV9vZmZzZXQgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvQ29udjJkX1wiICsgaWR4ICsgXCJfcG9pbnR3aXNlL2NvbnZvbHV0aW9uX2JuX29mZnNldFwiLCAxLCBtYXBwZWRQcmVmaXggKyBcIi9iYXRjaF9ub3JtX29mZnNldFwiKTtcclxuICAgICAgICByZXR1cm4geyBmaWx0ZXJzOiBmaWx0ZXJzLCBiYXRjaF9ub3JtX29mZnNldDogYmF0Y2hfbm9ybV9vZmZzZXQgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RDb252UGFpclBhcmFtcyhpZHgpIHtcclxuICAgICAgICB2YXIgbWFwcGVkUHJlZml4ID0gXCJtb2JpbGVuZXR2MS9jb252X1wiICsgaWR4O1xyXG4gICAgICAgIHZhciBwcmVmaXhEZXB0aHdpc2VDb252ID0gXCJNb2JpbGVuZXRWMS9Db252MmRfXCIgKyBpZHggKyBcIl9kZXB0aHdpc2VcIjtcclxuICAgICAgICB2YXIgbWFwcGVkUHJlZml4RGVwdGh3aXNlQ29udiA9IG1hcHBlZFByZWZpeCArIFwiL2RlcHRod2lzZV9jb252XCI7XHJcbiAgICAgICAgdmFyIG1hcHBlZFByZWZpeFBvaW50d2lzZUNvbnYgPSBtYXBwZWRQcmVmaXggKyBcIi9wb2ludHdpc2VfY29udlwiO1xyXG4gICAgICAgIHZhciBmaWx0ZXJzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeERlcHRod2lzZUNvbnYgKyBcIi9kZXB0aHdpc2Vfd2VpZ2h0c1wiLCA0LCBtYXBwZWRQcmVmaXhEZXB0aHdpc2VDb252ICsgXCIvZmlsdGVyc1wiKTtcclxuICAgICAgICB2YXIgYmF0Y2hfbm9ybV9zY2FsZSA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXhEZXB0aHdpc2VDb252ICsgXCIvQmF0Y2hOb3JtL2dhbW1hXCIsIDEsIG1hcHBlZFByZWZpeERlcHRod2lzZUNvbnYgKyBcIi9iYXRjaF9ub3JtX3NjYWxlXCIpO1xyXG4gICAgICAgIHZhciBiYXRjaF9ub3JtX29mZnNldCA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXhEZXB0aHdpc2VDb252ICsgXCIvQmF0Y2hOb3JtL2JldGFcIiwgMSwgbWFwcGVkUHJlZml4RGVwdGh3aXNlQ29udiArIFwiL2JhdGNoX25vcm1fb2Zmc2V0XCIpO1xyXG4gICAgICAgIHZhciBiYXRjaF9ub3JtX21lYW4gPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4RGVwdGh3aXNlQ29udiArIFwiL0JhdGNoTm9ybS9tb3ZpbmdfbWVhblwiLCAxLCBtYXBwZWRQcmVmaXhEZXB0aHdpc2VDb252ICsgXCIvYmF0Y2hfbm9ybV9tZWFuXCIpO1xyXG4gICAgICAgIHZhciBiYXRjaF9ub3JtX3ZhcmlhbmNlID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeERlcHRod2lzZUNvbnYgKyBcIi9CYXRjaE5vcm0vbW92aW5nX3ZhcmlhbmNlXCIsIDEsIG1hcHBlZFByZWZpeERlcHRod2lzZUNvbnYgKyBcIi9iYXRjaF9ub3JtX3ZhcmlhbmNlXCIpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRlcHRod2lzZV9jb252OiB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxyXG4gICAgICAgICAgICAgICAgYmF0Y2hfbm9ybV9zY2FsZTogYmF0Y2hfbm9ybV9zY2FsZSxcclxuICAgICAgICAgICAgICAgIGJhdGNoX25vcm1fb2Zmc2V0OiBiYXRjaF9ub3JtX29mZnNldCxcclxuICAgICAgICAgICAgICAgIGJhdGNoX25vcm1fbWVhbjogYmF0Y2hfbm9ybV9tZWFuLFxyXG4gICAgICAgICAgICAgICAgYmF0Y2hfbm9ybV92YXJpYW5jZTogYmF0Y2hfbm9ybV92YXJpYW5jZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwb2ludHdpc2VfY29udjogZXh0cmFjdFBvaW50d2lzZUNvbnZQYXJhbXMoJ01vYmlsZW5ldFYxJywgaWR4LCBtYXBwZWRQcmVmaXhQb2ludHdpc2VDb252KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0TW9iaWxlbmV0VjFQYXJhbXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29udl8wOiBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcygnTW9iaWxlbmV0VjEnLCAwLCAnbW9iaWxlbmV0djEvY29udl8wJyksXHJcbiAgICAgICAgICAgIGNvbnZfMTogZXh0cmFjdENvbnZQYWlyUGFyYW1zKDEpLFxyXG4gICAgICAgICAgICBjb252XzI6IGV4dHJhY3RDb252UGFpclBhcmFtcygyKSxcclxuICAgICAgICAgICAgY29udl8zOiBleHRyYWN0Q29udlBhaXJQYXJhbXMoMyksXHJcbiAgICAgICAgICAgIGNvbnZfNDogZXh0cmFjdENvbnZQYWlyUGFyYW1zKDQpLFxyXG4gICAgICAgICAgICBjb252XzU6IGV4dHJhY3RDb252UGFpclBhcmFtcyg1KSxcclxuICAgICAgICAgICAgY29udl82OiBleHRyYWN0Q29udlBhaXJQYXJhbXMoNiksXHJcbiAgICAgICAgICAgIGNvbnZfNzogZXh0cmFjdENvbnZQYWlyUGFyYW1zKDcpLFxyXG4gICAgICAgICAgICBjb252Xzg6IGV4dHJhY3RDb252UGFpclBhcmFtcyg4KSxcclxuICAgICAgICAgICAgY29udl85OiBleHRyYWN0Q29udlBhaXJQYXJhbXMoOSksXHJcbiAgICAgICAgICAgIGNvbnZfMTA6IGV4dHJhY3RDb252UGFpclBhcmFtcygxMCksXHJcbiAgICAgICAgICAgIGNvbnZfMTE6IGV4dHJhY3RDb252UGFpclBhcmFtcygxMSksXHJcbiAgICAgICAgICAgIGNvbnZfMTI6IGV4dHJhY3RDb252UGFpclBhcmFtcygxMiksXHJcbiAgICAgICAgICAgIGNvbnZfMTM6IGV4dHJhY3RDb252UGFpclBhcmFtcygxMylcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdENvbnZQYXJhbXMocHJlZml4LCBtYXBwZWRQcmVmaXgpIHtcclxuICAgICAgICB2YXIgZmlsdGVycyA9IGV4dHJhY3RXZWlnaHRFbnRyeShwcmVmaXggKyBcIi93ZWlnaHRzXCIsIDQsIG1hcHBlZFByZWZpeCArIFwiL2ZpbHRlcnNcIik7XHJcbiAgICAgICAgdmFyIGJpYXMgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvYmlhc2VzXCIsIDEsIG1hcHBlZFByZWZpeCArIFwiL2JpYXNcIik7XHJcbiAgICAgICAgcmV0dXJuIHsgZmlsdGVyczogZmlsdGVycywgYmlhczogYmlhcyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdEJveFByZWRpY3RvclBhcmFtcyhpZHgpIHtcclxuICAgICAgICB2YXIgYm94X2VuY29kaW5nX3ByZWRpY3RvciA9IGV4dHJhY3RDb252UGFyYW1zKFwiUHJlZGljdGlvbi9Cb3hQcmVkaWN0b3JfXCIgKyBpZHggKyBcIi9Cb3hFbmNvZGluZ1ByZWRpY3RvclwiLCBcInByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl9cIiArIGlkeCArIFwiL2JveF9lbmNvZGluZ19wcmVkaWN0b3JcIik7XHJcbiAgICAgICAgdmFyIGNsYXNzX3ByZWRpY3RvciA9IGV4dHJhY3RDb252UGFyYW1zKFwiUHJlZGljdGlvbi9Cb3hQcmVkaWN0b3JfXCIgKyBpZHggKyBcIi9DbGFzc1ByZWRpY3RvclwiLCBcInByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl9cIiArIGlkeCArIFwiL2NsYXNzX3ByZWRpY3RvclwiKTtcclxuICAgICAgICByZXR1cm4geyBib3hfZW5jb2RpbmdfcHJlZGljdG9yOiBib3hfZW5jb2RpbmdfcHJlZGljdG9yLCBjbGFzc19wcmVkaWN0b3I6IGNsYXNzX3ByZWRpY3RvciB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdFByZWRpY3Rpb25MYXllclBhcmFtcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb252XzA6IGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKCdQcmVkaWN0aW9uJywgMCwgJ3ByZWRpY3Rpb25fbGF5ZXIvY29udl8wJyksXHJcbiAgICAgICAgICAgIGNvbnZfMTogZXh0cmFjdFBvaW50d2lzZUNvbnZQYXJhbXMoJ1ByZWRpY3Rpb24nLCAxLCAncHJlZGljdGlvbl9sYXllci9jb252XzEnKSxcclxuICAgICAgICAgICAgY29udl8yOiBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcygnUHJlZGljdGlvbicsIDIsICdwcmVkaWN0aW9uX2xheWVyL2NvbnZfMicpLFxyXG4gICAgICAgICAgICBjb252XzM6IGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKCdQcmVkaWN0aW9uJywgMywgJ3ByZWRpY3Rpb25fbGF5ZXIvY29udl8zJyksXHJcbiAgICAgICAgICAgIGNvbnZfNDogZXh0cmFjdFBvaW50d2lzZUNvbnZQYXJhbXMoJ1ByZWRpY3Rpb24nLCA0LCAncHJlZGljdGlvbl9sYXllci9jb252XzQnKSxcclxuICAgICAgICAgICAgY29udl81OiBleHRyYWN0UG9pbnR3aXNlQ29udlBhcmFtcygnUHJlZGljdGlvbicsIDUsICdwcmVkaWN0aW9uX2xheWVyL2NvbnZfNScpLFxyXG4gICAgICAgICAgICBjb252XzY6IGV4dHJhY3RQb2ludHdpc2VDb252UGFyYW1zKCdQcmVkaWN0aW9uJywgNiwgJ3ByZWRpY3Rpb25fbGF5ZXIvY29udl82JyksXHJcbiAgICAgICAgICAgIGNvbnZfNzogZXh0cmFjdFBvaW50d2lzZUNvbnZQYXJhbXMoJ1ByZWRpY3Rpb24nLCA3LCAncHJlZGljdGlvbl9sYXllci9jb252XzcnKSxcclxuICAgICAgICAgICAgYm94X3ByZWRpY3Rvcl8wOiBleHRyYWN0Qm94UHJlZGljdG9yUGFyYW1zKDApLFxyXG4gICAgICAgICAgICBib3hfcHJlZGljdG9yXzE6IGV4dHJhY3RCb3hQcmVkaWN0b3JQYXJhbXMoMSksXHJcbiAgICAgICAgICAgIGJveF9wcmVkaWN0b3JfMjogZXh0cmFjdEJveFByZWRpY3RvclBhcmFtcygyKSxcclxuICAgICAgICAgICAgYm94X3ByZWRpY3Rvcl8zOiBleHRyYWN0Qm94UHJlZGljdG9yUGFyYW1zKDMpLFxyXG4gICAgICAgICAgICBib3hfcHJlZGljdG9yXzQ6IGV4dHJhY3RCb3hQcmVkaWN0b3JQYXJhbXMoNCksXHJcbiAgICAgICAgICAgIGJveF9wcmVkaWN0b3JfNTogZXh0cmFjdEJveFByZWRpY3RvclBhcmFtcyg1KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4dHJhY3RNb2JpbGVuZXRWMVBhcmFtczogZXh0cmFjdE1vYmlsZW5ldFYxUGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3RQcmVkaWN0aW9uTGF5ZXJQYXJhbXM6IGV4dHJhY3RQcmVkaWN0aW9uTGF5ZXJQYXJhbXNcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwKHdlaWdodE1hcCkge1xyXG4gICAgdmFyIHBhcmFtTWFwcGluZ3MgPSBbXTtcclxuICAgIHZhciBfYSA9IGV4dHJhY3RvcnNGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncyksIGV4dHJhY3RNb2JpbGVuZXRWMVBhcmFtcyA9IF9hLmV4dHJhY3RNb2JpbGVuZXRWMVBhcmFtcywgZXh0cmFjdFByZWRpY3Rpb25MYXllclBhcmFtcyA9IF9hLmV4dHJhY3RQcmVkaWN0aW9uTGF5ZXJQYXJhbXM7XHJcbiAgICB2YXIgZXh0cmFfZGltID0gd2VpZ2h0TWFwWydPdXRwdXQvZXh0cmFfZGltJ107XHJcbiAgICBwYXJhbU1hcHBpbmdzLnB1c2goeyBvcmlnaW5hbFBhdGg6ICdPdXRwdXQvZXh0cmFfZGltJywgcGFyYW1QYXRoOiAnb3V0cHV0X2xheWVyL2V4dHJhX2RpbScgfSk7XHJcbiAgICBpZiAoIWlzVGVuc29yM0QoZXh0cmFfZGltKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHdlaWdodE1hcFsnT3V0cHV0L2V4dHJhX2RpbSddIHRvIGJlIGEgVGVuc29yM0QsIGluc3RlYWQgaGF2ZSBcIiArIGV4dHJhX2RpbSk7XHJcbiAgICB9XHJcbiAgICB2YXIgcGFyYW1zID0ge1xyXG4gICAgICAgIG1vYmlsZW5ldHYxOiBleHRyYWN0TW9iaWxlbmV0VjFQYXJhbXMoKSxcclxuICAgICAgICBwcmVkaWN0aW9uX2xheWVyOiBleHRyYWN0UHJlZGljdGlvbkxheWVyUGFyYW1zKCksXHJcbiAgICAgICAgb3V0cHV0X2xheWVyOiB7XHJcbiAgICAgICAgICAgIGV4dHJhX2RpbTogZXh0cmFfZGltXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGRpc3Bvc2VVbnVzZWRXZWlnaHRUZW5zb3JzKHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICByZXR1cm4geyBwYXJhbXM6IHBhcmFtcywgcGFyYW1NYXBwaW5nczogcGFyYW1NYXBwaW5ncyB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwLmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBTc2RNb2JpbGVuZXR2MSB9IGZyb20gJy4vU3NkTW9iaWxlbmV0djEnO1xyXG5leHBvcnQgKiBmcm9tICcuL1NzZE1vYmlsZW5ldHYxJztcclxuZXhwb3J0ICogZnJvbSAnLi9Tc2RNb2JpbGVuZXR2MU9wdGlvbnMnO1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3NkTW9iaWxlbmV0djEod2VpZ2h0cykge1xyXG4gICAgdmFyIG5ldCA9IG5ldyBTc2RNb2JpbGVuZXR2MSgpO1xyXG4gICAgbmV0LmV4dHJhY3RXZWlnaHRzKHdlaWdodHMpO1xyXG4gICAgcmV0dXJuIG5ldDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRmFjZURldGVjdGlvbk5ldCh3ZWlnaHRzKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlU3NkTW9iaWxlbmV0djEod2VpZ2h0cyk7XHJcbn1cclxuLy8gYWxpYXMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWx5XHJcbnZhciBGYWNlRGV0ZWN0aW9uTmV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEZhY2VEZXRlY3Rpb25OZXQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGYWNlRGV0ZWN0aW9uTmV0KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBGYWNlRGV0ZWN0aW9uTmV0O1xyXG59KFNzZE1vYmlsZW5ldHYxKSk7XHJcbmV4cG9ydCB7IEZhY2VEZXRlY3Rpb25OZXQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgcG9pbnR3aXNlQ29udkxheWVyIH0gZnJvbSAnLi9wb2ludHdpc2VDb252TGF5ZXInO1xyXG52YXIgZXBzaWxvbiA9IDAuMDAxMDAwMDAwMDQ3NDk3NDUxMztcclxuZnVuY3Rpb24gZGVwdGh3aXNlQ29udkxheWVyKHgsIHBhcmFtcywgc3RyaWRlcykge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvdXQgPSB0Zi5kZXB0aHdpc2VDb252MmQoeCwgcGFyYW1zLmZpbHRlcnMsIHN0cmlkZXMsICdzYW1lJyk7XHJcbiAgICAgICAgb3V0ID0gdGYuYmF0Y2hOb3JtKG91dCwgcGFyYW1zLmJhdGNoX25vcm1fbWVhbiwgcGFyYW1zLmJhdGNoX25vcm1fdmFyaWFuY2UsIHBhcmFtcy5iYXRjaF9ub3JtX29mZnNldCwgcGFyYW1zLmJhdGNoX25vcm1fc2NhbGUsIGVwc2lsb24pO1xyXG4gICAgICAgIHJldHVybiB0Zi5jbGlwQnlWYWx1ZShvdXQsIDAsIDYpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U3RyaWRlc0ZvckxheWVySWR4KGxheWVySWR4KSB7XHJcbiAgICByZXR1cm4gWzIsIDQsIDYsIDEyXS5zb21lKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIGlkeCA9PT0gbGF5ZXJJZHg7IH0pID8gWzIsIDJdIDogWzEsIDFdO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBtb2JpbGVOZXRWMSh4LCBwYXJhbXMpIHtcclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY29udjExID0gbnVsbDtcclxuICAgICAgICB2YXIgb3V0ID0gcG9pbnR3aXNlQ29udkxheWVyKHgsIHBhcmFtcy5jb252XzAsIFsyLCAyXSk7XHJcbiAgICAgICAgdmFyIGNvbnZQYWlyUGFyYW1zID0gW1xyXG4gICAgICAgICAgICBwYXJhbXMuY29udl8xLFxyXG4gICAgICAgICAgICBwYXJhbXMuY29udl8yLFxyXG4gICAgICAgICAgICBwYXJhbXMuY29udl8zLFxyXG4gICAgICAgICAgICBwYXJhbXMuY29udl80LFxyXG4gICAgICAgICAgICBwYXJhbXMuY29udl81LFxyXG4gICAgICAgICAgICBwYXJhbXMuY29udl82LFxyXG4gICAgICAgICAgICBwYXJhbXMuY29udl83LFxyXG4gICAgICAgICAgICBwYXJhbXMuY29udl84LFxyXG4gICAgICAgICAgICBwYXJhbXMuY29udl85LFxyXG4gICAgICAgICAgICBwYXJhbXMuY29udl8xMCxcclxuICAgICAgICAgICAgcGFyYW1zLmNvbnZfMTEsXHJcbiAgICAgICAgICAgIHBhcmFtcy5jb252XzEyLFxyXG4gICAgICAgICAgICBwYXJhbXMuY29udl8xM1xyXG4gICAgICAgIF07XHJcbiAgICAgICAgY29udlBhaXJQYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0sIGkpIHtcclxuICAgICAgICAgICAgdmFyIGxheWVySWR4ID0gaSArIDE7XHJcbiAgICAgICAgICAgIHZhciBkZXB0aHdpc2VDb252U3RyaWRlcyA9IGdldFN0cmlkZXNGb3JMYXllcklkeChsYXllcklkeCk7XHJcbiAgICAgICAgICAgIG91dCA9IGRlcHRod2lzZUNvbnZMYXllcihvdXQsIHBhcmFtLmRlcHRod2lzZV9jb252LCBkZXB0aHdpc2VDb252U3RyaWRlcyk7XHJcbiAgICAgICAgICAgIG91dCA9IHBvaW50d2lzZUNvbnZMYXllcihvdXQsIHBhcmFtLnBvaW50d2lzZV9jb252LCBbMSwgMV0pO1xyXG4gICAgICAgICAgICBpZiAobGF5ZXJJZHggPT09IDExKSB7XHJcbiAgICAgICAgICAgICAgICBjb252MTEgPSBvdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoY29udjExID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbW9iaWxlTmV0VjEgLSBvdXRwdXQgb2YgY29udiBsYXllciAxMSBpcyBudWxsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG91dDogb3V0LFxyXG4gICAgICAgICAgICBjb252MTE6IGNvbnYxMVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2JpbGVOZXRWMS5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gbm9uTWF4U3VwcHJlc3Npb24oYm94ZXMsIHNjb3JlcywgbWF4T3V0cHV0U2l6ZSwgaW91VGhyZXNob2xkLCBzY29yZVRocmVzaG9sZCkge1xyXG4gICAgdmFyIG51bUJveGVzID0gYm94ZXMuc2hhcGVbMF07XHJcbiAgICB2YXIgb3V0cHV0U2l6ZSA9IE1hdGgubWluKG1heE91dHB1dFNpemUsIG51bUJveGVzKTtcclxuICAgIHZhciBjYW5kaWRhdGVzID0gc2NvcmVzXHJcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoc2NvcmUsIGJveEluZGV4KSB7IHJldHVybiAoeyBzY29yZTogc2NvcmUsIGJveEluZGV4OiBib3hJbmRleCB9KTsgfSlcclxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNjb3JlID4gc2NvcmVUaHJlc2hvbGQ7IH0pXHJcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGMxLCBjMikgeyByZXR1cm4gYzIuc2NvcmUgLSBjMS5zY29yZTsgfSk7XHJcbiAgICB2YXIgc3VwcHJlc3NGdW5jID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPD0gaW91VGhyZXNob2xkID8gMSA6IDA7IH07XHJcbiAgICB2YXIgc2VsZWN0ZWQgPSBbXTtcclxuICAgIGNhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xyXG4gICAgICAgIGlmIChzZWxlY3RlZC5sZW5ndGggPj0gb3V0cHV0U2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcmlnaW5hbFNjb3JlID0gYy5zY29yZTtcclxuICAgICAgICBmb3IgKHZhciBqID0gc2VsZWN0ZWQubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcclxuICAgICAgICAgICAgdmFyIGlvdSA9IElPVShib3hlcywgYy5ib3hJbmRleCwgc2VsZWN0ZWRbal0pO1xyXG4gICAgICAgICAgICBpZiAoaW91ID09PSAwLjApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGMuc2NvcmUgKj0gc3VwcHJlc3NGdW5jKGlvdSk7XHJcbiAgICAgICAgICAgIGlmIChjLnNjb3JlIDw9IHNjb3JlVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3JpZ2luYWxTY29yZSA9PT0gYy5zY29yZSkge1xyXG4gICAgICAgICAgICBzZWxlY3RlZC5wdXNoKGMuYm94SW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHNlbGVjdGVkO1xyXG59XHJcbmZ1bmN0aW9uIElPVShib3hlcywgaSwgaikge1xyXG4gICAgdmFyIGJveGVzRGF0YSA9IGJveGVzLmFycmF5U3luYygpO1xyXG4gICAgdmFyIHltaW5JID0gTWF0aC5taW4oYm94ZXNEYXRhW2ldWzBdLCBib3hlc0RhdGFbaV1bMl0pO1xyXG4gICAgdmFyIHhtaW5JID0gTWF0aC5taW4oYm94ZXNEYXRhW2ldWzFdLCBib3hlc0RhdGFbaV1bM10pO1xyXG4gICAgdmFyIHltYXhJID0gTWF0aC5tYXgoYm94ZXNEYXRhW2ldWzBdLCBib3hlc0RhdGFbaV1bMl0pO1xyXG4gICAgdmFyIHhtYXhJID0gTWF0aC5tYXgoYm94ZXNEYXRhW2ldWzFdLCBib3hlc0RhdGFbaV1bM10pO1xyXG4gICAgdmFyIHltaW5KID0gTWF0aC5taW4oYm94ZXNEYXRhW2pdWzBdLCBib3hlc0RhdGFbal1bMl0pO1xyXG4gICAgdmFyIHhtaW5KID0gTWF0aC5taW4oYm94ZXNEYXRhW2pdWzFdLCBib3hlc0RhdGFbal1bM10pO1xyXG4gICAgdmFyIHltYXhKID0gTWF0aC5tYXgoYm94ZXNEYXRhW2pdWzBdLCBib3hlc0RhdGFbal1bMl0pO1xyXG4gICAgdmFyIHhtYXhKID0gTWF0aC5tYXgoYm94ZXNEYXRhW2pdWzFdLCBib3hlc0RhdGFbal1bM10pO1xyXG4gICAgdmFyIGFyZWFJID0gKHltYXhJIC0geW1pbkkpICogKHhtYXhJIC0geG1pbkkpO1xyXG4gICAgdmFyIGFyZWFKID0gKHltYXhKIC0geW1pbkopICogKHhtYXhKIC0geG1pbkopO1xyXG4gICAgaWYgKGFyZWFJIDw9IDAgfHwgYXJlYUogPD0gMCkge1xyXG4gICAgICAgIHJldHVybiAwLjA7XHJcbiAgICB9XHJcbiAgICB2YXIgaW50ZXJzZWN0aW9uWW1pbiA9IE1hdGgubWF4KHltaW5JLCB5bWluSik7XHJcbiAgICB2YXIgaW50ZXJzZWN0aW9uWG1pbiA9IE1hdGgubWF4KHhtaW5JLCB4bWluSik7XHJcbiAgICB2YXIgaW50ZXJzZWN0aW9uWW1heCA9IE1hdGgubWluKHltYXhJLCB5bWF4Sik7XHJcbiAgICB2YXIgaW50ZXJzZWN0aW9uWG1heCA9IE1hdGgubWluKHhtYXhJLCB4bWF4Sik7XHJcbiAgICB2YXIgaW50ZXJzZWN0aW9uQXJlYSA9IE1hdGgubWF4KGludGVyc2VjdGlvblltYXggLSBpbnRlcnNlY3Rpb25ZbWluLCAwLjApICpcclxuICAgICAgICBNYXRoLm1heChpbnRlcnNlY3Rpb25YbWF4IC0gaW50ZXJzZWN0aW9uWG1pbiwgMC4wKTtcclxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25BcmVhIC8gKGFyZWFJICsgYXJlYUogLSBpbnRlcnNlY3Rpb25BcmVhKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub25NYXhTdXBwcmVzc2lvbi5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5mdW5jdGlvbiBnZXRDZW50ZXJDb29yZGluYXRlc0FuZFNpemVzTGF5ZXIoeCkge1xyXG4gICAgdmFyIHZlYyA9IHRmLnVuc3RhY2sodGYudHJhbnNwb3NlKHgsIFsxLCAwXSkpO1xyXG4gICAgdmFyIHNpemVzID0gW1xyXG4gICAgICAgIHRmLnN1Yih2ZWNbMl0sIHZlY1swXSksXHJcbiAgICAgICAgdGYuc3ViKHZlY1szXSwgdmVjWzFdKVxyXG4gICAgXTtcclxuICAgIHZhciBjZW50ZXJzID0gW1xyXG4gICAgICAgIHRmLmFkZCh2ZWNbMF0sIHRmLmRpdihzaXplc1swXSwgdGYuc2NhbGFyKDIpKSksXHJcbiAgICAgICAgdGYuYWRkKHZlY1sxXSwgdGYuZGl2KHNpemVzWzFdLCB0Zi5zY2FsYXIoMikpKVxyXG4gICAgXTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2l6ZXM6IHNpemVzLFxyXG4gICAgICAgIGNlbnRlcnM6IGNlbnRlcnNcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZGVjb2RlQm94ZXNMYXllcih4MCwgeDEpIHtcclxuICAgIHZhciBfYSA9IGdldENlbnRlckNvb3JkaW5hdGVzQW5kU2l6ZXNMYXllcih4MCksIHNpemVzID0gX2Euc2l6ZXMsIGNlbnRlcnMgPSBfYS5jZW50ZXJzO1xyXG4gICAgdmFyIHZlYyA9IHRmLnVuc3RhY2sodGYudHJhbnNwb3NlKHgxLCBbMSwgMF0pKTtcclxuICAgIHZhciBkaXYwX291dCA9IHRmLmRpdih0Zi5tdWwodGYuZXhwKHRmLmRpdih2ZWNbMl0sIHRmLnNjYWxhcig1KSkpLCBzaXplc1swXSksIHRmLnNjYWxhcigyKSk7XHJcbiAgICB2YXIgYWRkMF9vdXQgPSB0Zi5hZGQodGYubXVsKHRmLmRpdih2ZWNbMF0sIHRmLnNjYWxhcigxMCkpLCBzaXplc1swXSksIGNlbnRlcnNbMF0pO1xyXG4gICAgdmFyIGRpdjFfb3V0ID0gdGYuZGl2KHRmLm11bCh0Zi5leHAodGYuZGl2KHZlY1szXSwgdGYuc2NhbGFyKDUpKSksIHNpemVzWzFdKSwgdGYuc2NhbGFyKDIpKTtcclxuICAgIHZhciBhZGQxX291dCA9IHRmLmFkZCh0Zi5tdWwodGYuZGl2KHZlY1sxXSwgdGYuc2NhbGFyKDEwKSksIHNpemVzWzFdKSwgY2VudGVyc1sxXSk7XHJcbiAgICByZXR1cm4gdGYudHJhbnNwb3NlKHRmLnN0YWNrKFtcclxuICAgICAgICB0Zi5zdWIoYWRkMF9vdXQsIGRpdjBfb3V0KSxcclxuICAgICAgICB0Zi5zdWIoYWRkMV9vdXQsIGRpdjFfb3V0KSxcclxuICAgICAgICB0Zi5hZGQoYWRkMF9vdXQsIGRpdjBfb3V0KSxcclxuICAgICAgICB0Zi5hZGQoYWRkMV9vdXQsIGRpdjFfb3V0KVxyXG4gICAgXSksIFsxLCAwXSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG91dHB1dExheWVyKGJveFByZWRpY3Rpb25zLCBjbGFzc1ByZWRpY3Rpb25zLCBwYXJhbXMpIHtcclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYmF0Y2hTaXplID0gYm94UHJlZGljdGlvbnMuc2hhcGVbMF07XHJcbiAgICAgICAgdmFyIGJveGVzID0gZGVjb2RlQm94ZXNMYXllcih0Zi5yZXNoYXBlKHRmLnRpbGUocGFyYW1zLmV4dHJhX2RpbSwgW2JhdGNoU2l6ZSwgMSwgMV0pLCBbLTEsIDRdKSwgdGYucmVzaGFwZShib3hQcmVkaWN0aW9ucywgWy0xLCA0XSkpO1xyXG4gICAgICAgIGJveGVzID0gdGYucmVzaGFwZShib3hlcywgW2JhdGNoU2l6ZSwgKGJveGVzLnNoYXBlWzBdIC8gYmF0Y2hTaXplKSwgNF0pO1xyXG4gICAgICAgIHZhciBzY29yZXNBbmRDbGFzc2VzID0gdGYuc2lnbW9pZCh0Zi5zbGljZShjbGFzc1ByZWRpY3Rpb25zLCBbMCwgMCwgMV0sIFstMSwgLTEsIC0xXSkpO1xyXG4gICAgICAgIHZhciBzY29yZXMgPSB0Zi5zbGljZShzY29yZXNBbmRDbGFzc2VzLCBbMCwgMCwgMF0sIFstMSwgLTEsIDFdKTtcclxuICAgICAgICBzY29yZXMgPSB0Zi5yZXNoYXBlKHNjb3JlcywgW2JhdGNoU2l6ZSwgc2NvcmVzLnNoYXBlWzFdXSk7XHJcbiAgICAgICAgdmFyIGJveGVzQnlCYXRjaCA9IHRmLnVuc3RhY2soYm94ZXMpO1xyXG4gICAgICAgIHZhciBzY29yZXNCeUJhdGNoID0gdGYudW5zdGFjayhzY29yZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGJveGVzOiBib3hlc0J5QmF0Y2gsXHJcbiAgICAgICAgICAgIHNjb3Jlczogc2NvcmVzQnlCYXRjaFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdXRwdXRMYXllci5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5leHBvcnQgZnVuY3Rpb24gcG9pbnR3aXNlQ29udkxheWVyKHgsIHBhcmFtcywgc3RyaWRlcykge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvdXQgPSB0Zi5jb252MmQoeCwgcGFyYW1zLmZpbHRlcnMsIHN0cmlkZXMsICdzYW1lJyk7XHJcbiAgICAgICAgb3V0ID0gdGYuYWRkKG91dCwgcGFyYW1zLmJhdGNoX25vcm1fb2Zmc2V0KTtcclxuICAgICAgICByZXR1cm4gdGYuY2xpcEJ5VmFsdWUob3V0LCAwLCA2KTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvaW50d2lzZUNvbnZMYXllci5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBib3hQcmVkaWN0aW9uTGF5ZXIgfSBmcm9tICcuL2JveFByZWRpY3Rpb25MYXllcic7XHJcbmltcG9ydCB7IHBvaW50d2lzZUNvbnZMYXllciB9IGZyb20gJy4vcG9pbnR3aXNlQ29udkxheWVyJztcclxuZXhwb3J0IGZ1bmN0aW9uIHByZWRpY3Rpb25MYXllcih4LCBjb252MTEsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjb252MCA9IHBvaW50d2lzZUNvbnZMYXllcih4LCBwYXJhbXMuY29udl8wLCBbMSwgMV0pO1xyXG4gICAgICAgIHZhciBjb252MSA9IHBvaW50d2lzZUNvbnZMYXllcihjb252MCwgcGFyYW1zLmNvbnZfMSwgWzIsIDJdKTtcclxuICAgICAgICB2YXIgY29udjIgPSBwb2ludHdpc2VDb252TGF5ZXIoY29udjEsIHBhcmFtcy5jb252XzIsIFsxLCAxXSk7XHJcbiAgICAgICAgdmFyIGNvbnYzID0gcG9pbnR3aXNlQ29udkxheWVyKGNvbnYyLCBwYXJhbXMuY29udl8zLCBbMiwgMl0pO1xyXG4gICAgICAgIHZhciBjb252NCA9IHBvaW50d2lzZUNvbnZMYXllcihjb252MywgcGFyYW1zLmNvbnZfNCwgWzEsIDFdKTtcclxuICAgICAgICB2YXIgY29udjUgPSBwb2ludHdpc2VDb252TGF5ZXIoY29udjQsIHBhcmFtcy5jb252XzUsIFsyLCAyXSk7XHJcbiAgICAgICAgdmFyIGNvbnY2ID0gcG9pbnR3aXNlQ29udkxheWVyKGNvbnY1LCBwYXJhbXMuY29udl82LCBbMSwgMV0pO1xyXG4gICAgICAgIHZhciBjb252NyA9IHBvaW50d2lzZUNvbnZMYXllcihjb252NiwgcGFyYW1zLmNvbnZfNywgWzIsIDJdKTtcclxuICAgICAgICB2YXIgYm94UHJlZGljdGlvbjAgPSBib3hQcmVkaWN0aW9uTGF5ZXIoY29udjExLCBwYXJhbXMuYm94X3ByZWRpY3Rvcl8wKTtcclxuICAgICAgICB2YXIgYm94UHJlZGljdGlvbjEgPSBib3hQcmVkaWN0aW9uTGF5ZXIoeCwgcGFyYW1zLmJveF9wcmVkaWN0b3JfMSk7XHJcbiAgICAgICAgdmFyIGJveFByZWRpY3Rpb24yID0gYm94UHJlZGljdGlvbkxheWVyKGNvbnYxLCBwYXJhbXMuYm94X3ByZWRpY3Rvcl8yKTtcclxuICAgICAgICB2YXIgYm94UHJlZGljdGlvbjMgPSBib3hQcmVkaWN0aW9uTGF5ZXIoY29udjMsIHBhcmFtcy5ib3hfcHJlZGljdG9yXzMpO1xyXG4gICAgICAgIHZhciBib3hQcmVkaWN0aW9uNCA9IGJveFByZWRpY3Rpb25MYXllcihjb252NSwgcGFyYW1zLmJveF9wcmVkaWN0b3JfNCk7XHJcbiAgICAgICAgdmFyIGJveFByZWRpY3Rpb241ID0gYm94UHJlZGljdGlvbkxheWVyKGNvbnY3LCBwYXJhbXMuYm94X3ByZWRpY3Rvcl81KTtcclxuICAgICAgICB2YXIgYm94UHJlZGljdGlvbnMgPSB0Zi5jb25jYXQoW1xyXG4gICAgICAgICAgICBib3hQcmVkaWN0aW9uMC5ib3hQcmVkaWN0aW9uRW5jb2RpbmcsXHJcbiAgICAgICAgICAgIGJveFByZWRpY3Rpb24xLmJveFByZWRpY3Rpb25FbmNvZGluZyxcclxuICAgICAgICAgICAgYm94UHJlZGljdGlvbjIuYm94UHJlZGljdGlvbkVuY29kaW5nLFxyXG4gICAgICAgICAgICBib3hQcmVkaWN0aW9uMy5ib3hQcmVkaWN0aW9uRW5jb2RpbmcsXHJcbiAgICAgICAgICAgIGJveFByZWRpY3Rpb240LmJveFByZWRpY3Rpb25FbmNvZGluZyxcclxuICAgICAgICAgICAgYm94UHJlZGljdGlvbjUuYm94UHJlZGljdGlvbkVuY29kaW5nXHJcbiAgICAgICAgXSwgMSk7XHJcbiAgICAgICAgdmFyIGNsYXNzUHJlZGljdGlvbnMgPSB0Zi5jb25jYXQoW1xyXG4gICAgICAgICAgICBib3hQcmVkaWN0aW9uMC5jbGFzc1ByZWRpY3Rpb24sXHJcbiAgICAgICAgICAgIGJveFByZWRpY3Rpb24xLmNsYXNzUHJlZGljdGlvbixcclxuICAgICAgICAgICAgYm94UHJlZGljdGlvbjIuY2xhc3NQcmVkaWN0aW9uLFxyXG4gICAgICAgICAgICBib3hQcmVkaWN0aW9uMy5jbGFzc1ByZWRpY3Rpb24sXHJcbiAgICAgICAgICAgIGJveFByZWRpY3Rpb240LmNsYXNzUHJlZGljdGlvbixcclxuICAgICAgICAgICAgYm94UHJlZGljdGlvbjUuY2xhc3NQcmVkaWN0aW9uXHJcbiAgICAgICAgXSwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYm94UHJlZGljdGlvbnM6IGJveFByZWRpY3Rpb25zLFxyXG4gICAgICAgICAgICBjbGFzc1ByZWRpY3Rpb25zOiBjbGFzc1ByZWRpY3Rpb25zXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWRpY3Rpb25MYXllci5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZXh0ZW5kcywgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgRmFjZURldGVjdGlvbiB9IGZyb20gJy4uL2NsYXNzZXMnO1xyXG5pbXBvcnQgeyBUaW55WW9sb3YyQmFzZSB9IGZyb20gJy4uL3RpbnlZb2xvdjIvVGlueVlvbG92MkJhc2UnO1xyXG5pbXBvcnQgeyBCT1hfQU5DSE9SUywgSU9VX1RIUkVTSE9MRCwgTUVBTl9SR0IgfSBmcm9tICcuL2NvbnN0JztcclxudmFyIFRpbnlGYWNlRGV0ZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVGlueUZhY2VEZXRlY3RvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbnlGYWNlRGV0ZWN0b3IoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29uZmlnID0ge1xyXG4gICAgICAgICAgICB3aXRoU2VwYXJhYmxlQ29udnM6IHRydWUsXHJcbiAgICAgICAgICAgIGlvdVRocmVzaG9sZDogSU9VX1RIUkVTSE9MRCxcclxuICAgICAgICAgICAgY2xhc3NlczogWydmYWNlJ10sXHJcbiAgICAgICAgICAgIGFuY2hvcnM6IEJPWF9BTkNIT1JTLFxyXG4gICAgICAgICAgICBtZWFuUmdiOiBNRUFOX1JHQixcclxuICAgICAgICAgICAgaXNGaXJzdExheWVyQ29udjJkOiB0cnVlLFxyXG4gICAgICAgICAgICBmaWx0ZXJTaXplczogWzMsIDE2LCAzMiwgNjQsIDEyOCwgMjU2LCA1MTJdXHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGlueUZhY2VEZXRlY3Rvci5wcm90b3R5cGUsIFwiYW5jaG9yc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5hbmNob3JzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgVGlueUZhY2VEZXRlY3Rvci5wcm90b3R5cGUubG9jYXRlRmFjZXMgPSBmdW5jdGlvbiAoaW5wdXQsIGZvcndhcmRQYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmplY3REZXRlY3Rpb25zO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmRldGVjdChpbnB1dCwgZm9yd2FyZFBhcmFtcyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0RGV0ZWN0aW9ucyA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG9iamVjdERldGVjdGlvbnMubWFwKGZ1bmN0aW9uIChkZXQpIHsgcmV0dXJuIG5ldyBGYWNlRGV0ZWN0aW9uKGRldC5zY29yZSwgZGV0LnJlbGF0aXZlQm94LCB7IHdpZHRoOiBkZXQuaW1hZ2VXaWR0aCwgaGVpZ2h0OiBkZXQuaW1hZ2VIZWlnaHQgfSk7IH0pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVGlueUZhY2VEZXRlY3Rvci5wcm90b3R5cGUuZ2V0RGVmYXVsdE1vZGVsTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ3RpbnlfZmFjZV9kZXRlY3Rvcl9tb2RlbCc7XHJcbiAgICB9O1xyXG4gICAgVGlueUZhY2VEZXRlY3Rvci5wcm90b3R5cGUuZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAgPSBmdW5jdGlvbiAod2VpZ2h0TWFwKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuY2FsbCh0aGlzLCB3ZWlnaHRNYXApO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUaW55RmFjZURldGVjdG9yO1xyXG59KFRpbnlZb2xvdjJCYXNlKSk7XHJcbmV4cG9ydCB7IFRpbnlGYWNlRGV0ZWN0b3IgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlueUZhY2VEZXRlY3Rvci5qcy5tYXAiLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgVGlueVlvbG92Mk9wdGlvbnMgfSBmcm9tICcuLi90aW55WW9sb3YyJztcclxudmFyIFRpbnlGYWNlRGV0ZWN0b3JPcHRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRpbnlGYWNlRGV0ZWN0b3JPcHRpb25zLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGlueUZhY2VEZXRlY3Rvck9wdGlvbnMoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX25hbWUgPSAnVGlueUZhY2VEZXRlY3Rvck9wdGlvbnMnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBUaW55RmFjZURldGVjdG9yT3B0aW9ucztcclxufShUaW55WW9sb3YyT3B0aW9ucykpO1xyXG5leHBvcnQgeyBUaW55RmFjZURldGVjdG9yT3B0aW9ucyB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW55RmFjZURldGVjdG9yT3B0aW9ucy5qcy5tYXAiLCJpbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL2NsYXNzZXMnO1xyXG5leHBvcnQgdmFyIElPVV9USFJFU0hPTEQgPSAwLjQ7XHJcbmV4cG9ydCB2YXIgQk9YX0FOQ0hPUlMgPSBbXHJcbiAgICBuZXcgUG9pbnQoMS42MDMyMzEsIDIuMDk0NDY4KSxcclxuICAgIG5ldyBQb2ludCg2LjA0MTE0MywgNy4wODAxMjYpLFxyXG4gICAgbmV3IFBvaW50KDIuODgyNDU5LCAzLjUxODA2MSksXHJcbiAgICBuZXcgUG9pbnQoNC4yNjY5MDYsIDUuMTc4ODU3KSxcclxuICAgIG5ldyBQb2ludCg5LjA0MTc2NSwgMTAuNjYzMDgpXHJcbl07XHJcbmV4cG9ydCB2YXIgTUVBTl9SR0IgPSBbMTE3LjAwMSwgMTE0LjY5NywgOTcuNDA0XTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QuanMubWFwIiwiaW1wb3J0IHsgVGlueUZhY2VEZXRlY3RvciB9IGZyb20gJy4vVGlueUZhY2VEZXRlY3Rvcic7XHJcbmV4cG9ydCAqIGZyb20gJy4vVGlueUZhY2VEZXRlY3Rvcic7XHJcbmV4cG9ydCAqIGZyb20gJy4vVGlueUZhY2VEZXRlY3Rvck9wdGlvbnMnO1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGlueUZhY2VEZXRlY3Rvcih3ZWlnaHRzKSB7XHJcbiAgICB2YXIgbmV0ID0gbmV3IFRpbnlGYWNlRGV0ZWN0b3IoKTtcclxuICAgIG5ldC5leHRyYWN0V2VpZ2h0cyh3ZWlnaHRzKTtcclxuICAgIHJldHVybiBuZXQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX2V4dGVuZHMsIF9fZ2VuZXJhdG9yIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IEZhY2VEZXRlY3Rpb24gfSBmcm9tICcuLi9jbGFzc2VzJztcclxuaW1wb3J0IHsgQk9YX0FOQ0hPUlMsIEJPWF9BTkNIT1JTX1NFUEFSQUJMRSwgREVGQVVMVF9NT0RFTF9OQU1FLCBERUZBVUxUX01PREVMX05BTUVfU0VQQVJBQkxFX0NPTlYsIElPVV9USFJFU0hPTEQsIE1FQU5fUkdCX1NFUEFSQUJMRSwgfSBmcm9tICcuL2NvbnN0JztcclxuaW1wb3J0IHsgVGlueVlvbG92MkJhc2UgfSBmcm9tICcuL1RpbnlZb2xvdjJCYXNlJztcclxudmFyIFRpbnlZb2xvdjIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVGlueVlvbG92MiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbnlZb2xvdjIod2l0aFNlcGFyYWJsZUNvbnZzKSB7XHJcbiAgICAgICAgaWYgKHdpdGhTZXBhcmFibGVDb252cyA9PT0gdm9pZCAwKSB7IHdpdGhTZXBhcmFibGVDb252cyA9IHRydWU7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCB7XHJcbiAgICAgICAgICAgIHdpdGhTZXBhcmFibGVDb252czogd2l0aFNlcGFyYWJsZUNvbnZzLFxyXG4gICAgICAgICAgICBpb3VUaHJlc2hvbGQ6IElPVV9USFJFU0hPTEQsXHJcbiAgICAgICAgICAgIGNsYXNzZXM6IFsnZmFjZSddXHJcbiAgICAgICAgfSwgd2l0aFNlcGFyYWJsZUNvbnZzXHJcbiAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yczogQk9YX0FOQ0hPUlNfU0VQQVJBQkxFLFxyXG4gICAgICAgICAgICAgICAgbWVhblJnYjogTUVBTl9SR0JfU0VQQVJBQkxFXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICBhbmNob3JzOiBCT1hfQU5DSE9SUyxcclxuICAgICAgICAgICAgICAgIHdpdGhDbGFzc1Njb3JlczogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGlueVlvbG92Mi5wcm90b3R5cGUsIFwid2l0aFNlcGFyYWJsZUNvbnZzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLndpdGhTZXBhcmFibGVDb252cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaW55WW9sb3YyLnByb3RvdHlwZSwgXCJhbmNob3JzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmFuY2hvcnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBUaW55WW9sb3YyLnByb3RvdHlwZS5sb2NhdGVGYWNlcyA9IGZ1bmN0aW9uIChpbnB1dCwgZm9yd2FyZFBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG9iamVjdERldGVjdGlvbnM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZGV0ZWN0KGlucHV0LCBmb3J3YXJkUGFyYW1zKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3REZXRlY3Rpb25zID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgb2JqZWN0RGV0ZWN0aW9ucy5tYXAoZnVuY3Rpb24gKGRldCkgeyByZXR1cm4gbmV3IEZhY2VEZXRlY3Rpb24oZGV0LnNjb3JlLCBkZXQucmVsYXRpdmVCb3gsIHsgd2lkdGg6IGRldC5pbWFnZVdpZHRoLCBoZWlnaHQ6IGRldC5pbWFnZUhlaWdodCB9KTsgfSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBUaW55WW9sb3YyLnByb3RvdHlwZS5nZXREZWZhdWx0TW9kZWxOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpdGhTZXBhcmFibGVDb252cyA/IERFRkFVTFRfTU9ERUxfTkFNRV9TRVBBUkFCTEVfQ09OViA6IERFRkFVTFRfTU9ERUxfTkFNRTtcclxuICAgIH07XHJcbiAgICBUaW55WW9sb3YyLnByb3RvdHlwZS5leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcCA9IGZ1bmN0aW9uICh3ZWlnaHRNYXApIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5leHRyYWN0UGFyYW1zRnJvbVdlaWd0aE1hcC5jYWxsKHRoaXMsIHdlaWdodE1hcCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRpbnlZb2xvdjI7XHJcbn0oVGlueVlvbG92MkJhc2UpKTtcclxuZXhwb3J0IHsgVGlueVlvbG92MiB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW55WW9sb3YyLmpzLm1hcCIsImltcG9ydCB7IF9fYXNzaWduLCBfX2F3YWl0ZXIsIF9fZXh0ZW5kcywgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgQm91bmRpbmdCb3ggfSBmcm9tICcuLi9jbGFzc2VzL0JvdW5kaW5nQm94JztcclxuaW1wb3J0IHsgT2JqZWN0RGV0ZWN0aW9uIH0gZnJvbSAnLi4vY2xhc3Nlcy9PYmplY3REZXRlY3Rpb24nO1xyXG5pbXBvcnQgeyBjb252TGF5ZXIgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyB0b05ldElucHV0IH0gZnJvbSAnLi4vZG9tJztcclxuaW1wb3J0IHsgTmV1cmFsTmV0d29yayB9IGZyb20gJy4uL05ldXJhbE5ldHdvcmsnO1xyXG5pbXBvcnQgeyBzaWdtb2lkIH0gZnJvbSAnLi4vb3BzJztcclxuaW1wb3J0IHsgbm9uTWF4U3VwcHJlc3Npb24gfSBmcm9tICcuLi9vcHMvbm9uTWF4U3VwcHJlc3Npb24nO1xyXG5pbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuLi9vcHMvbm9ybWFsaXplJztcclxuaW1wb3J0IHsgdmFsaWRhdGVDb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XHJcbmltcG9ydCB7IGNvbnZXaXRoQmF0Y2hOb3JtIH0gZnJvbSAnLi9jb252V2l0aEJhdGNoTm9ybSc7XHJcbmltcG9ydCB7IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYgfSBmcm9tICcuL2RlcHRod2lzZVNlcGFyYWJsZUNvbnYnO1xyXG5pbXBvcnQgeyBleHRyYWN0UGFyYW1zIH0gZnJvbSAnLi9leHRyYWN0UGFyYW1zJztcclxuaW1wb3J0IHsgZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAgfSBmcm9tICcuL2V4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwJztcclxuaW1wb3J0IHsgbGVha3kgfSBmcm9tICcuL2xlYWt5JztcclxuaW1wb3J0IHsgVGlueVlvbG92Mk9wdGlvbnMgfSBmcm9tICcuL1RpbnlZb2xvdjJPcHRpb25zJztcclxudmFyIFRpbnlZb2xvdjJCYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRpbnlZb2xvdjJCYXNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGlueVlvbG92MkJhc2UoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ1RpbnlZb2xvdjInKSB8fCB0aGlzO1xyXG4gICAgICAgIHZhbGlkYXRlQ29uZmlnKGNvbmZpZyk7XHJcbiAgICAgICAgX3RoaXMuX2NvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGlueVlvbG92MkJhc2UucHJvdG90eXBlLCBcImNvbmZpZ1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25maWc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGlueVlvbG92MkJhc2UucHJvdG90eXBlLCBcIndpdGhDbGFzc1Njb3Jlc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy53aXRoQ2xhc3NTY29yZXMgfHwgdGhpcy5jb25maWcuY2xhc3Nlcy5sZW5ndGggPiAxO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbnlZb2xvdjJCYXNlLnByb3RvdHlwZSwgXCJib3hFbmNvZGluZ1NpemVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gNSArICh0aGlzLndpdGhDbGFzc1Njb3JlcyA/IHRoaXMuY29uZmlnLmNsYXNzZXMubGVuZ3RoIDogMCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBUaW55WW9sb3YyQmFzZS5wcm90b3R5cGUucnVuVGlueVlvbG92MiA9IGZ1bmN0aW9uICh4LCBwYXJhbXMpIHtcclxuICAgICAgICB2YXIgb3V0ID0gY29udldpdGhCYXRjaE5vcm0oeCwgcGFyYW1zLmNvbnYwKTtcclxuICAgICAgICBvdXQgPSB0Zi5tYXhQb29sKG91dCwgWzIsIDJdLCBbMiwgMl0sICdzYW1lJyk7XHJcbiAgICAgICAgb3V0ID0gY29udldpdGhCYXRjaE5vcm0ob3V0LCBwYXJhbXMuY29udjEpO1xyXG4gICAgICAgIG91dCA9IHRmLm1heFBvb2wob3V0LCBbMiwgMl0sIFsyLCAyXSwgJ3NhbWUnKTtcclxuICAgICAgICBvdXQgPSBjb252V2l0aEJhdGNoTm9ybShvdXQsIHBhcmFtcy5jb252Mik7XHJcbiAgICAgICAgb3V0ID0gdGYubWF4UG9vbChvdXQsIFsyLCAyXSwgWzIsIDJdLCAnc2FtZScpO1xyXG4gICAgICAgIG91dCA9IGNvbnZXaXRoQmF0Y2hOb3JtKG91dCwgcGFyYW1zLmNvbnYzKTtcclxuICAgICAgICBvdXQgPSB0Zi5tYXhQb29sKG91dCwgWzIsIDJdLCBbMiwgMl0sICdzYW1lJyk7XHJcbiAgICAgICAgb3V0ID0gY29udldpdGhCYXRjaE5vcm0ob3V0LCBwYXJhbXMuY29udjQpO1xyXG4gICAgICAgIG91dCA9IHRmLm1heFBvb2wob3V0LCBbMiwgMl0sIFsyLCAyXSwgJ3NhbWUnKTtcclxuICAgICAgICBvdXQgPSBjb252V2l0aEJhdGNoTm9ybShvdXQsIHBhcmFtcy5jb252NSk7XHJcbiAgICAgICAgb3V0ID0gdGYubWF4UG9vbChvdXQsIFsyLCAyXSwgWzEsIDFdLCAnc2FtZScpO1xyXG4gICAgICAgIG91dCA9IGNvbnZXaXRoQmF0Y2hOb3JtKG91dCwgcGFyYW1zLmNvbnY2KTtcclxuICAgICAgICBvdXQgPSBjb252V2l0aEJhdGNoTm9ybShvdXQsIHBhcmFtcy5jb252Nyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnZMYXllcihvdXQsIHBhcmFtcy5jb252OCwgJ3ZhbGlkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIFRpbnlZb2xvdjJCYXNlLnByb3RvdHlwZS5ydW5Nb2JpbGVuZXQgPSBmdW5jdGlvbiAoeCwgcGFyYW1zKSB7XHJcbiAgICAgICAgdmFyIG91dCA9IHRoaXMuY29uZmlnLmlzRmlyc3RMYXllckNvbnYyZFxyXG4gICAgICAgICAgICA/IGxlYWt5KGNvbnZMYXllcih4LCBwYXJhbXMuY29udjAsICd2YWxpZCcsIGZhbHNlKSlcclxuICAgICAgICAgICAgOiBkZXB0aHdpc2VTZXBhcmFibGVDb252KHgsIHBhcmFtcy5jb252MCk7XHJcbiAgICAgICAgb3V0ID0gdGYubWF4UG9vbChvdXQsIFsyLCAyXSwgWzIsIDJdLCAnc2FtZScpO1xyXG4gICAgICAgIG91dCA9IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYob3V0LCBwYXJhbXMuY29udjEpO1xyXG4gICAgICAgIG91dCA9IHRmLm1heFBvb2wob3V0LCBbMiwgMl0sIFsyLCAyXSwgJ3NhbWUnKTtcclxuICAgICAgICBvdXQgPSBkZXB0aHdpc2VTZXBhcmFibGVDb252KG91dCwgcGFyYW1zLmNvbnYyKTtcclxuICAgICAgICBvdXQgPSB0Zi5tYXhQb29sKG91dCwgWzIsIDJdLCBbMiwgMl0sICdzYW1lJyk7XHJcbiAgICAgICAgb3V0ID0gZGVwdGh3aXNlU2VwYXJhYmxlQ29udihvdXQsIHBhcmFtcy5jb252Myk7XHJcbiAgICAgICAgb3V0ID0gdGYubWF4UG9vbChvdXQsIFsyLCAyXSwgWzIsIDJdLCAnc2FtZScpO1xyXG4gICAgICAgIG91dCA9IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYob3V0LCBwYXJhbXMuY29udjQpO1xyXG4gICAgICAgIG91dCA9IHRmLm1heFBvb2wob3V0LCBbMiwgMl0sIFsyLCAyXSwgJ3NhbWUnKTtcclxuICAgICAgICBvdXQgPSBkZXB0aHdpc2VTZXBhcmFibGVDb252KG91dCwgcGFyYW1zLmNvbnY1KTtcclxuICAgICAgICBvdXQgPSB0Zi5tYXhQb29sKG91dCwgWzIsIDJdLCBbMSwgMV0sICdzYW1lJyk7XHJcbiAgICAgICAgb3V0ID0gcGFyYW1zLmNvbnY2ID8gZGVwdGh3aXNlU2VwYXJhYmxlQ29udihvdXQsIHBhcmFtcy5jb252NikgOiBvdXQ7XHJcbiAgICAgICAgb3V0ID0gcGFyYW1zLmNvbnY3ID8gZGVwdGh3aXNlU2VwYXJhYmxlQ29udihvdXQsIHBhcmFtcy5jb252NykgOiBvdXQ7XHJcbiAgICAgICAgcmV0dXJuIGNvbnZMYXllcihvdXQsIHBhcmFtcy5jb252OCwgJ3ZhbGlkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIFRpbnlZb2xvdjJCYXNlLnByb3RvdHlwZS5mb3J3YXJkSW5wdXQgPSBmdW5jdGlvbiAoaW5wdXQsIGlucHV0U2l6ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGlueVlvbG92MiAtIGxvYWQgbW9kZWwgYmVmb3JlIGluZmVyZW5jZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBiYXRjaFRlbnNvciA9IGlucHV0LnRvQmF0Y2hUZW5zb3IoaW5wdXRTaXplLCBmYWxzZSkudG9GbG9hdCgpO1xyXG4gICAgICAgICAgICBiYXRjaFRlbnNvciA9IF90aGlzLmNvbmZpZy5tZWFuUmdiXHJcbiAgICAgICAgICAgICAgICA/IG5vcm1hbGl6ZShiYXRjaFRlbnNvciwgX3RoaXMuY29uZmlnLm1lYW5SZ2IpXHJcbiAgICAgICAgICAgICAgICA6IGJhdGNoVGVuc29yO1xyXG4gICAgICAgICAgICBiYXRjaFRlbnNvciA9IGJhdGNoVGVuc29yLmRpdih0Zi5zY2FsYXIoMjU2KSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb25maWcud2l0aFNlcGFyYWJsZUNvbnZzXHJcbiAgICAgICAgICAgICAgICA/IF90aGlzLnJ1bk1vYmlsZW5ldChiYXRjaFRlbnNvciwgcGFyYW1zKVxyXG4gICAgICAgICAgICAgICAgOiBfdGhpcy5ydW5UaW55WW9sb3YyKGJhdGNoVGVuc29yLCBwYXJhbXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFRpbnlZb2xvdjJCYXNlLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKGlucHV0LCBpbnB1dFNpemUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLmZvcndhcmRJbnB1dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdG9OZXRJbnB1dChpbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuYXBwbHkodGhpcywgW19iLnNlbnQoKSwgaW5wdXRTaXplXSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFRpbnlZb2xvdjJCYXNlLnByb3RvdHlwZS5kZXRlY3QgPSBmdW5jdGlvbiAoaW5wdXQsIGZvcndhcmRQYXJhbXMpIHtcclxuICAgICAgICBpZiAoZm9yd2FyZFBhcmFtcyA9PT0gdm9pZCAwKSB7IGZvcndhcmRQYXJhbXMgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBpbnB1dFNpemUsIHNjb3JlVGhyZXNob2xkLCBuZXRJbnB1dCwgb3V0LCBvdXQwLCBpbnB1dERpbWVuc2lvbnMsIHJlc3VsdHMsIGJveGVzLCBzY29yZXMsIGNsYXNzU2NvcmVzLCBjbGFzc05hbWVzLCBpbmRpY2VzLCBkZXRlY3Rpb25zO1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IG5ldyBUaW55WW9sb3YyT3B0aW9ucyhmb3J3YXJkUGFyYW1zKSwgaW5wdXRTaXplID0gX2EuaW5wdXRTaXplLCBzY29yZVRocmVzaG9sZCA9IF9hLnNjb3JlVGhyZXNob2xkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0b05ldElucHV0KGlucHV0KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXRJbnB1dCA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5mb3J3YXJkSW5wdXQobmV0SW5wdXQsIGlucHV0U2l6ZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQwID0gdGYudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiB0Zi51bnN0YWNrKG91dClbMF0uZXhwYW5kRGltcygpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXREaW1lbnNpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5ldElucHV0LmdldElucHV0V2lkdGgoMCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5ldElucHV0LmdldElucHV0SGVpZ2h0KDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZXh0cmFjdEJveGVzKG91dDAsIG5ldElucHV0LmdldFJlc2hhcGVkSW5wdXREaW1lbnNpb25zKDApLCBzY29yZVRocmVzaG9sZCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveGVzID0gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLmJveDsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlcyA9IHJlc3VsdHMubWFwKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5zY29yZTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzU2NvcmVzID0gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLmNsYXNzU2NvcmU7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzID0gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gX3RoaXMuY29uZmlnLmNsYXNzZXNbcmVzLmxhYmVsXTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXMgPSBub25NYXhTdXBwcmVzc2lvbihib3hlcy5tYXAoZnVuY3Rpb24gKGJveCkgeyByZXR1cm4gYm94LnJlc2NhbGUoaW5wdXRTaXplKTsgfSksIHNjb3JlcywgdGhpcy5jb25maWcuaW91VGhyZXNob2xkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0aW9ucyA9IGluZGljZXMubWFwKGZ1bmN0aW9uIChpZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT2JqZWN0RGV0ZWN0aW9uKHNjb3Jlc1tpZHhdLCBjbGFzc1Njb3Jlc1tpZHhdLCBjbGFzc05hbWVzW2lkeF0sIGJveGVzW2lkeF0sIGlucHV0RGltZW5zaW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGV0ZWN0aW9uc107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFRpbnlZb2xvdjJCYXNlLnByb3RvdHlwZS5nZXREZWZhdWx0TW9kZWxOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH07XHJcbiAgICBUaW55WW9sb3YyQmFzZS5wcm90b3R5cGUuZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAgPSBmdW5jdGlvbiAod2VpZ2h0TWFwKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwKHdlaWdodE1hcCwgdGhpcy5jb25maWcpO1xyXG4gICAgfTtcclxuICAgIFRpbnlZb2xvdjJCYXNlLnByb3RvdHlwZS5leHRyYWN0UGFyYW1zID0gZnVuY3Rpb24gKHdlaWdodHMpIHtcclxuICAgICAgICB2YXIgZmlsdGVyU2l6ZXMgPSB0aGlzLmNvbmZpZy5maWx0ZXJTaXplcyB8fCBUaW55WW9sb3YyQmFzZS5ERUZBVUxUX0ZJTFRFUl9TSVpFUztcclxuICAgICAgICB2YXIgbnVtRmlsdGVycyA9IGZpbHRlclNpemVzID8gZmlsdGVyU2l6ZXMubGVuZ3RoIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChudW1GaWx0ZXJzICE9PSA3ICYmIG51bUZpbHRlcnMgIT09IDggJiYgbnVtRmlsdGVycyAhPT0gOSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaW55WW9sb3YyIC0gZXhwZWN0ZWQgNyB8IDggfCA5IGNvbnZvbHV0aW9uYWwgZmlsdGVycywgYnV0IGZvdW5kIFwiICsgbnVtRmlsdGVycyArIFwiIGZpbHRlclNpemVzIGluIGNvbmZpZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RQYXJhbXMod2VpZ2h0cywgdGhpcy5jb25maWcsIHRoaXMuYm94RW5jb2RpbmdTaXplLCBmaWx0ZXJTaXplcyk7XHJcbiAgICB9O1xyXG4gICAgVGlueVlvbG92MkJhc2UucHJvdG90eXBlLmV4dHJhY3RCb3hlcyA9IGZ1bmN0aW9uIChvdXRwdXRUZW5zb3IsIGlucHV0QmxvYkRpbWVuc2lvbnMsIHNjb3JlVGhyZXNob2xkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgd2lkdGgsIGhlaWdodCwgaW5wdXRTaXplLCBjb3JyZWN0aW9uRmFjdG9yWCwgY29ycmVjdGlvbkZhY3RvclksIG51bUNlbGxzLCBudW1Cb3hlcywgX2EsIGJveGVzVGVuc29yLCBzY29yZXNUZW5zb3IsIGNsYXNzU2NvcmVzVGVuc29yLCByZXN1bHRzLCBzY29yZXNEYXRhLCBib3hlc0RhdGEsIHJvdywgY29sLCBhbmNob3IsIHNjb3JlLCBjdFgsIGN0WSwgd2lkdGhfMSwgaGVpZ2h0XzEsIHgsIHksIHBvcywgX2IsIGNsYXNzU2NvcmUsIGxhYmVsLCBfYztcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZC5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbnB1dEJsb2JEaW1lbnNpb25zLndpZHRoLCBoZWlnaHQgPSBpbnB1dEJsb2JEaW1lbnNpb25zLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRTaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlY3Rpb25GYWN0b3JYID0gaW5wdXRTaXplIC8gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlY3Rpb25GYWN0b3JZID0gaW5wdXRTaXplIC8gaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1DZWxscyA9IG91dHB1dFRlbnNvci5zaGFwZVsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtQm94ZXMgPSB0aGlzLmNvbmZpZy5hbmNob3JzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNoYXBlZCA9IG91dHB1dFRlbnNvci5yZXNoYXBlKFtudW1DZWxscywgbnVtQ2VsbHMsIG51bUJveGVzLCBfdGhpcy5ib3hFbmNvZGluZ1NpemVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3hlcyA9IHJlc2hhcGVkLnNsaWNlKFswLCAwLCAwLCAwXSwgW251bUNlbGxzLCBudW1DZWxscywgbnVtQm94ZXMsIDRdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY29yZXMgPSByZXNoYXBlZC5zbGljZShbMCwgMCwgMCwgNF0sIFtudW1DZWxscywgbnVtQ2VsbHMsIG51bUJveGVzLCAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NTY29yZXMgPSBfdGhpcy53aXRoQ2xhc3NTY29yZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRmLnNvZnRtYXgocmVzaGFwZWQuc2xpY2UoWzAsIDAsIDAsIDVdLCBbbnVtQ2VsbHMsIG51bUNlbGxzLCBudW1Cb3hlcywgX3RoaXMuY29uZmlnLmNsYXNzZXMubGVuZ3RoXSksIDMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0Zi5zY2FsYXIoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2JveGVzLCBzY29yZXMsIGNsYXNzU2NvcmVzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIGJveGVzVGVuc29yID0gX2FbMF0sIHNjb3Jlc1RlbnNvciA9IF9hWzFdLCBjbGFzc1Njb3Jlc1RlbnNvciA9IF9hWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNjb3Jlc1RlbnNvci5hcnJheSgpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3Jlc0RhdGEgPSBfZC5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJveGVzVGVuc29yLmFycmF5KCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm94ZXNEYXRhID0gX2Quc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3cgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyb3cgPCBudW1DZWxscykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY29sIDwgbnVtQ2VsbHMpKSByZXR1cm4gWzMgLypicmVhayovLCAxMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gNTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGFuY2hvciA8IG51bUJveGVzKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29yZSA9IHNpZ21vaWQoc2NvcmVzRGF0YVtyb3ddW2NvbF1bYW5jaG9yXVswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCFzY29yZVRocmVzaG9sZCB8fCBzY29yZSA+IHNjb3JlVGhyZXNob2xkKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0WCA9ICgoY29sICsgc2lnbW9pZChib3hlc0RhdGFbcm93XVtjb2xdW2FuY2hvcl1bMF0pKSAvIG51bUNlbGxzKSAqIGNvcnJlY3Rpb25GYWN0b3JYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdFkgPSAoKHJvdyArIHNpZ21vaWQoYm94ZXNEYXRhW3Jvd11bY29sXVthbmNob3JdWzFdKSkgLyBudW1DZWxscykgKiBjb3JyZWN0aW9uRmFjdG9yWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhfMSA9ICgoTWF0aC5leHAoYm94ZXNEYXRhW3Jvd11bY29sXVthbmNob3JdWzJdKSAqIHRoaXMuY29uZmlnLmFuY2hvcnNbYW5jaG9yXS54KSAvIG51bUNlbGxzKSAqIGNvcnJlY3Rpb25GYWN0b3JYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHRfMSA9ICgoTWF0aC5leHAoYm94ZXNEYXRhW3Jvd11bY29sXVthbmNob3JdWzNdKSAqIHRoaXMuY29uZmlnLmFuY2hvcnNbYW5jaG9yXS55KSAvIG51bUNlbGxzKSAqIGNvcnJlY3Rpb25GYWN0b3JZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gKGN0WCAtICh3aWR0aF8xIC8gMikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gKGN0WSAtIChoZWlnaHRfMSAvIDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0geyByb3c6IHJvdywgY29sOiBjb2wsIGFuY2hvcjogYW5jaG9yIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy53aXRoQ2xhc3NTY29yZXMpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmV4dHJhY3RQcmVkaWN0ZWRDbGFzcyhjbGFzc1Njb3Jlc1RlbnNvciwgcG9zKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IF9kLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IHsgY2xhc3NTY29yZTogMSwgbGFiZWw6IDAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSA4O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSBfYywgY2xhc3NTY29yZSA9IF9iLmNsYXNzU2NvcmUsIGxhYmVsID0gX2IubGFiZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChfX2Fzc2lnbih7IGJveDogbmV3IEJvdW5kaW5nQm94KHgsIHksIHggKyB3aWR0aF8xLCB5ICsgaGVpZ2h0XzEpLCBzY29yZTogc2NvcmUsIGNsYXNzU2NvcmU6IHNjb3JlICogY2xhc3NTY29yZSwgbGFiZWw6IGxhYmVsIH0sIHBvcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAzXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hlc1RlbnNvci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3Jlc1RlbnNvci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzU2NvcmVzVGVuc29yLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdHNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBUaW55WW9sb3YyQmFzZS5wcm90b3R5cGUuZXh0cmFjdFByZWRpY3RlZENsYXNzID0gZnVuY3Rpb24gKGNsYXNzZXNUZW5zb3IsIHBvcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJvdywgY29sLCBhbmNob3IsIGNsYXNzZXNEYXRhO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3cgPSBwb3Mucm93LCBjb2wgPSBwb3MuY29sLCBhbmNob3IgPSBwb3MuYW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjbGFzc2VzVGVuc29yLmFycmF5KCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlc0RhdGEgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBBcnJheSh0aGlzLmNvbmZpZy5jbGFzc2VzLmxlbmd0aCkuZmlsbCgwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuIGNsYXNzZXNEYXRhW3Jvd11bY29sXVthbmNob3JdW2ldOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGNsYXNzU2NvcmUsIGxhYmVsKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzU2NvcmU6IGNsYXNzU2NvcmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChtYXgsIGN1cnIpIHsgcmV0dXJuIG1heC5jbGFzc1Njb3JlID4gY3Vyci5jbGFzc1Njb3JlID8gbWF4IDogY3VycjsgfSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBUaW55WW9sb3YyQmFzZS5ERUZBVUxUX0ZJTFRFUl9TSVpFUyA9IFtcclxuICAgICAgICAzLCAxNiwgMzIsIDY0LCAxMjgsIDI1NiwgNTEyLCAxMDI0LCAxMDI0XHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIFRpbnlZb2xvdjJCYXNlO1xyXG59KE5ldXJhbE5ldHdvcmspKTtcclxuZXhwb3J0IHsgVGlueVlvbG92MkJhc2UgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlueVlvbG92MkJhc2UuanMubWFwIiwiZXhwb3J0IHZhciBUaW55WW9sb3YyU2l6ZVR5cGU7XHJcbihmdW5jdGlvbiAoVGlueVlvbG92MlNpemVUeXBlKSB7XHJcbiAgICBUaW55WW9sb3YyU2l6ZVR5cGVbVGlueVlvbG92MlNpemVUeXBlW1wiWFNcIl0gPSAyMjRdID0gXCJYU1wiO1xyXG4gICAgVGlueVlvbG92MlNpemVUeXBlW1RpbnlZb2xvdjJTaXplVHlwZVtcIlNNXCJdID0gMzIwXSA9IFwiU01cIjtcclxuICAgIFRpbnlZb2xvdjJTaXplVHlwZVtUaW55WW9sb3YyU2l6ZVR5cGVbXCJNRFwiXSA9IDQxNl0gPSBcIk1EXCI7XHJcbiAgICBUaW55WW9sb3YyU2l6ZVR5cGVbVGlueVlvbG92MlNpemVUeXBlW1wiTEdcIl0gPSA2MDhdID0gXCJMR1wiO1xyXG59KShUaW55WW9sb3YyU2l6ZVR5cGUgfHwgKFRpbnlZb2xvdjJTaXplVHlwZSA9IHt9KSk7XHJcbnZhciBUaW55WW9sb3YyT3B0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRpbnlZb2xvdjJPcHRpb25zKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGlucHV0U2l6ZSA9IF9iLmlucHV0U2l6ZSwgc2NvcmVUaHJlc2hvbGQgPSBfYi5zY29yZVRocmVzaG9sZDtcclxuICAgICAgICB0aGlzLl9uYW1lID0gJ1RpbnlZb2xvdjJPcHRpb25zJztcclxuICAgICAgICB0aGlzLl9pbnB1dFNpemUgPSBpbnB1dFNpemUgfHwgNDE2O1xyXG4gICAgICAgIHRoaXMuX3Njb3JlVGhyZXNob2xkID0gc2NvcmVUaHJlc2hvbGQgfHwgMC41O1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5faW5wdXRTaXplICE9PSAnbnVtYmVyJyB8fCB0aGlzLl9pbnB1dFNpemUgJSAzMiAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fbmFtZSArIFwiIC0gZXhwZWN0ZWQgaW5wdXRTaXplIHRvIGJlIGEgbnVtYmVyIGRpdmlzaWJsZSBieSAzMlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9zY29yZVRocmVzaG9sZCAhPT0gJ251bWJlcicgfHwgdGhpcy5fc2NvcmVUaHJlc2hvbGQgPD0gMCB8fCB0aGlzLl9zY29yZVRocmVzaG9sZCA+PSAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9uYW1lICsgXCIgLSBleHBlY3RlZCBzY29yZVRocmVzaG9sZCB0byBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbnlZb2xvdjJPcHRpb25zLnByb3RvdHlwZSwgXCJpbnB1dFNpemVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faW5wdXRTaXplOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaW55WW9sb3YyT3B0aW9ucy5wcm90b3R5cGUsIFwic2NvcmVUaHJlc2hvbGRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2NvcmVUaHJlc2hvbGQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFRpbnlZb2xvdjJPcHRpb25zO1xyXG59KCkpO1xyXG5leHBvcnQgeyBUaW55WW9sb3YyT3B0aW9ucyB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW55WW9sb3YyT3B0aW9ucy5qcy5tYXAiLCJ2YXIgaXNOdW1iZXIgPSBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJzsgfTtcclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ29uZmlnKGNvbmZpZykge1xyXG4gICAgaWYgKCFjb25maWcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNvbmZpZzogXCIgKyBjb25maWcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjb25maWcud2l0aFNlcGFyYWJsZUNvbnZzICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25maWcud2l0aFNlcGFyYWJsZUNvbnZzIGhhcyB0byBiZSBhIGJvb2xlYW4sIGhhdmU6IFwiICsgY29uZmlnLndpdGhTZXBhcmFibGVDb252cyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTnVtYmVyKGNvbmZpZy5pb3VUaHJlc2hvbGQpIHx8IGNvbmZpZy5pb3VUaHJlc2hvbGQgPCAwIHx8IGNvbmZpZy5pb3VUaHJlc2hvbGQgPiAxLjApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25maWcuaW91VGhyZXNob2xkIGhhcyB0byBiZSBhIG51bWJlciBiZXR3ZWVuIFswLCAxXSwgaGF2ZTogXCIgKyBjb25maWcuaW91VGhyZXNob2xkKTtcclxuICAgIH1cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWcuY2xhc3NlcylcclxuICAgICAgICB8fCAhY29uZmlnLmNsYXNzZXMubGVuZ3RoXHJcbiAgICAgICAgfHwgIWNvbmZpZy5jbGFzc2VzLmV2ZXJ5KGZ1bmN0aW9uIChjKSB7IHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZyc7IH0pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uZmlnLmNsYXNzZXMgaGFzIHRvIGJlIGFuIGFycmF5IGNsYXNzIG5hbWVzOiBzdHJpbmdbXSwgaGF2ZTogXCIgKyBKU09OLnN0cmluZ2lmeShjb25maWcuY2xhc3NlcykpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZy5hbmNob3JzKVxyXG4gICAgICAgIHx8ICFjb25maWcuYW5jaG9ycy5sZW5ndGhcclxuICAgICAgICB8fCAhY29uZmlnLmFuY2hvcnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhIHx8IHt9OyB9KS5ldmVyeShmdW5jdGlvbiAoYSkgeyByZXR1cm4gaXNOdW1iZXIoYS54KSAmJiBpc051bWJlcihhLnkpOyB9KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmZpZy5hbmNob3JzIGhhcyB0byBiZSBhbiBhcnJheSBvZiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH0sIGhhdmU6IFwiICsgSlNPTi5zdHJpbmdpZnkoY29uZmlnLmFuY2hvcnMpKTtcclxuICAgIH1cclxuICAgIGlmIChjb25maWcubWVhblJnYiAmJiAoIUFycmF5LmlzQXJyYXkoY29uZmlnLm1lYW5SZ2IpXHJcbiAgICAgICAgfHwgY29uZmlnLm1lYW5SZ2IubGVuZ3RoICE9PSAzXHJcbiAgICAgICAgfHwgIWNvbmZpZy5tZWFuUmdiLmV2ZXJ5KGlzTnVtYmVyKSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25maWcubWVhblJnYiBoYXMgdG8gYmUgYW4gYXJyYXkgb2Ygc2hhcGUgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBoYXZlOiBcIiArIEpTT04uc3RyaW5naWZ5KGNvbmZpZy5tZWFuUmdiKSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlnLmpzLm1hcCIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vY2xhc3Nlcyc7XHJcbmV4cG9ydCB2YXIgSU9VX1RIUkVTSE9MRCA9IDAuNDtcclxuZXhwb3J0IHZhciBCT1hfQU5DSE9SUyA9IFtcclxuICAgIG5ldyBQb2ludCgwLjczODc2OCwgMC44NzQ5NDYpLFxyXG4gICAgbmV3IFBvaW50KDIuNDIyMDQsIDIuNjU3MDQpLFxyXG4gICAgbmV3IFBvaW50KDQuMzA5NzEsIDcuMDQ0OTMpLFxyXG4gICAgbmV3IFBvaW50KDEwLjI0NiwgNC41OTQyOCksXHJcbiAgICBuZXcgUG9pbnQoMTIuNjg2OCwgMTEuODc0MSlcclxuXTtcclxuZXhwb3J0IHZhciBCT1hfQU5DSE9SU19TRVBBUkFCTEUgPSBbXHJcbiAgICBuZXcgUG9pbnQoMS42MDMyMzEsIDIuMDk0NDY4KSxcclxuICAgIG5ldyBQb2ludCg2LjA0MTE0MywgNy4wODAxMjYpLFxyXG4gICAgbmV3IFBvaW50KDIuODgyNDU5LCAzLjUxODA2MSksXHJcbiAgICBuZXcgUG9pbnQoNC4yNjY5MDYsIDUuMTc4ODU3KSxcclxuICAgIG5ldyBQb2ludCg5LjA0MTc2NSwgMTAuNjYzMDgpXHJcbl07XHJcbmV4cG9ydCB2YXIgTUVBTl9SR0JfU0VQQVJBQkxFID0gWzExNy4wMDEsIDExNC42OTcsIDk3LjQwNF07XHJcbmV4cG9ydCB2YXIgREVGQVVMVF9NT0RFTF9OQU1FID0gJ3RpbnlfeW9sb3YyX21vZGVsJztcclxuZXhwb3J0IHZhciBERUZBVUxUX01PREVMX05BTUVfU0VQQVJBQkxFX0NPTlYgPSAndGlueV95b2xvdjJfc2VwYXJhYmxlX2NvbnZfbW9kZWwnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBsZWFreSB9IGZyb20gJy4vbGVha3knO1xyXG5leHBvcnQgZnVuY3Rpb24gY29udldpdGhCYXRjaE5vcm0oeCwgcGFyYW1zKSB7XHJcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG91dCA9IHRmLnBhZCh4LCBbWzAsIDBdLCBbMSwgMV0sIFsxLCAxXSwgWzAsIDBdXSk7XHJcbiAgICAgICAgb3V0ID0gdGYuY29udjJkKG91dCwgcGFyYW1zLmNvbnYuZmlsdGVycywgWzEsIDFdLCAndmFsaWQnKTtcclxuICAgICAgICBvdXQgPSB0Zi5zdWIob3V0LCBwYXJhbXMuYm4uc3ViKTtcclxuICAgICAgICBvdXQgPSB0Zi5tdWwob3V0LCBwYXJhbXMuYm4udHJ1ZWRpdik7XHJcbiAgICAgICAgb3V0ID0gdGYuYWRkKG91dCwgcGFyYW1zLmNvbnYuYmlhcyk7XHJcbiAgICAgICAgcmV0dXJuIGxlYWt5KG91dCk7XHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252V2l0aEJhdGNoTm9ybS5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBsZWFreSB9IGZyb20gJy4vbGVha3knO1xyXG5leHBvcnQgZnVuY3Rpb24gZGVwdGh3aXNlU2VwYXJhYmxlQ29udih4LCBwYXJhbXMpIHtcclxuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3V0ID0gdGYucGFkKHgsIFtbMCwgMF0sIFsxLCAxXSwgWzEsIDFdLCBbMCwgMF1dKTtcclxuICAgICAgICBvdXQgPSB0Zi5zZXBhcmFibGVDb252MmQob3V0LCBwYXJhbXMuZGVwdGh3aXNlX2ZpbHRlciwgcGFyYW1zLnBvaW50d2lzZV9maWx0ZXIsIFsxLCAxXSwgJ3ZhbGlkJyk7XHJcbiAgICAgICAgb3V0ID0gdGYuYWRkKG91dCwgcGFyYW1zLmJpYXMpO1xyXG4gICAgICAgIHJldHVybiBsZWFreShvdXQpO1xyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwdGh3aXNlU2VwYXJhYmxlQ29udi5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5pbXBvcnQgeyBleHRyYWN0Q29udlBhcmFtc0ZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnkgfSBmcm9tICcuLi9jb21tb24vZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXNGYWN0b3J5JztcclxuaW1wb3J0IHsgZXh0cmFjdFdlaWdodHNGYWN0b3J5IH0gZnJvbSAnLi4vY29tbW9uL2V4dHJhY3RXZWlnaHRzRmFjdG9yeSc7XHJcbmZ1bmN0aW9uIGV4dHJhY3RvcnNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKSB7XHJcbiAgICB2YXIgZXh0cmFjdENvbnZQYXJhbXMgPSBleHRyYWN0Q29udlBhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgZnVuY3Rpb24gZXh0cmFjdEJhdGNoTm9ybVBhcmFtcyhzaXplLCBtYXBwZWRQcmVmaXgpIHtcclxuICAgICAgICB2YXIgc3ViID0gdGYudGVuc29yMWQoZXh0cmFjdFdlaWdodHMoc2l6ZSkpO1xyXG4gICAgICAgIHZhciB0cnVlZGl2ID0gdGYudGVuc29yMWQoZXh0cmFjdFdlaWdodHMoc2l6ZSkpO1xyXG4gICAgICAgIHBhcmFtTWFwcGluZ3MucHVzaCh7IHBhcmFtUGF0aDogbWFwcGVkUHJlZml4ICsgXCIvc3ViXCIgfSwgeyBwYXJhbVBhdGg6IG1hcHBlZFByZWZpeCArIFwiL3RydWVkaXZcIiB9KTtcclxuICAgICAgICByZXR1cm4geyBzdWI6IHN1YiwgdHJ1ZWRpdjogdHJ1ZWRpdiB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCBtYXBwZWRQcmVmaXgpIHtcclxuICAgICAgICB2YXIgY29udiA9IGV4dHJhY3RDb252UGFyYW1zKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCAzLCBtYXBwZWRQcmVmaXggKyBcIi9jb252XCIpO1xyXG4gICAgICAgIHZhciBibiA9IGV4dHJhY3RCYXRjaE5vcm1QYXJhbXMoY2hhbm5lbHNPdXQsIG1hcHBlZFByZWZpeCArIFwiL2JuXCIpO1xyXG4gICAgICAgIHJldHVybiB7IGNvbnY6IGNvbnYsIGJuOiBibiB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZXh0cmFjdENvbnZQYXJhbXM6IGV4dHJhY3RDb252UGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtczogZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zOiBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtc1xyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtcyh3ZWlnaHRzLCBjb25maWcsIGJveEVuY29kaW5nU2l6ZSwgZmlsdGVyU2l6ZXMpIHtcclxuICAgIHZhciBfYSA9IGV4dHJhY3RXZWlnaHRzRmFjdG9yeSh3ZWlnaHRzKSwgZXh0cmFjdFdlaWdodHMgPSBfYS5leHRyYWN0V2VpZ2h0cywgZ2V0UmVtYWluaW5nV2VpZ2h0cyA9IF9hLmdldFJlbWFpbmluZ1dlaWdodHM7XHJcbiAgICB2YXIgcGFyYW1NYXBwaW5ncyA9IFtdO1xyXG4gICAgdmFyIF9iID0gZXh0cmFjdG9yc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpLCBleHRyYWN0Q29udlBhcmFtcyA9IF9iLmV4dHJhY3RDb252UGFyYW1zLCBleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMgPSBfYi5leHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMsIGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zID0gX2IuZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXM7XHJcbiAgICB2YXIgcGFyYW1zO1xyXG4gICAgaWYgKGNvbmZpZy53aXRoU2VwYXJhYmxlQ29udnMpIHtcclxuICAgICAgICB2YXIgczAgPSBmaWx0ZXJTaXplc1swXSwgczEgPSBmaWx0ZXJTaXplc1sxXSwgczIgPSBmaWx0ZXJTaXplc1syXSwgczMgPSBmaWx0ZXJTaXplc1szXSwgczQgPSBmaWx0ZXJTaXplc1s0XSwgczUgPSBmaWx0ZXJTaXplc1s1XSwgczYgPSBmaWx0ZXJTaXplc1s2XSwgczcgPSBmaWx0ZXJTaXplc1s3XSwgczggPSBmaWx0ZXJTaXplc1s4XTtcclxuICAgICAgICB2YXIgY29udjAgPSBjb25maWcuaXNGaXJzdExheWVyQ29udjJkXHJcbiAgICAgICAgICAgID8gZXh0cmFjdENvbnZQYXJhbXMoczAsIHMxLCAzLCAnY29udjAnKVxyXG4gICAgICAgICAgICA6IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKHMwLCBzMSwgJ2NvbnYwJyk7XHJcbiAgICAgICAgdmFyIGNvbnYxID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoczEsIHMyLCAnY29udjEnKTtcclxuICAgICAgICB2YXIgY29udjIgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhzMiwgczMsICdjb252MicpO1xyXG4gICAgICAgIHZhciBjb252MyA9IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKHMzLCBzNCwgJ2NvbnYzJyk7XHJcbiAgICAgICAgdmFyIGNvbnY0ID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoczQsIHM1LCAnY29udjQnKTtcclxuICAgICAgICB2YXIgY29udjUgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhzNSwgczYsICdjb252NScpO1xyXG4gICAgICAgIHZhciBjb252NiA9IHM3ID8gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoczYsIHM3LCAnY29udjYnKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB2YXIgY29udjcgPSBzOCA/IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKHM3LCBzOCwgJ2NvbnY3JykgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGNvbnY4ID0gZXh0cmFjdENvbnZQYXJhbXMoczggfHwgczcgfHwgczYsIDUgKiBib3hFbmNvZGluZ1NpemUsIDEsICdjb252OCcpO1xyXG4gICAgICAgIHBhcmFtcyA9IHsgY29udjA6IGNvbnYwLCBjb252MTogY29udjEsIGNvbnYyOiBjb252MiwgY29udjM6IGNvbnYzLCBjb252NDogY29udjQsIGNvbnY1OiBjb252NSwgY29udjY6IGNvbnY2LCBjb252NzogY29udjcsIGNvbnY4OiBjb252OCB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIHMwID0gZmlsdGVyU2l6ZXNbMF0sIHMxID0gZmlsdGVyU2l6ZXNbMV0sIHMyID0gZmlsdGVyU2l6ZXNbMl0sIHMzID0gZmlsdGVyU2l6ZXNbM10sIHM0ID0gZmlsdGVyU2l6ZXNbNF0sIHM1ID0gZmlsdGVyU2l6ZXNbNV0sIHM2ID0gZmlsdGVyU2l6ZXNbNl0sIHM3ID0gZmlsdGVyU2l6ZXNbN10sIHM4ID0gZmlsdGVyU2l6ZXNbOF07XHJcbiAgICAgICAgdmFyIGNvbnYwID0gZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKHMwLCBzMSwgJ2NvbnYwJyk7XHJcbiAgICAgICAgdmFyIGNvbnYxID0gZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKHMxLCBzMiwgJ2NvbnYxJyk7XHJcbiAgICAgICAgdmFyIGNvbnYyID0gZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKHMyLCBzMywgJ2NvbnYyJyk7XHJcbiAgICAgICAgdmFyIGNvbnYzID0gZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKHMzLCBzNCwgJ2NvbnYzJyk7XHJcbiAgICAgICAgdmFyIGNvbnY0ID0gZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKHM0LCBzNSwgJ2NvbnY0Jyk7XHJcbiAgICAgICAgdmFyIGNvbnY1ID0gZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKHM1LCBzNiwgJ2NvbnY1Jyk7XHJcbiAgICAgICAgdmFyIGNvbnY2ID0gZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKHM2LCBzNywgJ2NvbnY2Jyk7XHJcbiAgICAgICAgdmFyIGNvbnY3ID0gZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zKHM3LCBzOCwgJ2NvbnY3Jyk7XHJcbiAgICAgICAgdmFyIGNvbnY4ID0gZXh0cmFjdENvbnZQYXJhbXMoczgsIDUgKiBib3hFbmNvZGluZ1NpemUsIDEsICdjb252OCcpO1xyXG4gICAgICAgIHBhcmFtcyA9IHsgY29udjA6IGNvbnYwLCBjb252MTogY29udjEsIGNvbnYyOiBjb252MiwgY29udjM6IGNvbnYzLCBjb252NDogY29udjQsIGNvbnY1OiBjb252NSwgY29udjY6IGNvbnY2LCBjb252NzogY29udjcsIGNvbnY4OiBjb252OCB9O1xyXG4gICAgfVxyXG4gICAgaWYgKGdldFJlbWFpbmluZ1dlaWdodHMoKS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWlnaHRzIHJlbWFpbmcgYWZ0ZXIgZXh0cmFjdDogXCIgKyBnZXRSZW1haW5pbmdXZWlnaHRzKCkubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHBhcmFtczogcGFyYW1zLCBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFBhcmFtcy5qcy5tYXAiLCJpbXBvcnQgeyBkaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycyB9IGZyb20gJy4uL2NvbW1vbi9kaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycyc7XHJcbmltcG9ydCB7IGxvYWRTZXBhcmFibGVDb252UGFyYW1zRmFjdG9yeSB9IGZyb20gJy4uL2NvbW1vbi9leHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnknO1xyXG5pbXBvcnQgeyBleHRyYWN0V2VpZ2h0RW50cnlGYWN0b3J5IH0gZnJvbSAnLi4vY29tbW9uL2V4dHJhY3RXZWlnaHRFbnRyeUZhY3RvcnknO1xyXG5mdW5jdGlvbiBleHRyYWN0b3JzRmFjdG9yeSh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpIHtcclxuICAgIHZhciBleHRyYWN0V2VpZ2h0RW50cnkgPSBleHRyYWN0V2VpZ2h0RW50cnlGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0QmF0Y2hOb3JtUGFyYW1zKHByZWZpeCkge1xyXG4gICAgICAgIHZhciBzdWIgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvc3ViXCIsIDEpO1xyXG4gICAgICAgIHZhciB0cnVlZGl2ID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL3RydWVkaXZcIiwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHsgc3ViOiBzdWIsIHRydWVkaXY6IHRydWVkaXYgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RDb252UGFyYW1zKHByZWZpeCkge1xyXG4gICAgICAgIHZhciBmaWx0ZXJzID0gZXh0cmFjdFdlaWdodEVudHJ5KHByZWZpeCArIFwiL2ZpbHRlcnNcIiwgNCk7XHJcbiAgICAgICAgdmFyIGJpYXMgPSBleHRyYWN0V2VpZ2h0RW50cnkocHJlZml4ICsgXCIvYmlhc1wiLCAxKTtcclxuICAgICAgICByZXR1cm4geyBmaWx0ZXJzOiBmaWx0ZXJzLCBiaWFzOiBiaWFzIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMocHJlZml4KSB7XHJcbiAgICAgICAgdmFyIGNvbnYgPSBleHRyYWN0Q29udlBhcmFtcyhwcmVmaXggKyBcIi9jb252XCIpO1xyXG4gICAgICAgIHZhciBibiA9IGV4dHJhY3RCYXRjaE5vcm1QYXJhbXMocHJlZml4ICsgXCIvYm5cIik7XHJcbiAgICAgICAgcmV0dXJuIHsgY29udjogY29udiwgYm46IGJuIH07XHJcbiAgICB9XHJcbiAgICB2YXIgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMgPSBsb2FkU2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodEVudHJ5KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZXh0cmFjdENvbnZQYXJhbXM6IGV4dHJhY3RDb252UGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtczogZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zOiBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtc1xyXG4gICAgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAod2VpZ2h0TWFwLCBjb25maWcpIHtcclxuICAgIHZhciBwYXJhbU1hcHBpbmdzID0gW107XHJcbiAgICB2YXIgX2EgPSBleHRyYWN0b3JzRmFjdG9yeSh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpLCBleHRyYWN0Q29udlBhcmFtcyA9IF9hLmV4dHJhY3RDb252UGFyYW1zLCBleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMgPSBfYS5leHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXMsIGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zID0gX2EuZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXM7XHJcbiAgICB2YXIgcGFyYW1zO1xyXG4gICAgaWYgKGNvbmZpZy53aXRoU2VwYXJhYmxlQ29udnMpIHtcclxuICAgICAgICB2YXIgbnVtRmlsdGVycyA9IChjb25maWcuZmlsdGVyU2l6ZXMgJiYgY29uZmlnLmZpbHRlclNpemVzLmxlbmd0aCB8fCA5KTtcclxuICAgICAgICBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIGNvbnYwOiBjb25maWcuaXNGaXJzdExheWVyQ29udjJkID8gZXh0cmFjdENvbnZQYXJhbXMoJ2NvbnYwJykgOiBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcygnY29udjAnKSxcclxuICAgICAgICAgICAgY29udjE6IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKCdjb252MScpLFxyXG4gICAgICAgICAgICBjb252MjogZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoJ2NvbnYyJyksXHJcbiAgICAgICAgICAgIGNvbnYzOiBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcygnY29udjMnKSxcclxuICAgICAgICAgICAgY29udjQ6IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKCdjb252NCcpLFxyXG4gICAgICAgICAgICBjb252NTogZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoJ2NvbnY1JyksXHJcbiAgICAgICAgICAgIGNvbnY2OiBudW1GaWx0ZXJzID4gNyA/IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKCdjb252NicpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjb252NzogbnVtRmlsdGVycyA+IDggPyBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcygnY29udjcnKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgY29udjg6IGV4dHJhY3RDb252UGFyYW1zKCdjb252OCcpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgY29udjA6IGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtcygnY29udjAnKSxcclxuICAgICAgICAgICAgY29udjE6IGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtcygnY29udjEnKSxcclxuICAgICAgICAgICAgY29udjI6IGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtcygnY29udjInKSxcclxuICAgICAgICAgICAgY29udjM6IGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtcygnY29udjMnKSxcclxuICAgICAgICAgICAgY29udjQ6IGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtcygnY29udjQnKSxcclxuICAgICAgICAgICAgY29udjU6IGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtcygnY29udjUnKSxcclxuICAgICAgICAgICAgY29udjY6IGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtcygnY29udjYnKSxcclxuICAgICAgICAgICAgY29udjc6IGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtcygnY29udjcnKSxcclxuICAgICAgICAgICAgY29udjg6IGV4dHJhY3RDb252UGFyYW1zKCdjb252OCcpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2VVbnVzZWRXZWlnaHRUZW5zb3JzKHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICByZXR1cm4geyBwYXJhbXM6IHBhcmFtcywgcGFyYW1NYXBwaW5nczogcGFyYW1NYXBwaW5ncyB9O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwLmpzLm1hcCIsImltcG9ydCB7IFRpbnlZb2xvdjIgfSBmcm9tICcuL1RpbnlZb2xvdjInO1xyXG5leHBvcnQgKiBmcm9tICcuL1RpbnlZb2xvdjJPcHRpb25zJztcclxuZXhwb3J0ICogZnJvbSAnLi9jb25maWcnO1xyXG5leHBvcnQgeyBUaW55WW9sb3YyIH07XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUaW55WW9sb3YyKHdlaWdodHMsIHdpdGhTZXBhcmFibGVDb252cykge1xyXG4gICAgaWYgKHdpdGhTZXBhcmFibGVDb252cyA9PT0gdm9pZCAwKSB7IHdpdGhTZXBhcmFibGVDb252cyA9IHRydWU7IH1cclxuICAgIHZhciBuZXQgPSBuZXcgVGlueVlvbG92Mih3aXRoU2VwYXJhYmxlQ29udnMpO1xyXG4gICAgbmV0LmV4dHJhY3RXZWlnaHRzKHdlaWdodHMpO1xyXG4gICAgcmV0dXJuIG5ldDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5leHBvcnQgZnVuY3Rpb24gbGVha3koeCkge1xyXG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtaW4gPSB0Zi5tdWwoeCwgdGYuc2NhbGFyKDAuMTAwMDAwMDAxNDkwMTE2MTIpKTtcclxuICAgICAgICByZXR1cm4gdGYuYWRkKHRmLnJlbHUodGYuc3ViKHgsIG1pbikpLCBtaW4pO1xyXG4gICAgICAgIC8vcmV0dXJuIHRmLm1heGltdW0oeCwgbWluKVxyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVha3kuanMubWFwIiwiaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi9jbGFzc2VzJztcclxuaW1wb3J0IHsgRGltZW5zaW9ucyB9IGZyb20gJy4uL2NsYXNzZXMvRGltZW5zaW9ucyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBpc1RlbnNvcih0ZW5zb3IsIGRpbSkge1xyXG4gICAgcmV0dXJuIHRlbnNvciBpbnN0YW5jZW9mIHRmLlRlbnNvciAmJiB0ZW5zb3Iuc2hhcGUubGVuZ3RoID09PSBkaW07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVGVuc29yMUQodGVuc29yKSB7XHJcbiAgICByZXR1cm4gaXNUZW5zb3IodGVuc29yLCAxKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaXNUZW5zb3IyRCh0ZW5zb3IpIHtcclxuICAgIHJldHVybiBpc1RlbnNvcih0ZW5zb3IsIDIpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc1RlbnNvcjNEKHRlbnNvcikge1xyXG4gICAgcmV0dXJuIGlzVGVuc29yKHRlbnNvciwgMyk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVGVuc29yNEQodGVuc29yKSB7XHJcbiAgICByZXR1cm4gaXNUZW5zb3IodGVuc29yLCA0KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaXNGbG9hdChudW0pIHtcclxuICAgIHJldHVybiBudW0gJSAxICE9PSAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc0V2ZW4obnVtKSB7XHJcbiAgICByZXR1cm4gbnVtICUgMiA9PT0gMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcm91bmQobnVtLCBwcmVjKSB7XHJcbiAgICBpZiAocHJlYyA9PT0gdm9pZCAwKSB7IHByZWMgPSAyOyB9XHJcbiAgICB2YXIgZiA9IE1hdGgucG93KDEwLCBwcmVjKTtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKG51bSAqIGYpIC8gZjtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaXNEaW1lbnNpb25zKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiAmJiBvYmoud2lkdGggJiYgb2JqLmhlaWdodDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVJlc2hhcGVkRGltZW5zaW9ucyhfYSwgaW5wdXRTaXplKSB7XHJcbiAgICB2YXIgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgdmFyIHNjYWxlID0gaW5wdXRTaXplIC8gTWF0aC5tYXgoaGVpZ2h0LCB3aWR0aCk7XHJcbiAgICByZXR1cm4gbmV3IERpbWVuc2lvbnMoTWF0aC5yb3VuZCh3aWR0aCAqIHNjYWxlKSwgTWF0aC5yb3VuZChoZWlnaHQgKiBzY2FsZSkpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDZW50ZXJQb2ludChwdHMpIHtcclxuICAgIHJldHVybiBwdHMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIHB0KSB7IHJldHVybiBzdW0uYWRkKHB0KTsgfSwgbmV3IFBvaW50KDAsIDApKVxyXG4gICAgICAgIC5kaXYobmV3IFBvaW50KHB0cy5sZW5ndGgsIHB0cy5sZW5ndGgpKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2UobnVtLCBzdGFydCwgc3RlcCkge1xyXG4gICAgcmV0dXJuIEFycmF5KG51bSkuZmlsbCgwKS5tYXAoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuIHN0YXJ0ICsgKGkgKiBzdGVwKTsgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWROdW1iZXIobnVtKSB7XHJcbiAgICByZXR1cm4gISFudW0gJiYgbnVtICE9PSBJbmZpbml0eSAmJiBudW0gIT09IC1JbmZpbml0eSAmJiAhaXNOYU4obnVtKSB8fCBudW0gPT09IDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRQcm9iYWJsaXRpeShudW0pIHtcclxuICAgIHJldHVybiBpc1ZhbGlkTnVtYmVyKG51bSkgJiYgMCA8PSBudW0gJiYgbnVtIDw9IDEuMDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIsIF9fZXh0ZW5kcywgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcclxuaW1wb3J0IHsgZGVwdGh3aXNlU2VwYXJhYmxlQ29udiB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmltcG9ydCB7IHRvTmV0SW5wdXQgfSBmcm9tICcuLi9kb20nO1xyXG5pbXBvcnQgeyBOZXVyYWxOZXR3b3JrIH0gZnJvbSAnLi4vTmV1cmFsTmV0d29yayc7XHJcbmltcG9ydCB7IG5vcm1hbGl6ZSB9IGZyb20gJy4uL29wcyc7XHJcbmltcG9ydCB7IHJhbmdlIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQgeyBleHRyYWN0UGFyYW1zIH0gZnJvbSAnLi9leHRyYWN0UGFyYW1zJztcclxuaW1wb3J0IHsgZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAgfSBmcm9tICcuL2V4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwJztcclxuZnVuY3Rpb24gY29udih4LCBwYXJhbXMsIHN0cmlkZSkge1xyXG4gICAgcmV0dXJuIHRmLmFkZCh0Zi5jb252MmQoeCwgcGFyYW1zLmZpbHRlcnMsIHN0cmlkZSwgJ3NhbWUnKSwgcGFyYW1zLmJpYXMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZHVjdGlvbkJsb2NrKHgsIHBhcmFtcywgaXNBY3RpdmF0ZUlucHV0KSB7XHJcbiAgICBpZiAoaXNBY3RpdmF0ZUlucHV0ID09PSB2b2lkIDApIHsgaXNBY3RpdmF0ZUlucHV0ID0gdHJ1ZTsgfVxyXG4gICAgdmFyIG91dCA9IGlzQWN0aXZhdGVJbnB1dCA/IHRmLnJlbHUoeCkgOiB4O1xyXG4gICAgb3V0ID0gZGVwdGh3aXNlU2VwYXJhYmxlQ29udihvdXQsIHBhcmFtcy5zZXBhcmFibGVfY29udjAsIFsxLCAxXSk7XHJcbiAgICBvdXQgPSBkZXB0aHdpc2VTZXBhcmFibGVDb252KHRmLnJlbHUob3V0KSwgcGFyYW1zLnNlcGFyYWJsZV9jb252MSwgWzEsIDFdKTtcclxuICAgIG91dCA9IHRmLm1heFBvb2wob3V0LCBbMywgM10sIFsyLCAyXSwgJ3NhbWUnKTtcclxuICAgIG91dCA9IHRmLmFkZChvdXQsIGNvbnYoeCwgcGFyYW1zLmV4cGFuc2lvbl9jb252LCBbMiwgMl0pKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn1cclxuZnVuY3Rpb24gbWFpbkJsb2NrKHgsIHBhcmFtcykge1xyXG4gICAgdmFyIG91dCA9IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYodGYucmVsdSh4KSwgcGFyYW1zLnNlcGFyYWJsZV9jb252MCwgWzEsIDFdKTtcclxuICAgIG91dCA9IGRlcHRod2lzZVNlcGFyYWJsZUNvbnYodGYucmVsdShvdXQpLCBwYXJhbXMuc2VwYXJhYmxlX2NvbnYxLCBbMSwgMV0pO1xyXG4gICAgb3V0ID0gZGVwdGh3aXNlU2VwYXJhYmxlQ29udih0Zi5yZWx1KG91dCksIHBhcmFtcy5zZXBhcmFibGVfY29udjIsIFsxLCAxXSk7XHJcbiAgICBvdXQgPSB0Zi5hZGQob3V0LCB4KTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn1cclxudmFyIFRpbnlYY2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUaW55WGNlcHRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW55WGNlcHRpb24obnVtTWFpbkJsb2Nrcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICdUaW55WGNlcHRpb24nKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl9udW1NYWluQmxvY2tzID0gbnVtTWFpbkJsb2NrcztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBUaW55WGNlcHRpb24ucHJvdG90eXBlLmZvcndhcmRJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGlueVhjZXB0aW9uIC0gbG9hZCBtb2RlbCBiZWZvcmUgaW5mZXJlbmNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJhdGNoVGVuc29yID0gaW5wdXQudG9CYXRjaFRlbnNvcigxMTIsIHRydWUpO1xyXG4gICAgICAgICAgICB2YXIgbWVhblJnYiA9IFsxMjIuNzgyLCAxMTcuMDAxLCAxMDQuMjk4XTtcclxuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemUoYmF0Y2hUZW5zb3IsIG1lYW5SZ2IpLmRpdih0Zi5zY2FsYXIoMjU2KSk7XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSB0Zi5yZWx1KGNvbnYobm9ybWFsaXplZCwgcGFyYW1zLmVudHJ5X2Zsb3cuY29udl9pbiwgWzIsIDJdKSk7XHJcbiAgICAgICAgICAgIG91dCA9IHJlZHVjdGlvbkJsb2NrKG91dCwgcGFyYW1zLmVudHJ5X2Zsb3cucmVkdWN0aW9uX2Jsb2NrXzAsIGZhbHNlKTtcclxuICAgICAgICAgICAgb3V0ID0gcmVkdWN0aW9uQmxvY2sob3V0LCBwYXJhbXMuZW50cnlfZmxvdy5yZWR1Y3Rpb25fYmxvY2tfMSk7XHJcbiAgICAgICAgICAgIHJhbmdlKF90aGlzLl9udW1NYWluQmxvY2tzLCAwLCAxKS5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcclxuICAgICAgICAgICAgICAgIG91dCA9IG1haW5CbG9jayhvdXQsIHBhcmFtcy5taWRkbGVfZmxvd1tcIm1haW5fYmxvY2tfXCIgKyBpZHhdKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG91dCA9IHJlZHVjdGlvbkJsb2NrKG91dCwgcGFyYW1zLmV4aXRfZmxvdy5yZWR1Y3Rpb25fYmxvY2spO1xyXG4gICAgICAgICAgICBvdXQgPSB0Zi5yZWx1KGRlcHRod2lzZVNlcGFyYWJsZUNvbnYob3V0LCBwYXJhbXMuZXhpdF9mbG93LnNlcGFyYWJsZV9jb252LCBbMSwgMV0pKTtcclxuICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBUaW55WGNlcHRpb24ucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLmZvcndhcmRJbnB1dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdG9OZXRJbnB1dChpbnB1dCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHRoaXMsIFtfYi5zZW50KCldKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFRpbnlYY2VwdGlvbi5wcm90b3R5cGUuZ2V0RGVmYXVsdE1vZGVsTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ3RpbnlfeGNlcHRpb25fbW9kZWwnO1xyXG4gICAgfTtcclxuICAgIFRpbnlYY2VwdGlvbi5wcm90b3R5cGUuZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAgPSBmdW5jdGlvbiAod2VpZ2h0TWFwKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwKHdlaWdodE1hcCwgdGhpcy5fbnVtTWFpbkJsb2Nrcyk7XHJcbiAgICB9O1xyXG4gICAgVGlueVhjZXB0aW9uLnByb3RvdHlwZS5leHRyYWN0UGFyYW1zID0gZnVuY3Rpb24gKHdlaWdodHMpIHtcclxuICAgICAgICByZXR1cm4gZXh0cmFjdFBhcmFtcyh3ZWlnaHRzLCB0aGlzLl9udW1NYWluQmxvY2tzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGlueVhjZXB0aW9uO1xyXG59KE5ldXJhbE5ldHdvcmspKTtcclxuZXhwb3J0IHsgVGlueVhjZXB0aW9uIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbnlYY2VwdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBleHRyYWN0Q29udlBhcmFtc0ZhY3RvcnksIGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zRmFjdG9yeSwgZXh0cmFjdFdlaWdodHNGYWN0b3J5IH0gZnJvbSAnLi4vY29tbW9uJztcclxuaW1wb3J0IHsgcmFuZ2UgfSBmcm9tICcuLi91dGlscyc7XHJcbmZ1bmN0aW9uIGV4dHJhY3RvcnNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKSB7XHJcbiAgICB2YXIgZXh0cmFjdENvbnZQYXJhbXMgPSBleHRyYWN0Q29udlBhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodHMsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgdmFyIGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXNGYWN0b3J5KGV4dHJhY3RXZWlnaHRzLCBwYXJhbU1hcHBpbmdzKTtcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RSZWR1Y3Rpb25CbG9ja1BhcmFtcyhjaGFubmVsc0luLCBjaGFubmVsc091dCwgbWFwcGVkUHJlZml4KSB7XHJcbiAgICAgICAgdmFyIHNlcGFyYWJsZV9jb252MCA9IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCBtYXBwZWRQcmVmaXggKyBcIi9zZXBhcmFibGVfY29udjBcIik7XHJcbiAgICAgICAgdmFyIHNlcGFyYWJsZV9jb252MSA9IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKGNoYW5uZWxzT3V0LCBjaGFubmVsc091dCwgbWFwcGVkUHJlZml4ICsgXCIvc2VwYXJhYmxlX2NvbnYxXCIpO1xyXG4gICAgICAgIHZhciBleHBhbnNpb25fY29udiA9IGV4dHJhY3RDb252UGFyYW1zKGNoYW5uZWxzSW4sIGNoYW5uZWxzT3V0LCAxLCBtYXBwZWRQcmVmaXggKyBcIi9leHBhbnNpb25fY29udlwiKTtcclxuICAgICAgICByZXR1cm4geyBzZXBhcmFibGVfY29udjA6IHNlcGFyYWJsZV9jb252MCwgc2VwYXJhYmxlX2NvbnYxOiBzZXBhcmFibGVfY29udjEsIGV4cGFuc2lvbl9jb252OiBleHBhbnNpb25fY29udiB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdE1haW5CbG9ja1BhcmFtcyhjaGFubmVscywgbWFwcGVkUHJlZml4KSB7XHJcbiAgICAgICAgdmFyIHNlcGFyYWJsZV9jb252MCA9IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKGNoYW5uZWxzLCBjaGFubmVscywgbWFwcGVkUHJlZml4ICsgXCIvc2VwYXJhYmxlX2NvbnYwXCIpO1xyXG4gICAgICAgIHZhciBzZXBhcmFibGVfY29udjEgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhjaGFubmVscywgY2hhbm5lbHMsIG1hcHBlZFByZWZpeCArIFwiL3NlcGFyYWJsZV9jb252MVwiKTtcclxuICAgICAgICB2YXIgc2VwYXJhYmxlX2NvbnYyID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoY2hhbm5lbHMsIGNoYW5uZWxzLCBtYXBwZWRQcmVmaXggKyBcIi9zZXBhcmFibGVfY29udjJcIik7XHJcbiAgICAgICAgcmV0dXJuIHsgc2VwYXJhYmxlX2NvbnYwOiBzZXBhcmFibGVfY29udjAsIHNlcGFyYWJsZV9jb252MTogc2VwYXJhYmxlX2NvbnYxLCBzZXBhcmFibGVfY29udjI6IHNlcGFyYWJsZV9jb252MiB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBleHRyYWN0Q29udlBhcmFtczogZXh0cmFjdENvbnZQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXM6IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3RSZWR1Y3Rpb25CbG9ja1BhcmFtczogZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3RNYWluQmxvY2tQYXJhbXM6IGV4dHJhY3RNYWluQmxvY2tQYXJhbXNcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQYXJhbXMod2VpZ2h0cywgbnVtTWFpbkJsb2Nrcykge1xyXG4gICAgdmFyIHBhcmFtTWFwcGluZ3MgPSBbXTtcclxuICAgIHZhciBfYSA9IGV4dHJhY3RXZWlnaHRzRmFjdG9yeSh3ZWlnaHRzKSwgZXh0cmFjdFdlaWdodHMgPSBfYS5leHRyYWN0V2VpZ2h0cywgZ2V0UmVtYWluaW5nV2VpZ2h0cyA9IF9hLmdldFJlbWFpbmluZ1dlaWdodHM7XHJcbiAgICB2YXIgX2IgPSBleHRyYWN0b3JzRmFjdG9yeShleHRyYWN0V2VpZ2h0cywgcGFyYW1NYXBwaW5ncyksIGV4dHJhY3RDb252UGFyYW1zID0gX2IuZXh0cmFjdENvbnZQYXJhbXMsIGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zID0gX2IuZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMsIGV4dHJhY3RSZWR1Y3Rpb25CbG9ja1BhcmFtcyA9IF9iLmV4dHJhY3RSZWR1Y3Rpb25CbG9ja1BhcmFtcywgZXh0cmFjdE1haW5CbG9ja1BhcmFtcyA9IF9iLmV4dHJhY3RNYWluQmxvY2tQYXJhbXM7XHJcbiAgICB2YXIgZW50cnlfZmxvd19jb252X2luID0gZXh0cmFjdENvbnZQYXJhbXMoMywgMzIsIDMsICdlbnRyeV9mbG93L2NvbnZfaW4nKTtcclxuICAgIHZhciBlbnRyeV9mbG93X3JlZHVjdGlvbl9ibG9ja18wID0gZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zKDMyLCA2NCwgJ2VudHJ5X2Zsb3cvcmVkdWN0aW9uX2Jsb2NrXzAnKTtcclxuICAgIHZhciBlbnRyeV9mbG93X3JlZHVjdGlvbl9ibG9ja18xID0gZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zKDY0LCAxMjgsICdlbnRyeV9mbG93L3JlZHVjdGlvbl9ibG9ja18xJyk7XHJcbiAgICB2YXIgZW50cnlfZmxvdyA9IHtcclxuICAgICAgICBjb252X2luOiBlbnRyeV9mbG93X2NvbnZfaW4sXHJcbiAgICAgICAgcmVkdWN0aW9uX2Jsb2NrXzA6IGVudHJ5X2Zsb3dfcmVkdWN0aW9uX2Jsb2NrXzAsXHJcbiAgICAgICAgcmVkdWN0aW9uX2Jsb2NrXzE6IGVudHJ5X2Zsb3dfcmVkdWN0aW9uX2Jsb2NrXzFcclxuICAgIH07XHJcbiAgICB2YXIgbWlkZGxlX2Zsb3cgPSB7fTtcclxuICAgIHJhbmdlKG51bU1haW5CbG9ja3MsIDAsIDEpLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xyXG4gICAgICAgIG1pZGRsZV9mbG93W1wibWFpbl9ibG9ja19cIiArIGlkeF0gPSBleHRyYWN0TWFpbkJsb2NrUGFyYW1zKDEyOCwgXCJtaWRkbGVfZmxvdy9tYWluX2Jsb2NrX1wiICsgaWR4KTtcclxuICAgIH0pO1xyXG4gICAgdmFyIGV4aXRfZmxvd19yZWR1Y3Rpb25fYmxvY2sgPSBleHRyYWN0UmVkdWN0aW9uQmxvY2tQYXJhbXMoMTI4LCAyNTYsICdleGl0X2Zsb3cvcmVkdWN0aW9uX2Jsb2NrJyk7XHJcbiAgICB2YXIgZXhpdF9mbG93X3NlcGFyYWJsZV9jb252ID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoMjU2LCA1MTIsICdleGl0X2Zsb3cvc2VwYXJhYmxlX2NvbnYnKTtcclxuICAgIHZhciBleGl0X2Zsb3cgPSB7XHJcbiAgICAgICAgcmVkdWN0aW9uX2Jsb2NrOiBleGl0X2Zsb3dfcmVkdWN0aW9uX2Jsb2NrLFxyXG4gICAgICAgIHNlcGFyYWJsZV9jb252OiBleGl0X2Zsb3dfc2VwYXJhYmxlX2NvbnZcclxuICAgIH07XHJcbiAgICBpZiAoZ2V0UmVtYWluaW5nV2VpZ2h0cygpLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIndlaWdodHMgcmVtYWluZyBhZnRlciBleHRyYWN0OiBcIiArIGdldFJlbWFpbmluZ1dlaWdodHMoKS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzLFxyXG4gICAgICAgIHBhcmFtczogeyBlbnRyeV9mbG93OiBlbnRyeV9mbG93LCBtaWRkbGVfZmxvdzogbWlkZGxlX2Zsb3csIGV4aXRfZmxvdzogZXhpdF9mbG93IH1cclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFBhcmFtcy5qcy5tYXAiLCJpbXBvcnQgeyBkaXNwb3NlVW51c2VkV2VpZ2h0VGVuc29ycywgZXh0cmFjdFdlaWdodEVudHJ5RmFjdG9yeSwgbG9hZFNlcGFyYWJsZUNvbnZQYXJhbXNGYWN0b3J5LCB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmltcG9ydCB7IGxvYWRDb252UGFyYW1zRmFjdG9yeSB9IGZyb20gJy4uL2NvbW1vbi9sb2FkQ29udlBhcmFtc0ZhY3RvcnknO1xyXG5pbXBvcnQgeyByYW5nZSB9IGZyb20gJy4uL3V0aWxzJztcclxuZnVuY3Rpb24gbG9hZFBhcmFtc0ZhY3Rvcnkod2VpZ2h0TWFwLCBwYXJhbU1hcHBpbmdzKSB7XHJcbiAgICB2YXIgZXh0cmFjdFdlaWdodEVudHJ5ID0gZXh0cmFjdFdlaWdodEVudHJ5RmFjdG9yeSh3ZWlnaHRNYXAsIHBhcmFtTWFwcGluZ3MpO1xyXG4gICAgdmFyIGV4dHJhY3RDb252UGFyYW1zID0gbG9hZENvbnZQYXJhbXNGYWN0b3J5KGV4dHJhY3RXZWlnaHRFbnRyeSk7XHJcbiAgICB2YXIgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMgPSBsb2FkU2VwYXJhYmxlQ29udlBhcmFtc0ZhY3RvcnkoZXh0cmFjdFdlaWdodEVudHJ5KTtcclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RSZWR1Y3Rpb25CbG9ja1BhcmFtcyhtYXBwZWRQcmVmaXgpIHtcclxuICAgICAgICB2YXIgc2VwYXJhYmxlX2NvbnYwID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMobWFwcGVkUHJlZml4ICsgXCIvc2VwYXJhYmxlX2NvbnYwXCIpO1xyXG4gICAgICAgIHZhciBzZXBhcmFibGVfY29udjEgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhtYXBwZWRQcmVmaXggKyBcIi9zZXBhcmFibGVfY29udjFcIik7XHJcbiAgICAgICAgdmFyIGV4cGFuc2lvbl9jb252ID0gZXh0cmFjdENvbnZQYXJhbXMobWFwcGVkUHJlZml4ICsgXCIvZXhwYW5zaW9uX2NvbnZcIik7XHJcbiAgICAgICAgcmV0dXJuIHsgc2VwYXJhYmxlX2NvbnYwOiBzZXBhcmFibGVfY29udjAsIHNlcGFyYWJsZV9jb252MTogc2VwYXJhYmxlX2NvbnYxLCBleHBhbnNpb25fY29udjogZXhwYW5zaW9uX2NvbnYgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RNYWluQmxvY2tQYXJhbXMobWFwcGVkUHJlZml4KSB7XHJcbiAgICAgICAgdmFyIHNlcGFyYWJsZV9jb252MCA9IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zKG1hcHBlZFByZWZpeCArIFwiL3NlcGFyYWJsZV9jb252MFwiKTtcclxuICAgICAgICB2YXIgc2VwYXJhYmxlX2NvbnYxID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMobWFwcGVkUHJlZml4ICsgXCIvc2VwYXJhYmxlX2NvbnYxXCIpO1xyXG4gICAgICAgIHZhciBzZXBhcmFibGVfY29udjIgPSBleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtcyhtYXBwZWRQcmVmaXggKyBcIi9zZXBhcmFibGVfY29udjJcIik7XHJcbiAgICAgICAgcmV0dXJuIHsgc2VwYXJhYmxlX2NvbnYwOiBzZXBhcmFibGVfY29udjAsIHNlcGFyYWJsZV9jb252MTogc2VwYXJhYmxlX2NvbnYxLCBzZXBhcmFibGVfY29udjI6IHNlcGFyYWJsZV9jb252MiB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBleHRyYWN0Q29udlBhcmFtczogZXh0cmFjdENvbnZQYXJhbXMsXHJcbiAgICAgICAgZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXM6IGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3RSZWR1Y3Rpb25CbG9ja1BhcmFtczogZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zLFxyXG4gICAgICAgIGV4dHJhY3RNYWluQmxvY2tQYXJhbXM6IGV4dHJhY3RNYWluQmxvY2tQYXJhbXNcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQYXJhbXNGcm9tV2VpZ3RoTWFwKHdlaWdodE1hcCwgbnVtTWFpbkJsb2Nrcykge1xyXG4gICAgdmFyIHBhcmFtTWFwcGluZ3MgPSBbXTtcclxuICAgIHZhciBfYSA9IGxvYWRQYXJhbXNGYWN0b3J5KHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncyksIGV4dHJhY3RDb252UGFyYW1zID0gX2EuZXh0cmFjdENvbnZQYXJhbXMsIGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zID0gX2EuZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMsIGV4dHJhY3RSZWR1Y3Rpb25CbG9ja1BhcmFtcyA9IF9hLmV4dHJhY3RSZWR1Y3Rpb25CbG9ja1BhcmFtcywgZXh0cmFjdE1haW5CbG9ja1BhcmFtcyA9IF9hLmV4dHJhY3RNYWluQmxvY2tQYXJhbXM7XHJcbiAgICB2YXIgZW50cnlfZmxvd19jb252X2luID0gZXh0cmFjdENvbnZQYXJhbXMoJ2VudHJ5X2Zsb3cvY29udl9pbicpO1xyXG4gICAgdmFyIGVudHJ5X2Zsb3dfcmVkdWN0aW9uX2Jsb2NrXzAgPSBleHRyYWN0UmVkdWN0aW9uQmxvY2tQYXJhbXMoJ2VudHJ5X2Zsb3cvcmVkdWN0aW9uX2Jsb2NrXzAnKTtcclxuICAgIHZhciBlbnRyeV9mbG93X3JlZHVjdGlvbl9ibG9ja18xID0gZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zKCdlbnRyeV9mbG93L3JlZHVjdGlvbl9ibG9ja18xJyk7XHJcbiAgICB2YXIgZW50cnlfZmxvdyA9IHtcclxuICAgICAgICBjb252X2luOiBlbnRyeV9mbG93X2NvbnZfaW4sXHJcbiAgICAgICAgcmVkdWN0aW9uX2Jsb2NrXzA6IGVudHJ5X2Zsb3dfcmVkdWN0aW9uX2Jsb2NrXzAsXHJcbiAgICAgICAgcmVkdWN0aW9uX2Jsb2NrXzE6IGVudHJ5X2Zsb3dfcmVkdWN0aW9uX2Jsb2NrXzFcclxuICAgIH07XHJcbiAgICB2YXIgbWlkZGxlX2Zsb3cgPSB7fTtcclxuICAgIHJhbmdlKG51bU1haW5CbG9ja3MsIDAsIDEpLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xyXG4gICAgICAgIG1pZGRsZV9mbG93W1wibWFpbl9ibG9ja19cIiArIGlkeF0gPSBleHRyYWN0TWFpbkJsb2NrUGFyYW1zKFwibWlkZGxlX2Zsb3cvbWFpbl9ibG9ja19cIiArIGlkeCk7XHJcbiAgICB9KTtcclxuICAgIHZhciBleGl0X2Zsb3dfcmVkdWN0aW9uX2Jsb2NrID0gZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zKCdleGl0X2Zsb3cvcmVkdWN0aW9uX2Jsb2NrJyk7XHJcbiAgICB2YXIgZXhpdF9mbG93X3NlcGFyYWJsZV9jb252ID0gZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXMoJ2V4aXRfZmxvdy9zZXBhcmFibGVfY29udicpO1xyXG4gICAgdmFyIGV4aXRfZmxvdyA9IHtcclxuICAgICAgICByZWR1Y3Rpb25fYmxvY2s6IGV4aXRfZmxvd19yZWR1Y3Rpb25fYmxvY2ssXHJcbiAgICAgICAgc2VwYXJhYmxlX2NvbnY6IGV4aXRfZmxvd19zZXBhcmFibGVfY29udlxyXG4gICAgfTtcclxuICAgIGRpc3Bvc2VVbnVzZWRXZWlnaHRUZW5zb3JzKHdlaWdodE1hcCwgcGFyYW1NYXBwaW5ncyk7XHJcbiAgICByZXR1cm4geyBwYXJhbXM6IHsgZW50cnlfZmxvdzogZW50cnlfZmxvdywgbWlkZGxlX2Zsb3c6IG1pZGRsZV9mbG93LCBleGl0X2Zsb3c6IGV4aXRfZmxvdyB9LCBwYXJhbU1hcHBpbmdzOiBwYXJhbU1hcHBpbmdzIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdFBhcmFtc0Zyb21XZWlndGhNYXAuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIHQ9ZnVuY3Rpb24oZSxuKXtyZXR1cm4odD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lfXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKX0pKGUsbil9O2Z1bmN0aW9uIGUoZSxuKXtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfXQoZSxuKSxlLnByb3RvdHlwZT1udWxsPT09bj9PYmplY3QuY3JlYXRlKG4pOihyLnByb3RvdHlwZT1uLnByb3RvdHlwZSxuZXcgcil9ZnVuY3Rpb24gbih0LGUsbixyKXtyZXR1cm4gbmV3KG58fChuPVByb21pc2UpKSgoZnVuY3Rpb24obyxhKXtmdW5jdGlvbiBpKHQpe3RyeXt1KHIubmV4dCh0KSl9Y2F0Y2godCl7YSh0KX19ZnVuY3Rpb24gcyh0KXt0cnl7dShyLnRocm93KHQpKX1jYXRjaCh0KXthKHQpfX1mdW5jdGlvbiB1KHQpe3QuZG9uZT9vKHQudmFsdWUpOm5ldyBuKChmdW5jdGlvbihlKXtlKHQudmFsdWUpfSkpLnRoZW4oaSxzKX11KChyPXIuYXBwbHkodCxlfHxbXSkpLm5leHQoKSl9KSl9ZnVuY3Rpb24gcih0LGUpe3ZhciBuLHIsbyxhLGk9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmb1swXSl0aHJvdyBvWzFdO3JldHVybiBvWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIGE9e25leHQ6cygwKSx0aHJvdzpzKDEpLHJldHVybjpzKDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihhW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLGE7ZnVuY3Rpb24gcyhhKXtyZXR1cm4gZnVuY3Rpb24ocyl7cmV0dXJuIGZ1bmN0aW9uKGEpe2lmKG4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDtpOyl0cnl7aWYobj0xLHImJihvPTImYVswXT9yLnJldHVybjphWzBdP3IudGhyb3d8fCgobz1yLnJldHVybikmJm8uY2FsbChyKSwwKTpyLm5leHQpJiYhKG89by5jYWxsKHIsYVsxXSkpLmRvbmUpcmV0dXJuIG87c3dpdGNoKHI9MCxvJiYoYT1bMiZhWzBdLG8udmFsdWVdKSxhWzBdKXtjYXNlIDA6Y2FzZSAxOm89YTticmVhaztjYXNlIDQ6cmV0dXJuIGkubGFiZWwrKyx7dmFsdWU6YVsxXSxkb25lOiExfTtjYXNlIDU6aS5sYWJlbCsrLHI9YVsxXSxhPVswXTtjb250aW51ZTtjYXNlIDc6YT1pLm9wcy5wb3AoKSxpLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKG89KG89aS50cnlzKS5sZW5ndGg+MCYmb1tvLmxlbmd0aC0xXSkmJig2PT09YVswXXx8Mj09PWFbMF0pKXtpPTA7Y29udGludWV9aWYoMz09PWFbMF0mJighb3x8YVsxXT5vWzBdJiZhWzFdPG9bM10pKXtpLmxhYmVsPWFbMV07YnJlYWt9aWYoNj09PWFbMF0mJmkubGFiZWw8b1sxXSl7aS5sYWJlbD1vWzFdLG89YTticmVha31pZihvJiZpLmxhYmVsPG9bMl0pe2kubGFiZWw9b1syXSxpLm9wcy5wdXNoKGEpO2JyZWFrfW9bMl0mJmkub3BzLnBvcCgpLGkudHJ5cy5wb3AoKTtjb250aW51ZX1hPWUuY2FsbCh0LGkpfWNhdGNoKHQpe2E9WzYsdF0scj0wfWZpbmFsbHl7bj1vPTB9aWYoNSZhWzBdKXRocm93IGFbMV07cmV0dXJue3ZhbHVlOmFbMF0/YVsxXTp2b2lkIDAsZG9uZTohMH19KFthLHNdKX19fXZhciBvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmdsb2JhbD10LHRoaXMuZmxhZ3M9e30sdGhpcy5mbGFnUmVnaXN0cnk9e30sdGhpcy51cmxGbGFncz17fSx0aGlzLnBvcHVsYXRlVVJMRmxhZ3MoKX1yZXR1cm4gdC5wcm90b3R5cGUuc2V0UGxhdGZvcm09ZnVuY3Rpb24odCxlKXtudWxsIT10aGlzLnBsYXRmb3JtJiZjb25zb2xlLndhcm4oXCJQbGF0Zm9ybSBcIit0aGlzLnBsYXRmb3JtTmFtZStcIiBoYXMgYWxyZWFkeSBiZWVuIHNldC4gT3ZlcndyaXRpbmcgdGhlIHBsYXRmb3JtIHdpdGggXCIrZStcIi5cIiksdGhpcy5wbGF0Zm9ybU5hbWU9dCx0aGlzLnBsYXRmb3JtPWV9LHQucHJvdG90eXBlLnJlZ2lzdGVyRmxhZz1mdW5jdGlvbih0LGUsbil7aWYodGhpcy5mbGFnUmVnaXN0cnlbdF09e2V2YWx1YXRpb25GbjplLHNldEhvb2s6bn0sbnVsbCE9dGhpcy51cmxGbGFnc1t0XSl7dmFyIHI9dGhpcy51cmxGbGFnc1t0XTtjb25zb2xlLndhcm4oXCJTZXR0aW5nIGZlYXR1cmUgb3ZlcnJpZGUgZnJvbSBVUkwgXCIrdCtcIjogXCIrcitcIi5cIiksdGhpcy5zZXQodCxyKX19LHQucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbiB0aGlzLmZsYWdzP3RoaXMuZmxhZ3NbdF06KHRoaXMuZmxhZ3NbdF09dGhpcy5ldmFsdWF0ZUZsYWcodCksdGhpcy5mbGFnc1t0XSl9LHQucHJvdG90eXBlLmdldE51bWJlcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXQodCl9LHQucHJvdG90eXBlLmdldEJvb2w9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0KHQpfSx0LnByb3RvdHlwZS5nZXRGbGFncz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZsYWdzfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJmZWF0dXJlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mbGFnc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCxlKXtpZihudWxsPT10aGlzLmZsYWdSZWdpc3RyeVt0XSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IGZsYWcgXCIrdCtcIiBhcyBpdCBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC5cIik7dGhpcy5mbGFnc1t0XT1lLG51bGwhPXRoaXMuZmxhZ1JlZ2lzdHJ5W3RdLnNldEhvb2smJnRoaXMuZmxhZ1JlZ2lzdHJ5W3RdLnNldEhvb2soZSl9LHQucHJvdG90eXBlLmV2YWx1YXRlRmxhZz1mdW5jdGlvbih0KXtpZihudWxsPT10aGlzLmZsYWdSZWdpc3RyeVt0XSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZXZhbHVhdGUgZmxhZyAnXCIrdCtcIic6IG5vIGV2YWx1YXRpb24gZnVuY3Rpb24gZm91bmQuXCIpO3JldHVybiB0aGlzLmZsYWdSZWdpc3RyeVt0XS5ldmFsdWF0aW9uRm4oKX0sdC5wcm90b3R5cGUuc2V0RmxhZ3M9ZnVuY3Rpb24odCl7dGhpcy5mbGFncz1PYmplY3QuYXNzaWduKHt9LHQpfSx0LnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuZmxhZ3M9e30sdGhpcy51cmxGbGFncz17fSx0aGlzLnBvcHVsYXRlVVJMRmxhZ3MoKX0sdC5wcm90b3R5cGUucG9wdWxhdGVVUkxGbGFncz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYodm9pZCAwIT09dGhpcy5nbG9iYWwmJnZvaWQgMCE9PXRoaXMuZ2xvYmFsLmxvY2F0aW9uJiZ2b2lkIDAhPT10aGlzLmdsb2JhbC5sb2NhdGlvbi5zZWFyY2gpe3ZhciBlLG4scj0oZT10aGlzLmdsb2JhbC5sb2NhdGlvbi5zZWFyY2gsbj17fSxlLnJlcGxhY2UoL1s/Jl0oW149PyZdKykoPzo9KFteJl0qKSk/L2csKGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyllW3ItMV09YXJndW1lbnRzW3JdO3JldHVybiBhKG4sZVswXSxlWzFdKSxlLmpvaW4oXCI9XCIpfSkpLG4pO2lmKFwidGZqc2ZsYWdzXCJpbiByKXIudGZqc2ZsYWdzLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj1lLnNwbGl0KFwiOlwiKSxyPW5bMF0sbz1uWzFdO3QudXJsRmxhZ3Nbcl09ZnVuY3Rpb24odCxlKXtpZihcInRydWVcIj09PShlPWUudG9Mb3dlckNhc2UoKSl8fFwiZmFsc2VcIj09PWUpcmV0dXJuXCJ0cnVlXCI9PT1lO2lmKFwiXCIrICtlPT09ZSlyZXR1cm4rZTt0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgdmFsdWUgZmxhZyB2YWx1ZSBcIitlK1wiIGZvciBmbGFnIFwiK3QrXCIuXCIpfShyLG8pfSkpfX0sdH0oKTtmdW5jdGlvbiBhKHQsZSxuKXt0W2RlY29kZVVSSUNvbXBvbmVudChlKV09ZGVjb2RlVVJJQ29tcG9uZW50KG58fFwiXCIpfWZ1bmN0aW9uIGkoKXtyZXR1cm4gc312YXIgcz1udWxsO3ZhciB1PW5ldyBNYXAsYz1uZXcgTWFwO2Z1bmN0aW9uIGwodCxlKXt2YXIgbj1nKHQsZSk7cmV0dXJuIHUuZ2V0KG4pfWZ1bmN0aW9uIGgodCl7cmV0dXJuIGMuZ2V0KHQpfWZ1bmN0aW9uIGYodCl7Zm9yKHZhciBlPXUuZW50cmllcygpLG49W107Oyl7dmFyIHI9ZS5uZXh0KCksbz1yLmRvbmUsYT1yLnZhbHVlO2lmKG8pYnJlYWs7dmFyIGk9YVswXSxzPWFbMV07aS5zcGxpdChcIl9cIilbMF09PT10JiZuLnB1c2gocyl9cmV0dXJuIG59ZnVuY3Rpb24gZCh0KXt2YXIgZT10Lmtlcm5lbE5hbWUsbj10LmJhY2tlbmROYW1lLHI9ZyhlLG4pO2lmKHUuaGFzKHIpKXRocm93IG5ldyBFcnJvcihcIlRoZSBrZXJuZWwgJ1wiK2UrXCInIGZvciBiYWNrZW5kICdcIituK1wiJyBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7dS5zZXQocix0KX1mdW5jdGlvbiBwKHQpe3ZhciBlPXQua2VybmVsTmFtZTtjLmhhcyhlKSYmY29uc29sZS53YXJuKFwiT3ZlcnJpZGluZyB0aGUgZ3JhZGllbnQgZm9yICdcIitlK1wiJ1wiKSxjLnNldChlLHQpfWZ1bmN0aW9uIHYodCxlKXt2YXIgbj1nKHQsZSk7aWYoIXUuaGFzKG4pKXRocm93IG5ldyBFcnJvcihcIlRoZSBrZXJuZWwgJ1wiK3QrXCInIGZvciBiYWNrZW5kICdcIitlK1wiJyBpcyBub3QgcmVnaXN0ZXJlZFwiKTt1LmRlbGV0ZShuKX1mdW5jdGlvbiBtKHQpe2lmKCFjLmhhcyh0KSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZ3JhZGllbnQgJ1wiK3QrXCInIGZvciBiYWNrZW5kIGlzIG5vdCByZWdpc3RlcmVkXCIpO2MuZGVsZXRlKHQpfWZ1bmN0aW9uIGcodCxlKXtyZXR1cm4gZStcIl9cIit0fWZ1bmN0aW9uIHkodCl7Zm9yKHZhciBlPXQubGVuZ3RoLG49MCxyPTA7ZT4wOylyPU1hdGgucmFuZG9tKCkqZXwwLG49dFstLWVdLHRbZV09dFtyXSx0W3JdPW59ZnVuY3Rpb24geCh0LGUsbil7cmV0dXJuIE1hdGgubWF4KHQsTWF0aC5taW4oZSxuKSl9ZnVuY3Rpb24gYih0KXtyZXR1cm4gdCUyPT0wP3Q6dCsxfWZ1bmN0aW9uIHcodCl7Zm9yKHZhciBlPTAsbj0wO248dC5sZW5ndGg7bisrKWUrPXRbbl07cmV0dXJuIGV9ZnVuY3Rpb24gQyh0LGUpe2lmKCF0KXRocm93IG5ldyBFcnJvcihcInN0cmluZ1wiPT10eXBlb2YgZT9lOmUoKSl9ZnVuY3Rpb24gRSh0LGUsbil7dm9pZCAwPT09biYmKG49XCJcIiksQyhTKHQsZSksKGZ1bmN0aW9uKCl7cmV0dXJuIG4rXCIgU2hhcGVzIFwiK3QrXCIgYW5kIFwiK2UrXCIgbXVzdCBtYXRjaFwifSkpfWZ1bmN0aW9uIFIodCl7QyhudWxsIT10LChmdW5jdGlvbigpe3JldHVyblwiVGhlIGlucHV0IHRvIHRoZSB0ZW5zb3IgY29uc3RydWN0b3IgbXVzdCBiZSBhIG5vbi1udWxsIHZhbHVlLlwifSkpfWZ1bmN0aW9uIEkodCxlLG4pe2lmKHZvaWQgMD09PWUmJihlPVtdKSx2b2lkIDA9PT1uJiYobj0hMSksbnVsbD09ZSYmKGU9W10pLEFycmF5LmlzQXJyYXkodCl8fFYodCkmJiFuKWZvcih2YXIgcj0wO3I8dC5sZW5ndGg7KytyKUkodFtyXSxlLG4pO2Vsc2UgZS5wdXNoKHQpO3JldHVybiBlfWZ1bmN0aW9uIGsodCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiAxO2Zvcih2YXIgZT10WzBdLG49MTtuPHQubGVuZ3RoO24rKyllKj10W25dO3JldHVybiBlfWZ1bmN0aW9uIFModCxlKXtpZih0PT09ZSlyZXR1cm4hMDtpZihudWxsPT10fHxudWxsPT1lKXJldHVybiExO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspaWYodFtuXSE9PWVbbl0pcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gQSh0KXtyZXR1cm4gdCUxPT0wfWZ1bmN0aW9uIEQodCl7aWYobnVsbCE9TWF0aC50YW5oKXJldHVybiBNYXRoLnRhbmgodCk7aWYodD09PTEvMClyZXR1cm4gMTtpZih0PT09LTEvMClyZXR1cm4tMTt2YXIgZT1NYXRoLmV4cCgyKnQpO3JldHVybihlLTEpLyhlKzEpfWZ1bmN0aW9uIFQodCl7dmFyIGU9TWF0aC5jZWlsKE1hdGguc3FydCh0KSk7cmV0dXJuW2UsTWF0aC5jZWlsKHQvZSldfWZ1bmN0aW9uIE4odCxlKXtyZXR1cm4gZTw9dC5sZW5ndGg/dDp0K1wiIFwiLnJlcGVhdChlLXQubGVuZ3RoKX1mdW5jdGlvbiBGKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ZnVuY3Rpb24odCl7cmV0dXJuIDB9KSxuZXcgUHJvbWlzZSgoZnVuY3Rpb24ocixvKXt2YXIgYT0wLGk9ZnVuY3Rpb24oKXtpZih0KCkpcigpO2Vsc2V7YSsrO3ZhciBzPWUoYSk7bnVsbCE9biYmYT49bj9vKCk6c2V0VGltZW91dChpLHMpfX07aSgpfSkpfWZ1bmN0aW9uIF8odCxlKXtmb3IodmFyIG49MSxyPS0xLG89MDtvPHQubGVuZ3RoOysrbylpZih0W29dPj0wKW4qPXRbb107ZWxzZSBpZigtMT09PXRbb10pe2lmKC0xIT09cil0aHJvdyBFcnJvcihcIlNoYXBlcyBjYW4gb25seSBoYXZlIDEgaW1wbGljaXQgc2l6ZS4gRm91bmQgLTEgYXQgZGltIFwiK3IrXCIgYW5kIGRpbSBcIitvKTtyPW99ZWxzZSBpZih0W29dPDApdGhyb3cgRXJyb3IoXCJTaGFwZXMgY2FuIG5vdCBiZSA8IDAuIEZvdW5kIFwiK3Rbb10rXCIgYXQgZGltIFwiK28pO2lmKC0xPT09cil7aWYoZT4wJiZlIT09bil0aHJvdyBFcnJvcihcIlNpemUoXCIrZStcIikgbXVzdCBtYXRjaCB0aGUgcHJvZHVjdCBvZiBzaGFwZSBcIit0KTtyZXR1cm4gdH1pZigwPT09bil0aHJvdyBFcnJvcihcIkNhbm5vdCBpbmZlciB0aGUgbWlzc2luZyBzaXplIGluIFtcIit0K1wiXSB3aGVuIHRoZXJlIGFyZSAwIGVsZW1lbnRzXCIpO2lmKGUlbiE9MCl0aHJvdyBFcnJvcihcIlRoZSBpbXBsaWNpdCBzaGFwZSBjYW4ndCBiZSBhIGZyYWN0aW9uYWwgbnVtYmVyLiBHb3QgXCIrZStcIiAvIFwiK24pO3ZhciBhPXQuc2xpY2UoKTtyZXR1cm4gYVtyXT1lL24sYX1mdW5jdGlvbiBPKHQsZSl7dmFyIG49ZS5sZW5ndGg7cmV0dXJuIEMoKHQ9bnVsbD09dD9lLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gZX0pKTpbXS5jb25jYXQodCkpLmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gdD49LW4mJnQ8bn0pKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGluIHJhbmdlIFstXCIrbitcIiwgXCIrbitcIikgYnV0IGdvdCBheGlzIFwiK3R9KSksQyh0LmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gQSh0KX0pKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGludGVnZXJzIGJ1dCBnb3QgYXhpcyBcIit0fSkpLHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdDwwP24rdDp0fSkpfWZ1bmN0aW9uIE0odCxlKXtmb3IodmFyIG49W10scj1bXSxvPW51bGwhPWUmJkFycmF5LmlzQXJyYXkoZSkmJjA9PT1lLmxlbmd0aCxhPW51bGw9PWV8fG8/bnVsbDpPKGUsdCkuc29ydCgpLGk9MCxzPTA7czx0Lmxlbmd0aDsrK3Mpe2lmKG51bGwhPWEpe2lmKGFbaV09PT1zJiYxIT09dFtzXSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzcXVlZXplIGF4aXMgXCIrcytcIiBzaW5jZSBpdHMgZGltICdcIit0W3NdK1wiJyBpcyBub3QgMVwiKTsobnVsbD09YVtpXXx8YVtpXT5zKSYmMT09PXRbc10mJihuLnB1c2godFtzXSksci5wdXNoKHMpKSxhW2ldPD1zJiZpKyt9MSE9PXRbc10mJihuLnB1c2godFtzXSksci5wdXNoKHMpKX1yZXR1cm57bmV3U2hhcGU6bixrZXB0RGltczpyfX1mdW5jdGlvbiBCKHQsZSl7dmFyIG49bnVsbDtpZihudWxsPT10fHxcImZsb2F0MzJcIj09PXQpbj1uZXcgRmxvYXQzMkFycmF5KGUpO2Vsc2UgaWYoXCJpbnQzMlwiPT09dCluPW5ldyBJbnQzMkFycmF5KGUpO2Vsc2V7aWYoXCJib29sXCIhPT10KXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK3QpO249bmV3IFVpbnQ4QXJyYXkoZSl9cmV0dXJuIG59ZnVuY3Rpb24gUCh0LGUpe3ZhciBuPW51bGw7aWYobnVsbD09dHx8XCJmbG9hdDMyXCI9PT10KW49bmV3IEZsb2F0MzJBcnJheShlKTtlbHNlIGlmKFwiaW50MzJcIj09PXQpbj1uZXcgSW50MzJBcnJheShlKTtlbHNlIGlmKFwiYm9vbFwiPT09dCluPW5ldyBVaW50OEFycmF5KGUpO2Vsc2V7aWYoXCJzdHJpbmdcIiE9PXQpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrdCk7bj1uZXcgQXJyYXkoZSl9cmV0dXJuIG59ZnVuY3Rpb24gTCh0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO2lmKGlzTmFOKHIpfHwhaXNGaW5pdGUocikpdGhyb3cgRXJyb3IoXCJBIHRlbnNvciBvZiB0eXBlIFwiK2UrXCIgYmVpbmcgdXBsb2FkZWQgY29udGFpbnMgXCIrcitcIi5cIil9fWZ1bmN0aW9uIFcodCl7cmV0dXJuXCJib29sXCI9PT10fHxcImNvbXBsZXg2NFwiPT09dHx8XCJmbG9hdDMyXCI9PT10fHxcImludDMyXCI9PT10fHxcInN0cmluZ1wiPT09dH1mdW5jdGlvbiBVKHQsZSl7cmV0dXJuXCJjb21wbGV4NjRcIiE9PWUmJigoXCJmbG9hdDMyXCIhPT1lfHxcImNvbXBsZXg2NFwiPT09dCkmJigoXCJpbnQzMlwiIT09ZXx8XCJmbG9hdDMyXCI9PT10fHxcImNvbXBsZXg2NFwiPT09dCkmJihcImJvb2xcIiE9PWV8fFwiYm9vbFwiIT09dCkpKX1mdW5jdGlvbiBWKHQpe3JldHVybiB0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHx0IGluc3RhbmNlb2YgSW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl9ZnVuY3Rpb24geih0KXtpZihcImZsb2F0MzJcIj09PXR8fFwiaW50MzJcIj09PXQpcmV0dXJuIDQ7aWYoXCJjb21wbGV4NjRcIj09PXQpcmV0dXJuIDg7aWYoXCJib29sXCI9PT10KXJldHVybiAxO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gZHR5cGUgXCIrdCl9ZnVuY3Rpb24gRyh0KXtpZihudWxsPT10KXJldHVybiAwO3ZhciBlPTA7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGUrPXQubGVuZ3RofSkpLGV9ZnVuY3Rpb24gSCh0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdHx8dCBpbnN0YW5jZW9mIFN0cmluZ31mdW5jdGlvbiBxKHQpe3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgdH1mdW5jdGlvbiBLKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIGoodCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/aih0WzBdKTp0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P1wiZmxvYXQzMlwiOnQgaW5zdGFuY2VvZiBJbnQzMkFycmF5fHx0IGluc3RhbmNlb2YgVWludDhBcnJheT9cImludDMyXCI6Syh0KT9cImZsb2F0MzJcIjpIKHQpP1wic3RyaW5nXCI6cSh0KT9cImJvb2xcIjpcImZsb2F0MzJcIn1mdW5jdGlvbiBYKHQpe3JldHVybiEhKHQmJnQuY29uc3RydWN0b3ImJnQuY2FsbCYmdC5hcHBseSl9ZnVuY3Rpb24gWSh0LGUpe2Zvcih2YXIgbj1lO248dDsrK24paWYodCVuPT0wKXJldHVybiBuO3JldHVybiB0fWZ1bmN0aW9uICQodCl7dmFyIGU9dC5sZW5ndGg7aWYoZTwyKXJldHVybltdO3ZhciBuPW5ldyBBcnJheShlLTEpO25bZS0yXT10W2UtMV07Zm9yKHZhciByPWUtMztyPj0wOy0tciluW3JdPW5bcisxXSp0W3IrMV07cmV0dXJuIG59ZnVuY3Rpb24gUSh0LGUsbil7aWYoXCJzdHJpbmdcIj09PWUpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgYSBzdHJpbmdbXSB0byBhIFR5cGVkQXJyYXlcIik7aWYoQXJyYXkuaXNBcnJheSh0KSYmKHQ9SSh0KSksbiYmTCh0LGUpLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkmJlwiZmxvYXQzMlwiPT09ZXx8dCBpbnN0YW5jZW9mIEludDMyQXJyYXkmJlwiaW50MzJcIj09PWV8fHQgaW5zdGFuY2VvZiBVaW50OEFycmF5JiZcImJvb2xcIj09PWV9KHQsZSkpcmV0dXJuIHQ7aWYobnVsbD09ZXx8XCJmbG9hdDMyXCI9PT1lfHxcImNvbXBsZXg2NFwiPT09ZSlyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0KTtpZihcImludDMyXCI9PT1lKXJldHVybiBuZXcgSW50MzJBcnJheSh0KTtpZihcImJvb2xcIj09PWUpe2Zvcih2YXIgcj1uZXcgVWludDhBcnJheSh0Lmxlbmd0aCksbz0wO288ci5sZW5ndGg7KytvKTAhPT1NYXRoLnJvdW5kKHRbb10pJiYocltvXT0xKTtyZXR1cm4gcn10aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIitlKX1mdW5jdGlvbiBKKHQsZSl7aWYoMD09PXQubGVuZ3RoKXJldHVybiBlWzBdO3ZhciBuPXQucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSk7aWYoMD09PW4pcmV0dXJuW107aWYobiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIltcIit0K1wiXSBkb2VzIG5vdCBtYXRjaCB0aGUgaW5wdXQgc2l6ZS5cIik7cmV0dXJuIGZ1bmN0aW9uIHQoZSxuLHIpe3ZhciBvPW5ldyBBcnJheTtpZigxPT09bi5sZW5ndGgpZm9yKHZhciBhPW5bMF0saT0wO2k8YTtpKyspb1tpXT1yW2UraV07ZWxzZXthPW5bMF07dmFyIHM9bi5zbGljZSgxKSx1PXMucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSk7Zm9yKGk9MDtpPGE7aSsrKW9baV09dChlK2kqdSxzLHIpfXJldHVybiBvfSgwLHQsZSl9ZnVuY3Rpb24gWih0LGUpe2Zvcih2YXIgbj10dCh0LGUpLHI9MDtyPG4ubGVuZ3RoO3IrKyluW3JdPTE7cmV0dXJuIG59ZnVuY3Rpb24gdHQodCxlKXtpZihudWxsPT1lfHxcImZsb2F0MzJcIj09PWV8fFwiY29tcGxleDY0XCI9PT1lKXJldHVybiBuZXcgRmxvYXQzMkFycmF5KHQpO2lmKFwiaW50MzJcIj09PWUpcmV0dXJuIG5ldyBJbnQzMkFycmF5KHQpO2lmKFwiYm9vbFwiPT09ZSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodCk7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrZSl9ZnVuY3Rpb24gZXQoKXtyZXR1cm4gaSgpLnBsYXRmb3JtLm5vdygpfWZ1bmN0aW9uIG50KHQpe3QuZm9yRWFjaCgoZnVuY3Rpb24oZSl7QyhOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPj0wLChmdW5jdGlvbigpe3JldHVyblwiVGVuc29yIG11c3QgaGF2ZSBhIHNoYXBlIGNvbXByaXNlZCBvZiBwb3NpdGl2ZSBpbnRlZ2VycyBidXQgZ290IHNoYXBlIFtcIit0K1wiXS5cIn0pKX0pKX1mdW5jdGlvbiBydCh0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cInV0Zi04XCIpLGU9ZXx8XCJ1dGYtOFwiLGkoKS5wbGF0Zm9ybS5lbmNvZGUodCxlKX1mdW5jdGlvbiBvdCh0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cInV0Zi04XCIpLGU9ZXx8XCJ1dGYtOFwiLGkoKS5wbGF0Zm9ybS5kZWNvZGUodCxlKX1mdW5jdGlvbiBhdCh0LGUsbil7aWYoMD09PWUpcmV0dXJuIDA7aWYoMT09PWUpcmV0dXJuIHRbMF07Zm9yKHZhciByPXRbdC5sZW5ndGgtMV0sbz0wO288dC5sZW5ndGgtMTsrK28pcis9bltvXSp0W29dO3JldHVybiByfWZ1bmN0aW9uIGl0KHQsZSxuKXtpZigwPT09ZSlyZXR1cm5bXTtpZigxPT09ZSlyZXR1cm5bdF07Zm9yKHZhciByPW5ldyBBcnJheShlKSxvPTA7bzxyLmxlbmd0aC0xOysrbylyW29dPU1hdGguZmxvb3IodC9uW29dKSx0LT1yW29dKm5bb107cmV0dXJuIHJbci5sZW5ndGgtMV09dCxyfXZhciBzdD1PYmplY3QuZnJlZXplKHtzaHVmZmxlOnksY2xhbXA6eCxuZWFyZXN0TGFyZ2VyRXZlbjpiLHN1bTp3LHJhbmRVbmlmb3JtOmZ1bmN0aW9uKHQsZSl7dmFyIG49TWF0aC5yYW5kb20oKTtyZXR1cm4gZSpuKygxLW4pKnR9LGRpc3RTcXVhcmVkOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTAscj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbz1OdW1iZXIodFtyXSktTnVtYmVyKGVbcl0pO24rPW8qb31yZXR1cm4gbn0sYXNzZXJ0OkMsYXNzZXJ0U2hhcGVzTWF0Y2g6RSxhc3NlcnROb25OdWxsOlIsZmxhdHRlbjpJLHNpemVGcm9tU2hhcGU6ayxpc1NjYWxhclNoYXBlOmZ1bmN0aW9uKHQpe3JldHVybiAwPT09dC5sZW5ndGh9LGFycmF5c0VxdWFsOlMsaXNJbnQ6QSx0YW5oOkQsc2l6ZVRvU3F1YXJpc2hTaGFwZTpULGNyZWF0ZVNodWZmbGVkSW5kaWNlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IFVpbnQzMkFycmF5KHQpLG49MDtuPHQ7KytuKWVbbl09bjtyZXR1cm4geShlKSxlfSxyaWdodFBhZDpOLHJlcGVhdGVkVHJ5OkYsaW5mZXJGcm9tSW1wbGljaXRTaGFwZTpfLHBhcnNlQXhpc1BhcmFtOk8sc3F1ZWV6ZVNoYXBlOk0sZ2V0VHlwZWRBcnJheUZyb21EVHlwZTpCLGdldEFycmF5RnJvbURUeXBlOlAsY2hlY2tDb252ZXJzaW9uRm9yRXJyb3JzOkwsaXNWYWxpZER0eXBlOlcsaGFzRW5jb2RpbmdMb3NzOlUsaXNUeXBlZEFycmF5OlYsYnl0ZXNQZXJFbGVtZW50OnosYnl0ZXNGcm9tU3RyaW5nQXJyYXk6Ryxpc1N0cmluZzpILGlzQm9vbGVhbjpxLGlzTnVtYmVyOkssaW5mZXJEdHlwZTpqLGlzRnVuY3Rpb246WCxuZWFyZXN0RGl2aXNvcjpZLGNvbXB1dGVTdHJpZGVzOiQsdG9UeXBlZEFycmF5OlEsdG9OZXN0ZWRBcnJheTpKLG1ha2VPbmVzVHlwZWRBcnJheTpaLG1ha2VaZXJvc1R5cGVkQXJyYXk6dHQsbm93OmV0LGFzc2VydE5vbk5lZ2F0aXZlSW50ZWdlckRpbWVuc2lvbnM6bnQsZmV0Y2g6ZnVuY3Rpb24odCxlKXtyZXR1cm4gaSgpLnBsYXRmb3JtLmZldGNoKHQsZSl9LGVuY29kZVN0cmluZzpydCxkZWNvZGVTdHJpbmc6b3QsbG9jVG9JbmRleDphdCxpbmRleFRvTG9jOml0fSksdXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5iYWNrZW5kVGltZXI9dCx0aGlzLmxvZ2dlcj1lLG51bGw9PWUmJih0aGlzLmxvZ2dlcj1uZXcgY3QpfXJldHVybiB0LnByb3RvdHlwZS5wcm9maWxlS2VybmVsPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvPXRoaXMsYT10aGlzLmJhY2tlbmRUaW1lci50aW1lKChmdW5jdGlvbigpe3I9bigpfSkpO3JldHVybiByLmZvckVhY2goKGZ1bmN0aW9uKG4pe24uZGF0YSgpLnRoZW4oKGZ1bmN0aW9uKHIpeyFmdW5jdGlvbih0LGUsbil7aWYoXCJmbG9hdDMyXCIhPT1lKXJldHVybiExO2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbz10W3JdO2lmKGlzTmFOKG8pfHwhaXNGaW5pdGUobykpcmV0dXJuIGNvbnNvbGUud2FybihcIkZvdW5kIFwiK28rXCIgaW4gdGhlIHJlc3VsdCBvZiAnXCIrbitcIidcIiksITB9fShyLG4uZHR5cGUsdCksYS50aGVuKChmdW5jdGlvbihhKXt2YXIgaT1cIlwiO251bGwhPWEuZ2V0RXh0cmFQcm9maWxlSW5mbyYmKGk9YS5nZXRFeHRyYVByb2ZpbGVJbmZvKCkpLG8ubG9nZ2VyLmxvZ0tlcm5lbFByb2ZpbGUodCxuLHIsYS5rZXJuZWxNcyxlLGkpfSkpfSkpfSkpLHJ9LHR9KCk7dmFyIGN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUubG9nS2VybmVsUHJvZmlsZT1mdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9XCJudW1iZXJcIj09dHlwZW9mIHI/TihyK1wibXNcIiw5KTpyLmVycm9yLHM9Tih0LDI1KSx1PWUucmFuayxjPWUuc2l6ZSxsPU4oZS5zaGFwZS50b1N0cmluZygpLDE0KSxoPVwiXCI7Zm9yKHZhciBmIGluIG8pe3ZhciBkPW9bZl0uc2hhcGV8fGUuc2hhcGUscD1kLmxlbmd0aDtoKz1mK1wiOiBcIitwK1wiRCBcIisocD4wP2Q6XCJcIikrXCIgXCJ9Y29uc29sZS5sb2coXCIlY1wiK3MrXCJcXHQlY1wiK2krXCJcXHQlY1wiK3UrXCJEIFwiK2wrXCJcXHQlY1wiK2MrXCJcXHQlY1wiK2grXCJcXHQlY1wiK2EsXCJmb250LXdlaWdodDpib2xkXCIsXCJjb2xvcjpyZWRcIixcImNvbG9yOmJsdWVcIixcImNvbG9yOiBvcmFuZ2VcIixcImNvbG9yOiBncmVlblwiLFwiY29sb3I6IHN0ZWVsYmx1ZVwiKX0sdH0oKTt2YXIgbHQ9MjAsaHQ9MyxmdD03O2Z1bmN0aW9uIGR0KHQsZSxuLHIpe3ZhciBvPSQoZSksYT1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1rKGUpLGE9cltyLmxlbmd0aC0xXSxpPW5ldyBBcnJheShhKS5maWxsKDApLHM9ZS5sZW5ndGgsdT1cImNvbXBsZXg2NFwiPT09bj9tdCh0KTp0O2lmKHM+MSlmb3IodmFyIGM9MDtjPG8vYTtjKyspZm9yKHZhciBsPWMqYSxoPTA7aDxhO2grKylpW2hdPU1hdGgubWF4KGlbaF0scHQodVtsK2hdLDAsbikubGVuZ3RoKTtyZXR1cm4gaX0odCxlLG4sbyksaT1lLmxlbmd0aCxzPWZ1bmN0aW9uIHQoZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWkmJihpPSEwKTt2YXIgcz1cImNvbXBsZXg2NFwiPT09cj8yOjEsdT1uWzBdLGM9bi5sZW5ndGg7aWYoMD09PWMpe3JldHVyblwiY29tcGxleDY0XCI9PT1yP1twdChtdChlKVswXSwwLHIpXTpcImJvb2xcIj09PXI/W3Z0KGVbMF0pXTpbZVswXS50b1N0cmluZygpXX1pZigxPT09Yyl7aWYodT5sdCl7dmFyIGw9aHQqcyxoPUFycmF5LmZyb20oZS5zbGljZSgwLGwpKSxmPUFycmF5LmZyb20oZS5zbGljZSgodS1odCkqcyx1KnMpKTtyZXR1cm5cImNvbXBsZXg2NFwiPT09ciYmKGg9bXQoaCksZj1tdChmKSksW1wiW1wiK2gubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiBwdCh0LGFbZV0scil9KSkuam9pbihcIiwgXCIpK1wiLCAuLi4sIFwiK2YubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiBwdCh0LGFbdS1odCtlXSxyKX0pKS5qb2luKFwiLCBcIikrXCJdXCJdfXJldHVybltcIltcIisoXCJjb21wbGV4NjRcIj09PXI/bXQoZSk6QXJyYXkuZnJvbShlKSkubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiBwdCh0LGFbZV0scil9KSkuam9pbihcIiwgXCIpK1wiXVwiXX12YXIgZD1uLnNsaWNlKDEpLHA9by5zbGljZSgxKSx2PW9bMF0qcyxtPVtdO2lmKHU+bHQpe2Zvcih2YXIgZz0wO2c8aHQ7ZysrKXt2YXIgeT0oeD1nKnYpK3Y7bS5wdXNoLmFwcGx5KG0sdChlLnNsaWNlKHgseSksZCxyLHAsYSwhMSkpfW0ucHVzaChcIi4uLlwiKTtmb3IoZz11LWh0O2c8dTtnKyspe3k9KHg9Zyp2KSt2O20ucHVzaC5hcHBseShtLHQoZS5zbGljZSh4LHkpLGQscixwLGEsZz09PXUtMSkpfX1lbHNlIGZvcihnPTA7Zzx1O2crKyl7dmFyIHg7eT0oeD1nKnYpK3Y7bS5wdXNoLmFwcGx5KG0sdChlLnNsaWNlKHgseSksZCxyLHAsYSxnPT09dS0xKSl9dmFyIGI9Mj09PWM/XCIsXCI6XCJcIjttWzBdPVwiW1wiK21bMF0rYjtmb3IoZz0xO2c8bS5sZW5ndGgtMTtnKyspbVtnXT1cIiBcIittW2ddK2I7dmFyIHc9XCIsXFxuXCI7Zm9yKGc9MjtnPGM7ZysrKXcrPVwiXFxuXCI7cmV0dXJuIG1bbS5sZW5ndGgtMV09XCIgXCIrbVttLmxlbmd0aC0xXStcIl1cIisoaT9cIlwiOncpLG19KHQsZSxuLG8sYSksdT1bXCJUZW5zb3JcIl07cmV0dXJuIHImJih1LnB1c2goXCIgIGR0eXBlOiBcIituKSx1LnB1c2goXCIgIHJhbms6IFwiK2kpLHUucHVzaChcIiAgc2hhcGU6IFtcIitlK1wiXVwiKSx1LnB1c2goXCIgIHZhbHVlczpcIikpLHUucHVzaChzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuXCIgICAgXCIrdH0pKS5qb2luKFwiXFxuXCIpKSx1LmpvaW4oXCJcXG5cIil9ZnVuY3Rpb24gcHQodCxlLG4pe3JldHVybiBOKEFycmF5LmlzQXJyYXkodCk/cGFyc2VGbG9hdCh0WzBdLnRvRml4ZWQoZnQpKStcIiArIFwiK3BhcnNlRmxvYXQodFsxXS50b0ZpeGVkKGZ0KSkrXCJqXCI6SCh0KT9cIidcIit0K1wiJ1wiOlwiYm9vbFwiPT09bj92dCh0KTpwYXJzZUZsb2F0KHQudG9GaXhlZChmdCkpLnRvU3RyaW5nKCksZSl9ZnVuY3Rpb24gdnQodCl7cmV0dXJuIDA9PT10P1wiZmFsc2VcIjpcInRydWVcIn1mdW5jdGlvbiBtdCh0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7bis9MillLnB1c2goW3Rbbl0sdFtuKzFdXSk7cmV0dXJuIGV9dmFyIGd0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbil7dmFyIHI9dGhpcztpZih0aGlzLmR0eXBlPWUsdGhpcy5zaGFwZT10LnNsaWNlKCksdGhpcy5zaXplPWsodCksbnVsbCE9bil7dmFyIG89bi5sZW5ndGg7QyhvPT09dGhpcy5zaXplLChmdW5jdGlvbigpe3JldHVyblwiTGVuZ3RoIG9mIHZhbHVlcyAnXCIrbytcIicgZG9lcyBub3QgbWF0Y2ggdGhlIHNpemUgaW5mZXJyZWQgYnkgdGhlIHNoYXBlICdcIityLnNpemUrXCInLlwifSkpfWlmKFwiY29tcGxleDY0XCI9PT1lKXRocm93IG5ldyBFcnJvcihcImNvbXBsZXg2NCBkdHlwZSBUZW5zb3JCdWZmZXJzIGFyZSBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgY3JlYXRlIGEgVGVuc29yQnVmZmVyIGZvciB0aGUgcmVhbCBhbmQgaW1hZ2luYXJ5IHBhcnRzIHNlcGFyYXRlbHkgYW5kIGNhbGwgdGYuY29tcGxleChyZWFsLCBpbWFnKS5cIik7dGhpcy52YWx1ZXM9bnx8UChlLHRoaXMuc2l6ZSksdGhpcy5zdHJpZGVzPSQodCl9cmV0dXJuIHQucHJvdG90eXBlLnNldD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcyxuPVtdLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKW5bci0xXT1hcmd1bWVudHNbcl07MD09PW4ubGVuZ3RoJiYobj1bMF0pLEMobi5sZW5ndGg9PT10aGlzLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgbnVtYmVyIG9mIHByb3ZpZGVkIGNvb3JkaW5hdGVzIChcIituLmxlbmd0aCtcIikgbXVzdCBtYXRjaCB0aGUgcmFuayAoXCIrZS5yYW5rK1wiKVwifSkpO3ZhciBvPXRoaXMubG9jVG9JbmRleChuKTt0aGlzLnZhbHVlc1tvXT10fSx0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspdFtlXT1hcmd1bWVudHNbZV07MD09PXQubGVuZ3RoJiYodD1bMF0pO2Zvcih2YXIgbj0wLHI9MCxvPXQ7cjxvLmxlbmd0aDtyKyspe3ZhciBhPW9bcl07aWYoYTwwfHxhPj10aGlzLnNoYXBlW25dKXt2YXIgaT1cIlJlcXVlc3RlZCBvdXQgb2YgcmFuZ2UgZWxlbWVudCBhdCBcIit0K1wiLiAgIEJ1ZmZlciBzaGFwZT1cIit0aGlzLnNoYXBlO3Rocm93IG5ldyBFcnJvcihpKX1uKyt9Zm9yKHZhciBzPXRbdC5sZW5ndGgtMV0sdT0wO3U8dC5sZW5ndGgtMTsrK3Upcys9dGhpcy5zdHJpZGVzW3VdKnRbdV07cmV0dXJuIHRoaXMudmFsdWVzW3NdfSx0LnByb3RvdHlwZS5sb2NUb0luZGV4PWZ1bmN0aW9uKHQpe2lmKDA9PT10aGlzLnJhbmspcmV0dXJuIDA7aWYoMT09PXRoaXMucmFuaylyZXR1cm4gdFswXTtmb3IodmFyIGU9dFt0Lmxlbmd0aC0xXSxuPTA7bjx0Lmxlbmd0aC0xOysrbillKz10aGlzLnN0cmlkZXNbbl0qdFtuXTtyZXR1cm4gZX0sdC5wcm90b3R5cGUuaW5kZXhUb0xvYz1mdW5jdGlvbih0KXtpZigwPT09dGhpcy5yYW5rKXJldHVybltdO2lmKDE9PT10aGlzLnJhbmspcmV0dXJuW3RdO2Zvcih2YXIgZT1uZXcgQXJyYXkodGhpcy5zaGFwZS5sZW5ndGgpLG49MDtuPGUubGVuZ3RoLTE7KytuKWVbbl09TWF0aC5mbG9vcih0L3RoaXMuc3RyaWRlc1tuXSksdC09ZVtuXSp0aGlzLnN0cmlkZXNbbl07cmV0dXJuIGVbZS5sZW5ndGgtMV09dCxlfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyYW5rXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoYXBlLmxlbmd0aH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS50b1RlbnNvcj1mdW5jdGlvbigpe3JldHVybiB5dCgpLm1ha2VUZW5zb3IodGhpcy52YWx1ZXMsdGhpcy5zaGFwZSx0aGlzLmR0eXBlKX0sdH0oKSx5dD1udWxsLHh0PW51bGwsYnQ9bnVsbDt2YXIgd3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuLHIpe3RoaXMua2VwdD0hMSx0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbD0hMSx0aGlzLnNoYXBlPXQuc2xpY2UoKSx0aGlzLmR0eXBlPWV8fFwiZmxvYXQzMlwiLHRoaXMuc2l6ZT1rKHQpLHRoaXMuc3RyaWRlcz0kKHQpLHRoaXMuZGF0YUlkPW4sdGhpcy5pZD1yLHRoaXMucmFua1R5cGU9dGhpcy5yYW5rPDU/dGhpcy5yYW5rLnRvU3RyaW5nKCk6XCJoaWdoZXJcIn1yZXR1cm4gdC5wcm90b3R5cGUuZmxhdHRlbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMuYXMxRCgpfSx0LnByb3RvdHlwZS5hc1NjYWxhcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEMoMT09PXRoaXMuc2l6ZSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBhcnJheSBtdXN0IGhhdmUgb25seSAxIGVsZW1lbnQuXCJ9KSksdGhpcy5yZXNoYXBlKFtdKX0sdC5wcm90b3R5cGUuYXMxRD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZShbdGhpcy5zaXplXSl9LHQucHJvdG90eXBlLmFzMkQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUoW3QsZV0pfSx0LnByb3RvdHlwZS5hczNEPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUoW3QsZSxuXSl9LHQucHJvdG90eXBlLmFzNEQ9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFt0LGUsbixyXSl9LHQucHJvdG90eXBlLmFzNUQ9ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUoW3QsZSxuLHIsb10pfSx0LnByb3RvdHlwZS5hc1R5cGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuY2FzdCh0aGlzLHQpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyYW5rXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoYXBlLmxlbmd0aH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5idWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmRhdGEoKV07Y2FzZSAxOnJldHVybiB0PWUuc2VudCgpLFsyLHh0LmJ1ZmZlcih0aGlzLnNoYXBlLHRoaXMuZHR5cGUsdCldfX0pKX0pKX0sdC5wcm90b3R5cGUuYnVmZmVyU3luYz1mdW5jdGlvbigpe3JldHVybiB4dC5idWZmZXIodGhpcy5zaGFwZSx0aGlzLmR0eXBlLHRoaXMuZGF0YVN5bmMoKSl9LHQucHJvdG90eXBlLmFycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0O3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gdD1lLnNlbnQoKSxbMixKKHRoaXMuc2hhcGUsdCldfX0pKX0pKX0sdC5wcm90b3R5cGUuYXJyYXlTeW5jPWZ1bmN0aW9uKCl7cmV0dXJuIEoodGhpcy5zaGFwZSx0aGlzLmRhdGFTeW5jKCkpfSx0LnByb3RvdHlwZS5kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0LGU7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0PXl0KCkucmVhZCh0aGlzLmRhdGFJZCksXCJzdHJpbmdcIiE9PXRoaXMuZHR5cGU/WzMsMl06WzQsdF07Y2FzZSAxOmU9bi5zZW50KCk7dHJ5e3JldHVyblsyLGUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gb3QodCl9KSldfWNhdGNoKHQpe3Rocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNvZGUgdGhlIHN0cmluZyBieXRlcyBpbnRvIHV0Zi04LiBUbyBnZXQgdGhlIG9yaWdpbmFsIGJ5dGVzLCBjYWxsIHRlbnNvci5ieXRlcygpLlwiKX1uLmxhYmVsPTI7Y2FzZSAyOnJldHVyblsyLHRdfX0pKX0pKX0sdC5wcm90b3R5cGUuZGF0YVN5bmM9ZnVuY3Rpb24oKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO3ZhciB0PXl0KCkucmVhZFN5bmModGhpcy5kYXRhSWQpO2lmKFwic3RyaW5nXCI9PT10aGlzLmR0eXBlKXRyeXtyZXR1cm4gdC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBvdCh0KX0pKX1jYXRjaCh0KXt0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjb2RlIHRoZSBzdHJpbmcgYnl0ZXMgaW50byB1dGYtOC4gVG8gZ2V0IHRoZSBvcmlnaW5hbCBieXRlcywgY2FsbCB0ZW5zb3IuYnl0ZXMoKS5cIil9cmV0dXJuIHR9LHQucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0O3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksWzQseXQoKS5yZWFkKHRoaXMuZGF0YUlkKV07Y2FzZSAxOnJldHVybiB0PWUuc2VudCgpLFwic3RyaW5nXCI9PT10aGlzLmR0eXBlP1syLHRdOlsyLG5ldyBVaW50OEFycmF5KHQuYnVmZmVyKV19fSkpfSkpfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5pc0Rpc3Bvc2VkfHwoeXQoKS5kaXNwb3NlVGVuc29yKHRoaXMpLHRoaXMuaXNEaXNwb3NlZEludGVybmFsPSEwKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiaXNEaXNwb3NlZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0Rpc3Bvc2VkSW50ZXJuYWx9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUudGhyb3dJZkRpc3Bvc2VkPWZ1bmN0aW9uKCl7aWYodGhpcy5pc0Rpc3Bvc2VkKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBpcyBkaXNwb3NlZC5cIil9LHQucHJvdG90eXBlLnRvRmxvYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hc1R5cGUoXCJmbG9hdDMyXCIpfSx0LnByb3RvdHlwZS50b0ludD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFzVHlwZShcImludDMyXCIpfSx0LnByb3RvdHlwZS50b0Jvb2w9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hc1R5cGUoXCJib29sXCIpfSx0LnByb3RvdHlwZS5wcmludD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLHh0LnByaW50KHRoaXMsdCl9LHQucHJvdG90eXBlLnJlc2hhcGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQucmVzaGFwZSh0aGlzLHQpfSx0LnByb3RvdHlwZS5yZXNoYXBlQXM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKHQuc2hhcGUpfSx0LnByb3RvdHlwZS5leHBhbmREaW1zPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx4dC5leHBhbmREaW1zKHRoaXMsdCl9LHQucHJvdG90eXBlLmN1bXN1bT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLHZvaWQgMD09PWUmJihlPSExKSx2b2lkIDA9PT1uJiYobj0hMSkseHQuY3Vtc3VtKHRoaXMsdCxlLG4pfSx0LnByb3RvdHlwZS5zcXVlZXplPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNxdWVlemUodGhpcyx0KX0sdC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jbG9uZSh0aGlzKX0sdC5wcm90b3R5cGUub25lSG90PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5vbmVIb3QodGhpcyx0LGUsbil9LHQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0hMSksZHQodGhpcy5kYXRhU3luYygpLHRoaXMuc2hhcGUsdGhpcy5kdHlwZSx0KX0sdC5wcm90b3R5cGUudGlsZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC50aWxlKHRoaXMsdCl9LHQucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0wKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmdhdGhlcih0aGlzLHQsZSl9LHQucHJvdG90eXBlLm1hdE11bD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PWUmJihlPSExKSx2b2lkIDA9PT1uJiYobj0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5tYXRNdWwodGhpcyx0LGUsbil9LHQucHJvdG90eXBlLmRvdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5kb3QodGhpcyx0KX0sdC5wcm90b3R5cGUubm9ybT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PXQmJih0PVwiZXVjbGlkZWFuXCIpLHZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm5vcm0odGhpcyx0LGUsbil9LHQucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc2xpY2UodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnJldmVyc2UodGhpcyx0KX0sdC5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZSBpbnN0YW5jZW9mIHQmJihlPVtlXSkseHQuY29uY2F0KFt0aGlzXS5jb25jYXQoZSksbil9LHQucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3BsaXQodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5zdGFjaz1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0wKSx4dC5zdGFjayhbdGhpcyx0XSxlKX0sdC5wcm90b3R5cGUudW5zdGFjaz1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCkseHQudW5zdGFjayh0aGlzLHQpfSx0LnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MCkseHQucGFkKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHZvaWQgMD09PW4mJihuPS4wMDEpLGJ0KFwidGYuYmF0Y2hOb3JtYWxpemF0aW9uKCkgaXMgZ29pbmcgYXdheS4gVXNlIHRmLmJhdGNoTm9ybSgpIGluc3RlYWQsIGFuZCBub3RlIHRoZSBwb3NpdGlvbmFsIGFyZ3VtZW50IGNoYW5nZSBvZiBzY2FsZSwgb2Zmc2V0LCBhbmQgdmFyaWFuY2VFcHNpbG9uXCIpLHRoaXMuYmF0Y2hOb3JtKHQsZSxvLHIsbil9LHQucHJvdG90eXBlLmJhdGNoTm9ybT1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB2b2lkIDA9PT1vJiYobz0uMDAxKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmJhdGNoTm9ybSh0aGlzLHQsZSxuLHIsbyl9LHQucHJvdG90eXBlLmFsbD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hbGwodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5hbnk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYW55KHRoaXMsdCxlKX0sdC5wcm90b3R5cGUubG9nU3VtRXhwPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmxvZ1N1bUV4cCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnN1bT1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zdW0odGhpcyx0LGUpfSx0LnByb3RvdHlwZS5wcm9kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnByb2QodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5tZWFuPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1lYW4odGhpcyx0LGUpfSx0LnByb3RvdHlwZS5taW49ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubWluKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUubWF4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1heCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLmFyZ01pbj1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hcmdNaW4odGhpcyx0KX0sdC5wcm90b3R5cGUuYXJnTWF4PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmFyZ01heCh0aGlzLHQpfSx0LnByb3RvdHlwZS5jYXN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmNhc3QodGhpcyx0KX0sdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmFkZCh0aGlzLHQpfSx0LnByb3RvdHlwZS5hZGRTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYWRkU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmF0YW4yPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmF0YW4yKHRoaXMsdCl9LHQucHJvdG90eXBlLnN1Yj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zdWIodGhpcyx0KX0sdC5wcm90b3R5cGUuc3ViU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnN1YlN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQucG93KHRoaXMsdCl9LHQucHJvdG90eXBlLnBvd1N0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5wb3dTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubXVsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm11bCh0aGlzLHQpfSx0LnByb3RvdHlwZS5tdWxTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubXVsU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmRpdj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5kaXYodGhpcyx0KX0sdC5wcm90b3R5cGUuZGl2Tm9OYW49ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZGl2Tm9OYW4odGhpcyx0KX0sdC5wcm90b3R5cGUuZmxvb3JEaXY9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZmxvb3JEaXYodGhpcyx0KX0sdC5wcm90b3R5cGUuZGl2U3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmRpdlN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5taW5pbXVtPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1pbmltdW0odGhpcyx0KX0sdC5wcm90b3R5cGUubWluaW11bVN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5taW5pbXVtU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLm1heGltdW09ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubWF4aW11bSh0aGlzLHQpfSx0LnByb3RvdHlwZS5tYXhpbXVtU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1heGltdW1TdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1vZCh0aGlzLHQpfSx0LnByb3RvdHlwZS5tb2RTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubW9kU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLnNxdWFyZWREaWZmZXJlbmNlU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNxdWFyZWREaWZmZXJlbmNlU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLnRyYW5zcG9zZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC50cmFuc3Bvc2UodGhpcyx0KX0sdC5wcm90b3R5cGUubm90RXF1YWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubm90RXF1YWwodGhpcyx0KX0sdC5wcm90b3R5cGUubm90RXF1YWxTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubm90RXF1YWxTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubGVzcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sZXNzKHRoaXMsdCl9LHQucHJvdG90eXBlLmxlc3NTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubGVzc1N0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5lcXVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5lcXVhbCh0aGlzLHQpfSx0LnByb3RvdHlwZS5lcXVhbFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5lcXVhbFN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sZXNzRXF1YWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubGVzc0VxdWFsKHRoaXMsdCl9LHQucHJvdG90eXBlLmxlc3NFcXVhbFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sZXNzRXF1YWxTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuZ3JlYXRlcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5ncmVhdGVyKHRoaXMsdCl9LHQucHJvdG90eXBlLmdyZWF0ZXJTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZ3JlYXRlclN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5ncmVhdGVyRXF1YWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZ3JlYXRlckVxdWFsKHRoaXMsdCl9LHQucHJvdG90eXBlLmdyZWF0ZXJFcXVhbFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5ncmVhdGVyRXF1YWxTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubG9naWNhbEFuZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sb2dpY2FsQW5kKHRoaXMsdCl9LHQucHJvdG90eXBlLmxvZ2ljYWxPcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sb2dpY2FsT3IodGhpcyx0KX0sdC5wcm90b3R5cGUubG9naWNhbE5vdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmxvZ2ljYWxOb3QodGhpcyl9LHQucHJvdG90eXBlLmxvZ2ljYWxYb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubG9naWNhbFhvcih0aGlzLHQpfSx0LnByb3RvdHlwZS53aGVyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LndoZXJlKHQsdGhpcyxlKX0sdC5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubmVnKHRoaXMpfSx0LnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuY2VpbCh0aGlzKX0sdC5wcm90b3R5cGUuZmxvb3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5mbG9vcih0aGlzKX0sdC5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNpZ24odGhpcyl9LHQucHJvdG90eXBlLmlzTmFOPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuaXNOYU4odGhpcyl9LHQucHJvdG90eXBlLmlzSW5mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuaXNJbmYodGhpcyl9LHQucHJvdG90eXBlLmlzRmluaXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuaXNGaW5pdGUodGhpcyl9LHQucHJvdG90eXBlLmV4cD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmV4cCh0aGlzKX0sdC5wcm90b3R5cGUuZXhwbTE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5leHBtMSh0aGlzKX0sdC5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubG9nKHRoaXMpfSx0LnByb3RvdHlwZS5sb2cxcD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmxvZzFwKHRoaXMpfSx0LnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3FydCh0aGlzKX0sdC5wcm90b3R5cGUucnNxcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5yc3FydCh0aGlzKX0sdC5wcm90b3R5cGUuc3F1YXJlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3F1YXJlKHRoaXMpfSx0LnByb3RvdHlwZS5yZWNpcHJvY2FsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQucmVjaXByb2NhbCh0aGlzKX0sdC5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYWJzKHRoaXMpfSx0LnByb3RvdHlwZS5jbGlwQnlWYWx1ZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmNsaXBCeVZhbHVlKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUucmVsdT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnJlbHUodGhpcyl9LHQucHJvdG90eXBlLnJlbHU2PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQucmVsdTYodGhpcyl9LHQucHJvdG90eXBlLmVsdT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmVsdSh0aGlzKX0sdC5wcm90b3R5cGUuc2VsdT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNlbHUodGhpcyl9LHQucHJvdG90eXBlLmxlYWt5UmVsdT1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LjIpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubGVha3lSZWx1KHRoaXMsdCl9LHQucHJvdG90eXBlLnByZWx1PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnByZWx1KHRoaXMsdCl9LHQucHJvdG90eXBlLnNpZ21vaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zaWdtb2lkKHRoaXMpfSx0LnByb3RvdHlwZS5sb2dTaWdtb2lkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubG9nU2lnbW9pZCh0aGlzKX0sdC5wcm90b3R5cGUuc29mdHBsdXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zb2Z0cGx1cyh0aGlzKX0sdC5wcm90b3R5cGUuemVyb3NMaWtlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuemVyb3NMaWtlKHRoaXMpfSx0LnByb3RvdHlwZS5vbmVzTGlrZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm9uZXNMaWtlKHRoaXMpfSx0LnByb3RvdHlwZS5zaW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zaW4odGhpcyl9LHQucHJvdG90eXBlLmNvcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmNvcyh0aGlzKX0sdC5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQudGFuKHRoaXMpfSx0LnByb3RvdHlwZS5hc2luPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYXNpbih0aGlzKX0sdC5wcm90b3R5cGUuYWNvcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmFjb3ModGhpcyl9LHQucHJvdG90eXBlLmF0YW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hdGFuKHRoaXMpfSx0LnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc2luaCh0aGlzKX0sdC5wcm90b3R5cGUuY29zaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmNvc2godGhpcyl9LHQucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC50YW5oKHRoaXMpfSx0LnByb3RvdHlwZS5hc2luaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmFzaW5oKHRoaXMpfSx0LnByb3RvdHlwZS5hY29zaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmFjb3NoKHRoaXMpfSx0LnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmF0YW5oKHRoaXMpfSx0LnByb3RvdHlwZS5lcmY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5lcmYodGhpcyl9LHQucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQucm91bmQodGhpcyl9LHQucHJvdG90eXBlLnN0ZXA9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3RlcCh0aGlzLHQpfSx0LnByb3RvdHlwZS5zb2Z0bWF4PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0tMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zb2Z0bWF4KHRoaXMsdCl9LHQucHJvdG90eXBlLmxvZ1NvZnRtYXg9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PS0xKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmxvZ1NvZnRtYXgodGhpcyx0KX0sdC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuaW1hZ2UucmVzaXplQmlsaW5lYXIodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3I9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuaW1hZ2UucmVzaXplTmVhcmVzdE5laWdoYm9yKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuY29udjFkPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9XCJOV0NcIiksdm9pZCAwPT09byYmKG89MSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jb252MWQodGhpcyx0LGUsbixyLG8sYSl9LHQucHJvdG90eXBlLmNvbnYyZD1mdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPVwiTkhXQ1wiKSx2b2lkIDA9PT1vJiYobz1bMSwxXSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jb252MmQodGhpcyx0LGUsbixyLG8sYSl9LHQucHJvdG90eXBlLmNvbnYyZFRyYW5zcG9zZT1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmNvbnYyZFRyYW5zcG9zZSh0aGlzLHQsZSxuLHIsbyl9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPVwiTkhXQ1wiKSx2b2lkIDA9PT1vJiYobz1bMSwxXSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5kZXB0aHdpc2VDb252MmQodGhpcyx0LGUsbixyLG8sYSl9LHQucHJvdG90eXBlLnNlcGFyYWJsZUNvbnYyZD1mdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PW8mJihvPVsxLDFdKSx2b2lkIDA9PT1hJiYoYT1cIk5IV0NcIiksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zZXBhcmFibGVDb252MmQodGhpcyx0LGUsbixyLG8sYSl9LHQucHJvdG90eXBlLmF2Z1Bvb2w9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYXZnUG9vbCh0aGlzLHQsZSxuLHIpfSx0LnByb3RvdHlwZS5tYXhQb29sPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1heFBvb2wodGhpcyx0LGUsbixyKX0sdC5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb249ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHZvaWQgMD09PXQmJih0PTUpLHZvaWQgMD09PWUmJihlPTEpLHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PXImJihyPS41KSx4dC5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbih0aGlzLHQsZSxuLHIpfSx0LnByb3RvdHlwZS5wb29sPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQucG9vbCh0aGlzLHQsZSxuLHIsbyl9LHQucHJvdG90eXBlLnZhcmlhYmxlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseXQoKS5tYWtlVmFyaWFibGUodGhpcyx0LGUsbil9LHQucHJvdG90eXBlLnVuc29ydGVkU2VnbWVudFN1bT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnVuc29ydGVkU2VnbWVudFN1bSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLmJhdGNoVG9TcGFjZU5EPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYmF0Y2hUb1NwYWNlTkQodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5zcGFjZVRvQmF0Y2hORD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNwYWNlVG9CYXRjaE5EKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUudG9waz1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD0xKSx2b2lkIDA9PT1lJiYoZT0hMCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC50b3BrKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuc3RyaWRlZFNsaWNlPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyl7cmV0dXJuIHZvaWQgMD09PXImJihyPTApLHZvaWQgMD09PW8mJihvPTApLHZvaWQgMD09PWEmJihhPTApLHZvaWQgMD09PWkmJihpPTApLHZvaWQgMD09PXMmJihzPTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3RyaWRlZFNsaWNlKHRoaXMsdCxlLG4scixvLGEsaSxzKX0sdC5wcm90b3R5cGUuZGVwdGhUb1NwYWNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZGVwdGhUb1NwYWNlKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuZmZ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3BlY3RyYWwuZmZ0KHRoaXMpfSx0LnByb3RvdHlwZS5pZmZ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3BlY3RyYWwuaWZmdCh0aGlzKX0sdC5wcm90b3R5cGUucmZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNwZWN0cmFsLnJmZnQodGhpcyl9LHQucHJvdG90eXBlLmlyZmZ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3BlY3RyYWwuaXJmZnQodGhpcyl9LHR9KCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHd0LFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuISF0JiZudWxsIT10LmRhdGFJZCYmbnVsbCE9dC5zaGFwZSYmbnVsbCE9dC5kdHlwZX19KTt2YXIgQ3QsRXQsUnQsSXQsa3QsU3Q9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihlLG4scixvKXt2YXIgYT10LmNhbGwodGhpcyxlLnNoYXBlLGUuZHR5cGUsZS5kYXRhSWQsbyl8fHRoaXM7cmV0dXJuIGEudHJhaW5hYmxlPW4sYS5uYW1lPXIsYX1yZXR1cm4gZShuLHQpLG4ucHJvdG90eXBlLmFzc2lnbj1mdW5jdGlvbih0KXtpZih0LmR0eXBlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJkdHlwZSBvZiB0aGUgbmV3IHZhbHVlIChcIit0LmR0eXBlK1wiKSBhbmQgcHJldmlvdXMgdmFsdWUgKFwiK3RoaXMuZHR5cGUrXCIpIG11c3QgbWF0Y2hcIik7aWYoIVModC5zaGFwZSx0aGlzLnNoYXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFwZSBvZiB0aGUgbmV3IHZhbHVlIChcIit0LnNoYXBlK1wiKSBhbmQgcHJldmlvdXMgdmFsdWUgKFwiK3RoaXMuc2hhcGUrXCIpIG11c3QgbWF0Y2hcIik7eXQoKS5kaXNwb3NlVGVuc29yKHRoaXMpLHRoaXMuZGF0YUlkPXQuZGF0YUlkLHl0KCkuaW5jUmVmKHRoaXMsbnVsbCl9LG4ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt5dCgpLmRpc3Bvc2VWYXJpYWJsZSh0aGlzKSx0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbD0hMH0sbn0od3QpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShTdCxTeW1ib2wuaGFzSW5zdGFuY2Use3ZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygd3QmJm51bGwhPXQuYXNzaWduJiZ0LmFzc2lnbiBpbnN0YW5jZW9mIEZ1bmN0aW9ufX0pLGZ1bmN0aW9uKHQpe3QuUjA9XCJSMFwiLHQuUjE9XCJSMVwiLHQuUjI9XCJSMlwiLHQuUjM9XCJSM1wiLHQuUjQ9XCJSNFwiLHQuUjU9XCJSNVwiLHQuUjY9XCJSNlwifShDdHx8KEN0PXt9KSksZnVuY3Rpb24odCl7dC5mbG9hdDMyPVwiZmxvYXQzMlwiLHQuaW50MzI9XCJpbnQzMlwiLHQuYm9vbD1cImludDMyXCIsdC5jb21wbGV4NjQ9XCJjb21wbGV4NjRcIn0oRXR8fChFdD17fSkpLGZ1bmN0aW9uKHQpe3QuZmxvYXQzMj1cImZsb2F0MzJcIix0LmludDMyPVwiaW50MzJcIix0LmJvb2w9XCJib29sXCIsdC5jb21wbGV4NjQ9XCJjb21wbGV4NjRcIn0oUnR8fChSdD17fSkpLGZ1bmN0aW9uKHQpe3QuZmxvYXQzMj1cImZsb2F0MzJcIix0LmludDMyPVwiZmxvYXQzMlwiLHQuYm9vbD1cImZsb2F0MzJcIix0LmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShJdHx8KEl0PXt9KSksZnVuY3Rpb24odCl7dC5mbG9hdDMyPVwiY29tcGxleDY0XCIsdC5pbnQzMj1cImNvbXBsZXg2NFwiLHQuYm9vbD1cImNvbXBsZXg2NFwiLHQuY29tcGxleDY0PVwiY29tcGxleDY0XCJ9KGt0fHwoa3Q9e30pKTt2YXIgQXQ9e2Zsb2F0MzI6SXQsaW50MzI6RXQsYm9vbDpSdCxjb21wbGV4NjQ6a3R9O2Z1bmN0aW9uIER0KHQsZSl7aWYoXCJzdHJpbmdcIj09PXR8fFwic3RyaW5nXCI9PT1lKXtpZihcInN0cmluZ1wiPT09dCYmXCJzdHJpbmdcIj09PWUpcmV0dXJuXCJzdHJpbmdcIjt0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHVwY2FzdCBcIit0K1wiIHdpdGggXCIrZSl9cmV0dXJuIEF0W3RdW2VdfWZ1bmN0aW9uIFR0KHQpe3JldHVybiBEdCh0LFwiaW50MzJcIil9ZnVuY3Rpb24gTnQodCxlKXtpZih0LmR0eXBlPT09ZS5kdHlwZSlyZXR1cm5bdCxlXTt2YXIgbj1EdCh0LmR0eXBlLGUuZHR5cGUpO3JldHVyblt0LmNhc3QobiksZS5jYXN0KG4pXX1mdW5jdGlvbiBGdCh0LGUpe0ModC5kdHlwZT09PWUuZHR5cGUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHR5cGVzIG9mIHRoZSBmaXJzdChcIit0LmR0eXBlK1wiKSBhbmQgc2Vjb25kKFwiK2UuZHR5cGUrXCIpIGlucHV0IG11c3QgbWF0Y2hcIn0pKX1mdW5jdGlvbiBfdCh0KXt2YXIgZT1bXTtyZXR1cm4gZnVuY3Rpb24gdChlLG4scil7aWYobnVsbD09ZSlyZXR1cm47aWYoZSBpbnN0YW5jZW9mIHd0KXJldHVybiB2b2lkIG4ucHVzaChlKTtpZihvPWUsIUFycmF5LmlzQXJyYXkobykmJlwib2JqZWN0XCIhPXR5cGVvZiBvKXJldHVybjt2YXIgbzt2YXIgYT1lO2Zvcih2YXIgaSBpbiBhKXt2YXIgcz1hW2ldO3IuaGFzKHMpfHwoci5hZGQocyksdChzLG4scikpfX0odCxlLG5ldyBTZXQpLGV9dmFyIE90LE10PU9iamVjdC5mcmVlemUoe21ha2VUeXBlc01hdGNoOk50LGFzc2VydFR5cGVzTWF0Y2g6RnQsaXNUZW5zb3JJbkxpc3Q6ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZD09PXQuaWR9KSl9LGdldFRlbnNvcnNJbkNvbnRhaW5lcjpfdH0pLEJ0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMucmVnaXN0ZXJlZFZhcmlhYmxlcz17fSx0aGlzLm5leHRUYXBlTm9kZUlkPTAsdGhpcy5udW1CeXRlcz0wLHRoaXMubnVtVGVuc29ycz0wLHRoaXMubnVtU3RyaW5nVGVuc29ycz0wLHRoaXMubnVtRGF0YUJ1ZmZlcnM9MCx0aGlzLmdyYWRpZW50RGVwdGg9MCx0aGlzLmtlcm5lbERlcHRoPTAsdGhpcy5zY29wZVN0YWNrPVtdLHRoaXMubnVtRGF0YU1vdmVzU3RhY2s9W10sdGhpcy5uZXh0U2NvcGVJZD0wLHRoaXMudGVuc29ySW5mbz1uZXcgV2Vha01hcCx0aGlzLnByb2ZpbGluZz0hMSx0aGlzLmFjdGl2ZVByb2ZpbGU9e25ld0J5dGVzOjAsbmV3VGVuc29yczowLHBlYWtCeXRlczowLGtlcm5lbHM6W10scmVzdWx0Om51bGx9fXJldHVybiB0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlcyl0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdF0uZGlzcG9zZSgpfSx0fSgpLFB0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLkVOVj10LHRoaXMucmVnaXN0cnk9e30sdGhpcy5yZWdpc3RyeUZhY3Rvcnk9e30sdGhpcy5wZW5kaW5nQmFja2VuZEluaXRJZD0wLHRoaXMuc3RhdGU9bmV3IEJ0fXJldHVybiB0LnByb3RvdHlwZS5yZWFkeT1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxlLG47cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDppZihudWxsIT10aGlzLnBlbmRpbmdCYWNrZW5kSW5pdClyZXR1cm5bMix0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdC50aGVuKChmdW5jdGlvbigpe30pKV07aWYobnVsbCE9dGhpcy5iYWNrZW5kSW5zdGFuY2UpcmV0dXJuWzJdO3Q9dGhpcy5nZXRTb3J0ZWRCYWNrZW5kcygpLGU9MCxyLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBlPHQubGVuZ3RoPyhuPXRbZV0sWzQsdGhpcy5pbml0aWFsaXplQmFja2VuZChuKS5zdWNjZXNzXSk6WzMsNV07Y2FzZSAyOnJldHVybiByLnNlbnQoKT9bNCx0aGlzLnNldEJhY2tlbmQobildOlszLDRdO2Nhc2UgMzpyZXR1cm4gci5zZW50KCksWzJdO2Nhc2UgNDpyZXR1cm4gZSsrLFszLDFdO2Nhc2UgNTp0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgaW5pdGlhbGl6ZSBhbnkgYmFja2VuZHMsIGFsbCBiYWNrZW5kIGluaXRpYWxpemF0aW9ucyBmYWlsZWQuXCIpfX0pKX0pKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmFja2VuZFwiLHtnZXQ6ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLnBlbmRpbmdCYWNrZW5kSW5pdCl0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZW5kICdcIit0aGlzLmJhY2tlbmROYW1lK1wiJyBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpemVkLiBNYWtlIHN1cmUgdG8gYXdhaXQgdGYucmVhZHkoKSBvciBhd2FpdCB0Zi5zZXRCYWNrZW5kKCkgYmVmb3JlIGNhbGxpbmcgb3RoZXIgbWV0aG9kc1wiKTtpZihudWxsPT10aGlzLmJhY2tlbmRJbnN0YW5jZSl7dmFyIHQ9dGhpcy5pbml0aWFsaXplQmFja2VuZHNBbmRSZXR1cm5CZXN0KCksZT10Lm5hbWU7aWYodC5hc3luY0luaXQpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGhpZ2hlc3QgcHJpb3JpdHkgYmFja2VuZCAnXCIrZStcIicgaGFzIG5vdCB5ZXQgYmVlbiBpbml0aWFsaXplZC4gTWFrZSBzdXJlIHRvIGF3YWl0IHRmLnJlYWR5KCkgb3IgYXdhaXQgdGYuc2V0QmFja2VuZCgpIGJlZm9yZSBjYWxsaW5nIG90aGVyIG1ldGhvZHNcIik7dGhpcy5zZXRCYWNrZW5kKGUpfXJldHVybiB0aGlzLmJhY2tlbmRJbnN0YW5jZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5iYWNrZW5kTmFtZXM9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5yZWdpc3RyeUZhY3RvcnkpfSx0LnByb3RvdHlwZS5maW5kQmFja2VuZD1mdW5jdGlvbih0KXtpZighKHQgaW4gdGhpcy5yZWdpc3RyeSkpe2lmKCEodCBpbiB0aGlzLnJlZ2lzdHJ5RmFjdG9yeSkpcmV0dXJuIG51bGw7aWYodGhpcy5pbml0aWFsaXplQmFja2VuZCh0KS5hc3luY0luaXQpcmV0dXJuIG51bGx9cmV0dXJuIHRoaXMucmVnaXN0cnlbdF19LHQucHJvdG90eXBlLmZpbmRCYWNrZW5kRmFjdG9yeT1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbiB0aGlzLnJlZ2lzdHJ5RmFjdG9yeT90aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XS5mYWN0b3J5Om51bGx9LHQucHJvdG90eXBlLnJlZ2lzdGVyQmFja2VuZD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTEpLHQgaW4gdGhpcy5yZWdpc3RyeUZhY3Rvcnk/KGNvbnNvbGUud2Fybih0K1wiIGJhY2tlbmQgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZC4gUmV1c2luZyBleGlzdGluZyBiYWNrZW5kIGZhY3RvcnkuXCIpLCExKToodGhpcy5yZWdpc3RyeUZhY3RvcnlbdF09e2ZhY3Rvcnk6ZSxwcmlvcml0eTpufSwhMCl9LHQucHJvdG90eXBlLnNldEJhY2tlbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG4sbztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKG51bGw9PXRoaXMucmVnaXN0cnlGYWN0b3J5W3RdKXRocm93IG5ldyBFcnJvcihcIkJhY2tlbmQgbmFtZSAnXCIrdCtcIicgbm90IGZvdW5kIGluIHJlZ2lzdHJ5XCIpO3JldHVybiB0aGlzLmJhY2tlbmROYW1lPXQsbnVsbCE9dGhpcy5yZWdpc3RyeVt0XT9bMyw0XToodGhpcy5iYWNrZW5kSW5zdGFuY2U9bnVsbCxlPXRoaXMuaW5pdGlhbGl6ZUJhY2tlbmQodCksbj1lLnN1Y2Nlc3MsZS5hc3luY0luaXQ/WzQsbl06WzMsMl0pO2Nhc2UgMTpyZXR1cm4gbz1yLnNlbnQoKSxbMywzXTtjYXNlIDI6bz1uLHIubGFiZWw9MztjYXNlIDM6aWYoIW8pcmV0dXJuWzIsITFdO3IubGFiZWw9NDtjYXNlIDQ6cmV0dXJuIHRoaXMuYmFja2VuZEluc3RhbmNlPXRoaXMucmVnaXN0cnlbdF0sdGhpcy5zZXR1cFJlZ2lzdGVyZWRLZXJuZWxzKCksdGhpcy5wcm9maWxlcj1uZXcgdXQodGhpcy5iYWNrZW5kSW5zdGFuY2UpLFsyLCEwXX19KSl9KSl9LHQucHJvdG90eXBlLnNldHVwUmVnaXN0ZXJlZEtlcm5lbHM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2YodGhpcy5iYWNrZW5kTmFtZSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7bnVsbCE9ZS5zZXR1cEZ1bmMmJmUuc2V0dXBGdW5jKHQuYmFja2VuZEluc3RhbmNlKX0pKX0sdC5wcm90b3R5cGUuZGlzcG9zZVJlZ2lzdGVyZWRLZXJuZWxzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7Zih0KS5mb3JFYWNoKChmdW5jdGlvbihuKXtudWxsIT1uLmRpc3Bvc2VGdW5jJiZuLmRpc3Bvc2VGdW5jKGUucmVnaXN0cnlbdF0pfSkpfSx0LnByb3RvdHlwZS5pbml0aWFsaXplQmFja2VuZD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dGhpcy5yZWdpc3RyeUZhY3RvcnlbdF07aWYobnVsbD09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5pdGlhbGl6ZSBiYWNrZW5kIFwiK3QrXCIsIG5vIHJlZ2lzdHJhdGlvbiBmb3VuZC5cIik7dHJ5e3ZhciByPW4uZmFjdG9yeSgpO2lmKFByb21pc2UucmVzb2x2ZShyKT09PXIpe3ZhciBvPSsrdGhpcy5wZW5kaW5nQmFja2VuZEluaXRJZCxhPXIudGhlbigoZnVuY3Rpb24obil7cmV0dXJuIShvPGUucGVuZGluZ0JhY2tlbmRJbml0SWQpJiYoZS5yZWdpc3RyeVt0XT1uLGUucGVuZGluZ0JhY2tlbmRJbml0PW51bGwsITApfSkpLmNhdGNoKChmdW5jdGlvbihuKXtyZXR1cm4hKG88ZS5wZW5kaW5nQmFja2VuZEluaXRJZCkmJihlLnBlbmRpbmdCYWNrZW5kSW5pdD1udWxsLGNvbnNvbGUud2FybihcIkluaXRpYWxpemF0aW9uIG9mIGJhY2tlbmQgXCIrdCtcIiBmYWlsZWRcIiksY29uc29sZS53YXJuKG4uc3RhY2t8fG4ubWVzc2FnZSksITEpfSkpO3JldHVybiB0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdD1hLHtzdWNjZXNzOmEsYXN5bmNJbml0OiEwfX1yZXR1cm4gdGhpcy5yZWdpc3RyeVt0XT1yLHtzdWNjZXNzOiEwLGFzeW5jSW5pdDohMX19Y2F0Y2goZSl7cmV0dXJuIGNvbnNvbGUud2FybihcIkluaXRpYWxpemF0aW9uIG9mIGJhY2tlbmQgXCIrdCtcIiBmYWlsZWRcIiksY29uc29sZS53YXJuKGUuc3RhY2t8fGUubWVzc2FnZSkse3N1Y2Nlc3M6ITEsYXN5bmNJbml0OiExfX19LHQucHJvdG90eXBlLnJlbW92ZUJhY2tlbmQ9ZnVuY3Rpb24odCl7aWYoISh0IGluIHRoaXMucmVnaXN0cnlGYWN0b3J5KSl0aHJvdyBuZXcgRXJyb3IodCtcIiBiYWNrZW5kIG5vdCBmb3VuZCBpbiByZWdpc3RyeVwiKTt0aGlzLmJhY2tlbmROYW1lPT09dCYmbnVsbCE9dGhpcy5wZW5kaW5nQmFja2VuZEluaXQmJnRoaXMucGVuZGluZ0JhY2tlbmRJbml0SWQrKyx0IGluIHRoaXMucmVnaXN0cnkmJih0aGlzLmRpc3Bvc2VSZWdpc3RlcmVkS2VybmVscyh0KSx0aGlzLnJlZ2lzdHJ5W3RdLmRpc3Bvc2UoKSxkZWxldGUgdGhpcy5yZWdpc3RyeVt0XSksZGVsZXRlIHRoaXMucmVnaXN0cnlGYWN0b3J5W3RdLHRoaXMuYmFja2VuZE5hbWU9PT10JiYodGhpcy5wZW5kaW5nQmFja2VuZEluaXQ9bnVsbCx0aGlzLmJhY2tlbmROYW1lPW51bGwsdGhpcy5iYWNrZW5kSW5zdGFuY2U9bnVsbCl9LHQucHJvdG90eXBlLmdldFNvcnRlZEJhY2tlbmRzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZigwPT09T2JqZWN0LmtleXModGhpcy5yZWdpc3RyeUZhY3RvcnkpLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJObyBiYWNrZW5kIGZvdW5kIGluIHJlZ2lzdHJ5LlwiKTtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5yZWdpc3RyeUZhY3RvcnkpLnNvcnQoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIHQucmVnaXN0cnlGYWN0b3J5W25dLnByaW9yaXR5LXQucmVnaXN0cnlGYWN0b3J5W2VdLnByaW9yaXR5fSkpfSx0LnByb3RvdHlwZS5pbml0aWFsaXplQmFja2VuZHNBbmRSZXR1cm5CZXN0PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ2V0U29ydGVkQmFja2VuZHMoKSxlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciBuPXRbZV0scj10aGlzLmluaXRpYWxpemVCYWNrZW5kKG4pLG89ci5zdWNjZXNzLGE9ci5hc3luY0luaXQ7aWYoYXx8bylyZXR1cm57bmFtZTpuLGFzeW5jSW5pdDphfX10aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgaW5pdGlhbGl6ZSBhbnkgYmFja2VuZHMsIGFsbCBiYWNrZW5kIGluaXRpYWxpemF0aW9ucyBmYWlsZWQuXCIpfSx0LnByb3RvdHlwZS5tb3ZlRGF0YT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQoZSkscj1uLmJhY2tlbmQsbz10aGlzLnJlYWRTeW5jKGUpO3IuZGlzcG9zZURhdGEoZSksbi5iYWNrZW5kPXQsdC5tb3ZlKGUsbyxuLnNoYXBlLG4uZHR5cGUpLHRoaXMuc2hvdWxkQ2hlY2tGb3JNZW1MZWFrcygpJiZ0aGlzLnN0YXRlLm51bURhdGFNb3Zlc1N0YWNrW3RoaXMuc3RhdGUubnVtRGF0YU1vdmVzU3RhY2subGVuZ3RoLTFdKyt9LHQucHJvdG90eXBlLnRpZHk9ZnVuY3Rpb24odCxlKXt2YXIgbixyPXRoaXMsbz1udWxsO2lmKG51bGw9PWUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYSBmdW5jdGlvbiB0byB0aWR5KClcIik7ZT10fWVsc2V7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIHQmJiEodCBpbnN0YW5jZW9mIFN0cmluZykpdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBjYWxsaW5nIHdpdGggdHdvIGFyZ3VtZW50cywgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRpZHkoKSBtdXN0IGJlIGEgc3RyaW5nXCIpO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBjYWxsaW5nIHdpdGggdHdvIGFyZ3VtZW50cywgdGhlIDJuZCBhcmd1bWVudCB0byB0aWR5KCkgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO289dH1yZXR1cm4gdGhpcy5zY29wZWRSdW4oKGZ1bmN0aW9uKCl7cmV0dXJuIHIuc3RhcnRTY29wZShvKX0pLChmdW5jdGlvbigpe3JldHVybiByLmVuZFNjb3BlKG4pfSksKGZ1bmN0aW9uKCl7cmV0dXJuKG49ZSgpKWluc3RhbmNlb2YgUHJvbWlzZSYmY29uc29sZS5lcnJvcihcIkNhbm5vdCByZXR1cm4gYSBQcm9taXNlIGluc2lkZSBvZiB0aWR5LlwiKSxufSkpfSx0LnByb3RvdHlwZS5zY29wZWRSdW49ZnVuY3Rpb24odCxlLG4pe3QoKTt0cnl7dmFyIHI9bigpO3JldHVybiBlKCkscn1jYXRjaCh0KXt0aHJvdyBlKCksdH19LHQucHJvdG90eXBlLm5leHRUZW5zb3JJZD1mdW5jdGlvbigpe3JldHVybiB0Lm5leHRUZW5zb3JJZCsrfSx0LnByb3RvdHlwZS5uZXh0VmFyaWFibGVJZD1mdW5jdGlvbigpe3JldHVybiB0Lm5leHRWYXJpYWJsZUlkKyt9LHQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubWFrZVRlbnNvckZyb21EYXRhSWQodC5kYXRhSWQsdC5zaGFwZSx0LmR0eXBlKSxuPXt4OnR9O3JldHVybiB0aGlzLmFkZFRhcGVOb2RlKHRoaXMuc3RhdGUuYWN0aXZlU2NvcGUubmFtZSxuLFtlXSwoZnVuY3Rpb24odCl7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC50b0Zsb2F0KCl9fX0pLFtdKSxlfSx0LnByb3RvdHlwZS5ydW5LZXJuZWw9ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdGhpcy5ydW5LZXJuZWxGdW5jKG51bGwsZSxudWxsLHQsbixyLG8pfSx0LnByb3RvdHlwZS5zaG91bGRDaGVja0Zvck1lbUxlYWtzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuRU5WLmdldEJvb2woXCJJU19URVNUXCIpfSx0LnByb3RvdHlwZS5jaGVja0tlcm5lbEZvck1lbUxlYWs9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMuYmFja2VuZC5udW1EYXRhSWRzKCksbz0wO24uZm9yRWFjaCgoZnVuY3Rpb24odCl7bys9XCJjb21wbGV4NjRcIj09PXQuZHR5cGU/MzoxfSkpO3ZhciBhPXRoaXMuc3RhdGUubnVtRGF0YU1vdmVzU3RhY2tbdGhpcy5zdGF0ZS5udW1EYXRhTW92ZXNTdGFjay5sZW5ndGgtMV0saT1yLWUtby1hO2lmKGk+MCl0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZW5kICdcIit0aGlzLmJhY2tlbmROYW1lK1wiJyBoYXMgYW4gaW50ZXJuYWwgbWVtb3J5IGxlYWsgKFwiK2krXCIgZGF0YSBpZHMpIGFmdGVyIHJ1bm5pbmcgJ1wiK3QrXCInXCIpfSx0LnByb3RvdHlwZS5ydW5LZXJuZWxGdW5jPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZhciBzLHU9dGhpczt2b2lkIDA9PT1hJiYoYT1bXSksdm9pZCAwPT09aSYmKGk9W10pO3ZhciBjPVtdLGg9dGhpcy5pc1RhcGVPbigpO251bGw9PXImJihyPW51bGwhPXRoaXMuc3RhdGUuYWN0aXZlU2NvcGU/dGhpcy5zdGF0ZS5hY3RpdmVTY29wZS5uYW1lOlwiXCIpO3ZhciBmLGQ9ZnVuY3Rpb24odCl7aCYmKGM9dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB1LmtlZXAodS5jbG9uZSh0KSl9KSkpfSxwPXRoaXMuc3RhdGUubnVtQnl0ZXMsdj10aGlzLnN0YXRlLm51bVRlbnNvcnM7dGhpcy5zaG91bGRDaGVja0Zvck1lbUxlYWtzKCkmJnRoaXMuc3RhdGUubnVtRGF0YU1vdmVzU3RhY2sucHVzaCgwKTt2YXIgbSxnPWwocix0aGlzLmJhY2tlbmROYW1lKTtyZXR1cm4gZj1udWxsIT1nP2Z1bmN0aW9uKCl7dmFyIHQ9dS5iYWNrZW5kLm51bURhdGFJZHMoKTttPWcua2VybmVsRnVuYyh7aW5wdXRzOmUsYXR0cnM6byxiYWNrZW5kOnUuYmFja2VuZH0pO3ZhciBuPUFycmF5LmlzQXJyYXkobSk/bTpbbV07dS5zaG91bGRDaGVja0Zvck1lbUxlYWtzKCkmJnUuY2hlY2tLZXJuZWxGb3JNZW1MZWFrKHIsdCxuKTt2YXIgcz1uLm1hcCgoZnVuY3Rpb24odCl7dmFyIGU9dC5kYXRhSWQsbj10LnNoYXBlLHI9dC5kdHlwZTtyZXR1cm4gdS5tYWtlVGVuc29yRnJvbURhdGFJZChlLG4scil9KSksYz1zLmZpbHRlcigoZnVuY3Rpb24odCxlKXtyZXR1cm4gaVtlXX0pKTtyZXR1cm4gZCgoYXx8W10pLnNsaWNlKCkuY29uY2F0KGMpKSxzfTpmdW5jdGlvbigpe3ZhciBlPXUuYmFja2VuZC5udW1EYXRhSWRzKCk7bT11LnRpZHkoKGZ1bmN0aW9uKCl7cmV0dXJuIHQodS5iYWNrZW5kLGQpfSkpO3ZhciBuPUFycmF5LmlzQXJyYXkobSk/bTpbbV07cmV0dXJuIHUuc2hvdWxkQ2hlY2tGb3JNZW1MZWFrcygpJiZ1LmNoZWNrS2VybmVsRm9yTWVtTGVhayhyLGUsbiksbn0sdGhpcy5zY29wZWRSdW4oKGZ1bmN0aW9uKCl7cmV0dXJuIHUuc3RhdGUua2VybmVsRGVwdGgrK30pLChmdW5jdGlvbigpe3JldHVybiB1LnN0YXRlLmtlcm5lbERlcHRoLS19KSwoZnVuY3Rpb24oKXtzPXUuRU5WLmdldEJvb2woXCJERUJVR1wiKT91LnByb2ZpbGVyLnByb2ZpbGVLZXJuZWwocixlLChmdW5jdGlvbigpe3JldHVybiBmKCl9KSk6ZigpfSkpLGgmJnRoaXMuYWRkVGFwZU5vZGUocixlLHMsbixjKSx0aGlzLnN0YXRlLnByb2ZpbGluZyYmdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLmtlcm5lbHMucHVzaCh7bmFtZTpyLGJ5dGVzQWRkZWQ6dGhpcy5zdGF0ZS5udW1CeXRlcy1wLHRvdGFsQnl0ZXNTbmFwc2hvdDp0aGlzLnN0YXRlLm51bUJ5dGVzLHRlbnNvcnNBZGRlZDp0aGlzLnN0YXRlLm51bVRlbnNvcnMtdix0b3RhbFRlbnNvcnNTbmFwc2hvdDp0aGlzLnN0YXRlLm51bVRlbnNvcnMsaW5wdXRTaGFwZXM6T2JqZWN0LmtleXMoZSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZVt0XS5zaGFwZX0pKSxvdXRwdXRTaGFwZXM6cy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkpfSksQXJyYXkuaXNBcnJheShtKT9zOnNbMF19LHQucHJvdG90eXBlLm1ha2VUZW5zb3I9ZnVuY3Rpb24odCxlLG4scil7aWYobnVsbD09dCl0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZXMgcGFzc2VkIHRvIGVuZ2luZS5tYWtlVGVuc29yKCkgYXJlIG51bGxcIik7bj1ufHxcImZsb2F0MzJcIixyPXJ8fHRoaXMuYmFja2VuZDt2YXIgbz10O1wic3RyaW5nXCI9PT1uJiZIKHRbMF0pJiYobz10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHJ0KHQpfSkpKTt2YXIgYT1yLndyaXRlKG8sZSxuKSxpPW5ldyB3dChlLG4sYSx0aGlzLm5leHRUZW5zb3JJZCgpKTtpZih0aGlzLmluY1JlZihpLHIpLFwic3RyaW5nXCI9PT1uKXt2YXIgcz10aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KGEpLHU9RyhvKTt0aGlzLnN0YXRlLm51bUJ5dGVzKz11LXMuYnl0ZXMscy5ieXRlcz11fXJldHVybiBpfSx0LnByb3RvdHlwZS5tYWtlVGVuc29yRnJvbURhdGFJZD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uZXcgd3QoZSxuPW58fFwiZmxvYXQzMlwiLHQsdGhpcy5uZXh0VGVuc29ySWQoKSk7cmV0dXJuIHRoaXMuaW5jUmVmKG8sciksb30sdC5wcm90b3R5cGUubWFrZVZhcmlhYmxlPWZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PWUmJihlPSEwKSxuPW58fHRoaXMubmV4dFZhcmlhYmxlSWQoKS50b1N0cmluZygpLG51bGwhPXImJnIhPT10LmR0eXBlJiYodD10LmFzVHlwZShyKSk7dmFyIG89bmV3IFN0KHQsZSxuLHRoaXMubmV4dFRlbnNvcklkKCkpO2lmKG51bGwhPXRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1tvLm5hbWVdKXRocm93IG5ldyBFcnJvcihcIlZhcmlhYmxlIHdpdGggbmFtZSBcIitvLm5hbWUrXCIgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZFwiKTtyZXR1cm4gdGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW28ubmFtZV09byx0aGlzLmluY1JlZihvLHRoaXMuYmFja2VuZCksb30sdC5wcm90b3R5cGUuaW5jUmVmPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmhhcyh0LmRhdGFJZCk/dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0LmRhdGFJZCkucmVmQ291bnQ6MDtpZih0aGlzLnN0YXRlLm51bVRlbnNvcnMrKyxcInN0cmluZ1wiPT09dC5kdHlwZSYmdGhpcy5zdGF0ZS5udW1TdHJpbmdUZW5zb3JzKyssMD09PW4pe3RoaXMuc3RhdGUubnVtRGF0YUJ1ZmZlcnMrKzt2YXIgcj0wO1wiY29tcGxleDY0XCIhPT10LmR0eXBlJiZcInN0cmluZ1wiIT09dC5kdHlwZSYmKHI9dC5zaXplKnoodC5kdHlwZSkpLHRoaXMuc3RhdGUudGVuc29ySW5mby5zZXQodC5kYXRhSWQse2JhY2tlbmQ6ZXx8dGhpcy5iYWNrZW5kLGR0eXBlOnQuZHR5cGUsc2hhcGU6dC5zaGFwZSxieXRlczpyLHJlZkNvdW50OjB9KSx0aGlzLnN0YXRlLm51bUJ5dGVzKz1yfXRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodC5kYXRhSWQpLnJlZkNvdW50KyssdCBpbnN0YW5jZW9mIFN0fHx0aGlzLnRyYWNrKHQpfSx0LnByb3RvdHlwZS5kaXNwb3NlVGVuc29yPWZ1bmN0aW9uKHQpe2lmKHRoaXMuc3RhdGUudGVuc29ySW5mby5oYXModC5kYXRhSWQpKXt0aGlzLnN0YXRlLm51bVRlbnNvcnMtLSxcInN0cmluZ1wiPT09dC5kdHlwZSYmdGhpcy5zdGF0ZS5udW1TdHJpbmdUZW5zb3JzLS07dmFyIGU9dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0LmRhdGFJZCk7ZS5yZWZDb3VudDw9MT8oXCJjb21wbGV4NjRcIiE9PXQuZHR5cGUmJih0aGlzLnN0YXRlLm51bUJ5dGVzLT1lLmJ5dGVzKSx0aGlzLnN0YXRlLm51bURhdGFCdWZmZXJzLS0sZS5iYWNrZW5kLmRpc3Bvc2VEYXRhKHQuZGF0YUlkKSx0aGlzLnN0YXRlLnRlbnNvckluZm8uZGVsZXRlKHQuZGF0YUlkKSk6dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0LmRhdGFJZCkucmVmQ291bnQtLX19LHQucHJvdG90eXBlLmRpc3Bvc2VWYXJpYWJsZXM9ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzKXt2YXIgZT10aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdF07dGhpcy5kaXNwb3NlVmFyaWFibGUoZSl9fSx0LnByb3RvdHlwZS5kaXNwb3NlVmFyaWFibGU9ZnVuY3Rpb24odCl7dGhpcy5kaXNwb3NlVGVuc29yKHQpLG51bGwhPXRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1t0Lm5hbWVdJiZkZWxldGUgdGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW3QubmFtZV19LHQucHJvdG90eXBlLm1lbW9yeT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuYmFja2VuZC5tZW1vcnkoKTtyZXR1cm4gdC5udW1UZW5zb3JzPXRoaXMuc3RhdGUubnVtVGVuc29ycyx0Lm51bURhdGFCdWZmZXJzPXRoaXMuc3RhdGUubnVtRGF0YUJ1ZmZlcnMsdC5udW1CeXRlcz10aGlzLnN0YXRlLm51bUJ5dGVzLHRoaXMuc3RhdGUubnVtU3RyaW5nVGVuc29ycz4wJiYodC51bnJlbGlhYmxlPSEwLG51bGw9PXQucmVhc29ucyYmKHQucmVhc29ucz1bXSksdC5yZWFzb25zLnB1c2goXCJNZW1vcnkgdXNhZ2UgYnkgc3RyaW5nIHRlbnNvcnMgaXMgYXBwcm94aW1hdGUgKDIgYnl0ZXMgcGVyIGNoYXJhY3RlcilcIikpLHR9LHQucHJvdG90eXBlLnByb2ZpbGU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG47cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7cmV0dXJuIHRoaXMuc3RhdGUucHJvZmlsaW5nPSEwLGU9dGhpcy5zdGF0ZS5udW1CeXRlcyxuPXRoaXMuc3RhdGUubnVtVGVuc29ycyx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUua2VybmVscz1bXSx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUucmVzdWx0PXQoKSx0aGlzLnN0YXRlLnByb2ZpbGluZz0hMSx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUucGVha0J5dGVzPU1hdGgubWF4LmFwcGx5KE1hdGgsdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLmtlcm5lbHMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC50b3RhbEJ5dGVzU25hcHNob3R9KSkpLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5uZXdCeXRlcz10aGlzLnN0YXRlLm51bUJ5dGVzLWUsdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLm5ld1RlbnNvcnM9dGhpcy5zdGF0ZS5udW1UZW5zb3JzLW4sWzIsdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlXX0pKX0pKX0sdC5wcm90b3R5cGUuaXNUYXBlT249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoPjAmJjA9PT10aGlzLnN0YXRlLmtlcm5lbERlcHRofSx0LnByb3RvdHlwZS5hZGRUYXBlTm9kZT1mdW5jdGlvbih0LGUsbixyLG8pe3ZhciBhPXRoaXMsaT17aWQ6dGhpcy5zdGF0ZS5uZXh0VGFwZU5vZGVJZCsrLGtlcm5lbE5hbWU6dCxpbnB1dHM6ZSxvdXRwdXRzOm4sc2F2ZWQ6b30scz1oKHQpO251bGwhPXMmJihyPXMuZ3JhZEZ1bmMpLG51bGwhPXImJihpLmdyYWRpZW50PWZ1bmN0aW9uKHQpe3JldHVybiB0PXQubWFwKChmdW5jdGlvbih0LGUpe2lmKG51bGw9PXQpe3ZhciByPW5bZV0sbz10dChyLnNpemUsci5kdHlwZSk7cmV0dXJuIGEubWFrZVRlbnNvcihvLHIuc2hhcGUsci5kdHlwZSl9cmV0dXJuIHR9KSkscih0Lmxlbmd0aD4xP3Q6dFswXSxvKX0pLHRoaXMuc3RhdGUuYWN0aXZlVGFwZS5wdXNoKGkpfSx0LnByb3RvdHlwZS5rZWVwPWZ1bmN0aW9uKHQpe3JldHVybiB0LmtlcHQ9ITAsdH0sdC5wcm90b3R5cGUuc3RhcnRUYXBlPWZ1bmN0aW9uKCl7MD09PXRoaXMuc3RhdGUuZ3JhZGllbnREZXB0aCYmKHRoaXMuc3RhdGUuYWN0aXZlVGFwZT1bXSksdGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoKyt9LHQucHJvdG90eXBlLmVuZFRhcGU9ZnVuY3Rpb24oKXt0aGlzLnN0YXRlLmdyYWRpZW50RGVwdGgtLX0sdC5wcm90b3R5cGUuc3RhcnRTY29wZT1mdW5jdGlvbih0KXt2YXIgZT17dHJhY2s6W10sbmFtZTpcInVubmFtZWQgc2NvcGVcIixpZDp0aGlzLnN0YXRlLm5leHRTY29wZUlkKyt9O3QmJihlLm5hbWU9dCksdGhpcy5zdGF0ZS5zY29wZVN0YWNrLnB1c2goZSksdGhpcy5zdGF0ZS5hY3RpdmVTY29wZT1lfSx0LnByb3RvdHlwZS5lbmRTY29wZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcyxuPV90KHQpLHI9bmV3IFNldChuLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuaWR9KSkpLG89MDtvPHRoaXMuc3RhdGUuYWN0aXZlU2NvcGUudHJhY2subGVuZ3RoO28rKyl7dmFyIGE9dGhpcy5zdGF0ZS5hY3RpdmVTY29wZS50cmFja1tvXTthLmtlcHR8fHIuaGFzKGEuaWQpfHxhLmRpc3Bvc2UoKX12YXIgaT10aGlzLnN0YXRlLnNjb3BlU3RhY2sucG9wKCk7dGhpcy5zdGF0ZS5hY3RpdmVTY29wZT0wPT09dGhpcy5zdGF0ZS5zY29wZVN0YWNrLmxlbmd0aD9udWxsOnRoaXMuc3RhdGUuc2NvcGVTdGFja1t0aGlzLnN0YXRlLnNjb3BlU3RhY2subGVuZ3RoLTFdLG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5rZXB0fHx0LnNjb3BlSWQhPT1pLmlkfHxlLnRyYWNrKHQpfSkpfSx0LnByb3RvdHlwZS5ncmFkaWVudHM9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89dGhpcztpZih2b2lkIDA9PT1yJiYocj0hMSksQyhlLmxlbmd0aD4wLChmdW5jdGlvbigpe3JldHVyblwiZ3JhZGllbnRzKCkgcmVjZWl2ZWQgYW4gZW1wdHkgbGlzdCBvZiB4cy5cIn0pKSxudWxsIT1uJiZcImZsb2F0MzJcIiE9PW4uZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiZHkgbXVzdCBoYXZlICdmbG9hdDMyJyBkdHlwZSwgYnV0IGhhcyAnXCIrbi5kdHlwZStcIidcIik7dmFyIGE9dGhpcy5zY29wZWRSdW4oKGZ1bmN0aW9uKCl7cmV0dXJuIG8uc3RhcnRUYXBlKCl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gby5lbmRUYXBlKCl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gby50aWR5KFwiZm9yd2FyZFwiLHQpfSkpO0MoYSBpbnN0YW5jZW9mIHd0LChmdW5jdGlvbigpe3JldHVyblwiVGhlIHJlc3VsdCB5IHJldHVybmVkIGJ5IGYoKSBtdXN0IGJlIGEgdGVuc29yLlwifSkpO3ZhciBpPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9e30sbz17fSxhPTA7YTxlLmxlbmd0aDthKyspcltlW2FdLmlkXT0hMDtmb3IoYT0wO2E8dC5sZW5ndGg7YSsrKXt2YXIgaT0ocD10W2FdKS5pbnB1dHM7Zm9yKHZhciBzIGluIGkpe2Zvcih2YXIgdT1pW3NdLGM9ITEsbD0wO2w8ZS5sZW5ndGg7bCsrKWlmKHJbdS5pZF0pe3Aub3V0cHV0cy5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gclt0LmlkXT0hMH0pKSxjPSEwLG9bcC5pZF09ITA7YnJlYWt9aWYoYylicmVha319dmFyIGg9e307aFtuLmlkXT0hMDt2YXIgZj17fTtmb3IoYT10Lmxlbmd0aC0xO2E+PTA7YS0tKWZvcihpPShwPXRbYV0pLmlucHV0cyxsPTA7bDxwLm91dHB1dHMubGVuZ3RoO2wrKylpZihoW3Aub3V0cHV0c1tsXS5pZF0pe2Zvcih2YXIgcyBpbiBpKWhbaVtzXS5pZF09ITAsZltwLmlkXT0hMDticmVha312YXIgZD1bXTtmb3IoYT0wO2E8dC5sZW5ndGg7YSsrKXt2YXIgcDtpZihvWyhwPXRbYV0pLmlkXSYmZltwLmlkXSl7dmFyIHY9e307Zm9yKHZhciBzIGluIHAuaW5wdXRzKXt2YXIgbT1wLmlucHV0c1tzXTtyW20uaWRdJiYodltzXT1tKX12YXIgZz1PYmplY3QuYXNzaWduKHt9LHApO2cuaW5wdXRzPXYsZy5vdXRwdXRzPXAub3V0cHV0cyxkLnB1c2goZyl9fXJldHVybiBkfSh0aGlzLnN0YXRlLmFjdGl2ZVRhcGUsZSxhKTtpZighciYmMD09PWkubGVuZ3RoJiZlLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIGdyYWRpZW50IG9mIHk9Zih4KSB3aXRoIHJlc3BlY3QgdG8geC4gTWFrZSBzdXJlIHRoYXQgdGhlIGYgeW91IHBhc3NlZCBlbmNsb3NlcyBhbGwgb3BlcmF0aW9ucyB0aGF0IGxlYWQgZnJvbSB4IHRvIHkuXCIpO3JldHVybiB0aGlzLnRpZHkoXCJiYWNrd2FyZFwiLChmdW5jdGlvbigpe3ZhciB0LHIscz17fTtzW2EuaWRdPW51bGw9PW4/KHQ9YS5zaGFwZSxyPVooayh0KSxcImZsb2F0MzJcIiksTHQubWFrZVRlbnNvcihyLHQsXCJmbG9hdDMyXCIpKTpuLGZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9ZnVuY3Rpb24ocil7dmFyIG89ZVtyXSxhPVtdO2lmKG8ub3V0cHV0cy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj10W2UuaWRdO251bGwhPW4/YS5wdXNoKG4pOmEucHVzaChudWxsKX0pKSxudWxsPT1vLmdyYWRpZW50KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIGdyYWRpZW50OiBncmFkaWVudCBmdW5jdGlvbiBub3QgZm91bmQgZm9yIFwiK28ua2VybmVsTmFtZStcIi5cIik7dmFyIGk9by5ncmFkaWVudChhKSxzPWZ1bmN0aW9uKGUpe2lmKCEoZSBpbiBpKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYmFja3Byb3AgdGhyb3VnaCBpbnB1dCBcIitlK1wiLiBBdmFpbGFibGUgZ3JhZGllbnRzIGZvdW5kOiBcIitPYmplY3Qua2V5cyhpKStcIi5cIik7dmFyIHI9bigoZnVuY3Rpb24oKXtyZXR1cm4gaVtlXSgpfSkpO2lmKFwiZmxvYXQzMlwiIT09ci5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBncmFkaWVudCBmb3Igb3AgXCIrby5rZXJuZWxOYW1lK1wiLiBUaGUgZ3JhZGllbnQgb2YgaW5wdXQgXCIrZStcIiBtdXN0IGhhdmUgJ2Zsb2F0MzInIGR0eXBlLCBidXQgaGFzICdcIityLmR0eXBlK1wiJ1wiKTt2YXIgYT1vLmlucHV0c1tlXTtpZighUyhyLnNoYXBlLGEuc2hhcGUpKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIGdyYWRpZW50IGZvciBvcCBcIitvLmtlcm5lbE5hbWUrXCIuIFRoZSBncmFkaWVudCBvZiBpbnB1dCAnXCIrZStcIicgaGFzIHNoYXBlICdcIityLnNoYXBlK1wiJywgd2hpY2ggZG9lcyBub3QgbWF0Y2ggdGhlIHNoYXBlIG9mIHRoZSBpbnB1dCAnXCIrYS5zaGFwZStcIidcIik7aWYobnVsbD09dFthLmlkXSl0W2EuaWRdPXI7ZWxzZXt2YXIgcz10W2EuaWRdO3RbYS5pZF09cy5hZGQocikscy5kaXNwb3NlKCl9fTtmb3IodmFyIHUgaW4gby5pbnB1dHMpcyh1KX0sbz1lLmxlbmd0aC0xO28+PTA7by0tKXIobyl9KHMsaSwoZnVuY3Rpb24odCl7cmV0dXJuIG8udGlkeSh0KX0pKTt2YXIgdT1lLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHNbdC5pZF19KSk7cmV0dXJuIDA9PT1vLnN0YXRlLmdyYWRpZW50RGVwdGgmJihvLnN0YXRlLmFjdGl2ZVRhcGUuZm9yRWFjaCgoZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj10LnNhdmVkO2U8bi5sZW5ndGg7ZSsrKXtuW2VdLmRpc3Bvc2UoKX19KSksby5zdGF0ZS5hY3RpdmVUYXBlPW51bGwpLHt2YWx1ZTphLGdyYWRzOnV9fSkpfSx0LnByb3RvdHlwZS5jdXN0b21HcmFkPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIEMoWCh0KSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgYmUgYSBmdW5jdGlvbi5cIn0pKSxmdW5jdGlvbigpe2Zvcih2YXIgbixyPVtdLG89MDtvPGFyZ3VtZW50cy5sZW5ndGg7bysrKXJbb109YXJndW1lbnRzW29dO0Moci5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiB3dH0pKSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBhcmdzIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpKHgxLCB4MiwuLi4pIG11c3QgYWxsIGJlIHRlbnNvcnNcIn0pKTt2YXIgYT17fTtyZXR1cm4gci5mb3JFYWNoKChmdW5jdGlvbih0LGUpe2FbZV09dH0pKSxlLnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKGUsbyl7cmV0dXJuIEMoKG49dC5hcHBseSh2b2lkIDAsci5jb25jYXQoW29dKSkpLnZhbHVlIGluc3RhbmNlb2Ygd3QsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2hlcmUgYG9iai52YWx1ZWAgaXMgYSB0ZW5zb3JcIn0pKSxDKFgobi5ncmFkRnVuYyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2hlcmUgYG9iai5ncmFkRnVuY2AgaXMgYSBmdW5jdGlvbi5cIn0pKSxuLnZhbHVlfSksYSwoZnVuY3Rpb24odCxlKXt2YXIgbz1uLmdyYWRGdW5jKHQsZSksYT1BcnJheS5pc0FycmF5KG8pP286W29dO0MoYS5sZW5ndGg9PT1yLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgc2FtZSBudW1iZXIgb2YgdGVuc29ycyBhcyBpbnB1dHMgcGFzc2VkIHRvIGYoLi4uKS5cIn0pKSxDKGEuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygd3R9KSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2hlcmUgYG9iai5ncmFkRnVuY2AgaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBsaXN0IG9mIG9ubHkgdGVuc29ycy5cIn0pKTt2YXIgaT17fTtyZXR1cm4gYS5mb3JFYWNoKChmdW5jdGlvbih0LGUpe2lbZV09ZnVuY3Rpb24oKXtyZXR1cm4gdH19KSksaX0pKX19LHQucHJvdG90eXBlLnJlYWRTeW5jPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQpLmJhY2tlbmQucmVhZFN5bmModCl9LHQucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodCkuYmFja2VuZC5yZWFkKHQpfSx0LnByb3RvdHlwZS50aW1lPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIGU9ZXQoKSxbNCx0aGlzLmJhY2tlbmQudGltZSh0KV07Y2FzZSAxOnJldHVybihuPXIuc2VudCgpKS53YWxsTXM9ZXQoKS1lLFsyLG5dfX0pKX0pKX0sdC5wcm90b3R5cGUudHJhY2s9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXRoaXMuc3RhdGUuYWN0aXZlU2NvcGUmJih0LnNjb3BlSWQ9dGhpcy5zdGF0ZS5hY3RpdmVTY29wZS5pZCx0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLnRyYWNrLnB1c2godCkpLHR9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlZ2lzdGVyZWRWYXJpYWJsZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdElkKyssdGhpcy5zdGF0ZS5kaXNwb3NlKCksdGhpcy5FTlYucmVzZXQoKSx0aGlzLnN0YXRlPW5ldyBCdCx0aGlzLnJlZ2lzdHJ5KXRoaXMuZGlzcG9zZVJlZ2lzdGVyZWRLZXJuZWxzKHQpLHRoaXMucmVnaXN0cnlbdF0uZGlzcG9zZSgpLGRlbGV0ZSB0aGlzLnJlZ2lzdHJ5W3RdO3RoaXMuYmFja2VuZE5hbWU9bnVsbCx0aGlzLmJhY2tlbmRJbnN0YW5jZT1udWxsLHRoaXMucGVuZGluZ0JhY2tlbmRJbml0PW51bGx9LHQubmV4dFRlbnNvcklkPTAsdC5uZXh0VmFyaWFibGVJZD0wLHR9KCk7dmFyIEx0PWZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24oKXtpZihudWxsPT1PdCl7dmFyIHQ9dm9pZCAwO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cpdD13aW5kb3c7ZWxzZSBpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsKXQ9Z2xvYmFsO2Vsc2UgaWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3MpdD1wcm9jZXNzO2Vsc2V7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHNlbGYpdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYSBnbG9iYWwgb2JqZWN0XCIpO3Q9c2VsZn1PdD10fXJldHVybiBPdH0oKTtpZihudWxsPT10Ll90ZmVuZ2luZSl7dmFyIGU9bmV3IG8odCk7dC5fdGZlbmdpbmU9bmV3IFB0KGUpfXJldHVybiBmdW5jdGlvbih0KXtzPXR9KHQuX3RmZW5naW5lLkVOVikseXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdC5fdGZlbmdpbmV9LHQuX3RmZW5naW5lfSgpO2Z1bmN0aW9uIFd0KCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmbnVsbCE9d2luZG93LmRvY3VtZW50fHxcInVuZGVmaW5lZFwiIT10eXBlb2YgV29ya2VyR2xvYmFsU2NvcGV9dmFyIFV0PWkoKTtVdC5yZWdpc3RlckZsYWcoXCJERUJVR1wiLChmdW5jdGlvbigpe3JldHVybiExfSksKGZ1bmN0aW9uKHQpe3QmJmNvbnNvbGUud2FybihcIkRlYnVnZ2luZyBtb2RlIGlzIE9OLiBUaGUgb3V0cHV0IG9mIGV2ZXJ5IG1hdGggY2FsbCB3aWxsIGJlIGRvd25sb2FkZWQgdG8gQ1BVIGFuZCBjaGVja2VkIGZvciBOYU5zLiBUaGlzIHNpZ25pZmljYW50bHkgaW1wYWN0cyBwZXJmb3JtYW5jZS5cIil9KSksVXQucmVnaXN0ZXJGbGFnKFwiSVNfQlJPV1NFUlwiLChmdW5jdGlvbigpe3JldHVybiBXdCgpfSkpLFV0LnJlZ2lzdGVyRmxhZyhcIklTX05PREVcIiwoZnVuY3Rpb24oKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2VzcyYmdm9pZCAwIT09cHJvY2Vzcy52ZXJzaW9ucyYmdm9pZCAwIT09cHJvY2Vzcy52ZXJzaW9ucy5ub2RlfSkpLFV0LnJlZ2lzdGVyRmxhZyhcIklTX0NIUk9NRVwiLChmdW5jdGlvbigpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJm51bGwhPW5hdmlnYXRvciYmbnVsbCE9bmF2aWdhdG9yLnVzZXJBZ2VudCYmL0Nocm9tZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmL0dvb2dsZSBJbmMvLnRlc3QobmF2aWdhdG9yLnZlbmRvcil9KSksVXQucmVnaXN0ZXJGbGFnKFwiUFJPRFwiLChmdW5jdGlvbigpe3JldHVybiExfSkpLFV0LnJlZ2lzdGVyRmxhZyhcIlRFTlNPUkxJS0VfQ0hFQ0tfU0hBUEVfQ09OU0lTVEVOQ1lcIiwoZnVuY3Rpb24oKXtyZXR1cm4gVXQuZ2V0Qm9vbChcIkRFQlVHXCIpfSkpLFV0LnJlZ2lzdGVyRmxhZyhcIkRFUFJFQ0FUSU9OX1dBUk5JTkdTX0VOQUJMRURcIiwoZnVuY3Rpb24oKXtyZXR1cm4hMH0pKSxVdC5yZWdpc3RlckZsYWcoXCJJU19URVNUXCIsKGZ1bmN0aW9uKCl7cmV0dXJuITF9KSk7dmFyIFZ0LHp0LEd0LEh0PXt9LHF0PXthbHBoYTohMSxhbnRpYWxpYXM6ITEscHJlbXVsdGlwbGllZEFscGhhOiExLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMSxkZXB0aDohMSxzdGVuY2lsOiExLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ITB9O2Z1bmN0aW9uIEt0KHQsZSl7SHRbdF09ZX1mdW5jdGlvbiBqdCh0KXt0IGluIEh0fHwoSHRbdF09ZnVuY3Rpb24odCl7aWYoMSE9PXQmJjIhPT10KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQsIFdlYkdMIGlzIGRpc2FibGVkLlwiKTt2YXIgZT1mdW5jdGlvbih0KXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgT2Zmc2NyZWVuQ2FudmFzJiYyPT09dClyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygzMDAsMTUwKTtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQpcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNyZWF0ZSBhIGNhbnZhcyBpbiB0aGlzIGNvbnRleHRcIil9KHQpO2lmKGUuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIiwoZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLGRlbGV0ZSBIdFt0XX0pLCExKSwxPT09dClyZXR1cm4gZS5nZXRDb250ZXh0KFwid2ViZ2xcIixxdCl8fGUuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLHF0KTtyZXR1cm4gZS5nZXRDb250ZXh0KFwid2ViZ2wyXCIscXQpfSh0KSk7dmFyIGU9SHRbdF07cmV0dXJuIGUuaXNDb250ZXh0TG9zdCgpPyhkZWxldGUgSHRbdF0sanQodCkpOihlLmRpc2FibGUoZS5ERVBUSF9URVNUKSxlLmRpc2FibGUoZS5TVEVOQ0lMX1RFU1QpLGUuZGlzYWJsZShlLkJMRU5EKSxlLmRpc2FibGUoZS5ESVRIRVIpLGUuZGlzYWJsZShlLlBPTFlHT05fT0ZGU0VUX0ZJTEwpLGUuZGlzYWJsZShlLlNBTVBMRV9DT1ZFUkFHRSksZS5lbmFibGUoZS5TQ0lTU09SX1RFU1QpLGUuZW5hYmxlKGUuQ1VMTF9GQUNFKSxlLmN1bGxGYWNlKGUuQkFDSyksSHRbdF0pfWZ1bmN0aW9uIFh0KHQsZSl7cmV0dXJuW2UsdF19ZnVuY3Rpb24gWXQodCl7dmFyIGU9ayh0KTtyZXR1cm4gVChNYXRoLmNlaWwoZS80KSl9ZnVuY3Rpb24gJHQodCxlKXtyZXR1cm5bTWF0aC5tYXgoMSxNYXRoLmNlaWwoZS8yKSksTWF0aC5tYXgoMSxNYXRoLmNlaWwodC8yKSldfWZ1bmN0aW9uIFF0KHQsZSl7dmFyIG4scixvLGEscyx1LGMsbCxoLGY9dDtyZXR1cm4gMj09PWkoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPyhuPWYuUjMyRixyPWYuUjE2RixvPWYuUkdCQTE2RixhPWYuUkdCQTMyRixzPWYuUkVELHU9NCxjPTEsbD1mLkhBTEZfRkxPQVQsaD1mLkZMT0FUKToobj10LlJHQkEscj10LlJHQkEsbz10LlJHQkEsYT1mLlJHQkEscz10LlJHQkEsdT00LGM9NCxsPW51bGwhPWU/ZS5IQUxGX0ZMT0FUX09FUzpudWxsLGg9dC5GTE9BVCkse2ludGVybmFsRm9ybWF0RmxvYXQ6bixpbnRlcm5hbEZvcm1hdEhhbGZGbG9hdDpyLGludGVybmFsRm9ybWF0UGFja2VkSGFsZkZsb2F0Om8saW50ZXJuYWxGb3JtYXRQYWNrZWRGbG9hdDphLHRleHR1cmVGb3JtYXRGbG9hdDpzLGRvd25sb2FkVGV4dHVyZUZvcm1hdDp0LlJHQkEsZG93bmxvYWRVbnBhY2tOdW1DaGFubmVsczp1LGRlZmF1bHROdW1DaGFubmVsczpjLHRleHR1cmVUeXBlSGFsZkZsb2F0OmwsdGV4dHVyZVR5cGVGbG9hdDpofX1mdW5jdGlvbiBKdCh0LGUsbil7dmFyIHI9bigpO3JldHVybiBlJiZmdW5jdGlvbih0KXt2YXIgZT10LmdldEVycm9yKCk7aWYoZSE9PXQuTk9fRVJST1IpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgRXJyb3I6IFwiK25lKHQsZSkpfSh0KSxyfSFmdW5jdGlvbih0KXt0W3QuREVOU0U9MF09XCJERU5TRVwiLHRbdC5TSEFSRURfQkFUQ0g9MV09XCJTSEFSRURfQkFUQ0hcIn0oVnR8fChWdD17fSkpLGZ1bmN0aW9uKHQpe3RbdC5SRU5ERVI9MF09XCJSRU5ERVJcIix0W3QuVVBMT0FEPTFdPVwiVVBMT0FEXCIsdFt0LlBJWEVMUz0yXT1cIlBJWEVMU1wiLHRbdC5ET1dOTE9BRD0zXT1cIkRPV05MT0FEXCJ9KHp0fHwoenQ9e30pKSxmdW5jdGlvbih0KXt0W3QuVU5QQUNLRURfRkxPQVQxNj0wXT1cIlVOUEFDS0VEX0ZMT0FUMTZcIix0W3QuVU5QQUNLRURfRkxPQVQzMj0xXT1cIlVOUEFDS0VEX0ZMT0FUMzJcIix0W3QuUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFPTJdPVwiUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFXCIsdFt0LlBBQ0tFRF8yWDJfRkxPQVQzMj0zXT1cIlBBQ0tFRF8yWDJfRkxPQVQzMlwiLHRbdC5QQUNLRURfMlgyX0ZMT0FUMTY9NF09XCJQQUNLRURfMlgyX0ZMT0FUMTZcIn0oR3R8fChHdD17fSkpO3ZhciBadD01Ljk2ZS04LHRlPTY1NTA0O2Z1bmN0aW9uIGVlKHQpe3JldHVybiEhKGkoKS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiKXx8MD09PXR8fFp0PE1hdGguYWJzKHQpJiZNYXRoLmFicyh0KTx0ZSl9ZnVuY3Rpb24gbmUodCxlKXtzd2l0Y2goZSl7Y2FzZSB0Lk5PX0VSUk9SOnJldHVyblwiTk9fRVJST1JcIjtjYXNlIHQuSU5WQUxJRF9FTlVNOnJldHVyblwiSU5WQUxJRF9FTlVNXCI7Y2FzZSB0LklOVkFMSURfVkFMVUU6cmV0dXJuXCJJTlZBTElEX1ZBTFVFXCI7Y2FzZSB0LklOVkFMSURfT1BFUkFUSU9OOnJldHVyblwiSU5WQUxJRF9PUEVSQVRJT05cIjtjYXNlIHQuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046cmV0dXJuXCJJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTlwiO2Nhc2UgdC5PVVRfT0ZfTUVNT1JZOnJldHVyblwiT1VUX09GX01FTU9SWVwiO2Nhc2UgdC5DT05URVhUX0xPU1RfV0VCR0w6cmV0dXJuXCJDT05URVhUX0xPU1RfV0VCR0xcIjtkZWZhdWx0OnJldHVyblwiVW5rbm93biBlcnJvciBjb2RlIFwiK2V9fWZ1bmN0aW9uIHJlKHQsZSxuKXtyZXR1cm4ga2UodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmdldEV4dGVuc2lvbihuKX0pLCdFeHRlbnNpb24gXCInK24rJ1wiIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLicpfWZ1bmN0aW9uIG9lKHQsZSxuKXt2YXIgcj1rZSh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlU2hhZGVyKHQuVkVSVEVYX1NIQURFUil9KSxcIlVuYWJsZSB0byBjcmVhdGUgdmVydGV4IFdlYkdMU2hhZGVyLlwiKTtpZihKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2hhZGVyU291cmNlKHIsbil9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmNvbXBpbGVTaGFkZXIocil9KSksITE9PT10LmdldFNoYWRlclBhcmFtZXRlcihyLHQuQ09NUElMRV9TVEFUVVMpKXRocm93IGNvbnNvbGUubG9nKHQuZ2V0U2hhZGVySW5mb0xvZyhyKSksbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbXBpbGUgdmVydGV4IHNoYWRlci5cIik7cmV0dXJuIHJ9ZnVuY3Rpb24gYWUodCxlLG4pe3ZhciByPWtlKHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVTaGFkZXIodC5GUkFHTUVOVF9TSEFERVIpfSksXCJVbmFibGUgdG8gY3JlYXRlIGZyYWdtZW50IFdlYkdMU2hhZGVyLlwiKTtpZihKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2hhZGVyU291cmNlKHIsbil9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmNvbXBpbGVTaGFkZXIocil9KSksITE9PT10LmdldFNoYWRlclBhcmFtZXRlcihyLHQuQ09NUElMRV9TVEFUVVMpKXRocm93IGZ1bmN0aW9uKHQsZSl7dmFyIG49dWUuZXhlYyhlKTtpZihudWxsPT1uKXJldHVybiBjb25zb2xlLmxvZyhcIkNvdWxkbid0IHBhcnNlIGxpbmUgbnVtYmVyIGluIGVycm9yOiBcIitlKSx2b2lkIGNvbnNvbGUubG9nKHQpO2Zvcih2YXIgcj0rblsxXSxvPXQuc3BsaXQoXCJcXG5cIiksYT1vLmxlbmd0aC50b1N0cmluZygpLmxlbmd0aCsyLGk9by5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIE4oKGUrMSkudG9TdHJpbmcoKSxhKSt0fSkpLHM9MCx1PTA7dTxpLmxlbmd0aDt1Kyspcz1NYXRoLm1heChpW3VdLmxlbmd0aCxzKTt2YXIgYz1pLnNsaWNlKDAsci0xKSxsPWkuc2xpY2Uoci0xLHIpLGg9aS5zbGljZShyKTtjb25zb2xlLmxvZyhjLmpvaW4oXCJcXG5cIikpLGNvbnNvbGUubG9nKGUuc3BsaXQoXCJcXG5cIilbMF0pLGNvbnNvbGUubG9nKFwiJWMgXCIrTihsWzBdLHMpLFwiYm9yZGVyOjFweCBzb2xpZCByZWQ7IGJhY2tncm91bmQtY29sb3I6I2UzZDJkMjsgY29sb3I6I2E2MTcxN1wiKSxjb25zb2xlLmxvZyhoLmpvaW4oXCJcXG5cIikpfShuLHQuZ2V0U2hhZGVySW5mb0xvZyhyKSksbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbXBpbGUgZnJhZ21lbnQgc2hhZGVyLlwiKTtyZXR1cm4gcn12YXIgaWUsc2UsdWU9L0VSUk9SOiBbMC05XSs6KFswLTldKyk6L2c7ZnVuY3Rpb24gY2UodCxlKXtyZXR1cm4ga2UodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZVByb2dyYW0oKX0pLFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFByb2dyYW0uXCIpfWZ1bmN0aW9uIGxlKHQsZSxuKXtpZihKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQubGlua1Byb2dyYW0obil9KSksITE9PT10LmdldFByb2dyYW1QYXJhbWV0ZXIobix0LkxJTktfU1RBVFVTKSl0aHJvdyBjb25zb2xlLmxvZyh0LmdldFByb2dyYW1JbmZvTG9nKG4pKSxuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbGluayB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMuXCIpfWZ1bmN0aW9uIGhlKHQsZSxuKXtpZihKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQudmFsaWRhdGVQcm9ncmFtKG4pfSkpLCExPT09dC5nZXRQcm9ncmFtUGFyYW1ldGVyKG4sdC5WQUxJREFURV9TVEFUVVMpKXRocm93IGNvbnNvbGUubG9nKHQuZ2V0UHJvZ3JhbUluZm9Mb2cobikpLG5ldyBFcnJvcihcIlNoYWRlciBwcm9ncmFtIHZhbGlkYXRpb24gZmFpbGVkLlwiKX1mdW5jdGlvbiBmZSh0LGUsbil7dmFyIHI9a2UodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZUJ1ZmZlcigpfSksXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMQnVmZmVyXCIpO3JldHVybiBKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEJ1ZmZlcih0LkFSUkFZX0JVRkZFUixyKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYnVmZmVyRGF0YSh0LkFSUkFZX0JVRkZFUixuLHQuU1RBVElDX0RSQVcpfSkpLHJ9ZnVuY3Rpb24gZGUodCxlLG4pe3ZhciByPWtlKHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVCdWZmZXIoKX0pLFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlclwiKTtyZXR1cm4gSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5FTEVNRU5UX0FSUkFZX0JVRkZFUixyKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYnVmZmVyRGF0YSh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLG4sdC5TVEFUSUNfRFJBVyl9KSkscn1mdW5jdGlvbiBwZSh0LGUpe3JldHVybiBrZSh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlVGV4dHVyZSgpfSksXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMVGV4dHVyZS5cIil9ZnVuY3Rpb24gdmUodCxlKXt2YXIgbj1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfTUFYX1RFWFRVUkVfU0laRVwiKTtpZih0PD0wfHxlPD0wKXt2YXIgcj1cIltcIit0K1wieFwiK2UrXCJdXCI7dGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSBcIityK1wiIGlzIGludmFsaWQuXCIpfWlmKHQ+bnx8ZT5uKXtyPVwiW1wiK3QrXCJ4XCIrZStcIl1cIjt0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplIFwiK3IrXCIgZ3JlYXRlciB0aGFuIFdlYkdMIG1heGltdW0gb24gdGhpcyBicm93c2VyIC8gR1BVIFwiKyhcIltcIituK1wieFwiK24rXCJdXCIpK1wiLlwiKX19ZnVuY3Rpb24gbWUodCxlKXtyZXR1cm4ga2UodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZUZyYW1lYnVmZmVyKCl9KSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xGcmFtZWJ1ZmZlci5cIil9ZnVuY3Rpb24gZ2UodCxlLG4scixvLGEsaSxzKXt2YXIgdT10LmdldEF0dHJpYkxvY2F0aW9uKG4scik7cmV0dXJuLTEhPT11JiYoSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIsbyl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnZlcnRleEF0dHJpYlBvaW50ZXIodSxhLHQuRkxPQVQsITEsaSxzKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodSl9KSksITApfWZ1bmN0aW9uIHllKHQsZSxuLHIpe1NlKHQsciksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmFjdGl2ZVRleHR1cmUodC5URVhUVVJFMCtyKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG4pfSkpfWZ1bmN0aW9uIHhlKHQsZSxuLHIpe3JldHVybiBrZSh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuZ2V0VW5pZm9ybUxvY2F0aW9uKG4scil9KSwndW5pZm9ybSBcIicrcisnXCIgbm90IHByZXNlbnQgaW4gcHJvZ3JhbS4nKX1mdW5jdGlvbiBiZSh0LGUsbil7cmV0dXJuIHQuZ2V0VW5pZm9ybUxvY2F0aW9uKGUsbil9ZnVuY3Rpb24gd2UodCxlLG4scixvLGEpe0p0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4geWUodCxlLHIsYSl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnVuaWZvcm0xaShvLGEpfSkpfWZ1bmN0aW9uIENlKHQsZSxuLHIpe0p0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixyKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuZnJhbWVidWZmZXJUZXh0dXJlMkQodC5GUkFNRUJVRkZFUix0LkNPTE9SX0FUVEFDSE1FTlQwLHQuVEVYVFVSRV8yRCxuLDApfSkpfWZ1bmN0aW9uIEVlKHQsZSxuKXtKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsbil9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmZyYW1lYnVmZmVyVGV4dHVyZTJEKHQuRlJBTUVCVUZGRVIsdC5DT0xPUl9BVFRBQ0hNRU5UMCx0LlRFWFRVUkVfMkQsbnVsbCwwKX0pKX1mdW5jdGlvbiBSZSh0KXt2YXIgZT10LmNoZWNrRnJhbWVidWZmZXJTdGF0dXModC5GUkFNRUJVRkZFUik7aWYoZSE9PXQuRlJBTUVCVUZGRVJfQ09NUExFVEUpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgYmluZGluZyBmcmFtZWJ1ZmZlcjogXCIrSWUodCxlKSl9ZnVuY3Rpb24gSWUodCxlKXtzd2l0Y2goZSl7Y2FzZSB0LkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpyZXR1cm5cIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVFwiO2Nhc2UgdC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVDpyZXR1cm5cIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXCI7Y2FzZSB0LkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzpyZXR1cm5cIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU1wiO2Nhc2UgdC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpyZXR1cm5cIkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEXCI7ZGVmYXVsdDpyZXR1cm5cInVua25vd24gZXJyb3IgXCIrZX19ZnVuY3Rpb24ga2UodCxlLG4scil7dmFyIG89SnQodCxlLChmdW5jdGlvbigpe3JldHVybiBuKCl9KSk7aWYobnVsbD09byl0aHJvdyBuZXcgRXJyb3Iocik7cmV0dXJuIG99ZnVuY3Rpb24gU2UodCxlKXt2YXIgbj10Lk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTLTEscj1lK3QuVEVYVFVSRTA7aWYocjx0LlRFWFRVUkUwfHxyPm4pdGhyb3cgbmV3IEVycm9yKFwidGV4dHVyZVVuaXQgbXVzdCBiZSBpbiBcIisoXCJbZ2wuVEVYVFVSRTAsIGdsLlRFWFRVUkVcIituK1wiXVwiKStcIi5cIil9ZnVuY3Rpb24gQWUodCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9Miksayh0LnNsaWNlKDAsdC5sZW5ndGgtZSkpfWZ1bmN0aW9uIERlKHQpe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBFcnJvcihcIkNhbm5vdCBnZXQgcm93cyBhbmQgY29sdW1ucyBvZiBhbiBlbXB0eSBzaGFwZSBhcnJheS5cIik7cmV0dXJuW3QubGVuZ3RoPjE/dFt0Lmxlbmd0aC0yXToxLHRbdC5sZW5ndGgtMV1dfWZ1bmN0aW9uIFRlKHQpe3ZhciBlPVsxLDEsMV07cmV0dXJuIDA9PT10Lmxlbmd0aHx8MT09PXQubGVuZ3RoJiYxPT09dFswXXx8KGU9W0FlKHQpXS5jb25jYXQoRGUodCkpKSxlfWZ1bmN0aW9uIE5lKHQsZSl7dmFyIG47dm9pZCAwPT09ZSYmKGU9ITEpO3ZhciByPWkoKS5nZXROdW1iZXIoXCJXRUJHTF9NQVhfVEVYVFVSRV9TSVpFXCIpO2lmKGUmJihyKj0yLDE9PT0odD10Lm1hcCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gbj49dC5sZW5ndGgtMj9iKHRbbl0pOnRbbl19KSkpLmxlbmd0aCYmKHQ9WzIsdFswXV0pKSwyIT09dC5sZW5ndGgpe3ZhciBvPU0odCk7dD1vLm5ld1NoYXBlfXZhciBhPWsodCk7aWYodC5sZW5ndGg8PTEmJmE8PXIpcmV0dXJuWzEsYV07aWYoMj09PXQubGVuZ3RoJiZ0WzBdPD1yJiZ0WzFdPD1yKXJldHVybiB0O2lmKDM9PT10Lmxlbmd0aCYmdFswXSp0WzFdPD1yJiZ0WzJdPD1yKXJldHVyblt0WzBdKnRbMV0sdFsyXV07aWYoMz09PXQubGVuZ3RoJiZ0WzBdPD1yJiZ0WzFdKnRbMl08PXIpcmV0dXJuW3RbMF0sdFsxXSp0WzJdXTtpZig0PT09dC5sZW5ndGgmJnRbMF0qdFsxXSp0WzJdPD1yJiZ0WzNdPD1yKXJldHVyblt0WzBdKnRbMV0qdFsyXSx0WzNdXTtpZig0PT09dC5sZW5ndGgmJnRbMF08PXImJnRbMV0qdFsyXSp0WzNdPD1yKXJldHVyblt0WzBdLHRbMV0qdFsyXSp0WzNdXTtpZihlKXt2YXIgcz1BZSh0KSx1PTIsYz0yO3JldHVybiB0Lmxlbmd0aCYmKHU9KG49RGUodCkpWzBdLGM9blsxXSksVChhPXMqKHUvMikqKGMvMikpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIDIqdH0pKX1yZXR1cm4gVChhKX1mdW5jdGlvbiBGZSh0KXtyZXR1cm4gdCUyPT0wfWZ1bmN0aW9uIF9lKHQsZSl7aWYoUyh0PXQuc2xpY2UoLTIpLGU9ZS5zbGljZSgtMikpKXJldHVybiEwO2lmKCF0Lmxlbmd0aHx8IWUubGVuZ3RoKXJldHVybiEwO2lmKDA9PT10WzBdfHwwPT09dFsxXXx8MD09PWVbMF18fDA9PT1lWzFdKXJldHVybiEwO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpe3ZhciBuPXQuc2xpY2UoLTEpWzBdLHI9ZS5zbGljZSgtMSlbMF07aWYobj09PXIpcmV0dXJuITA7aWYoRmUobikmJkZlKHIpJiYoMT09PXRbMF18fDE9PT1lWzBdKSlyZXR1cm4hMH1yZXR1cm4gdFsxXT09PWVbMV0mJkZlKHRbMF0pJiZGZShlWzBdKX1mdW5jdGlvbiBPZSh0KXtpZihudWxsPT1pZSl7dmFyIGU9anQodCk7aWU9ZS5nZXRQYXJhbWV0ZXIoZS5NQVhfVEVYVFVSRV9TSVpFKX1yZXR1cm4gaWV9ZnVuY3Rpb24gTWUodCl7aWYobnVsbD09c2Upe3ZhciBlPWp0KHQpO3NlPWUuZ2V0UGFyYW1ldGVyKGUuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpfXJldHVybiBNYXRoLm1pbigxNixzZSl9ZnVuY3Rpb24gQmUodCl7aWYoMD09PXQpcmV0dXJuIDA7dmFyIGU9anQodCk7cmV0dXJuIFBlKGUsXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyXCIpJiYyPT09dD8yOlBlKGUsXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlcIik/MTowfWZ1bmN0aW9uIFBlKHQsZSl7cmV0dXJuIG51bGwhPXQuZ2V0RXh0ZW5zaW9uKGUpfWZ1bmN0aW9uIExlKHQpe3RyeXtpZihudWxsIT1qdCh0KSlyZXR1cm4hMH1jYXRjaCh0KXtyZXR1cm4hMX1yZXR1cm4hMX1mdW5jdGlvbiBXZSh0KXtpZigwPT09dClyZXR1cm4hMTt2YXIgZT1qdCh0KTtpZigxPT09dCl7aWYoIVBlKGUsXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSlyZXR1cm4hMX1lbHNlIGlmKCFQZShlLFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSlyZXR1cm4hMTtyZXR1cm4gVmUoZSl9ZnVuY3Rpb24gVWUodCl7aWYoMD09PXQpcmV0dXJuITE7dmFyIGU9anQodCk7aWYoMSE9PXQpe2lmKFBlKGUsXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpKXJldHVybiBWZShlKTtpZihQZShlLFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpKXt2YXIgbj1lLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKTtyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgbj1RdCh0LGUpLHI9dC5jcmVhdGVUZXh0dXJlKCk7dC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQscik7dC50ZXhJbWFnZTJEKHQuVEVYVFVSRV8yRCwwLG4uaW50ZXJuYWxGb3JtYXRIYWxmRmxvYXQsMSwxLDAsbi50ZXh0dXJlRm9ybWF0RmxvYXQsbi50ZXh0dXJlVHlwZUhhbGZGbG9hdCxudWxsKTt2YXIgbz10LmNyZWF0ZUZyYW1lYnVmZmVyKCk7dC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixvKSx0LmZyYW1lYnVmZmVyVGV4dHVyZTJEKHQuRlJBTUVCVUZGRVIsdC5DT0xPUl9BVFRBQ0hNRU5UMCx0LlRFWFRVUkVfMkQsciwwKTt2YXIgYT10LmNoZWNrRnJhbWVidWZmZXJTdGF0dXModC5GUkFNRUJVRkZFUik9PT10LkZSQU1FQlVGRkVSX0NPTVBMRVRFO3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlVGV4dHVyZShyKSx0LmRlbGV0ZUZyYW1lYnVmZmVyKG8pLGF9KGUsbil9cmV0dXJuITF9cmV0dXJuISFQZShlLFwiT0VTX3RleHR1cmVfZmxvYXRcIikmJighIVBlKGUsXCJXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXRcIikmJlZlKGUpKX1mdW5jdGlvbiBWZSh0KXt2YXIgZT1RdCh0KSxuPXQuY3JlYXRlVGV4dHVyZSgpO3QuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG4pO3QudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsMCxlLmludGVybmFsRm9ybWF0RmxvYXQsMSwxLDAsZS50ZXh0dXJlRm9ybWF0RmxvYXQsZS50ZXh0dXJlVHlwZUZsb2F0LG51bGwpO3ZhciByPXQuY3JlYXRlRnJhbWVidWZmZXIoKTt0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLHIpLHQuZnJhbWVidWZmZXJUZXh0dXJlMkQodC5GUkFNRUJVRkZFUix0LkNPTE9SX0FUVEFDSE1FTlQwLHQuVEVYVFVSRV8yRCxuLDApO3ZhciBvPXQuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyh0LkZSQU1FQlVGRkVSKT09PXQuRlJBTUVCVUZGRVJfQ09NUExFVEU7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpLHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsbnVsbCksdC5kZWxldGVUZXh0dXJlKG4pLHQuZGVsZXRlRnJhbWVidWZmZXIociksb31mdW5jdGlvbiB6ZSh0KXtyZXR1cm4gMj09PXQmJm51bGwhPWp0KHQpLmZlbmNlU3luY312YXIgR2U9T2JqZWN0LmZyZWV6ZSh7Y2FsbEFuZENoZWNrOkp0LGNhbkJlUmVwcmVzZW50ZWQ6ZWUsZ2V0V2ViR0xFcnJvck1lc3NhZ2U6bmUsZ2V0RXh0ZW5zaW9uT3JUaHJvdzpyZSxjcmVhdGVWZXJ0ZXhTaGFkZXI6b2UsY3JlYXRlRnJhZ21lbnRTaGFkZXI6YWUsY3JlYXRlUHJvZ3JhbTpjZSxsaW5rUHJvZ3JhbTpsZSx2YWxpZGF0ZVByb2dyYW06aGUsY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyOmZlLGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyOmRlLGdldE51bUNoYW5uZWxzOmZ1bmN0aW9uKCl7cmV0dXJuIDI9PT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT8xOjR9LGNyZWF0ZVRleHR1cmU6cGUsdmFsaWRhdGVUZXh0dXJlU2l6ZTp2ZSxjcmVhdGVGcmFtZWJ1ZmZlcjptZSxiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlOmdlLGJpbmRUZXh0dXJlVW5pdDp5ZSx1bmJpbmRUZXh0dXJlVW5pdDpmdW5jdGlvbih0LGUsbil7U2UodCxuKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYWN0aXZlVGV4dHVyZSh0LlRFWFRVUkUwK24pfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCl9KSl9LGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93OnhlLGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb246YmUsYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcjp3ZSxiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcjpmdW5jdGlvbih0LGUpe0p0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixudWxsKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQudmlld3BvcnQoMCwwLHQuY2FudmFzLndpZHRoLHQuY2FudmFzLmhlaWdodCl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnNjaXNzb3IoMCwwLHQuY2FudmFzLndpZHRoLHQuY2FudmFzLmhlaWdodCl9KSl9LGJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyOkNlLHVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcjpFZSx2YWxpZGF0ZUZyYW1lYnVmZmVyOlJlLGdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlOkllLGdldEJhdGNoRGltOkFlLGdldFJvd3NDb2xzOkRlLGdldFNoYXBlQXMzRDpUZSxnZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlOk5lLGlzUmVzaGFwZUZyZWU6X2UsZ2V0V2ViR0xNYXhUZXh0dXJlU2l6ZTpPZSxyZXNldE1heFRleHR1cmVTaXplOmZ1bmN0aW9uKCl7aWU9bnVsbH0scmVzZXRNYXhUZXh0dXJlc0luU2hhZGVyOmZ1bmN0aW9uKCl7c2U9bnVsbH0sZ2V0TWF4VGV4dHVyZXNJblNoYWRlcjpNZSxnZXRXZWJHTERpc2pvaW50UXVlcnlUaW1lclZlcnNpb246QmUsaGFzRXh0ZW5zaW9uOlBlLGlzV2ViR0xWZXJzaW9uRW5hYmxlZDpMZSxpc0NhcGFibGVPZlJlbmRlcmluZ1RvRmxvYXRUZXh0dXJlOldlLGlzRG93bmxvYWRGbG9hdFRleHR1cmVFbmFibGVkOlVlLGlzV2ViR0xGZW5jZUVuYWJsZWQ6emV9KSxIZT1pKCk7ZnVuY3Rpb24gcWUoKXtpKCkuc2V0KFwiUFJPRFwiLCEwKX1mdW5jdGlvbiBLZSgpe2koKS5zZXQoXCJERUJVR1wiLCEwKX1mdW5jdGlvbiBqZSgpe2koKS5zZXQoXCJERVBSRUNBVElPTl9XQVJOSU5HU19FTkFCTEVEXCIsITEpLGNvbnNvbGUud2FybihcIlRlbnNvckZsb3cuanMgZGVwcmVjYXRpb24gd2FybmluZ3MgaGF2ZSBiZWVuIGRpc2FibGVkLlwiKX1mdW5jdGlvbiBYZSh0KXtpKCkuZ2V0Qm9vbChcIkRFUFJFQ0FUSU9OX1dBUk5JTkdTX0VOQUJMRURcIikmJmNvbnNvbGUud2Fybih0K1wiIFlvdSBjYW4gZGlzYWJsZSBkZXByZWNhdGlvbiB3YXJuaW5ncyB3aXRoIHRmLmRpc2FibGVEZXByZWNhdGlvbldhcm5pbmdzKCkuXCIpfWZ1bmN0aW9uIFllKCl7THQuZGlzcG9zZVZhcmlhYmxlcygpfWZ1bmN0aW9uICRlKCl7cmV0dXJuIEx0fWZ1bmN0aW9uIFFlKCl7cmV0dXJuIEx0Lm1lbW9yeSgpfWZ1bmN0aW9uIEplKHQpe3JldHVybiBMdC5wcm9maWxlKHQpfWZ1bmN0aW9uIFplKHQsZSl7cmV0dXJuIEx0LnRpZHkodCxlKX1mdW5jdGlvbiB0bih0KXtfdCh0KS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdC5kaXNwb3NlKCl9KSl9ZnVuY3Rpb24gZW4odCl7cmV0dXJuIEx0LmtlZXAodCl9ZnVuY3Rpb24gbm4odCl7cmV0dXJuIEx0LnRpbWUodCl9ZnVuY3Rpb24gcm4odCl7cmV0dXJuIEx0LnNldEJhY2tlbmQodCl9ZnVuY3Rpb24gb24oKXtyZXR1cm4gTHQucmVhZHkoKX1mdW5jdGlvbiBhbigpe3JldHVybiBMdC5iYWNrZW5kTmFtZX1mdW5jdGlvbiBzbih0KXtMdC5yZW1vdmVCYWNrZW5kKHQpfWZ1bmN0aW9uIHVuKHQpe3JldHVybiBMdC5maW5kQmFja2VuZCh0KX1mdW5jdGlvbiBjbih0KXtyZXR1cm4gTHQuZmluZEJhY2tlbmRGYWN0b3J5KHQpfWZ1bmN0aW9uIGxuKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MSksTHQucmVnaXN0ZXJCYWNrZW5kKHQsZSxuKX1mdW5jdGlvbiBobigpe3JldHVybiBMdC5iYWNrZW5kfWZ1bmN0aW9uIGZuKHQsZSl7aSgpLnNldFBsYXRmb3JtKHQsZSl9ZnVuY3Rpb24gZG4oKXtmb3IodmFyIHQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspdFtlXT1hcmd1bWVudHNbZV07aSgpLmdldEJvb2woXCJJU19URVNUXCIpfHxjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSx0KX1mdW5jdGlvbiBwbih0LGUpe3ZhciBuPXQ7aWYoVih0KSlyZXR1cm5cInN0cmluZ1wiPT09ZT9bXTpbdC5sZW5ndGhdO2lmKCFBcnJheS5pc0FycmF5KHQpKXJldHVybltdO2Zvcih2YXIgcj1bXTtBcnJheS5pc0FycmF5KG4pfHxWKG4pJiZcInN0cmluZ1wiIT09ZTspci5wdXNoKG4ubGVuZ3RoKSxuPW5bMF07cmV0dXJuIEFycmF5LmlzQXJyYXkodCkmJmkoKS5nZXRCb29sKFwiVEVOU09STElLRV9DSEVDS19TSEFQRV9DT05TSVNURU5DWVwiKSYmZnVuY3Rpb24gdChlLG4scil7aWYocj1yfHxbXSwhQXJyYXkuaXNBcnJheShlKSYmIVYoZSkpcmV0dXJuIHZvaWQgQygwPT09bi5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFbGVtZW50IGFycltcIityLmpvaW4oXCJdW1wiKStcIl0gaXMgYSBwcmltaXRpdmUsIGJ1dCBzaG91bGQgYmUgYW4gYXJyYXkvVHlwZWRBcnJheSBvZiBcIituWzBdK1wiIGVsZW1lbnRzXCJ9KSk7QyhuLmxlbmd0aD4wLChmdW5jdGlvbigpe3JldHVyblwiRWxlbWVudCBhcnJbXCIrci5qb2luKFwiXVtcIikrXCJdIHNob3VsZCBiZSBhIHByaW1pdGl2ZSwgYnV0IGlzIGFuIGFycmF5IG9mIFwiK2UubGVuZ3RoK1wiIGVsZW1lbnRzXCJ9KSksQyhlLmxlbmd0aD09PW5bMF0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFbGVtZW50IGFycltcIityLmpvaW4oXCJdW1wiKStcIl0gc2hvdWxkIGhhdmUgXCIrblswXStcIiBlbGVtZW50cywgYnV0IGhhcyBcIitlLmxlbmd0aCtcIiBlbGVtZW50c1wifSkpO2Zvcih2YXIgbz1uLnNsaWNlKDEpLGE9MDthPGUubGVuZ3RoOysrYSl0KGVbYV0sbyxyLmNvbmNhdChhKSl9KHQscixbXSkscn1mdW5jdGlvbiB2bih0LGUsbixyKXtpZihudWxsIT10JiYoXCJudW1lcmljXCIhPT10JiZ0IT09ZXx8XCJudW1lcmljXCI9PT10JiZcInN0cmluZ1wiPT09ZSkpdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgJ1wiK24rXCInIHBhc3NlZCB0byAnXCIrcitcIicgbXVzdCBiZSBcIit0K1wiIHRlbnNvciwgYnV0IGdvdCBcIitlK1wiIHRlbnNvclwiKX1mdW5jdGlvbiBtbih0LGUsbixyKXtpZih2b2lkIDA9PT1yJiYocj1cIm51bWVyaWNcIiksdCBpbnN0YW5jZW9mIHd0KXJldHVybiB2bihyLHQuZHR5cGUsZSxuKSx0O3ZhciBvPWoodCk7aWYoXCJzdHJpbmdcIiE9PW8mJltcImJvb2xcIixcImludDMyXCIsXCJmbG9hdDMyXCJdLmluZGV4T2Yocik+PTAmJihvPXIpLHZuKHIsbyxlLG4pLG51bGw9PXR8fCFWKHQpJiYhQXJyYXkuaXNBcnJheSh0KSYmXCJudW1iZXJcIiE9dHlwZW9mIHQmJlwiYm9vbGVhblwiIT10eXBlb2YgdCYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpe3ZhciBhPW51bGw9PXQ/XCJudWxsXCI6dC5jb25zdHJ1Y3Rvci5uYW1lO3Rocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50ICdcIitlK1wiJyBwYXNzZWQgdG8gJ1wiK24rXCInIG11c3QgYmUgYSBUZW5zb3Igb3IgVGVuc29yTGlrZSwgYnV0IGdvdCAnXCIrYStcIidcIil9dmFyIHM9cG4odCxvKTtWKHQpfHxBcnJheS5pc0FycmF5KHQpfHwodD1bdF0pO3ZhciB1PVwic3RyaW5nXCIhPT1vP1EodCxvLGkoKS5nZXRCb29sKFwiREVCVUdcIikpOkkodCxbXSwhMCk7cmV0dXJuIEx0Lm1ha2VUZW5zb3IodSxzLG8pfWZ1bmN0aW9uIGduKHQsZSxuLHIpe2lmKHZvaWQgMD09PXImJihyPVwibnVtZXJpY1wiKSwhQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBcIitlK1wiIHBhc3NlZCB0byBcIituK1wiIG11c3QgYmUgYSBgVGVuc29yW11gIG9yIGBUZW5zb3JMaWtlW11gXCIpO3JldHVybiB0Lm1hcCgoZnVuY3Rpb24odCxyKXtyZXR1cm4gbW4odCxlK1wiW1wiK3IrXCJdXCIsbil9KSxyKX1mdW5jdGlvbiB5bih0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7KytuKWlmKHRbdC5sZW5ndGgtbi0xXSE9PWUtMS1uKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHhuKHQsZSxuKXtmb3IodmFyIHI9dC5sZW5ndGgrZS5sZW5ndGgsbz1bXSxhPTAsaT0wLHM9MDtzPHI7cysrKS0xPT09bi5pbmRleE9mKHMpP28ucHVzaCh0W2ErK10pOm8ucHVzaChlW2krK10pO3JldHVybiBvfWZ1bmN0aW9uIGJuKHQsZSl7Zm9yKHZhciBuPVtdLHI9dC5sZW5ndGgsbz0wO288cjtvKyspLTE9PT1lLmluZGV4T2YobykmJm4ucHVzaCh0W29dKTtyZXR1cm5bbixlLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19KSldfWZ1bmN0aW9uIHduKHQsZSl7cmV0dXJuIHhuKHQsZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiAxfSkpLGUpfWZ1bmN0aW9uIENuKHQsZSxuKXtDKHluKGUsbiksKGZ1bmN0aW9uKCl7cmV0dXJuIHQrXCIgc3VwcG9ydHMgb25seSBpbm5lci1tb3N0IGF4ZXMgZm9yIG5vdy4gR290IGF4ZXMgXCIrZStcIiBhbmQgcmFuay1cIituK1wiIGlucHV0LlwifSkpfWZ1bmN0aW9uIEVuKHQsZSl7aWYoeW4odCxlKSlyZXR1cm4gbnVsbDtmb3IodmFyIG49W10scj0wO3I8ZTsrK3IpLTE9PT10LmluZGV4T2YocikmJm4ucHVzaChyKTtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gbi5wdXNoKHQpfSkpLG59ZnVuY3Rpb24gUm4odCl7cmV0dXJuIHQubWFwKChmdW5jdGlvbih0LGUpe3JldHVybltlLHRdfSkpLnNvcnQoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbMV0tZVsxXX0pKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSkpfWZ1bmN0aW9uIEluKHQsZSl7Zm9yKHZhciBuPVtdLHI9ZS10O3I8ZTsrK3Ipbi5wdXNoKHIpO3JldHVybiBufWZ1bmN0aW9uIGtuKHQsZSl7dmFyIG49dFswXS5sZW5ndGg7dC5mb3JFYWNoKChmdW5jdGlvbih0LGUpe0ModC5sZW5ndGg9PT1uLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29uY2F0XCIrbitcIkQ6IHJhbmsgb2YgdGVuc29yc1tcIitlK1wiXSBtdXN0IGJlIHRoZSBzYW1lIGFzIHRoZSByYW5rIG9mIHRoZSByZXN0IChcIituK1wiKVwifSkpfSkpLEMoZT49MCYmZTxuLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29uY2F0XCIrbitcIkQ6IGF4aXMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIFwiKyhuLTEpK1wiLlwifSkpO3ZhciByPXRbMF07dC5mb3JFYWNoKChmdW5jdGlvbih0LG8pe2Zvcih2YXIgYT0wO2E8bjthKyspQyhhPT09ZXx8dFthXT09PXJbYV0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb25jYXRcIituK1wiRDogU2hhcGUgb2YgdGVuc29yc1tcIitvK1wiXSAoXCIrdCtcIikgZG9lcyBub3QgbWF0Y2ggdGhlIHNoYXBlIG9mIHRoZSByZXN0IChcIityK1wiKSBhbG9uZyB0aGUgbm9uLWNvbmNhdGVuYXRlZCBheGlzIFwiK28rXCIuXCJ9KSl9KSl9ZnVuY3Rpb24gU24odCxlKXtmb3IodmFyIG49dFswXS5zbGljZSgpLHI9MTtyPHQubGVuZ3RoO3IrKyluW2VdKz10W3JdW2VdO3JldHVybiBufWZ1bmN0aW9uIEFuKHQpe3ZhciBlPU9iamVjdC5rZXlzKHQpO2lmKDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBrZXkgKG9wZXJhdGlvbiBuYW1lKSBtYXBwaW5nIHRvIGEgZnVuY3Rpb24uIEdvdCBhbiBvYmplY3Qgd2l0aCBcIitlLmxlbmd0aCtcIiBrZXlzLlwiKTt2YXIgbj1lWzBdLHI9dFtuXTtuLmVuZHNXaXRoKFwiX1wiKSYmKG49bi5zdWJzdHJpbmcoMCxuLmxlbmd0aC0xKSk7dmFyIG89ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspdFtlXT1hcmd1bWVudHNbZV07THQuc3RhcnRTY29wZShuKTt0cnl7dmFyIG89ci5hcHBseSh2b2lkIDAsdCk7cmV0dXJuIG8gaW5zdGFuY2VvZiBQcm9taXNlJiZjb25zb2xlLmVycm9yKFwiQ2Fubm90IHJldHVybiBhIFByb21pc2UgaW5zaWRlIG9mIHRpZHkuXCIpLEx0LmVuZFNjb3BlKG8pLG99Y2F0Y2godCl7dGhyb3cgTHQuZW5kU2NvcGUobnVsbCksdH19O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkobyxcIm5hbWVcIix7dmFsdWU6bixjb25maWd1cmFibGU6ITB9KSxvfUhlLnJlZ2lzdGVyRmxhZyhcIkhBU19XRUJHTFwiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPjB9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfVkVSU0lPTlwiLChmdW5jdGlvbigpe3JldHVybiBMZSgyKT8yOkxlKDEpPzE6MH0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9CVUZGRVJfU1VQUE9SVEVEXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIDI9PT1IZS5nZXQoXCJXRUJHTF9WRVJTSU9OXCIpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0NQVV9GT1JXQVJEXCIsKGZ1bmN0aW9uKCl7cmV0dXJuITB9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfRk9SQ0VfRjE2X1RFWFRVUkVTXCIsKGZ1bmN0aW9uKCl7cmV0dXJuITF9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS1wiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXRCb29sKFwiSEFTX1dFQkdMXCIpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfTk9STUFMSVpBVElPTlwiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0NMSVBcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19ERVBUSFdJU0VDT05WXCIsKGZ1bmN0aW9uKCl7cmV0dXJuITF9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX1VOQVJZX09QRVJBVElPTlNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfSU1BR0VfT1BFUkFUSU9OU1wiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX1JFRFVDRVwiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9MQVpJTFlfVU5QQUNLXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0NPTlZfSU0yQ09MXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX01BWF9URVhUVVJFX1NJWkVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gT2UoSGUuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfTUFYX1RFWFRVUkVTX0lOX1NIQURFUlwiLChmdW5jdGlvbigpe3JldHVybiBNZShIZS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiLChmdW5jdGlvbigpe3ZhciB0PUhlLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik7cmV0dXJuIDA9PT10PzA6QmUodCl9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpPjAmJih0PW5hdmlnYXRvci51c2VyQWdlbnR8fG5hdmlnYXRvci52ZW5kb3J8fHdpbmRvdy5vcGVyYSwhKC8oYW5kcm9pZHxiYlxcZCt8bWVlZ28pLittb2JpbGV8YXZhbnRnb3xiYWRhXFwvfGJsYWNrYmVycnl8YmxhemVyfGNvbXBhbHxlbGFpbmV8ZmVubmVjfGhpcHRvcHxpZW1vYmlsZXxpcChob25lfG9kKXxpcmlzfGtpbmRsZXxsZ2UgfG1hZW1vfG1pZHB8bW1wfG1vYmlsZS4rZmlyZWZveHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyBjZXx4ZGF8eGlpbm8vaS50ZXN0KHQpfHwvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaS50ZXN0KHQuc3Vic3RyKDAsNCkpKSk7dmFyIHR9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfQ0FQQUJMRVwiLChmdW5jdGlvbigpe3JldHVybiBXZShIZS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIUhlLmdldEJvb2woXCJXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVNcIikmJkhlLmdldEJvb2woXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9DQVBBQkxFXCIpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRURcIiwoZnVuY3Rpb24oKXtyZXR1cm4gVWUoSGUuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfRkVOQ0VfQVBJX0VOQUJMRURcIiwoZnVuY3Rpb24oKXtyZXR1cm4gemUoSGUuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfU0laRV9VUExPQURfVU5JRk9STVwiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiKT80OjB9KSksYnQ9WGU7dmFyIERuPUFuKHtjb21wbGV4XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJyZWFsXCIsXCJjb21wbGV4XCIpLHI9bW4oZSxcImltYWdcIixcImNvbXBsZXhcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwicmVhbCBhbmQgaW1hZyBzaGFwZXMsIFwiK24uc2hhcGUrXCIgYW5kIFwiK3Iuc2hhcGUrXCIsIG11c3QgbWF0Y2ggaW4gY2FsbCB0byB0Zi5jb21wbGV4KCkuXCIpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbXBsZXgobixyKX0pLHskcmVhbDpuLCRpbWFnOnJ9KX19KSxUbj1Bbih7cmVhbF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcImlucHV0XCIsXCJyZWFsXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWFsKGUpfSkseyRpbnB1dDplfSl9fSksTm49QW4oe2ltYWdfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJpbnB1dFwiLFwiaW1hZ1wiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuaW1hZyhlKX0pLHskaW5wdXQ6ZX0pfX0pO2Z1bmN0aW9uIEZuKHQsZSxuKXtyZXR1cm4gX24odCxlLHBuKHQsbiksbil9ZnVuY3Rpb24gX24odCxlLG4scil7aWYobnVsbD09ciYmKHI9aih0KSksXCJjb21wbGV4NjRcIj09PXIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnN0cnVjdCBhIGNvbXBsZXg2NCB0ZW5zb3IgZGlyZWN0bHkuIFBsZWFzZSB1c2UgdGYuY29tcGxleChyZWFsLCBpbWFnKS5cIik7aWYoIVYodCkmJiFBcnJheS5pc0FycmF5KHQpJiZcIm51bWJlclwiIT10eXBlb2YgdCYmXCJib29sZWFuXCIhPXR5cGVvZiB0JiZcInN0cmluZ1wiIT10eXBlb2YgdCl0aHJvdyBuZXcgRXJyb3IoXCJ2YWx1ZXMgcGFzc2VkIHRvIHRlbnNvcih2YWx1ZXMpIG11c3QgYmUgYSBudW1iZXIvYm9vbGVhbi9zdHJpbmcgb3IgYW4gYXJyYXkgb2YgbnVtYmVycy9ib29sZWFucy9zdHJpbmdzLCBvciBhIFR5cGVkQXJyYXlcIik7aWYobnVsbCE9ZSl7bnQoZSk7dmFyIG89ayhlKSxhPWsobik7QyhvPT09YSwoZnVuY3Rpb24oKXtyZXR1cm5cIkJhc2VkIG9uIHRoZSBwcm92aWRlZCBzaGFwZSwgW1wiK2UrXCJdLCB0aGUgdGVuc29yIHNob3VsZCBoYXZlIFwiK28rXCIgdmFsdWVzIGJ1dCBoYXMgXCIrYX0pKTtmb3IodmFyIHM9MDtzPG4ubGVuZ3RoOysrcyl7dmFyIHU9bltzXSxjPXMhPT1uLmxlbmd0aC0xfHx1IT09ayhlLnNsaWNlKHMpKTtDKG5bc109PT1lW3NdfHwhYywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGNyZWF0aW5nIGEgbmV3IFRlbnNvci4gSW5mZXJyZWQgc2hhcGUgKFwiK24rXCIpIGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBzaGFwZSAoXCIrZStcIikuIFwifSkpfX1yZXR1cm4gVih0KXx8QXJyYXkuaXNBcnJheSh0KXx8KHQ9W3RdKSxlPWV8fG4sdD1cInN0cmluZ1wiIT09cj9RKHQscixpKCkuZ2V0Qm9vbChcIkRFQlVHXCIpKTpJKHQsW10sITApLEx0Lm1ha2VUZW5zb3IodCxlLHIpfWZ1bmN0aW9uIE9uKHQsZSl7aWYoKFYodCkmJlwic3RyaW5nXCIhPT1lfHxBcnJheS5pc0FycmF5KHQpKSYmXCJjb21wbGV4NjRcIiE9PWUpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY3JlYXRpbmcgYSBuZXcgU2NhbGFyOiB2YWx1ZSBtdXN0IGJlIGEgcHJpbWl0aXZlIChudW1iZXJ8Ym9vbGVhbnxzdHJpbmcpXCIpO2lmKFwic3RyaW5nXCI9PT1lJiZWKHQpJiYhKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIG1ha2luZyBhIHNjYWxhciBmcm9tIGVuY29kZWQgc3RyaW5nLCB0aGUgdmFsdWUgbXVzdCBiZSBgVWludDhBcnJheWAuXCIpO3JldHVybiBfbih0LFtdLFtdLGUpfWZ1bmN0aW9uIE1uKHQsZSl7Uih0KTt2YXIgbj1wbih0LGUpO2lmKDEhPT1uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IxZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBhIGZsYXQvVHlwZWRBcnJheVwiKTtyZXR1cm4gX24odCxudWxsLG4sZSl9ZnVuY3Rpb24gQm4odCxlLG4pe2lmKFIodCksbnVsbCE9ZSYmMiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjJkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSB0d28gbnVtYmVyc1wiKTt2YXIgcj1wbih0LG4pO2lmKDIhPT1yLmxlbmd0aCYmMSE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjJkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKDE9PT1yLmxlbmd0aCYmbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IyZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdC9UeXBlZEFycmF5XCIpO3JldHVybiBfbih0LGUscixuKX1mdW5jdGlvbiBQbih0LGUsbil7aWYoUih0KSxudWxsIT1lJiYzIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yM2QoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIHRocmVlIG51bWJlcnNcIik7dmFyIHI9cG4odCxuKTtpZigzIT09ci5sZW5ndGgmJjEhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IzZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKDE9PT1yLmxlbmd0aCYmbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IzZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdCBhcnJheVwiKTtyZXR1cm4gX24odCxlLHIsbil9ZnVuY3Rpb24gTG4odCxlLG4pe2lmKFIodCksbnVsbCE9ZSYmNCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjRkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBmb3VyIG51bWJlcnNcIik7dmFyIHI9cG4odCxuKTtpZig0IT09ci5sZW5ndGgmJjEhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I0ZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoMT09PXIubGVuZ3RoJiZudWxsPT1lKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjRkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0IGFycmF5XCIpO3JldHVybiBfbih0LGUscixuKX1mdW5jdGlvbiBXbih0LGUsbil7aWYoUih0KSxudWxsIT1lJiY1IT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNWQoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIGZpdmUgbnVtYmVyc1wiKTt2YXIgcj1wbih0LG4pO2lmKDUhPT1yLmxlbmd0aCYmMSE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjVkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKDE9PT1yLmxlbmd0aCYmbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I1ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdCBhcnJheVwiKTtyZXR1cm4gX24odCxlLHIsbil9ZnVuY3Rpb24gVW4odCxlLG4pe2lmKFIodCksbnVsbCE9ZSYmNiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjZkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBzaXggbnVtYmVyc1wiKTt2YXIgcj1wbih0LG4pO2lmKDYhPT1yLmxlbmd0aCYmMSE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjZkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXVtdW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoMT09PXIubGVuZ3RoJiZudWxsPT1lKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjZkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0IGFycmF5XCIpO3JldHVybiBfbih0LGU9ZXx8cixyLG4pfWZ1bmN0aW9uIFZuKHQsZSxuLHIpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMCksTHQubWFrZVZhcmlhYmxlKHQsZSxuLHIpfWZ1bmN0aW9uIHpuKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9XCJmbG9hdDMyXCIpLFwiY29tcGxleDY0XCI9PT1lKXt2YXIgbj16bih0LFwiZmxvYXQzMlwiKSxyPUduKHQsXCJmbG9hdDMyXCIpO3JldHVybiBEbihuLHIpfXZhciBvPVooayh0KSxlKTtyZXR1cm4gTHQubWFrZVRlbnNvcihvLHQsZSl9ZnVuY3Rpb24gR24odCxlKXtpZih2b2lkIDA9PT1lJiYoZT1cImZsb2F0MzJcIiksXCJjb21wbGV4NjRcIj09PWUpe3ZhciBuPUduKHQsXCJmbG9hdDMyXCIpLHI9R24odCxcImZsb2F0MzJcIik7cmV0dXJuIERuKG4scil9dmFyIG89dHQoayh0KSxlKTtyZXR1cm4gTHQubWFrZVRlbnNvcihvLHQsZSl9ZnVuY3Rpb24gSG4odCxlLG4pe3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbihyKXtyZXR1cm4gci5maWxsKHQsZSxuKX0pLHt9KX1mdW5jdGlvbiBxbih0LGUsbil7aWYobjw9MCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbnVtYmVyIG9mIHZhbHVlcyBzaG91bGQgYmUgcG9zaXRpdmUuXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbihyKXtyZXR1cm4gci5saW5zcGFjZSh0LGUsbil9KSx7fSl9ZnVuY3Rpb24gS24odCxlLG4scil7aWYodm9pZCAwPT09biYmKG49MSksdm9pZCAwPT09ciYmKHI9XCJmbG9hdDMyXCIpLDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYXZlIGEgc3RlcCBvZiB6ZXJvXCIpO2lmKHQ9PT1lfHx0PGUmJm48MHx8ZTx0JiZuPjEpcmV0dXJuIEduKFswXSxyKTt2YXIgbz10dChNYXRoLmFicyhNYXRoLmNlaWwoKGUtdCkvbikpLHIpO2U8dCYmMT09PW4mJihuPS0xKSxvWzBdPXQ7Zm9yKHZhciBhPTE7YTxvLmxlbmd0aDthKyspb1thXT1vW2EtMV0rbjtyZXR1cm4gTW4obyxyKX12YXIgam49QW4oe29uZXNMaWtlXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwib25lc0xpa2VcIik7aWYoXCJjb21wbGV4NjRcIj09PWUuZHR5cGUpe3ZhciBuPWpuKFRuKGUpKSxyPVhuKE5uKGUpKTtyZXR1cm4gRG4obixyKX1yZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQub25lc0xpa2UoZSl9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KSl9fSksWG49QW4oe3plcm9zTGlrZV86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInplcm9zTGlrZVwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuemVyb3NMaWtlKGUpfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSkpfX0pO3ZhciBZbj1Bbih7Y29uY2F0XzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApLEModC5sZW5ndGg+PTEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJQYXNzIGF0IGxlYXN0IG9uZSB0ZW5zb3IgdG8gY29uY2F0XCJ9KSk7dmFyIG49Z24odCxcInRlbnNvcnNcIixcImNvbmNhdFwiKTtcImNvbXBsZXg2NFwiPT09blswXS5kdHlwZSYmbi5mb3JFYWNoKChmdW5jdGlvbih0KXtpZihcImNvbXBsZXg2NFwiIT09dC5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29uY2F0ZW5hdGUgY29tcGxleDY0IHRlbnNvcnMgd2l0aCBhIHRlbnNvclxcbiAgICAgICAgICB3aXRoIGR0eXBlIFwiK3QuZHR5cGUrXCIuIFwiKX0pKSxlPU8oZSxuWzBdLnNoYXBlKVswXTt2YXIgcj1TbihuLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSksZSk7aWYoMD09PWsocikpcmV0dXJuIEZuKFtdLHIpO2lmKDE9PT0obj1uLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2l6ZT4wfSkpKS5sZW5ndGgpcmV0dXJuIG5bMF07dmFyIG89bi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkpO2tuKG8sZSk7dmFyIGE9bixpPXtheGlzOmV9O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb25jYXQobixlKX0pLGEsKGZ1bmN0aW9uKHQpe3ZhciBuPW8ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdFtlXX0pKTtyZXR1cm4gdHIodCxuLGUpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHR9fSkpfSksXCJDb25jYXRcIixpKX19KSwkbj1Bbih7Y29uY2F0MWRfOmZ1bmN0aW9uKHQpe3JldHVybiBZbih0LDApfX0pLFFuPUFuKHtjb25jYXQyZF86ZnVuY3Rpb24odCxlKXtyZXR1cm4gWW4odCxlKX19KSxKbj1Bbih7Y29uY2F0M2RfOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIFluKHQsZSl9fSksWm49QW4oe2NvbmNhdDRkXzpmdW5jdGlvbih0LGUpe3JldHVybiBZbih0LGUpfX0pLHRyPUFuKHtzcGxpdF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPTApO3ZhciByLG89bW4odCxcInhcIixcInNwbGl0XCIpO3JldHVybiBuPU8obixvLnNoYXBlKVswXSxcIm51bWJlclwiPT10eXBlb2YgZT8oQyhvLnNoYXBlW25dJWU9PTAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJOdW1iZXIgb2Ygc3BsaXRzIG11c3QgZXZlbmx5IGRpdmlkZSB0aGUgYXhpcy5cIn0pKSxyPW5ldyBBcnJheShlKS5maWxsKG8uc2hhcGVbbl0vZSkpOihDKG8uc2hhcGVbbl09PT1lLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlfSkpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIHN1bSBvZiBzaXplcyBtdXN0IG1hdGNoIHRoZSBzaXplIG9mIHRoZSBheGlzIGRpbWVuc2lvbi5cIn0pKSxyPWUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNwbGl0KG8scixuKX0pLHskeDpvfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFluKHQsbil9fX0pKX19KTtcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmO2Z1bmN0aW9uIGVyKHQsZSl7cmV0dXJuIHQoZT17ZXhwb3J0czp7fX0sZS5leHBvcnRzKSxlLmV4cG9ydHN9dmFyIG5yPWVyKChmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGUsbj10aGlzLHI9KGU9NDAyMjg3MTE5NyxmdW5jdGlvbih0KXt0PXQudG9TdHJpbmcoKTtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9LjAyNTE5NjAzMjgyNDE2OTM4KihlKz10LmNoYXJDb2RlQXQobikpO3ItPWU9cj4+PjAsZT0ocio9ZSk+Pj4wLGUrPTQyOTQ5NjcyOTYqKHItPWUpfXJldHVybiAyLjMyODMwNjQzNjUzODY5NjNlLTEwKihlPj4+MCl9KTtuLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdD0yMDkxNjM5Km4uczArMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMCpuLmM7cmV0dXJuIG4uczA9bi5zMSxuLnMxPW4uczIsbi5zMj10LShuLmM9MHx0KX0sbi5jPTEsbi5zMD1yKFwiIFwiKSxuLnMxPXIoXCIgXCIpLG4uczI9cihcIiBcIiksbi5zMC09cih0KSxuLnMwPDAmJihuLnMwKz0xKSxuLnMxLT1yKHQpLG4uczE8MCYmKG4uczErPTEpLG4uczItPXIodCksbi5zMjwwJiYobi5zMis9MSkscj1udWxsfWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZS5jPXQuYyxlLnMwPXQuczAsZS5zMT10LnMxLGUuczI9dC5zMixlfWZ1bmN0aW9uIGEodCxlKXt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1uLm5leHQ7cmV0dXJuIGkuaW50MzI9ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDk2NzI5NipuLm5leHQoKXwwfSxpLmRvdWJsZT1mdW5jdGlvbigpe3JldHVybiBpKCkrMTExMDIyMzAyNDYyNTE1NjVlLTMyKigyMDk3MTUyKmkoKXwwKX0saS5xdWljaz1pLGEmJihcIm9iamVjdFwiPT10eXBlb2YgYSYmbyhhLG4pLGkuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbyhuLHt9KX0pLGl9ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1hOm4mJm4uYW1kP24oKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSk6dGhpcy5hbGVhPWF9KDAsdCwhMSl9KSkscnI9ZXIoKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZT10aGlzLG49XCJcIjtlLng9MCxlLnk9MCxlLno9MCxlLnc9MCxlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdD1lLnheZS54PDwxMTtyZXR1cm4gZS54PWUueSxlLnk9ZS56LGUuej1lLncsZS53Xj1lLnc+Pj4xOV50XnQ+Pj44fSx0PT09KDB8dCk/ZS54PXQ6bis9dDtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoKzY0O3IrKyllLnhePTB8bi5jaGFyQ29kZUF0KHIpLGUubmV4dCgpfWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZS54PXQueCxlLnk9dC55LGUuej10LnosZS53PXQudyxlfWZ1bmN0aW9uIGEodCxlKXt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1mdW5jdGlvbigpe3JldHVybihuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBpLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgobi5uZXh0KCk+Pj4xMSkrKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LGkuaW50MzI9bi5uZXh0LGkucXVpY2s9aSxhJiYoXCJvYmplY3RcIj09dHlwZW9mIGEmJm8oYSxuKSxpLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG8obix7fSl9KSxpfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9YTpuJiZuLmFtZD9uKChmdW5jdGlvbigpe3JldHVybiBhfSkpOnRoaXMueG9yMTI4PWF9KDAsdCwhMSl9KSksb3I9ZXIoKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZT10aGlzLG49XCJcIjtlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdD1lLnheZS54Pj4+MjtyZXR1cm4gZS54PWUueSxlLnk9ZS56LGUuej1lLncsZS53PWUudiwoZS5kPWUuZCszNjI0Mzd8MCkrKGUudj1lLnZeZS52PDw0XnRedDw8MSl8MH0sZS54PTAsZS55PTAsZS56PTAsZS53PTAsZS52PTAsdD09PSgwfHQpP2UueD10Om4rPXQ7Zm9yKHZhciByPTA7cjxuLmxlbmd0aCs2NDtyKyspZS54Xj0wfG4uY2hhckNvZGVBdChyKSxyPT1uLmxlbmd0aCYmKGUuZD1lLng8PDEwXmUueD4+PjQpLGUubmV4dCgpfWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZS54PXQueCxlLnk9dC55LGUuej10LnosZS53PXQudyxlLnY9dC52LGUuZD10LmQsZX1mdW5jdGlvbiBhKHQsZSl7dmFyIG49bmV3IHIodCksYT1lJiZlLnN0YXRlLGk9ZnVuY3Rpb24oKXtyZXR1cm4obi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gaS5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKG4ubmV4dCgpPj4+MTEpKyhuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxpLmludDMyPW4ubmV4dCxpLnF1aWNrPWksYSYmKFwib2JqZWN0XCI9PXR5cGVvZiBhJiZvKGEsbiksaS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBvKG4se30pfSksaX1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWE6biYmbi5hbWQ/bigoZnVuY3Rpb24oKXtyZXR1cm4gYX0pKTp0aGlzLnhvcndvdz1hfSgwLHQsITEpfSkpLGFyPWVyKChmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9dGhpcztlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdCxuLHI9ZS54LG89ZS5pO3JldHVybiB0PXJbb10sbj0odF49dD4+PjcpXnQ8PDI0LG5ePSh0PXJbbysxJjddKV50Pj4+MTAsbl49KHQ9cltvKzMmN10pXnQ+Pj4zLG5ePSh0PXJbbys0JjddKV50PDw3LHQ9cltvKzcmN10sbl49KHRePXQ8PDEzKV50PDw5LHJbb109bixlLmk9bysxJjcsbn0sZnVuY3Rpb24odCxlKXt2YXIgbixyPVtdO2lmKGU9PT0oMHxlKSlyWzBdPWU7ZWxzZSBmb3IoZT1cIlwiK2Usbj0wO248ZS5sZW5ndGg7KytuKXJbNyZuXT1yWzcmbl08PDE1XmUuY2hhckNvZGVBdChuKStyW24rMSY3XTw8MTM7Zm9yKDtyLmxlbmd0aDw4OylyLnB1c2goMCk7Zm9yKG49MDtuPDgmJjA9PT1yW25dOysrbik7Zm9yKDg9PW4/cls3XT0tMTpyW25dLHQueD1yLHQuaT0wLG49MjU2O24+MDstLW4pdC5uZXh0KCl9KGUsdCl9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLng9dC54LnNsaWNlKCksZS5pPXQuaSxlfWZ1bmN0aW9uIGEodCxlKXtudWxsPT10JiYodD0rbmV3IERhdGUpO3ZhciBuPW5ldyByKHQpLGE9ZSYmZS5zdGF0ZSxpPWZ1bmN0aW9uKCl7cmV0dXJuKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGkuZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChuLm5leHQoKT4+PjExKSsobi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0saS5pbnQzMj1uLm5leHQsaS5xdWljaz1pLGEmJihhLngmJm8oYSxuKSxpLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG8obix7fSl9KSxpfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9YTpuJiZuLmFtZD9uKChmdW5jdGlvbigpe3JldHVybiBhfSkpOnRoaXMueG9yc2hpZnQ3PWF9KDAsdCwhMSl9KSksaXI9ZXIoKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZT10aGlzO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0LG4scj1lLncsbz1lLlgsYT1lLmk7cmV0dXJuIGUudz1yPXIrMTY0MDUzMTUyN3wwLG49b1thKzM0JjEyN10sdD1vW2E9YSsxJjEyN10sbl49bjw8MTMsdF49dDw8MTcsbl49bj4+PjE1LHRePXQ+Pj4xMixuPW9bYV09bl50LGUuaT1hLG4rKHJecj4+PjE2KXwwfSxmdW5jdGlvbih0LGUpe3ZhciBuLHIsbyxhLGkscz1bXSx1PTEyODtmb3IoZT09PSgwfGUpPyhyPWUsZT1udWxsKTooZSs9XCJcXDBcIixyPTAsdT1NYXRoLm1heCh1LGUubGVuZ3RoKSksbz0wLGE9LTMyO2E8dTsrK2EpZSYmKHJePWUuY2hhckNvZGVBdCgoYSszMiklZS5sZW5ndGgpKSwwPT09YSYmKGk9cikscl49cjw8MTAscl49cj4+PjE1LHJePXI8PDQscl49cj4+PjEzLGE+PTAmJihpPWkrMTY0MDUzMTUyN3wwLG89MD09KG49c1sxMjcmYV1ePXIraSk/bysxOjApO2ZvcihvPj0xMjgmJihzWzEyNyYoZSYmZS5sZW5ndGh8fDApXT0tMSksbz0xMjcsYT01MTI7YT4wOy0tYSlyPXNbbyszNCYxMjddLG49c1tvPW8rMSYxMjddLHJePXI8PDEzLG5ePW48PDE3LHJePXI+Pj4xNSxuXj1uPj4+MTIsc1tvXT1yXm47dC53PWksdC5YPXMsdC5pPW99KGUsdCl9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLmk9dC5pLGUudz10LncsZS5YPXQuWC5zbGljZSgpLGV9ZnVuY3Rpb24gYSh0LGUpe251bGw9PXQmJih0PStuZXcgRGF0ZSk7dmFyIG49bmV3IHIodCksYT1lJiZlLnN0YXRlLGk9ZnVuY3Rpb24oKXtyZXR1cm4obi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gaS5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKG4ubmV4dCgpPj4+MTEpKyhuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxpLmludDMyPW4ubmV4dCxpLnF1aWNrPWksYSYmKGEuWCYmbyhhLG4pLGkuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbyhuLHt9KX0pLGl9ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1hOm4mJm4uYW1kP24oKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSk6dGhpcy54b3I0MDk2PWF9KDAsdCwhMSl9KSksc3I9ZXIoKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZT10aGlzLG49XCJcIjtlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdD1lLmIsbj1lLmMscj1lLmQsbz1lLmE7cmV0dXJuIHQ9dDw8MjVedD4+PjdebixuPW4tcnwwLHI9cjw8MjRecj4+PjhebyxvPW8tdHwwLGUuYj10PXQ8PDIwXnQ+Pj4xMl5uLGUuYz1uPW4tcnwwLGUuZD1yPDwxNl5uPj4+MTZebyxlLmE9by10fDB9LGUuYT0wLGUuYj0wLGUuYz0tMTY0MDUzMTUyNyxlLmQ9MTM2NzEzMDU1MSx0PT09TWF0aC5mbG9vcih0KT8oZS5hPXQvNDI5NDk2NzI5NnwwLGUuYj0wfHQpOm4rPXQ7Zm9yKHZhciByPTA7cjxuLmxlbmd0aCsyMDtyKyspZS5iXj0wfG4uY2hhckNvZGVBdChyKSxlLm5leHQoKX1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGUuYT10LmEsZS5iPXQuYixlLmM9dC5jLGUuZD10LmQsZX1mdW5jdGlvbiBhKHQsZSl7dmFyIG49bmV3IHIodCksYT1lJiZlLnN0YXRlLGk9ZnVuY3Rpb24oKXtyZXR1cm4obi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gaS5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKG4ubmV4dCgpPj4+MTEpKyhuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxpLmludDMyPW4ubmV4dCxpLnF1aWNrPWksYSYmKFwib2JqZWN0XCI9PXR5cGVvZiBhJiZvKGEsbiksaS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBvKG4se30pfSksaX1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWE6biYmbi5hbWQ/bigoZnVuY3Rpb24oKXtyZXR1cm4gYX0pKTp0aGlzLnR5Y2hlaT1hfSgwLHQsITEpfSkpLHVyPWVyKChmdW5jdGlvbih0KXshZnVuY3Rpb24oZSxuKXt2YXIgcixvPXRoaXMsYT0yNTYsaT02LHM9XCJyYW5kb21cIix1PW4ucG93KGEsaSksYz1uLnBvdygyLDUyKSxsPTIqYyxoPWEtMTtmdW5jdGlvbiBmKHQsaCxmKXt2YXIgZz1bXSx5PXYoZnVuY3Rpb24gdChlLG4pe3ZhciByLG89W10sYT10eXBlb2YgZTtpZihuJiZcIm9iamVjdFwiPT1hKWZvcihyIGluIGUpdHJ5e28ucHVzaCh0KGVbcl0sbi0xKSl9Y2F0Y2godCl7fXJldHVybiBvLmxlbmd0aD9vOlwic3RyaW5nXCI9PWE/ZTplK1wiXFwwXCJ9KChoPTE9PWg/e2VudHJvcHk6ITB9Omh8fHt9KS5lbnRyb3B5P1t0LG0oZSldOm51bGw9PXQ/ZnVuY3Rpb24oKXt0cnl7dmFyIHQ7cmV0dXJuIHImJih0PXIucmFuZG9tQnl0ZXMpP3Q9dChhKToodD1uZXcgVWludDhBcnJheShhKSwoby5jcnlwdG98fG8ubXNDcnlwdG8pLmdldFJhbmRvbVZhbHVlcyh0KSksbSh0KX1jYXRjaCh0KXt2YXIgbj1vLm5hdmlnYXRvcixpPW4mJm4ucGx1Z2lucztyZXR1cm5bK25ldyBEYXRlLG8saSxvLnNjcmVlbixtKGUpXX19KCk6dCwzKSxnKSx4PW5ldyBkKGcpLGI9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9eC5nKGkpLGU9dSxuPTA7dDxjOyl0PSh0K24pKmEsZSo9YSxuPXguZygxKTtmb3IoO3Q+PWw7KXQvPTIsZS89MixuPj4+PTE7cmV0dXJuKHQrbikvZX07cmV0dXJuIGIuaW50MzI9ZnVuY3Rpb24oKXtyZXR1cm4gMHx4LmcoNCl9LGIucXVpY2s9ZnVuY3Rpb24oKXtyZXR1cm4geC5nKDQpLzQyOTQ5NjcyOTZ9LGIuZG91YmxlPWIsdihtKHguUyksZSksKGgucGFzc3x8Znx8ZnVuY3Rpb24odCxlLHIsbyl7cmV0dXJuIG8mJihvLlMmJnAobyx4KSx0LnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHAoeCx7fSl9KSxyPyhuW3NdPXQsZSk6dH0pKGIseSxcImdsb2JhbFwiaW4gaD9oLmdsb2JhbDp0aGlzPT1uLGguc3RhdGUpfWZ1bmN0aW9uIGQodCl7dmFyIGUsbj10Lmxlbmd0aCxyPXRoaXMsbz0wLGk9ci5pPXIuaj0wLHM9ci5TPVtdO2ZvcihufHwodD1bbisrXSk7bzxhOylzW29dPW8rKztmb3Iobz0wO288YTtvKyspc1tvXT1zW2k9aCZpK3RbbyVuXSsoZT1zW29dKV0sc1tpXT1lOyhyLmc9ZnVuY3Rpb24odCl7Zm9yKHZhciBlLG49MCxvPXIuaSxpPXIuaixzPXIuUzt0LS07KWU9c1tvPWgmbysxXSxuPW4qYStzW2gmKHNbb109c1tpPWgmaStlXSkrKHNbaV09ZSldO3JldHVybiByLmk9byxyLmo9aSxufSkoYSl9ZnVuY3Rpb24gcCh0LGUpe3JldHVybiBlLmk9dC5pLGUuaj10LmosZS5TPXQuUy5zbGljZSgpLGV9ZnVuY3Rpb24gdih0LGUpe2Zvcih2YXIgbixyPXQrXCJcIixvPTA7bzxyLmxlbmd0aDspZVtoJm9dPWgmKG5ePTE5KmVbaCZvXSkrci5jaGFyQ29kZUF0KG8rKyk7cmV0dXJuIG0oZSl9ZnVuY3Rpb24gbSh0KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSgwLHQpfWlmKG5bXCJzZWVkXCIrc109Zix2KG4ucmFuZG9tKCksZSksdC5leHBvcnRzKXt0LmV4cG9ydHM9Zjt0cnl7cj1yZXF1aXJlKFwiY3J5cHRvXCIpfWNhdGNoKHQpe319fShbXSxNYXRoKX0pKTt1ci5hbGVhPW5yLHVyLnhvcjEyOD1ycix1ci54b3J3b3c9b3IsdXIueG9yc2hpZnQ3PWFyLHVyLnhvcjQwOTY9aXIsdXIudHljaGVpPXNyO3ZhciBjcj11ci5hbGVhLGxyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbixyLG8pe3RoaXMubWVhbj10LHRoaXMuc3RkRGV2PWUsdGhpcy5kdHlwZT1uLHRoaXMubmV4dFZhbD1OYU4sdGhpcy50cnVuY2F0ZWQ9cix0aGlzLnRydW5jYXRlZCYmKHRoaXMudXBwZXI9dGhpcy5tZWFuKzIqdGhpcy5zdGREZXYsdGhpcy5sb3dlcj10aGlzLm1lYW4tMip0aGlzLnN0ZERldik7dmFyIGE9b3x8TWF0aC5yYW5kb20oKTt0aGlzLnJhbmRvbT1jcihhLnRvU3RyaW5nKCkpfXJldHVybiB0LnByb3RvdHlwZS5uZXh0VmFsdWU9ZnVuY3Rpb24oKXtpZighaXNOYU4odGhpcy5uZXh0VmFsKSl7dmFyIHQ9dGhpcy5uZXh0VmFsO3JldHVybiB0aGlzLm5leHRWYWw9TmFOLHR9Zm9yKHZhciBlLG4scj0hMTshcjspe3ZhciBvPXZvaWQgMCxhPXZvaWQgMCxpPXZvaWQgMDtkb3tpPShvPTIqdGhpcy5yYW5kb20oKS0xKSpvKyhhPTIqdGhpcy5yYW5kb20oKS0xKSphfXdoaWxlKGk+PTF8fDA9PT1pKTt2YXIgcz1NYXRoLnNxcnQoLTIqTWF0aC5sb2coaSkvaSk7ZT10aGlzLm1lYW4rdGhpcy5zdGREZXYqbypzLG49dGhpcy5tZWFuK3RoaXMuc3RkRGV2KmEqcyx0aGlzLnRydW5jYXRlZCYmIXRoaXMuaXNWYWxpZFRydW5jYXRlZChlKXx8KHI9ITApfXJldHVybiB0aGlzLnRydW5jYXRlZCYmIXRoaXMuaXNWYWxpZFRydW5jYXRlZChuKXx8KHRoaXMubmV4dFZhbD10aGlzLmNvbnZlcnRWYWx1ZShuKSksdGhpcy5jb252ZXJ0VmFsdWUoZSl9LHQucHJvdG90eXBlLmNvbnZlcnRWYWx1ZT1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dGhpcy5kdHlwZXx8XCJmbG9hdDMyXCI9PT10aGlzLmR0eXBlP3Q6TWF0aC5yb3VuZCh0KX0sdC5wcm90b3R5cGUuaXNWYWxpZFRydW5jYXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdDw9dGhpcy51cHBlciYmdD49dGhpcy5sb3dlcn0sdH0oKSxocj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4scil7dGhpcy5hbHBoYT10LHRoaXMuYmV0YT0xL2UsdGhpcy5kdHlwZT1uO3ZhciBvPXJ8fE1hdGgucmFuZG9tKCk7dGhpcy5yYW5kdT1jcihvLnRvU3RyaW5nKCkpLHRoaXMucmFuZG49bmV3IGxyKDAsMSxuLCExLHRoaXMucmFuZHUoKSksdGhpcy5kPXQ8MT90KzIvMzp0LTEvMyx0aGlzLmM9MS9NYXRoLnNxcnQoOSp0aGlzLmQpfXJldHVybiB0LnByb3RvdHlwZS5uZXh0VmFsdWU9ZnVuY3Rpb24oKXtmb3IodmFyIHQsZSxuLHIsbyxhOzspe2Rve3I9dGhpcy5yYW5kbi5uZXh0VmFsdWUoKSxhPTErdGhpcy5jKnJ9d2hpbGUoYTw9MCk7aWYoYSo9YSphLGU9MS0uMzMxKih0PXIqcikqdCxuPS41KnQrdGhpcy5kKigxLWErTWF0aC5sb2coYSkpLChvPXRoaXMucmFuZHUoKSk8ZXx8TWF0aC5sb2cobyk8bilicmVha31yZXR1cm4gYT0xL3RoaXMuYmV0YSp0aGlzLmQqYSx0aGlzLmFscGhhPDEmJihhKj1NYXRoLnBvdyh0aGlzLnJhbmR1KCksMS90aGlzLmFscGhhKSksdGhpcy5jb252ZXJ0VmFsdWUoYSl9LHQucHJvdG90eXBlLmNvbnZlcnRWYWx1ZT1mdW5jdGlvbih0KXtyZXR1cm5cImZsb2F0MzJcIj09PXRoaXMuZHR5cGU/dDpNYXRoLnJvdW5kKHQpfSx0fSgpLGZyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbixyKXt2YXIgbz10aGlzO2lmKHZvaWQgMD09PXQmJih0PTApLHZvaWQgMD09PWUmJihlPTEpLHRoaXMuY2FuUmV0dXJuRmxvYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09by5kdHlwZXx8XCJmbG9hdDMyXCI9PT1vLmR0eXBlfSx0aGlzLm1pbj10LHRoaXMucmFuZ2U9ZS10LHRoaXMuZHR5cGU9bixudWxsPT1yJiYocj1NYXRoLnJhbmRvbSgpKSxcIm51bWJlclwiPT10eXBlb2YgciYmKHI9ci50b1N0cmluZygpKSwhdGhpcy5jYW5SZXR1cm5GbG9hdCgpJiZ0aGlzLnJhbmdlPD0xKXRocm93IG5ldyBFcnJvcihcIlRoZSBkaWZmZXJlbmNlIGJldHdlZW4gXCIrdCtcIiAtIFwiK2UrXCIgPD0gMSBhbmQgZHR5cGUgaXMgbm90IGZsb2F0XCIpO3RoaXMucmFuZG9tPWNyKHIpfXJldHVybiB0LnByb3RvdHlwZS5jb252ZXJ0VmFsdWU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY2FuUmV0dXJuRmxvYXQoKT90Ok1hdGgucm91bmQodCl9LHQucHJvdG90eXBlLm5leHRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnZlcnRWYWx1ZSh0aGlzLm1pbit0aGlzLnJhbmdlKnRoaXMucmFuZG9tKCkpfSx0fSgpO2Z1bmN0aW9uIGRyKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJmbG9hdDMyXCIpLGU9ZXx8XCJmbG9hdDMyXCIsbnQodCksbmV3IGd0KHQsZSxuKX1mdW5jdGlvbiBwcih0LGUpe3ZvaWQgMD09PWUmJihlPSExKSxjb25zb2xlLmxvZyh0LnRvU3RyaW5nKGUpKX12YXIgdnI9QW4oe2JhdGNoVG9TcGFjZU5EXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9bW4odCxcInhcIixcImJhdGNoVG9TcGFjZU5EXCIpLG89ZS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pKTtyZXR1cm4gQyhyLnJhbms+PTErZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJpbnB1dCByYW5rIGlzIFwiK3IucmFuaytcIiBidXQgc2hvdWxkIGJlID4gdGhhbiBibG9ja1NoYXBlLmxlbmd0aCBcIitlLmxlbmd0aH0pKSxDKG4ubGVuZ3RoPT09ZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJjcm9wcy5sZW5ndGggaXMgXCIrbi5sZW5ndGgrXCIgYnV0IHNob3VsZCBiZSBlcXVhbCB0byBibG9ja1NoYXBlLmxlbmd0aCAgXCIrZS5sZW5ndGh9KSksQyhyLnNoYXBlWzBdJW89PTAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJpbnB1dCB0ZW5zb3IgYmF0Y2ggaXMgXCIrci5zaGFwZVswXStcIiBidXQgaXMgbm90IGRpdmlzaWJsZSBieSB0aGUgcHJvZHVjdCBvZiB0aGUgZWxlbWVudHMgb2YgYmxvY2tTaGFwZSBcIitlLmpvaW4oXCIgKiBcIikrXCIgPT09IFwiK299KSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuYmF0Y2hUb1NwYWNlTkQocixlLG4pfSkseyR4OnJ9LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5zcGFjZVRvQmF0Y2hORChlLG4pfX19KSl9fSksbXI9QW4oe2Jyb2FkY2FzdFRvXzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJicm9hZGNhc3RUb1wiLFwieFwiKSxyPW4uc2hhcGU7aWYoZS5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4hKHQ+MCl8fHQlMSE9MH0pKSl0aHJvdyBuZXcgRXJyb3IoXCJicm9hZGNhc3RUbygpOiBJbnZhbGlkIGJyb2FkY2FzdCBzaGFwZSBbXCIrZStcIl0uXCIpO2lmKGUubGVuZ3RoPG4ucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJicm9hZGNhc3RUbygpOiBzaGFwZS5sZW5ndGg9XCIrZS5sZW5ndGgrXCIgPCBpbnB1dC5yYW5rPVwiK24ucmFuaytcIi5cIik7aWYoZS5sZW5ndGg+bi5yYW5rKXtmb3IodmFyIG89bi5zaGFwZS5zbGljZSgpO28ubGVuZ3RoPGUubGVuZ3RoOylvLnVuc2hpZnQoMSk7bj1uLnJlc2hhcGUobyl9Zm9yKHZhciBhPUFycmF5LmZyb20oZSksaT1lLmxlbmd0aC0xO2k+PTA7aS0tKWlmKG4uc2hhcGVbaV09PT1lW2ldKWFbaV09MTtlbHNlIGlmKDEhPT1uLnNoYXBlW2ldKXRocm93IG5ldyBFcnJvcihcImJyb2FkY2FzdFRvKCk6IFtcIityK1wiXSBjYW5ub3QgYmUgYnJvYWRjYXN0IHRvIFtcIitlK1wiXS5cIik7dmFyIHM9YS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+MT9lOi0xfSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQ+PTB9KSk7cmV0dXJuIDA9PT1zLmxlbmd0aD9uLmNsb25lKCk6THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQudGlsZShuLGEpfSkse2lucHV0Om59LChmdW5jdGlvbih0KXtyZXR1cm57aW5wdXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC5zdW0ocywhMCl9fX0pKX19KSxncj1Bbih7Y2FzdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwieFwiLFwiY2FzdFwiKTtpZighVyhlKSl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY2FzdCB0byB1bmtub3duIGR0eXBlIFwiK2UpO2lmKFwic3RyaW5nXCI9PT1lJiZcInN0cmluZ1wiIT09bi5kdHlwZXx8XCJzdHJpbmdcIiE9PWUmJlwic3RyaW5nXCI9PT1uLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIk9ubHkgc3RyaW5ncyBjYW4gYmUgY2FzdGVkIHRvIHN0cmluZ3NcIik7dmFyIHI9e2R0eXBlOmV9O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jYXN0KG4sZSl9KSx7eDpufSwoZnVuY3Rpb24odCl7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5jbG9uZSgpfX19KSxcIkNhc3RcIixyKX19KSx5cj1Bbih7Y2xvbmVfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJjbG9uZVwiLG51bGwpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbigpe3JldHVybiBMdC5tYWtlVGVuc29yRnJvbURhdGFJZChlLmRhdGFJZCxlLnNoYXBlLGUuZHR5cGUpfSkseyR4OmV9LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC50b0Zsb2F0KCl9fX0pKX19KSx4cj1Bbih7Y3Vtc3VtXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1uJiYobj0hMSksdm9pZCAwPT09ciYmKHI9ITEpO3ZhciBvPW1uKHQsXCJ4XCIsXCJjdW1zdW1cIiksYT1FbihbZXw9MF0sby5yYW5rKSxpPW87bnVsbCE9YSYmKGk9by50cmFuc3Bvc2UoYSkpO3ZhciBzPUluKDEsby5yYW5rKVswXSx1PUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmN1bXN1bShpLHMsbixyKX0pLHtwZXJtdXRlZFg6aX0sKGZ1bmN0aW9uKHQpe3JldHVybntwZXJtdXRlZFg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5jdW1zdW0oZSxuLCFyKX19fSkpO3JldHVybiBudWxsIT1hJiYodT11LnRyYW5zcG9zZShhKSksdX19KSxicj1Bbih7ZGVwdGhUb1NwYWNlXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49XCJOSFdDXCIpO3ZhciByPW1uKHQsXCJ4XCIsXCJkZXB0aFRvU3BhY2VcIiksbz1cIk5IV0NcIj09PW4/ci5zaGFwZVsxXTpyLnNoYXBlWzJdLGE9XCJOSFdDXCI9PT1uP3Iuc2hhcGVbMl06ci5zaGFwZVszXSxpPVwiTkhXQ1wiPT09bj9yLnNoYXBlWzNdOnIuc2hhcGVbMV07cmV0dXJuIEMobyplPj0wLChmdW5jdGlvbigpe3JldHVyblwiTmVnYXRpdmUgZGltZW5zaW9uIHNpemUgY2F1c2VkIGJ5IG92ZXJmbG93IHdoZW4gbXVsdGlwbHlpbmdcXG4gICAgICBcIitvK1wiIGFuZCBcIitlK1wiICBmb3IgZGVwdGhUb1NwYWNlIHdpdGggaW5wdXQgc2hhcGVcXG4gICAgICBcIityLnNoYXBlfSkpLEMoYSplPj0wLChmdW5jdGlvbigpe3JldHVyblwiTmVnYXRpdmUgZGltZW5zaW9uIHNpemUgY2F1c2VkIGJ5IG92ZXJmbG93IHdoZW4gbXVsdGlwbHlpbmdcXG4gICAgICBcIithK1wiIGFuZCBcIitlK1wiIGZvciBkZXB0aFRvU3BhY2Ugd2l0aCBpbnB1dCBzaGFwZVxcbiAgICAgICAgICBcIityLnNoYXBlfSkpLEMoaSUoZSplKT09MCwoZnVuY3Rpb24oKXtyZXR1cm5cIkRpbWVuc2lvbiBzaXplIG11c3QgYmUgZXZlbmx5IGRpdmlzaWJsZSBieSBcIitlKmUrXCIgYnV0IGlzIFwiK2krXCIgZm9yIGRlcHRoVG9TcGFjZSB3aXRoIGlucHV0IHNoYXBlIFwiK3Iuc2hhcGV9KSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGVwdGhUb1NwYWNlKHIsZSxuKX0pLHskeDpyfSl9fSksd3I9QW4oe2V4cGFuZERpbXNfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCk7dmFyIG49bW4odCxcInhcIixcImV4cGFuZERpbXNcIixudWxsKTtDKGU8PW4ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkF4aXMgbXVzdCBiZSA8PSByYW5rIG9mIHRoZSB0ZW5zb3JcIn0pKTt2YXIgcj1uLnNoYXBlLnNsaWNlKCk7cmV0dXJuIGU8MCYmKEMoLShuLnJhbmsrMSk8PWUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJBeGlzIG11c3QgYmUgaW4gdGhlIGludGVydmFsIFtcIistKG4ucmFuaysxKStcIiwgXCIrbi5yYW5rK1wiXVwifSkpLGU9bi5yYW5rK2UrMSksci5zcGxpY2UoZSwwLDEpLE9yKG4scil9fSksQ3I9QW4oe2V5ZV86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9XCJmbG9hdDMyXCIpLG51bGw9PWUmJihlPXQpO2Zvcih2YXIgbz1kcihbdCxlXSxyKSxhPXQ8PWU/dDplLGk9MDtpPGE7KytpKW8uc2V0KDEsaSxpKTt2YXIgcz1vLnRvVGVuc29yKCkuYXMyRCh0LGUpO2lmKG51bGw9PW4pcmV0dXJuIHM7aWYoMT09PW4ubGVuZ3RoKXJldHVybiBMcih3cihzLDApLFtuWzBdLDEsMV0pO2lmKDI9PT1uLmxlbmd0aClyZXR1cm4gTHIod3Iod3IocywwKSwwKSxbblswXSxuWzFdLDEsMV0pO2lmKDM9PT1uLmxlbmd0aClyZXR1cm4gTHIod3Iod3Iod3IocywwKSwwKSwwKSxbblswXSxuWzFdLG5bMl0sMSwxXSk7dGhyb3cgbmV3IEVycm9yKFwiZXllKCkgY3VycmVudGx5IHN1cHBvcnRzIG9ubHkgMUQgYW5kIDJEIGJhdGNoU2hhcGVzLCBidXQgcmVjZWl2ZWQgXCIrbi5sZW5ndGgrXCJELlwiKX19KSxFcj1Bbih7bXVsdGlub21pYWxfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPSExKTt2YXIgbz1tbih0LFwibG9naXRzXCIsXCJtdWx0aW5vbWlhbFwiKSxhPW8uc2l6ZSxpPW8ucmFuaztpZihhPDIpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbXVsdGlub21pYWw6IHlvdSBuZWVkIGF0IGxlYXN0IDIgb3V0Y29tZXMsIGJ1dCBnb3QgXCIrYStcIi5cIik7aWYoaT4yKXRocm93IG5ldyBFcnJvcihcIlJhbmsgb2YgcHJvYmFiaWxpdGllcyBtdXN0IGJlIDEgb3IgMiwgYnV0IGlzIFwiK2kpO249bnx8TWF0aC5yYW5kb20oKTt2YXIgcz0xPT09aT9vLmFzMkQoMSwtMSk6byx1PUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm11bHRpbm9taWFsKHMscixlLG4pfSkse2xvZ2l0czJEOnN9KTtyZXR1cm4gMT09PWk/dS5hczFEKCk6dX19KSxScj1Bbih7b25lSG90XzpmdW5jdGlvbih0LGUsbixyKXtpZih2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj0wKSxlPDIpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gb25lSG90OiBkZXB0aCBtdXN0IGJlID49MiwgYnV0IGl0IGlzIFwiK2UpO3ZhciBvPW1uKHQsXCJpbmRpY2VzXCIsXCJvbmVIb3RcIixcImludDMyXCIpLGE9by5zaGFwZS5jb25jYXQoW2VdKTtyZXR1cm4gbz1vLmZsYXR0ZW4oKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5vbmVIb3QobyxlLG4scil9KSx7JGluZGljZXM6b30sKGZ1bmN0aW9uKHQpe3JldHVybnskaW5kaWNlczpmdW5jdGlvbigpe3JldHVybiBHbihvLnNoYXBlLFwiZmxvYXQzMlwiKX19fSkpLnJlc2hhcGUoYSl9fSksSXI9QW4oe3BhZF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPTApO3ZhciByPW1uKHQsXCJ4XCIsXCJwYWRcIik7aWYoMD09PXIucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJwYWQoc2NhbGFyKSBpcyBub3QgZGVmaW5lZC4gUGFzcyBub24tc2NhbGFyIHRvIHBhZFwiKTt2YXIgbz17cGFkZGluZ3M6ZSxjb25zdGFudFZhbHVlOm59O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5wYWQocixlLG4pfSkse3g6cn0sKGZ1bmN0aW9uKHQpe3ZhciBuPWUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pKTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LnNsaWNlKG4sci5zaGFwZSl9fX0pLFwiUGFkVjJcIixvKX19KSxrcj1Bbih7cGFkMWRfOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksQygyPT09ZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMi5cIn0pKSxJcih0LFtlXSxuKX19KSxTcj1Bbih7cGFkMmRfOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksQygyPT09ZS5sZW5ndGgmJjI9PT1lWzBdLmxlbmd0aCYmMj09PWVbMV0ubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC5cIn0pKSxJcih0LGUsbil9fSksQXI9QW4oe3BhZDNkXzpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTApLEMoMz09PWUubGVuZ3RoJiYyPT09ZVswXS5sZW5ndGgmJjI9PT1lWzFdLmxlbmd0aCYmMj09PWVbMl0ubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC5cIn0pKSxJcih0LGUsbil9fSksRHI9QW4oe3BhZDRkXzpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTApLEMoND09PWUubGVuZ3RoJiYyPT09ZVswXS5sZW5ndGgmJjI9PT1lWzFdLmxlbmd0aCYmMj09PWVbMl0ubGVuZ3RoJiYyPT09ZVszXS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMiBlYWNoLlwifSkpLElyKHQsZSxuKX19KSxUcj1Bbih7cmFuZF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPWsodCksbz1udWxsO2lmKG51bGw9PW58fFwiZmxvYXQzMlwiPT09bilvPW5ldyBGbG9hdDMyQXJyYXkocik7ZWxzZSBpZihcImludDMyXCI9PT1uKW89bmV3IEludDMyQXJyYXkocik7ZWxzZXtpZihcImJvb2xcIiE9PW4pdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrbik7bz1uZXcgVWludDhBcnJheShyKX1mb3IodmFyIGE9MDthPHI7YSsrKW9bYV09ZSgpO3JldHVybiBMdC5tYWtlVGVuc29yKG8sdCxuKX19KSxOcj1Bbih7cmFuZG9tTm9ybWFsXzpmdW5jdGlvbih0LGUsbixyLG8pe2lmKHZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PW4mJihuPTEpLG51bGwhPXImJlwiYm9vbFwiPT09cil0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUgXCIrcik7Zm9yKHZhciBhPW5ldyBscihlLG4sciwhMSxvKSxpPWRyKHQscikscz0wO3M8aS52YWx1ZXMubGVuZ3RoO3MrKylpLnZhbHVlc1tzXT1hLm5leHRWYWx1ZSgpO3JldHVybiBpLnRvVGVuc29yKCl9fSksRnI9QW4oe3JhbmRvbUdhbW1hXzpmdW5jdGlvbih0LGUsbixyLG8pe2lmKHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PXImJihyPVwiZmxvYXQzMlwiKSxudWxsPT1uJiYobj0xKSxudWxsPT1yJiYocj1cImZsb2F0MzJcIiksXCJmbG9hdDMyXCIhPT1yJiZcImludDMyXCIhPT1yKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSBcIityKTtmb3IodmFyIGE9bmV3IGhyKGUsbixyLG8pLGk9ZHIodCxyKSxzPTA7czxpLnZhbHVlcy5sZW5ndGg7cysrKWkudmFsdWVzW3NdPWEubmV4dFZhbHVlKCk7cmV0dXJuIGkudG9UZW5zb3IoKX19KSxfcj1Bbih7cmFuZG9tVW5pZm9ybV86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj1cImZsb2F0MzJcIik7Zm9yKHZhciBhPWRyKHQsciksaT1uZXcgZnIoZSxuLG51bGwsbykscz0wO3M8YS52YWx1ZXMubGVuZ3RoO3MrKylhLnZhbHVlc1tzXT1pLm5leHRWYWx1ZSgpO3JldHVybiBhLnRvVGVuc29yKCl9fSksT3I9QW4oe3Jlc2hhcGVfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcInhcIixcInJlc2hhcGVcIixudWxsKTtlPV8oZSxuLnNpemUpLEMobi5zaXplPT09ayhlKSwoZnVuY3Rpb24oKXtyZXR1cm5cIm5ldyBzaGFwZSBhbmQgb2xkIHNoYXBlIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuXCJ9KSk7dmFyIHI9e3NoYXBlOmV9O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZXNoYXBlKG4sZSl9KSx7eDpufSwoZnVuY3Rpb24odCl7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5yZXNoYXBlKG4uc2hhcGUpfX19KSxcIlJlc2hhcGVcIixyKX19KSxNcj1Bbih7c3BhY2VUb0JhdGNoTkRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1tbih0LFwieFwiLFwic3BhY2VUb0JhdGNoTkRcIik7cmV0dXJuIEMoci5yYW5rPj0xK2UubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiaW5wdXQgcmFuayBcIityLnJhbmsrXCIgc2hvdWxkIGJlID4gdGhhbiBbYmxvY2tTaGFwZV0gXCIrZS5sZW5ndGh9KSksQyhuLmxlbmd0aD09PWUubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwicGFkZGluZ3Muc2hhcGVbMF0gXCIrbi5sZW5ndGgrXCIgbXVzdCBiZSBlcXVhbCB0byBbYmxvY2tTaGFwZV0gXCIrZS5sZW5ndGh9KSksQyhyLnNoYXBlLnJlZHVjZSgoZnVuY3Rpb24odCxyLG8pe3JldHVybiBvPjAmJm88PWUubGVuZ3RoP3QmJihyK25bby0xXVswXStuW28tMV1bMV0pJWVbby0xXT09MDp0fSksITApLChmdW5jdGlvbigpe3JldHVyblwiaW5wdXQgc3BhdGlhbCBkaW1lbnNpb25zIFwiK3Iuc2hhcGUuc2xpY2UoMSkrXCIgd2l0aCBwYWRkaW5ncyBcIituLnRvU3RyaW5nKCkrXCIgbXVzdCBiZSBkaXZpc2libGUgYnkgYmxvY2tTaGFwZXMgXCIrZS50b1N0cmluZygpfSkpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNwYWNlVG9CYXRjaE5EKHIsZSxuKX0pLHskeDpyfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuYmF0Y2hUb1NwYWNlTkQoZSxuKX19fSkpfX0pLEJyPUFuKHtzcXVlZXplXzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJ4XCIsXCJzcXVlZXplXCIpO3JldHVybiBPcihuLE0obi5zaGFwZSxlKS5uZXdTaGFwZSl9fSksUHI9QW4oe3N0YWNrXzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApO3ZhciBuPWduKHQsXCJ0ZW5zb3JzXCIsXCJzdGFja1wiKTtpZihDKG4ubGVuZ3RoPj0xLChmdW5jdGlvbigpe3JldHVyblwiUGFzcyBhdCBsZWFzdCBvbmUgdGVuc29yIHRvIHRmLnN0YWNrXCJ9KSksMT09PW4ubGVuZ3RoKXJldHVybiBuWzBdLmV4cGFuZERpbXMoZSk7dmFyIHI9blswXS5yYW5rLG89blswXS5zaGFwZSxhPW5bMF0uZHR5cGU7QyhlPD1yLChmdW5jdGlvbigpe3JldHVyblwiQXhpcyBtdXN0IGJlIDw9IHJhbmsgb2YgdGhlIHRlbnNvclwifSkpLG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7RShvLHQuc2hhcGUsXCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gc3RhY2sgbXVzdCBoYXZlIG1hdGNoaW5nIHNoYXBlc1wiKX0pKSxuLmZvckVhY2goKGZ1bmN0aW9uKHQpe0MoYT09PXQuZHR5cGUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gc3RhY2sgbXVzdCBoYXZlIG1hdGNoaW5nIGR0eXBlc1wifSkpfSkpO3ZhciBpPW4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5leHBhbmREaW1zKGUpfSkpO3JldHVybiBZbihpLGUpfX0pLExyPUFuKHt0aWxlXzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJ4XCIsXCJ0aWxlXCIsbnVsbCk7QyhuLnJhbms9PT1lLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHRyYW5zcG9zZTogcmFuayBvZiBpbnB1dCBcIituLnJhbmsrXCIgbXVzdCBtYXRjaCBsZW5ndGggb2YgcmVwcyBcIitlK1wiLlwifSkpO3ZhciByPVtuXSxvPXtyZXBzOmV9O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LHIpe3ZhciBvPXQudGlsZShuLGUpO3JldHVybiByKFtuXSksb30pLHt4Om59LChmdW5jdGlvbih0LG4pe3ZhciByPW5bMF07cmV0dXJue3g6ZnVuY3Rpb24oKXt2YXIgbj1YbihyKTtpZigxPT09ci5yYW5rKWZvcih2YXIgbz0wO288ZVswXTsrK28pbj1uLmFkZCh0LnNsaWNlKFtvKnIuc2hhcGVbMF1dLFtyLnNoYXBlWzBdXSkpO2Vsc2UgaWYoMj09PXIucmFuaylmb3Iobz0wO288ZVswXTsrK28pZm9yKHZhciBhPTA7YTxlWzFdOysrYSluPW4uYWRkKHQuc2xpY2UoW28qci5zaGFwZVswXSxhKnIuc2hhcGVbMV1dLFtyLnNoYXBlWzBdLHIuc2hhcGVbMV1dKSk7ZWxzZSBpZigzPT09ci5yYW5rKWZvcihvPTA7bzxlWzBdOysrbylmb3IoYT0wO2E8ZVsxXTsrK2EpZm9yKHZhciBpPTA7aTxlWzJdOysraSluPW4uYWRkKHQuc2xpY2UoW28qci5zaGFwZVswXSxhKnIuc2hhcGVbMV0saSpyLnNoYXBlWzJdXSxbci5zaGFwZVswXSxyLnNoYXBlWzFdLHIuc2hhcGVbMl1dKSk7ZWxzZXtpZig0IT09ci5yYW5rKXRocm93IG5ldyBFcnJvcihcIkdyYWRpZW50IGZvciB0aWxlIG9wZXJhdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIHJhbmstXCIrci5yYW5rK1wiIHRlbnNvcnMgeWV0LlwiKTtmb3Iobz0wO288ZVswXTsrK28pZm9yKGE9MDthPGVbMV07KythKWZvcihpPTA7aTxlWzJdOysraSlmb3IodmFyIHM9MDtzPGVbM107KytzKW49bi5hZGQodC5zbGljZShbbypyLnNoYXBlWzBdLGEqci5zaGFwZVsxXSxpKnIuc2hhcGVbMl0scypyLnNoYXBlWzNdXSxbci5zaGFwZVswXSxyLnNoYXBlWzFdLHIuc2hhcGVbMl0sci5zaGFwZVszXV0pKX1yZXR1cm4gbn19fSksXCJUaWxlXCIsbyxyKX19KSxXcj1Bbih7dHJ1bmNhdGVkTm9ybWFsXzpmdW5jdGlvbih0LGUsbixyLG8pe2lmKHZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PW4mJihuPTEpLG51bGwhPXImJlwiYm9vbFwiPT09cil0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUgXCIrcik7Zm9yKHZhciBhPW5ldyBscihlLG4sciwhMCxvKSxpPWRyKHQscikscz0wO3M8aS52YWx1ZXMubGVuZ3RoO3MrKylpLnZhbHVlc1tzXT1hLm5leHRWYWx1ZSgpO3JldHVybiBpLnRvVGVuc29yKCl9fSksVXI9QW4oe3Vuc3RhY2tfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCksZT1lfHwwO3ZhciBuPW1uKHQsXCJ4XCIsXCJ1bnN0YWNrXCIpO0MoZT49LW4uc2hhcGUubGVuZ3RoJiZlPG4uc2hhcGUubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiQXhpcyA9IFwiK2UrXCIgaXMgbm90IGluIFstXCIrbi5zaGFwZS5sZW5ndGgrXCIsIFwiK24uc2hhcGUubGVuZ3RoK1wiKVwifSkpLGU8MCYmKGUrPW4uc2hhcGUubGVuZ3RoKTt2YXIgcj17YXhpczplfTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQudW5zdGFjayhuLGUpfSkse3g6bn0sKGZ1bmN0aW9uKHQpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIFByKHQsZSl9fX0pLFwiVW5wYWNrXCIscil9fSksVnI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sbyxhLGkscyx1LGMsbCxoLGY7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbj1tbih0LFwieFwiLFwic2V0ZGlmZjFkXCIpLG89bW4oZSxcInlcIixcInNldGRpZmYxZFwiKSxDKG4uZHR5cGU9PT1vLmR0eXBlLChmdW5jdGlvbigpe3JldHVyblwieCBhbmQgeSBzaG91bGQgaGF2ZSB0aGUgc2FtZSBkdHlwZSwgYnV0IGdvdCB4IChcIituLmR0eXBlK1wiKSBhbmQgeSAoXCIrby5kdHlwZStcIikuXCJ9KSksQygxPT09bi5yYW5rLChmdW5jdGlvbigpe3JldHVyblwieCBzaG91bGQgYmUgMUQgdGVuc29yLCBidXQgZ290IHggKFwiK24uc2hhcGUrXCIpLlwifSkpLEMoMT09PW8ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cInkgc2hvdWxkIGJlIDFEIHRlbnNvciwgYnV0IGdvdCB5IChcIitvLnNoYXBlK1wiKS5cIn0pKSxbNCxuLmRhdGEoKV07Y2FzZSAxOnJldHVybiBhPXIuc2VudCgpLFs0LG8uZGF0YSgpXTtjYXNlIDI6Zm9yKGk9ci5zZW50KCkscz1uZXcgU2V0KGkpLHU9MCxoPTA7aDxhLmxlbmd0aDtoKyspcy5oYXMoYVtoXSl8fHUrKztmb3IoYz1uZXcgZ3QoW3VdLG4uZHR5cGUpLGw9bmV3IGd0KFt1XSxcImludDMyXCIpLGg9MCxmPTA7aDxhLmxlbmd0aDtoKyspcy5oYXMoYVtoXSl8fChjLnZhbHVlc1tmXT1hW2hdLGwudmFsdWVzW2ZdPWgsZisrKTtyZXR1cm5bMixbYy50b1RlbnNvcigpLGwudG9UZW5zb3IoKV1dfX0pKX0pKX07ZnVuY3Rpb24genIodCxlLG4scil7dm9pZCAwPT09ciYmKHI9ITApO3ZhciBvPVtdO2lmKHIpKG89by5jb25jYXQoZS5zbGljZSgwKSkpLnB1c2godFswXS9uKSxvPW8uY29uY2F0KHQuc2xpY2UoMSkpO2Vsc2V7bz1vLmNvbmNhdCh0WzBdKTtmb3IodmFyIGE9ZS5sZW5ndGgsaT0wO2k8YTsrK2kpbz1vLmNvbmNhdChbdFtpKzFdL2VbaV0sZVtpXV0pO289by5jb25jYXQodC5zbGljZShhKzEpKX1yZXR1cm4gb31mdW5jdGlvbiBHcih0LGUsbil7dm9pZCAwPT09biYmKG49ITApO3ZhciByPVtdO2lmKG4pe3IucHVzaChlKTtmb3IodmFyIG89ZSsxO288dDsrK28pbzw9MiplPyhyLnB1c2gobyksci5wdXNoKG8tKGUrMSkpKTpyLnB1c2gobyl9ZWxzZXt2YXIgYT1bXSxpPVtdO2ZvcihvPTE7bzx0OysrbylvPj0yKmUrMXx8byUyPT0xP2kucHVzaChvKTphLnB1c2gobyk7ci5wdXNoLmFwcGx5KHIsYSksci5wdXNoKDApLHIucHVzaC5hcHBseShyLGkpfXJldHVybiByfWZ1bmN0aW9uIEhyKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPSEwKTt2YXIgbz1bXTtyP28ucHVzaCh0WzBdL24pOm8ucHVzaCh0WzBdKm4pO2Zvcih2YXIgYT0xO2E8dC5sZW5ndGg7KythKWE8PWUubGVuZ3RoP3I/by5wdXNoKGVbYS0xXSp0W2FdKTpvLnB1c2godFthXS9lW2EtMV0pOm8ucHVzaCh0W2FdKTtyZXR1cm4gb31mdW5jdGlvbiBxcih0LGUpe2Zvcih2YXIgbj1bMF0scj0wO3I8ZTsrK3Ipbi5wdXNoKHRbcl1bMF0pO3JldHVybiBufWZ1bmN0aW9uIEtyKHQsZSxuKXtmb3IodmFyIHI9dC5zbGljZSgwLDEpLG89MDtvPG47KytvKXIucHVzaCh0W28rMV0tZVtvXVswXS1lW29dWzFdKTtyZXR1cm4gcn1mdW5jdGlvbiBqcih0LGUpe2lmKHQucmFuazwxKXRocm93IG5ldyBFcnJvcihcInRmLmdhdGhlck5EKCkgZXhwZWN0cyB0aGUgaW5wdXQgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyBcIit0LnJhbmsrXCIuXCIpO2lmKGUucmFuazwxKXRocm93IG5ldyBFcnJvcihcInRmLmdhdGhlck5EKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzIFwiK2UucmFuaytcIi5cIik7aWYoXCJpbnQzMlwiIT09ZS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5nYXRoZXJORCgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgaW50MzIgdHlwZSwgYnV0IHRoZSBkdHlwZSB3YXMgXCIrZS5kdHlwZStcIi5cIik7aWYoZS5zaGFwZVtlLnJhbmstMV0+dC5yYW5rKXRocm93IG5ldyBFcnJvcihcImluZGV4IGlubmVybW9zdCBkaW1lbnNpb24gbGVuZ3RoIG11c3QgYmUgPD0gdGVuc29yIHJhbms7IHNhdzogXCIrZS5zaGFwZVtlLnJhbmstMV0rXCIgdnMuIFwiK3QucmFuayk7aWYoMD09PXQuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgbW9yZSB0aGFuIDAgZW50cmllcywgYnV0IGlucHV0IGlzIGVtcHR5LiBJbnB1dCBzaGFwZTogXCIrdC5zaGFwZStcIi5cIik7Zm9yKHZhciBuPWUuc2hhcGUscj1uW24ubGVuZ3RoLTFdLG89MSxhPTA7YTxuLmxlbmd0aC0xOysrYSlvKj1uW2FdO3ZhciBpPXQuc2hhcGUscz1uLnNsaWNlKCk7cy5wb3AoKTt2YXIgdT0xO2ZvcihhPXI7YTx0LnJhbms7KythKXUqPWlbYV0scy5wdXNoKGlbYV0pO3ZhciBjPSQodC5zaGFwZSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC91fSkpLmNvbmNhdChbMV0pLnNsaWNlKDAscik7cmV0dXJuW3Msbyx1LGNdfXZhciBYcj1PYmplY3QuZnJlZXplKHtwcmVwYXJlQW5kVmFsaWRhdGU6anJ9KSxZcj0zMDtmdW5jdGlvbiAkcih0KXtyZXR1cm4gdDw9WXI/dDpZKHQsTWF0aC5mbG9vcihNYXRoLnNxcnQodCkpKX1mdW5jdGlvbiBRcih0LGUsbil7dmFyIHI9ZS5yYW5rPjE/ZS5zaGFwZVtlLnJhbmstMV06MSxvPWUucmFuaz4xP2UucmFuay0xOjEsYT1cIk11c3QgaGF2ZSB1cGRhdGVzLnNoYXBlID0gaW5kaWNlcy5zaGFwZVs6YmF0Y2hEaW1dICsgc2hhcGVbc2xpY2VEaW06XSwgZ290IHVwZGF0ZXMuc2hhcGU6IFwiK24uc2hhcGUrXCIsIGluZGljZXMuc2hhcGU6IFwiK2Uuc2hhcGUrXCIsIHNoYXBlOiBcIit0K1wiLCBzbGljZURpbTogXCIrcitcIiwgYW5kIGJhdGNoRGltOiBcIitvK1wiLlwiO2lmKG4ucmFuazxvKXRocm93IG5ldyBFcnJvcihhK1wiIHVwZGF0ZS5yYW5rIDwgXCIrbytcIi4gXCIpO2lmKHQubGVuZ3RoPHIrKG4ucmFuay1vKSl0aHJvdyBuZXcgRXJyb3IoYStcIiBPdXRwdXQgc2hhcGUgbGVuZ3RoIDwgXCIrKHIrKG4ucmFuay1vKSkpO2lmKG4ucmFuayE9PW8rdC5sZW5ndGgtcil0aHJvdyBuZXcgRXJyb3IoYStcIiB1cGRhdGUucmFuayAhPSBcIisobyt0Lmxlbmd0aC1yKSk7Zm9yKHZhciBpPTA7aTxvOysraSlpZihuLnNoYXBlW2ldIT09ZS5zaGFwZVtpXSl0aHJvdyBuZXcgRXJyb3IoYStcIiB1cGRhdGVzLnNoYXBlW1wiK2krXCJdIChcIituLnNoYXBlW2ldK1wiKSAhPSBpbmRpY2VzLnNoYXBlW1wiK2krXCJdIChcIitlLnNoYXBlW2ldK1wiKS5cIik7Zm9yKGk9MDtpPG4ucmFuay1vOysraSlpZihuLnNoYXBlW2krb10hPT10W2krcl0pdGhyb3cgbmV3IEVycm9yKGErXCIgdXBkYXRlcy5zaGFwZVtcIisoaStvKStcIl0gKFwiK24uc2hhcGVbaStvXStcIikgIT0gc2hhcGVbXCIrKGkrbykrXCJdIChcIit0W2krb10rXCIpXCIpfWZ1bmN0aW9uIEpyKHQsZSxuKXtpZihlLnJhbms8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5zY2F0dGVyTkQoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIHJhbmsgMSBvciBoaWdoZXIsIGJ1dCB0aGUgcmFuayB3YXMgXCIrZS5yYW5rK1wiLlwiKTtpZih0LnJhbms8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5zY2F0dGVyTkQoKSBleHBlY3RzIHRoZSB1cGRhdGVzIHRvIGJlIHJhbmsgMSBvciBoaWdoZXIsIGJ1dCB0aGUgcmFuayB3YXMgXCIrdC5yYW5rK1wiLlwiKTtpZihcImludDMyXCIhPT1lLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlRoZSBkdHlwZSBvZiAnaW5kaWNlcycgc2hvdWxkIGJlIGludDMyLCBidXQgZ290IGR0eXBlOiBcIitlLmR0eXBlKTtpZihuLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIk91dHB1dCByYW5rIG11c3QgYmUgZ3JlYXRlciBvciBlcXVhbCB0byAxLCBidXQgZ290IHNoYXBlOiBcIituKTtpZigwPT09bi5sZW5ndGgpe2lmKDA9PT1lLnNpemUpdGhyb3cgbmV3IEVycm9yKFwiSW5kaWNlcyBzcGVjaWZpZWQgZm9yIGVtcHR5IG91dHB1dC4gaW5kaWNlcyBzaGFwZTogXCIrZS5zaGFwZSk7aWYoMD09PXQuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJVcGRhdGVzIHNwZWNpZmllZCBmb3IgZW1wdHkgb3V0cHV0LiB1cGRhdGVzIHNoYXBlOiBcIit0LnNoYXBlKX1RcihuLGUsdCl9ZnVuY3Rpb24gWnIodCxlLG4pe2Zvcih2YXIgcj1lLnNoYXBlLmxlbmd0aCxvPXI+MT9lLnNoYXBlW3ItMV06MSxhPW4ubGVuZ3RoLGk9MSxzPW87czxhOysrcylpKj1uW3NdO3ZhciB1PW88MT8xOm87cmV0dXJue3NsaWNlUmFuazpvLG51bVVwZGF0ZXM6ayhlLnNoYXBlKS91LHNsaWNlU2l6ZTppLHN0cmlkZXM6JChuLnNsaWNlKDAsbykpLmNvbmNhdChbMV0pLG91dHB1dFNpemU6ayhuKX19dmFyIHRvPU9iamVjdC5mcmVlemUoe3ZhbGlkYXRlVXBkYXRlU2hhcGU6UXIsdmFsaWRhdGVJbnB1dDpKcixjYWxjdWxhdGVTaGFwZXM6WnJ9KTtmdW5jdGlvbiBlbyh0LGUsbil7Qyh0LnJhbms9PT1lLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNsaWNlXCIrdC5yYW5rK1wiRDogTGVuZ3RoIG9mIGJlZ2luIFwiK2UrXCIgbXVzdCBtYXRjaCB0aGUgcmFuayBvZiB0aGUgYXJyYXkgKFwiK3QucmFuaytcIikuXCJ9KSksQyh0LnJhbms9PT1uLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNsaWNlXCIrdC5yYW5rK1wiRDogTGVuZ3RoIG9mIHNpemUgXCIrbitcIiBtdXN0IG1hdGNoIHRoZSByYW5rIG9mIHRoZSBhcnJheSAoXCIrdC5yYW5rK1wiKS5cIn0pKTtmb3IodmFyIHI9ZnVuY3Rpb24ocil7QyhlW3JdK25bcl08PXQuc2hhcGVbcl0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzbGljZVwiK3QucmFuaytcIkQ6IGJlZ2luW1wiK3IrXCJdICsgc2l6ZVtcIityK1wiXSAoXCIrKGVbcl0rbltyXSkrXCIpIHdvdWxkIG92ZXJmbG93IGlucHV0LnNoYXBlW1wiK3IrXCJdIChcIit0LnNoYXBlW3JdK1wiKVwifSkpfSxvPTA7bzx0LnJhbms7KytvKXIobyl9ZnVuY3Rpb24gbm8odCl7Zm9yKHZhciBlPVtdLG49MDt0PjA7KTEmdCYmZS5wdXNoKG4pLHQvPTIsbisrO3JldHVybiBlfWZ1bmN0aW9uIHJvKHQsZSxuKXtmb3IodmFyIHI9W10sbz0wO288dC5sZW5ndGg7bysrKXJbb109TWF0aC5jZWlsKChlW29dLXRbb10pL25bb10pO3JldHVybiByfWZ1bmN0aW9uIG9vKHQsZSxuLHIsbyl7dmFyIGE9ZVtvXSxpPW5bb118fDE7KHQmMTw8b3x8bnVsbD09YSkmJihhPWk+MD9OdW1iZXIuTUlOX1NBRkVfSU5URUdFUjpOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7dmFyIHM9cltvXTtyZXR1cm4gYTwwJiYoYSs9cyksYT14KDAsYSxzLTEpfWZ1bmN0aW9uIGFvKHQsZSxuLHIsbyl7dmFyIGE9ZVtvXSxpPW5bb118fDE7KHQmMTw8b3x8bnVsbD09YSkmJihhPWk+MD9OdW1iZXIuTUFYX1NBRkVfSU5URUdFUjpOdW1iZXIuTUlOX1NBRkVfSU5URUdFUik7dmFyIHM9cltvXTtyZXR1cm4gYTwwJiYoYSs9cyksYT1pPjA/eCgwLGEscyk6eCgtMSxhLHMtMSl9ZnVuY3Rpb24gaW8odCxlLG4pe2Zvcih2YXIgcj1uLmxlbmd0aCxvPTA7bzxuLmxlbmd0aDtvKyspaWYobltvXT4xKXtyPW87YnJlYWt9Zm9yKG89cisxO288bi5sZW5ndGg7bysrKWlmKGVbb10+MHx8bltvXSE9PXRbb10pcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gc28odCxlKXtmb3IodmFyIG49dC5sZW5ndGg+MD90W3QubGVuZ3RoLTFdOjEscj0wO3I8dC5sZW5ndGgtMTtyKyspbis9dFtyXSplW3JdO3JldHVybiBufXZhciB1bz1PYmplY3QuZnJlZXplKHthc3NlcnRQYXJhbXNWYWxpZDplbyxtYXNrVG9BeGVzOm5vLGNvbXB1dGVPdXRTaGFwZTpybyxzdGFydEZvckF4aXM6b28sc3RvcEZvckF4aXM6YW8saXNTbGljZUNvbnRpbm91czppbyxjb21wdXRlRmxhdE9mZnNldDpzb30pO2Z1bmN0aW9uIGNvKHQpe3JldHVybiBDKFgodCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gZ3JhZChmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIn0pKSxmdW5jdGlvbihlLG4pe3ZhciByPW1uKGUsXCJ4XCIsXCJ0Zi5ncmFkXCIsbnVsbCksbz1udWxsIT1uP21uKG4sXCJkeVwiLFwidGYuZ3JhZFwiKTpudWxsO3JldHVybiBMdC50aWR5KChmdW5jdGlvbigpe3ZhciBlPUx0LmdyYWRpZW50cygoZnVuY3Rpb24oKXtyZXR1cm4gdChyKX0pLFtyXSxvKSxuPWUudmFsdWUsYT1lLmdyYWRzO3JldHVybiBudWxsIT1vJiZFKG4uc2hhcGUsby5zaGFwZSxcIlRoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gZ3JhZChmKSh4LCBkeSkgbXVzdCBtYXRjaCB0aGUgc2hhcGUgcmV0dXJuZWQgYnkgZih4KVwiKSxtbyhhKSxhWzBdfSkpfX1mdW5jdGlvbiBsbyh0KXtyZXR1cm4gQyhYKHQpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIGdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvblwifSkpLGZ1bmN0aW9uKGUsbil7QyhBcnJheS5pc0FycmF5KGUpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGFyZ3MgcGFzc2VkIGluIGdyYWRzKGYpKGFyZ3MpIG11c3QgYmUgYW4gYXJyYXkgb2YgYFRlbnNvcmBzIG9yIGBUZW5zb3JMaWtlYHNcIn0pKTt2YXIgcj1nbihlLFwiYXJnc1wiLFwidGYuZ3JhZHNcIixudWxsKSxvPW51bGwhPW4/bW4obixcImR5XCIsXCJ0Zi5ncmFkc1wiKTpudWxsO3JldHVybiBMdC50aWR5KChmdW5jdGlvbigpe3ZhciBlPUx0LmdyYWRpZW50cygoZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseSh2b2lkIDAscil9KSxyLG8pLG49ZS52YWx1ZSxhPWUuZ3JhZHM7cmV0dXJuIG51bGwhPW8mJkUobi5zaGFwZSxvLnNoYXBlLFwiVGhlIHNoYXBlIG9mIGR5IHBhc3NlZCBpbiBncmFkcyhmKShbeDEsLi4uXSwgZHkpIG11c3QgbWF0Y2ggdGhlIHNoYXBlIHJldHVybmVkIGJ5IGYoW3gxLC4uLl0pXCIpLG1vKGEpLGF9KSl9fWZ1bmN0aW9uIGhvKHQpe3JldHVybiBDKFgodCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkKGYpIG11c3QgYmUgYSBmdW5jdGlvblwifSkpLGZ1bmN0aW9uKGUsbil7QyhlIGluc3RhbmNlb2Ygd3QsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgeCBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkKGYpKHgpIG11c3QgYmUgYSB0ZW5zb3JcIn0pKSxDKG51bGw9PW58fG4gaW5zdGFuY2VvZiB3dCwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkKGYpKHgsIGR5KSBtdXN0IGJlIGEgdGVuc29yXCJ9KSk7dmFyIHI9THQuZ3JhZGllbnRzKChmdW5jdGlvbigpe3JldHVybiB0KGUpfSksW2VdLG4pLG89ci5ncmFkcyxhPXIudmFsdWU7cmV0dXJuIG1vKG8pLHtncmFkOm9bMF0sdmFsdWU6YX19fWZ1bmN0aW9uIGZvKHQpe3JldHVybiBDKFgodCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIn0pKSxmdW5jdGlvbihlLG4pe0MoQXJyYXkuaXNBcnJheShlKSYmZS5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiB3dH0pKSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBhcmdzIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpKGFyZ3MpIG11c3QgYmUgYXJyYXkgb2YgdGVuc29yc1wifSkpLEMobnVsbD09bnx8biBpbnN0YW5jZW9mIHd0LChmdW5jdGlvbigpe3JldHVyblwiVGhlIGR5IHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpKGFyZ3MsIGR5KSBtdXN0IGJlIGEgdGVuc29yXCJ9KSk7dmFyIHI9THQuZ3JhZGllbnRzKChmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KHZvaWQgMCxlKX0pLGUsbik7cmV0dXJuIG51bGwhPW4mJkUoci52YWx1ZS5zaGFwZSxuLnNoYXBlLFwiVGhlIHNoYXBlIG9mIGR5IHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpKFt4MSwuLi5dLCBkeSkgbXVzdCBtYXRjaCB0aGUgc2hhcGUgcmV0dXJuZWQgYnkgZihbeDEsLi4uXSlcIiksbW8oci5ncmFkcykscn19ZnVuY3Rpb24gcG8odCxlKXtDKFgodCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gdmFyaWFibGVHcmFkcyhmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIn0pKSxDKG51bGw9PWV8fEFycmF5LmlzQXJyYXkoZSkmJmUuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgU3R9KSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgdmFyTGlzdCBwYXNzZWQgaW4gdmFyaWFibGVHcmFkcyhmLCB2YXJMaXN0KSBtdXN0IGJlIGFuIGFycmF5IG9mIHZhcmlhYmxlc1wifSkpO3ZhciBuPW51bGwhPWU7aWYoIW4pZm9yKHZhciByIGluIGU9W10sTHQucmVnaXN0ZXJlZFZhcmlhYmxlcyllLnB1c2goTHQucmVnaXN0ZXJlZFZhcmlhYmxlc1tyXSk7dmFyIG89bj9lLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIXQudHJhaW5hYmxlfSkpOm51bGwsYT1lLmxlbmd0aDtDKChlPWUuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdC50cmFpbmFibGV9KSkpLmxlbmd0aD4wLChmdW5jdGlvbigpe3JldHVyblwidmFyaWFibGVHcmFkcygpIGV4cGVjdHMgYXQgbGVhc3Qgb25lIG9mIHRoZSBpbnB1dCB2YXJpYWJsZXMgdG8gYmUgdHJhaW5hYmxlLCBidXQgbm9uZSBvZiB0aGUgXCIrYStcIiB2YXJpYWJsZXMgaXMgdHJhaW5hYmxlLlwifSkpO3ZhciBpPUx0LmdyYWRpZW50cyh0LGUsbnVsbCwhMCkscz1pLnZhbHVlLHU9aS5ncmFkcztDKHUuc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXR9KSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJDYW5ub3QgZmluZCBhIGNvbm5lY3Rpb24gYmV0d2VlbiBhbnkgdmFyaWFibGUgYW5kIHRoZSByZXN1bHQgb2YgdGhlIGxvc3MgZnVuY3Rpb24geT1mKHgpLiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBvcGVyYXRpb25zIHRoYXQgdXNlIHZhcmlhYmxlcyBhcmUgaW5zaWRlIHRoZSBmdW5jdGlvbiBmIHBhc3NlZCB0byBtaW5pbWl6ZSgpLlwifSkpLEMoMD09PXMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYpIG11c3QgcmV0dXJuIGEgc2NhbGFyLCBidXQgaXQgcmV0dXJuZWQgYSByYW5rLVwiK3MucmFuaytcIiB0ZW5zb3JcIn0pKTt2YXIgYz17fTtyZXR1cm4gZS5mb3JFYWNoKChmdW5jdGlvbih0LGUpe251bGwhPXVbZV0mJihjW3QubmFtZV09dVtlXSl9KSksbnVsbCE9byYmby5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gY1t0Lm5hbWVdPW51bGx9KSkse3ZhbHVlOnMsZ3JhZHM6Y319ZnVuY3Rpb24gdm8odCl7cmV0dXJuIEx0LmN1c3RvbUdyYWQodCl9ZnVuY3Rpb24gbW8odCl7aWYodC5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT10fSkpLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIGdyYWRpZW50IG9mIHk9Zih4KSB3aXRoIHJlc3BlY3QgdG8geC4gTWFrZSBzdXJlIHRoYXRcXG4gICAgdGhlIGYgeW91IHBhc3NlZCBlbmNsb3NlcyBhbGwgb3BlcmF0aW9ucyB0aGF0IGxlYWQgZnJvbSB4IHRvIHkuXCIpfXZhciBnbz1Bbih7c29mdG1heF86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0tMSk7dmFyIG49bW4odCxcImxvZ2l0c1wiLFwic29mdG1heFwiLFwiZmxvYXQzMlwiKTtpZigtMT09PWUmJihlPW4ucmFuay0xKSxlIT09bi5yYW5rLTEpdGhyb3cgRXJyb3IoXCJTb2Z0bWF4IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBMb2dpdHMgd2FzIHJhbmsgXCIrbi5yYW5rK1wiIGFuZCBkaW0gd2FzIFwiK2UpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LHIpe3ZhciBvPXQuc29mdG1heChuLGUpO3JldHVybiByKFtvXSksb30pLHtsb2dpdHM6bn0sKGZ1bmN0aW9uKHQsbil7dmFyIHI9blswXSxvPXQubXVsKHIpO3JldHVybntsb2dpdHM6ZnVuY3Rpb24oKXtyZXR1cm4gby5zdWIoby5zdW0oW2VdLCEwKS5tdWwocikpfX19KSxcIlNvZnRtYXhcIix7ZGltOmV9LFtdLFshMF0pfX0pLHlvPUFuKHtsb2dTb2Z0bWF4XzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPS0xKTt2YXIgbj1tbih0LFwibG9naXRzXCIsXCJsb2dTb2Z0bWF4XCIpO2lmKC0xPT09ZSYmKGU9bi5yYW5rLTEpLGUhPT1uLnJhbmstMSl0aHJvdyBFcnJvcihcIkxvZyBTb2Z0bWF4IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBMb2dpdHMgd2FzIHJhbmsgXCIrbi5yYW5rK1wiIGFuZCBheGlzIHdhcyBcIitlKTtyZXR1cm4gdm8oKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5tYXgoZSwhMCksbz10LnN1YihyKSxhPW8udG9GbG9hdCgpLnN1YihvLmV4cCgpLnN1bShlLCEwKS5sb2coKSk7bihbYV0pO3JldHVybnt2YWx1ZTphLGdyYWRGdW5jOmZ1bmN0aW9uKHQsbil7dmFyIHI9blswXS5leHAoKTtyZXR1cm4gdC5zdWIodC5zdW0oZSwhMCkubXVsKHIpKX19fSkpKG4pfX0pLHhvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMuYmFja2VuZD10LHRoaXMuZGF0YU1vdmVyPWUsdGhpcy5kYXRhPW5ldyBXZWFrTWFwLHRoaXMuZGF0YUlkc0NvdW50PTB9cmV0dXJuIHQucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhLmhhcyh0KXx8dGhpcy5kYXRhTW92ZXIubW92ZURhdGEodGhpcy5iYWNrZW5kLHQpLHRoaXMuZGF0YS5nZXQodCl9LHQucHJvdG90eXBlLnNldD1mdW5jdGlvbih0LGUpe3RoaXMuZGF0YUlkc0NvdW50KyssdGhpcy5kYXRhLnNldCh0LGUpfSx0LnByb3RvdHlwZS5oYXM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YS5oYXModCl9LHQucHJvdG90eXBlLmRlbGV0ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhSWRzQ291bnQtLSx0aGlzLmRhdGEuZGVsZXRlKHQpfSx0LnByb3RvdHlwZS5udW1EYXRhSWRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YUlkc0NvdW50fSx0fSgpLGJvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUudGltZT1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJ0aW1lXCIpfSx0LnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInJlYWRcIil9LHQucHJvdG90eXBlLnJlYWRTeW5jPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInJlYWRTeW5jXCIpfSx0LnByb3RvdHlwZS5udW1EYXRhSWRzPWZ1bmN0aW9uKCl7cmV0dXJuIHdvKFwibnVtRGF0YUlkc1wiKX0sdC5wcm90b3R5cGUuZGlzcG9zZURhdGE9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiZGlzcG9zZURhdGFcIil9LHQucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJ3cml0ZVwiKX0sdC5wcm90b3R5cGUubW92ZT1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gd28oXCJtb3ZlXCIpfSx0LnByb3RvdHlwZS5tZW1vcnk9ZnVuY3Rpb24oKXtyZXR1cm4gd28oXCJtZW1vcnlcIil9LHQucHJvdG90eXBlLmZsb2F0UHJlY2lzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHdvKFwiZmxvYXRQcmVjaXNpb25cIil9LHQucHJvdG90eXBlLmVwc2lsb249ZnVuY3Rpb24oKXtyZXR1cm4gMzI9PT10aGlzLmZsb2F0UHJlY2lzaW9uKCk/MWUtNzoxZS00fSx0LnByb3RvdHlwZS5iYXRjaE1hdE11bD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gd28oXCJiYXRjaE1hdE11bFwiKX0sdC5wcm90b3R5cGUuZnVzZWRCYXRjaE1hdE11bD1mdW5jdGlvbih0KXt0LmEsdC5iLHQudHJhbnNwb3NlQSx0LnRyYW5zcG9zZUIsdC5iaWFzLHQuYWN0aXZhdGlvbix0LnByZWx1QWN0aXZhdGlvbldlaWdodHM7cmV0dXJuIHdvKFwiZnVzZWRCYXRjaE1hdE11bFwiKX0sdC5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcInNsaWNlXCIpfSx0LnByb3RvdHlwZS5zdHJpZGVkU2xpY2U9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHdvKFwic3RyaWRlZFNsaWNlXCIpfSx0LnByb3RvdHlwZS51bnN0YWNrPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwidW5zdGFja1wiKX0sdC5wcm90b3R5cGUucmV2ZXJzZT1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcInJldmVyc2VcIil9LHQucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImNvbmNhdFwiKX0sdC5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcIm5lZ1wiKX0sdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiYWRkXCIpfSx0LnByb3RvdHlwZS5hZGROPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImFkZE5cIil9LHQucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwic3VidHJhY3RcIil9LHQucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwibXVsdGlwbHlcIil9LHQucHJvdG90eXBlLnJlYWxEaXZpZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJyZWFsRGl2aWRlXCIpfSx0LnByb3RvdHlwZS5mbG9vckRpdj1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImZsb29yRGl2XCIpfSx0LnByb3RvdHlwZS5zdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJzdW1cIil9LHQucHJvdG90eXBlLnByb2Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJwcm9kXCIpfSx0LnByb3RvdHlwZS51bnNvcnRlZFNlZ21lbnRTdW09ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcInVuc29ydGVkU2VnbWVudFN1bVwiKX0sdC5wcm90b3R5cGUuYXJnTWluPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiYXJnTWluXCIpfSx0LnByb3RvdHlwZS5hcmdNYXg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJhcmdNYXhcIil9LHQucHJvdG90eXBlLmVxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiZXF1YWxcIil9LHQucHJvdG90eXBlLm5vdEVxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwibm90RXF1YWxcIil9LHQucHJvdG90eXBlLmxlc3M9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJsZXNzXCIpfSx0LnByb3RvdHlwZS5sZXNzRXF1YWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJsZXNzRXF1YWxcIil9LHQucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJncmVhdGVyXCIpfSx0LnByb3RvdHlwZS5ncmVhdGVyRXF1YWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJncmVhdGVyRXF1YWxcIil9LHQucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwibG9naWNhbE5vdFwiKX0sdC5wcm90b3R5cGUubG9naWNhbEFuZD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImxvZ2ljYWxBbmRcIil9LHQucHJvdG90eXBlLmxvZ2ljYWxPcj1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImxvZ2ljYWxPclwiKX0sdC5wcm90b3R5cGUud2hlcmU9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwid2hlcmVcIil9LHQucHJvdG90eXBlLnNlbGVjdD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwic2VsZWN0XCIpfSx0LnByb3RvdHlwZS50b3BrPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJ0b3BrXCIpfSx0LnByb3RvdHlwZS5taW49ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJtaW5cIil9LHQucHJvdG90eXBlLm1pbmltdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJtaW5pbXVtXCIpfSx0LnByb3RvdHlwZS5tb2Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJtb2RcIil9LHQucHJvdG90eXBlLm1heD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcIm1heFwiKX0sdC5wcm90b3R5cGUubWF4aW11bT1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcIm1heGltdW1cIil9LHQucHJvdG90eXBlLmFsbD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImFsbFwiKX0sdC5wcm90b3R5cGUuYW55PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiYW55XCIpfSx0LnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcInNxdWFyZWREaWZmZXJlbmNlXCIpfSx0LnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImNlaWxcIil9LHQucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImZsb29yXCIpfSx0LnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJyb3VuZFwiKX0sdC5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJzaWduXCIpfSx0LnByb3RvdHlwZS5pc05hTj1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJpc05hTlwiKX0sdC5wcm90b3R5cGUuaXNJbmY9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiaXNJbmZcIil9LHQucHJvdG90eXBlLmlzRmluaXRlPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImlzRmluaXRlXCIpfSx0LnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJwb3dcIil9LHQucHJvdG90eXBlLmV4cD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJleHBcIil9LHQucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImV4cG0xXCIpfSx0LnByb3RvdHlwZS5zb2Z0bWF4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwic29mdG1heFwiKX0sdC5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImxvZ1wiKX0sdC5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwibG9nMXBcIil9LHQucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwic3FydFwiKX0sdC5wcm90b3R5cGUucnNxcnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwicnNxcnRcIil9LHQucHJvdG90eXBlLnNxdWFyZT1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJzcXVhcmVcIil9LHQucHJvdG90eXBlLnJlY2lwcm9jYWw9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwicmVjaXByb2NhbFwiKX0sdC5wcm90b3R5cGUucmVsdT1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJyZWx1XCIpfSx0LnByb3RvdHlwZS5yZWx1Nj1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJyZWx1NlwiKX0sdC5wcm90b3R5cGUucHJlbHU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJwcmVsdVwiKX0sdC5wcm90b3R5cGUuZWx1PWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImVsdVwiKX0sdC5wcm90b3R5cGUuZWx1RGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiZWx1RGVyXCIpfSx0LnByb3RvdHlwZS5zZWx1PWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInNlbHVcIil9LHQucHJvdG90eXBlLmludD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJpbnRcIil9LHQucHJvdG90eXBlLmNsaXA9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImNsaXBcIil9LHQucHJvdG90eXBlLmFicz1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJhYnNcIil9LHQucHJvdG90eXBlLmNvbXBsZXhBYnM9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiY29tcGxleEFic1wiKX0sdC5wcm90b3R5cGUuc2lnbW9pZD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJzaWdtb2lkXCIpfSx0LnByb3RvdHlwZS5zb2Z0cGx1cz1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJzb2Z0cGx1c1wiKX0sdC5wcm90b3R5cGUuc2luPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInNpblwiKX0sdC5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImNvc1wiKX0sdC5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInRhblwiKX0sdC5wcm90b3R5cGUuYXNpbj1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJhc2luXCIpfSx0LnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImFjb3NcIil9LHQucHJvdG90eXBlLmF0YW49ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiYXRhblwiKX0sdC5wcm90b3R5cGUuYXRhbjI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJhdGFuMlwiKX0sdC5wcm90b3R5cGUuc2luaD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJzaW5oXCIpfSx0LnByb3RvdHlwZS5jb3NoPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImNvc2hcIil9LHQucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwidGFuaFwiKX0sdC5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiYXNpbmhcIil9LHQucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImFjb3NoXCIpfSx0LnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJhdGFuaFwiKX0sdC5wcm90b3R5cGUuZXJmPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImVyZlwiKX0sdC5wcm90b3R5cGUuc3RlcD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcInN0ZXBcIil9LHQucHJvdG90eXBlLmZ1c2VkQ29udjJkPWZ1bmN0aW9uKHQpe3QuaW5wdXQsdC5maWx0ZXIsdC5jb252SW5mbyx0LmJpYXMsdC5hY3RpdmF0aW9uLHQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cztyZXR1cm4gd28oXCJmdXNlZENvbnYyZFwiKX0sdC5wcm90b3R5cGUuY29udjJkPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJjb252MmRcIil9LHQucHJvdG90eXBlLmNvbnYyZERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJjb252MmREZXJJbnB1dFwiKX0sdC5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJjb252MmREZXJGaWx0ZXJcIil9LHQucHJvdG90eXBlLmZ1c2VkRGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKHQpe3QuaW5wdXQsdC5maWx0ZXIsdC5jb252SW5mbyx0LmJpYXMsdC5hY3RpdmF0aW9uLHQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cztyZXR1cm4gd28oXCJmdXNlZERlcHRod2lzZUNvbnYyRFwiKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJkZXB0aHdpc2VDb252MkRcIil9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJkZXB0aHdpc2VDb252MkREZXJJbnB1dFwiKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJkZXB0aHdpc2VDb252MkREZXJGaWx0ZXJcIil9LHQucHJvdG90eXBlLmNvbnYzZD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiY29udjNkXCIpfSx0LnByb3RvdHlwZS5jb252M2REZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiY29udjNkRGVySW5wdXRcIil9LHQucHJvdG90eXBlLmNvbnYzZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiY29udjNkRGVyRmlsdGVyXCIpfSx0LnByb3RvdHlwZS5tYXhQb29sPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwibWF4UG9vbFwiKX0sdC5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB3byhcIm1heFBvb2xCYWNrcHJvcFwiKX0sdC5wcm90b3R5cGUuYXZnUG9vbD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImF2Z1Bvb2xcIil9LHQucHJvdG90eXBlLmF2Z1Bvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiYXZnUG9vbEJhY2twcm9wXCIpfSx0LnByb3RvdHlwZS5hdmdQb29sM2Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJhdmdQb29sM2RcIil9LHQucHJvdG90eXBlLmF2Z1Bvb2wzZEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJhdmdQb29sM2RCYWNrcHJvcFwiKX0sdC5wcm90b3R5cGUubWF4UG9vbDNkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwibWF4UG9vbDNkXCIpfSx0LnByb3RvdHlwZS5tYXhQb29sM2RCYWNrcHJvcD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gd28oXCJtYXhQb29sM2RCYWNrcHJvcFwiKX0sdC5wcm90b3R5cGUucmVzaGFwZT1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcInJlc2hhcGVcIil9LHQucHJvdG90eXBlLmNhc3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJjYXN0XCIpfSx0LnByb3RvdHlwZS50aWxlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwidGlsZVwiKX0sdC5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJwYWRcIil9LHQucHJvdG90eXBlLnRyYW5zcG9zZT1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcInRyYW5zcG9zZVwiKX0sdC5wcm90b3R5cGUuZ2F0aGVyPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJnYXRoZXJcIil9LHQucHJvdG90eXBlLmdhdGhlck5EPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiZ2F0aGVyTkRcIil9LHQucHJvdG90eXBlLnNjYXR0ZXJORD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwic2NhdHRlck5EXCIpfSx0LnByb3RvdHlwZS5iYXRjaFRvU3BhY2VORD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiYmF0Y2hUb1NwYWNlTkRcIil9LHQucHJvdG90eXBlLnNwYWNlVG9CYXRjaE5EPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJzcGFjZVRvQmF0Y2hORFwiKX0sdC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXI9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHdvKFwicmVzaXplQmlsaW5lYXJcIil9LHQucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcInJlc2l6ZUJpbGluZWFyQmFja3Byb3BcIil9LHQucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcj1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gd28oXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JcIil9LHQucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcFwiKX0sdC5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gd28oXCJiYXRjaE5vcm1hbGl6YXRpb25cIil9LHQucHJvdG90eXBlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQ9ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gd28oXCJsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREXCIpfSx0LnByb3RvdHlwZS5MUk5HcmFkPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3JldHVybiB3byhcIkxSTkdyYWRcIil9LHQucHJvdG90eXBlLm11bHRpbm9taWFsPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB3byhcIm11bHRpbm9taWFsXCIpfSx0LnByb3RvdHlwZS5vbmVIb3Q9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHdvKFwib25lSG90XCIpfSx0LnByb3RvdHlwZS5jdW1zdW09ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHdvKFwiY3Vtc3VtXCIpfSx0LnByb3RvdHlwZS5ub25NYXhTdXBwcmVzc2lvbj1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB3byhcIm5vbk1heFN1cHByZXNzaW9uXCIpfSx0LnByb3RvdHlwZS5mZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiZmZ0XCIpfSx0LnByb3RvdHlwZS5pZmZ0PWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImlmZnRcIil9LHQucHJvdG90eXBlLmNvbXBsZXg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJjb21wbGV4XCIpfSx0LnByb3RvdHlwZS5yZWFsPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInJlYWxcIil9LHQucHJvdG90eXBlLmltYWc9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiaW1hZ1wiKX0sdC5wcm90b3R5cGUuY3JvcEFuZFJlc2l6ZT1mdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHdvKFwiY3JvcEFuZFJlc2l6ZVwiKX0sdC5wcm90b3R5cGUuZGVwdGhUb1NwYWNlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJkZXB0aFRvU3BhY2VcIil9LHQucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJzcGxpdFwiKX0sdC5wcm90b3R5cGUuc3BhcnNlVG9EZW5zZT1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gd28oXCJzcGFyc2VUb0RlbnNlXCIpfSx0LnByb3RvdHlwZS5kaWFnPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImRpYWdcIil9LHQucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImZpbGxcIil9LHQucHJvdG90eXBlLm9uZXNMaWtlPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcIm9uZXNMaWtlXCIpfSx0LnByb3RvdHlwZS56ZXJvc0xpa2U9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiemVyb3NMaWtlXCIpfSx0LnByb3RvdHlwZS5saW5zcGFjZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwibGluc3BhY2VcIil9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gd28oXCJkaXNwb3NlXCIpfSx0fSgpO2Z1bmN0aW9uIHdvKHQpe3Rocm93IG5ldyBFcnJvcihcIidcIit0K1wiJyBub3QgeWV0IGltcGxlbWVudGVkIG9yIG5vdCBmb3VuZCBpbiB0aGUgcmVnaXN0cnkuIERpZCB5b3UgZm9yZ2V0IHRvIGltcG9ydCB0aGUga2VybmVsP1wiKX1mdW5jdGlvbiBDbyh0LGUpe2Zvcih2YXIgbj10Lmxlbmd0aCxyPVtdLG89MDtvPG47bysrKXt2YXIgYT1uLTEtbyxpPXRbYV18fDE7KGVbZS5sZW5ndGgtMS1vXXx8MSk+MSYmMT09PWkmJnIudW5zaGlmdChhKX1yZXR1cm4gcn1mdW5jdGlvbiBFbyh0LGUpe2Zvcih2YXIgbj1bXSxyPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBvPXRbdC5sZW5ndGgtci0xXSxhPWUubGVuZ3RoLXItMSxpPWVbYV07KG51bGw9PW98fDE9PT1vJiZpPjEpJiZuLnVuc2hpZnQoYSl9cmV0dXJuIG59ZnVuY3Rpb24gUm8odCxlKXtmb3IodmFyIG49W10scj1NYXRoLm1heCh0Lmxlbmd0aCxlLmxlbmd0aCksbz0wO288cjtvKyspe3ZhciBhPXRbdC5sZW5ndGgtby0xXTtudWxsPT1hJiYoYT0xKTt2YXIgaT1lW2UubGVuZ3RoLW8tMV07aWYobnVsbD09aSYmKGk9MSksMT09PWEpbi51bnNoaWZ0KGkpO2Vsc2UgaWYoMT09PWkpbi51bnNoaWZ0KGEpO2Vsc2V7aWYoYSE9PWkpdGhyb3cgRXJyb3IoXCJPcGVyYW5kcyBjb3VsZCBub3QgYmUgYnJvYWRjYXN0IHRvZ2V0aGVyIHdpdGggc2hhcGVzIFwiK3QrXCIgYW5kIFwiK2UrXCIuXCIpO24udW5zaGlmdChhKX19cmV0dXJuIG59ZnVuY3Rpb24gSW8odCxlLG4scixvLGEsaSl7dm9pZCAwPT09aSYmKGk9XCJjaGFubmVsc0xhc3RcIik7dmFyIHMsdT1UbyhlKSxjPXVbMF0sbD11WzFdO2lmKFwiY2hhbm5lbHNMYXN0XCI9PT1pKXM9W2MsbCx0WzNdLHRbM11dO2Vsc2V7aWYoXCJjaGFubmVsc0ZpcnN0XCIhPT1pKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YUZvcm1hdCBcIitpKTtzPVtjLGwsdFsxXSx0WzFdXX1yZXR1cm4gU28odCxzLG4scixvLGEsITEsaSl9ZnVuY3Rpb24ga28odCxlLG4scixvLGEsaSl7dm9pZCAwPT09aSYmKGk9XCJOREhXQ1wiKTt2YXIgcyx1LGM9Tm8oZSksbD1jWzBdLGg9Y1sxXSxmPWNbMl07aWYoXCJOREhXQ1wiPT09aSl1PVwiY2hhbm5lbHNMYXN0XCIscz1bbCxoLGYsdFs0XSx0WzRdXTtlbHNle2lmKFwiTkNESFdcIiE9PWkpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhRm9ybWF0IFwiK2kpO3U9XCJjaGFubmVsc0ZpcnN0XCIscz1bbCxoLGYsdFsxXSx0WzFdXX1yZXR1cm4gQW8odCxzLG4scixvLCExLHUsYSl9ZnVuY3Rpb24gU28odCxlLG4scixvLGEsaSxzKXt2b2lkIDA9PT1pJiYoaT0hMSksdm9pZCAwPT09cyYmKHM9XCJjaGFubmVsc0xhc3RcIik7dmFyIHU9Wy0xLC0xLC0xLC0xXSxjPXVbMF0sbD11WzFdLGg9dVsyXSxmPXVbM107aWYoXCJjaGFubmVsc0xhc3RcIj09PXMpYz10WzBdLGw9dFsxXSxoPXRbMl0sZj10WzNdO2Vsc2V7aWYoXCJjaGFubmVsc0ZpcnN0XCIhPT1zKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YUZvcm1hdCBcIitzKTtjPXRbMF0sZj10WzFdLGw9dFsyXSxoPXRbM119dmFyIGQscD1lWzBdLHY9ZVsxXSxtPWVbM10sZz1UbyhuKSx5PWdbMF0seD1nWzFdLGI9VG8ociksdz1iWzBdLEU9YlsxXSxSPUZvKHAsdyksST1Gbyh2LEUpLGs9ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzKXt2YXIgdSxjLGw7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpe3U9e3RvcDp0LGJvdHRvbTp0LGxlZnQ6dCxyaWdodDp0LHR5cGU6MD09PXQ/XCJWQUxJRFwiOlwiTlVNQkVSXCJ9O3ZhciBoPWZ1bmN0aW9uKHQsZSxuLHIsbyl7bnVsbD09ciYmKHI9RG8odCxlLG4pKTt2YXIgYT10WzBdLGk9dFsxXSxzPV9vKChhLWUrMipyKS9uKzEsbyk7QyhBKHMpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIG91dHB1dCAjIG9mIHJvd3MgKFwiK3MrXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIn0pKTt2YXIgdT1fbygoaS1lKzIqcikvbisxLG8pO3JldHVybiBDKEEodSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgb3V0cHV0ICMgb2YgY29sdW1ucyAoXCIrdStcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIHN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wifSkpLFtzLHVdfShbZSxuXSxhLHIsdCxzKTtjPWhbMF0sbD1oWzFdfWVsc2UgaWYoXCJzYW1lXCI9PT10KXtjPU1hdGguY2VpbChlL3IpLGw9TWF0aC5jZWlsKG4vbyk7dmFyIGY9TWF0aC5tYXgoMCwoYy0xKSpyK2EtZSksZD1NYXRoLm1heCgwLChsLTEpKm8raS1uKSxwPU1hdGguZmxvb3IoZi8yKSx2PWYtcCxtPU1hdGguZmxvb3IoZC8yKTt1PXt0b3A6cCxib3R0b206dixsZWZ0Om0scmlnaHQ6ZC1tLHR5cGU6XCJTQU1FXCJ9fWVsc2V7aWYoXCJ2YWxpZFwiIT09dCl0aHJvdyBFcnJvcihcIlVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6IFwiK3QpO3U9e3RvcDowLGJvdHRvbTowLGxlZnQ6MCxyaWdodDowLHR5cGU6XCJWQUxJRFwifSxjPU1hdGguY2VpbCgoZS1hKzEpL3IpLGw9TWF0aC5jZWlsKChuLWkrMSkvbyl9cmV0dXJue3BhZEluZm86dSxvdXRIZWlnaHQ6YyxvdXRXaWR0aDpsfX0obyxsLGgseSx4LFIsSSxhKSxTPWsucGFkSW5mbyxEPWsub3V0SGVpZ2h0LFQ9ay5vdXRXaWR0aCxOPWk/bSpmOm07cmV0dXJuXCJjaGFubmVsc0ZpcnN0XCI9PT1zP2Q9W2MsTixELFRdOlwiY2hhbm5lbHNMYXN0XCI9PT1zJiYoZD1bYyxELFQsTl0pLHtiYXRjaFNpemU6YyxkYXRhRm9ybWF0OnMsaW5IZWlnaHQ6bCxpbldpZHRoOmgsaW5DaGFubmVsczpmLG91dEhlaWdodDpELG91dFdpZHRoOlQsb3V0Q2hhbm5lbHM6TixwYWRJbmZvOlMsc3RyaWRlSGVpZ2h0Onksc3RyaWRlV2lkdGg6eCxmaWx0ZXJIZWlnaHQ6cCxmaWx0ZXJXaWR0aDp2LGVmZmVjdGl2ZUZpbHRlckhlaWdodDpSLGVmZmVjdGl2ZUZpbHRlcldpZHRoOkksZGlsYXRpb25IZWlnaHQ6dyxkaWxhdGlvbldpZHRoOkUsaW5TaGFwZTp0LG91dFNoYXBlOmQsZmlsdGVyU2hhcGU6ZX19ZnVuY3Rpb24gQW8odCxlLG4scixvLGEsaSxzKXt2b2lkIDA9PT1hJiYoYT0hMSksdm9pZCAwPT09aSYmKGk9XCJjaGFubmVsc0xhc3RcIik7dmFyIHU9Wy0xLC0xLC0xLC0xLC0xXSxjPXVbMF0sbD11WzFdLGg9dVsyXSxmPXVbM10sZD11WzRdO2lmKFwiY2hhbm5lbHNMYXN0XCI9PT1pKWM9dFswXSxsPXRbMV0saD10WzJdLGY9dFszXSxkPXRbNF07ZWxzZXtpZihcImNoYW5uZWxzRmlyc3RcIiE9PWkpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhRm9ybWF0IFwiK2kpO2M9dFswXSxkPXRbMV0sbD10WzJdLGg9dFszXSxmPXRbNF19dmFyIHAsdj1lWzBdLG09ZVsxXSxnPWVbMl0seT1lWzRdLHg9Tm8obiksYj14WzBdLHc9eFsxXSxFPXhbMl0sUj1ObyhyKSxJPVJbMF0saz1SWzFdLFM9UlsyXSxEPUZvKHYsSSksVD1GbyhtLGspLE49Rm8oZyxTKSxGPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyx1LGMsbCl7dmFyIGgsZixkLHA7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpe2g9e3RvcDp0LGJvdHRvbTp0LGxlZnQ6dCxyaWdodDp0LGZyb250OnQsYmFjazp0LHR5cGU6MD09PXQ/XCJWQUxJRFwiOlwiTlVNQkVSXCJ9O3ZhciB2PWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtudWxsPT1vJiYobz1Ebyh0LGUscikpO3ZhciBpPXRbMF0scz10WzFdLHU9dFsyXSxjPV9vKChpLWUrMipvKS9yKzEsYSk7QyhBKGMpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIG91dHB1dCAjIG9mIGRlcHRocyAoXCIrYytcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIHN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wifSkpO3ZhciBsPV9vKChzLWUrMipvKS9yKzEsYSk7QyhBKGwpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIG91dHB1dCAjIG9mIHJvd3MgKFwiK2wrXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIn0pKTt2YXIgaD1fbygodS1lKzIqbykvcisxLGEpO3JldHVybiBDKEEoaCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgb3V0cHV0ICMgb2YgY29sdW1ucyAoXCIraCtcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIHN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wifSkpLFtjLGwsaCxuXX0oW2UsbixyLDFdLHMsMSxvLHQsbCk7Zj12WzBdLGQ9dlsxXSxwPXZbMl19ZWxzZSBpZihcInNhbWVcIj09PXQpe2Y9TWF0aC5jZWlsKGUvbyksZD1NYXRoLmNlaWwobi9hKSxwPU1hdGguY2VpbChyL2kpO3ZhciBtPShmLTEpKm8rcy1lLGc9KGQtMSkqYSt1LW4seT0ocC0xKSppK2Mtcix4PU1hdGguZmxvb3IobS8yKSxiPW0teCx3PU1hdGguZmxvb3IoZy8yKSxFPWctdyxSPU1hdGguZmxvb3IoeS8yKTtoPXt0b3A6dyxib3R0b206RSxsZWZ0OlIscmlnaHQ6eS1SLGZyb250OngsYmFjazpiLHR5cGU6XCJTQU1FXCJ9fWVsc2V7aWYoXCJ2YWxpZFwiIT09dCl0aHJvdyBFcnJvcihcIlVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6IFwiK3QpO2g9e3RvcDowLGJvdHRvbTowLGxlZnQ6MCxyaWdodDowLGZyb250OjAsYmFjazowLHR5cGU6XCJWQUxJRFwifSxmPU1hdGguY2VpbCgoZS1zKzEpL28pLGQ9TWF0aC5jZWlsKChuLXUrMSkvYSkscD1NYXRoLmNlaWwoKHItYysxKS9pKX1yZXR1cm57cGFkSW5mbzpoLG91dERlcHRoOmYsb3V0SGVpZ2h0OmQsb3V0V2lkdGg6cH19KG8sbCxoLGYsYix3LEUsRCxULE4scyksXz1GLnBhZEluZm8sTz1GLm91dERlcHRoLE09Ri5vdXRIZWlnaHQsQj1GLm91dFdpZHRoLFA9YT95KmQ6eTtyZXR1cm5cImNoYW5uZWxzRmlyc3RcIj09PWk/cD1bYyxQLE8sTSxCXTpcImNoYW5uZWxzTGFzdFwiPT09aSYmKHA9W2MsTyxNLEIsUF0pLHtiYXRjaFNpemU6YyxkYXRhRm9ybWF0OmksaW5EZXB0aDpsLGluSGVpZ2h0OmgsaW5XaWR0aDpmLGluQ2hhbm5lbHM6ZCxvdXREZXB0aDpPLG91dEhlaWdodDpNLG91dFdpZHRoOkIsb3V0Q2hhbm5lbHM6UCxwYWRJbmZvOl8sc3RyaWRlRGVwdGg6YixzdHJpZGVIZWlnaHQ6dyxzdHJpZGVXaWR0aDpFLGZpbHRlckRlcHRoOnYsZmlsdGVySGVpZ2h0Om0sZmlsdGVyV2lkdGg6ZyxlZmZlY3RpdmVGaWx0ZXJEZXB0aDpELGVmZmVjdGl2ZUZpbHRlckhlaWdodDpULGVmZmVjdGl2ZUZpbHRlcldpZHRoOk4sZGlsYXRpb25EZXB0aDpJLGRpbGF0aW9uSGVpZ2h0OmssZGlsYXRpb25XaWR0aDpTLGluU2hhcGU6dCxvdXRTaGFwZTpwLGZpbHRlclNoYXBlOmV9fWZ1bmN0aW9uIERvKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPTEpO3ZhciBvPUZvKGUscik7cmV0dXJuIE1hdGguZmxvb3IoKHRbMF0qKG4tMSktbitvKS8yKX1mdW5jdGlvbiBUbyh0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdD9bdCx0LHRdOjI9PT10Lmxlbmd0aD9bdFswXSx0WzFdLDFdOnR9ZnVuY3Rpb24gTm8odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/W3QsdCx0XTp0fWZ1bmN0aW9uIEZvKHQsZSl7cmV0dXJuIGU8PTE/dDp0Kyh0LTEpKihlLTEpfWZ1bmN0aW9uIF9vKHQsZSl7aWYoIWUpcmV0dXJuIHQ7c3dpdGNoKGUpe2Nhc2VcInJvdW5kXCI6cmV0dXJuIE1hdGgucm91bmQodCk7Y2FzZVwiY2VpbFwiOnJldHVybiBNYXRoLmNlaWwodCk7Y2FzZVwiZmxvb3JcIjpyZXR1cm4gTWF0aC5mbG9vcih0KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVua25vd24gcm91bmRpbmdNb2RlIFwiK2UpfX1mdW5jdGlvbiBPbyh0KXt2YXIgZT1Ubyh0KSxuPWVbMF0scj1lWzFdLG89ZVsyXTtyZXR1cm4gMT09PW4mJjE9PT1yJiYxPT09b31mdW5jdGlvbiBNbyh0LGUpe3JldHVybiBPbyh0KXx8T28oZSl9ZnVuY3Rpb24gQm8odCl7aWYoXCJOSFdDXCI9PT10KXJldHVyblwiY2hhbm5lbHNMYXN0XCI7aWYoXCJOQ0hXXCI9PT10KXJldHVyblwiY2hhbm5lbHNGaXJzdFwiO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YUZvcm1hdCBcIit0KX1mdW5jdGlvbiBQbyh0LGUsbil7aWYoXCJjb21wbGV4NjRcIj09PWUpe2lmKFwiY29tcGxleDY0XCI9PT10LmR0eXBlKXJldHVybiB0LmNsb25lKCk7dmFyIHI9R24odC5zaGFwZSksbz10LnRvRmxvYXQoKSxhPW4uY29tcGxleChvLHIpO3JldHVybiByLmRpc3Bvc2UoKSxvLmRpc3Bvc2UoKSxhfWlmKCFVKHQuZHR5cGUsZSkpcmV0dXJuIEx0Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKHQuZGF0YUlkLHQuc2hhcGUsZSk7aWYoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUpe3ZhciBpPW4ucmVhbCh0KTthPWkuY2FzdChlKTtyZXR1cm4gaS5kaXNwb3NlKCksYX1pZihcImludDMyXCI9PT1lKXJldHVybiBuLmludCh0KTtpZihcImJvb2xcIj09PWUpe3ZhciBzPU9uKDAsdC5kdHlwZSk7YT1uLm5vdEVxdWFsKHQscyk7cmV0dXJuIHMuZGlzcG9zZSgpLGF9dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gQ2FzdDogZmFpbGVkIHRvIGNhc3QgXCIrdC5kdHlwZStcIiB0byBcIitlKX1mdW5jdGlvbiBMbyh0LGUpe3JldHVybiBMdC5tYWtlVGVuc29yRnJvbURhdGFJZCh0LmRhdGFJZCxlLHQuZHR5cGUpfWZ1bmN0aW9uIFdvKHQsZSxuKXt2YXIgcj0oZS10KS8obi0xKSxvPXR0KG4sXCJmbG9hdDMyXCIpO29bMF09dDtmb3IodmFyIGE9MTthPG8ubGVuZ3RoO2ErKylvW2FdPW9bYS0xXStyO3JldHVybiBNbihvLFwiZmxvYXQzMlwiKX12YXIgVW89T2JqZWN0LmZyZWV6ZSh7Y2FzdFRlbnNvcjpQbyxyZXNoYXBlVGVuc29yOkxvLGxpbnNwYWNlSW1wbDpXbyx1cGNhc3RUeXBlOkR0LGF4ZXNBcmVJbm5lck1vc3REaW1zOnluLGNvbWJpbmVMb2NhdGlvbnM6eG4sY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlczpibixleHBhbmRTaGFwZVRvS2VlcERpbTp3bixhc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltczpDbixnZXRBeGVzUGVybXV0YXRpb246RW4sZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbjpSbixnZXRJbm5lck1vc3RBeGVzOkluLGdldEJyb2FkY2FzdERpbXM6Q28sZ2V0UmVkdWN0aW9uQXhlczpFbyxhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZTpSbyxhc3NlcnRQYXJhbXNDb25zaXN0ZW50OmtuLGNvbXB1dGVPdXRTaGFwZTpTbixjb21wdXRlUG9vbDJESW5mbzpJbyxjb21wdXRlUG9vbDNESW5mbzprbyxjb21wdXRlQ29udjJESW5mbzpTbyxjb21wdXRlQ29udjNESW5mbzpBbyxjb21wdXRlRGVmYXVsdFBhZDpEbyx0dXBsZVZhbHVlc0FyZU9uZTpPbyxlaXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmU6TW8sY29udmVydENvbnYyRERhdGFGb3JtYXQ6Qm8sUEFSQUxMRUxJWkVfVEhSRVNIT0xEOllyLGNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZTokcn0pO2Z1bmN0aW9uIFZvKHQsZSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVyZ2UgcmVhbCBhbmQgaW1hZyBhcnJheXMgb2YgZGlmZmVyZW50IGxlbmd0aHMuIHJlYWw6XCIrdC5sZW5ndGgrXCIsIGltYWc6IFwiK2UubGVuZ3RoK1wiLlwiKTtmb3IodmFyIG49bmV3IEZsb2F0MzJBcnJheSgyKnQubGVuZ3RoKSxyPTA7cjxuLmxlbmd0aDtyKz0yKW5bcl09dFtyLzJdLG5bcisxXT1lW3IvMl07cmV0dXJuIG59ZnVuY3Rpb24gem8odCxlKXtyZXR1cm57cmVhbDp0WzIqZV0saW1hZzp0WzIqZSsxXX19ZnVuY3Rpb24gR28odCxlLG4scil7dFsyKnJdPWUsdFsyKnIrMV09bn1mdW5jdGlvbiBIbyh0LGUsbil7dmFyIHI9KG4/MjotMikqTWF0aC5QSSoodC9lKTtyZXR1cm57cmVhbDpNYXRoLmNvcyhyKSxpbWFnOk1hdGguc2luKHIpfX1mdW5jdGlvbiBxbyh0LGUsbil7dmFyIHI9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBmdW5jdGlvbih0LGUsbil7dmFyIHI9MCxvPXQubGVuZ3RoLGE9MCxpPSExO2Zvcig7cjxvOyl7dmFyIHM9bihlLHRbYT1yKyhvLXI+Pj4xKV0pO3M+MD9yPWErMToobz1hLGk9IXMpfXJldHVybiBpP3I6LXItMX0odCxlLG58fEtvKX0odCxlLG4pLG89cjwwPy0ocisxKTpyO3Quc3BsaWNlKG8sMCxlKX1mdW5jdGlvbiBLbyh0LGUpe3JldHVybiB0PmU/MTp0PGU/LTE6MH1mdW5jdGlvbiBqbyh0LGUsbixyLG8pe3JldHVybiBZbyh0LGUsbixyLG8sMCkuc2VsZWN0ZWRJbmRpY2VzfWZ1bmN0aW9uIFhvKHQsZSxuLHIsbyxhKXt2YXIgaT1Zbyh0LGUsbixyLG8sYSwhMCk7cmV0dXJuIGkubnVtVmFsaWRPdXRwdXRzLmRpc3Bvc2UoKSx7c2VsZWN0ZWRJbmRpY2VzOmkuc2VsZWN0ZWRJbmRpY2VzLHNlbGVjdGVkU2NvcmVzOmkuc2VsZWN0ZWRTY29yZXN9fWZ1bmN0aW9uIFlvKHQsZSxuLHIsbyxhLGkscyl7dm9pZCAwPT09aSYmKGk9ITEpLHZvaWQgMD09PXMmJihzPSExKTtmb3IodmFyIHU9QXJyYXkuZnJvbShlKS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJue3Njb3JlOnQsYm94SW5kZXg6ZSxzdXBwcmVzc0JlZ2luSW5kZXg6MH19KSkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zY29yZT5vfSkpLnNvcnQoSm8pLGM9YT4wPy0uNS9hOjAsbD1bXSxoPVtdO2wubGVuZ3RoPG4mJnUubGVuZ3RoPjA7KXt2YXIgZj11LnBvcCgpLGQ9Zi5zY29yZSxwPWYuYm94SW5kZXgsdj1mLnN1cHByZXNzQmVnaW5JbmRleDtpZihkPG8pYnJlYWs7Zm9yKHZhciBtPSExLGc9bC5sZW5ndGgtMTtnPj12Oy0tZyl7dmFyIHk9JG8odCxwLGxbZ10pO2lmKHk+PXIpe209ITA7YnJlYWt9aWYoZi5zY29yZT1mLnNjb3JlKlFvKHIsYyx5KSxmLnNjb3JlPD1vKWJyZWFrfWYuc3VwcHJlc3NCZWdpbkluZGV4PWwubGVuZ3RoLG18fChmLnNjb3JlPT09ZD8obC5wdXNoKHApLGgucHVzaChmLnNjb3JlKSk6Zi5zY29yZT5vJiZxbyh1LGYsSm8pKX12YXIgeD1sLmxlbmd0aDtyZXR1cm4gcyYmKGwuZmlsbCgwLHgpLGguZmlsbCgwLHgpKSx7c2VsZWN0ZWRJbmRpY2VzOk1uKGwsXCJpbnQzMlwiKSxzZWxlY3RlZFNjb3JlczpNbihoLFwiZmxvYXQzMlwiKSxudW1WYWxpZE91dHB1dHM6T24oeCxcImludDMyXCIpfX1mdW5jdGlvbiAkbyh0LGUsbil7dmFyIHI9dC5zdWJhcnJheSg0KmUsNCplKzQpLG89dC5zdWJhcnJheSg0Km4sNCpuKzQpLGE9TWF0aC5taW4oclswXSxyWzJdKSxpPU1hdGgubWluKHJbMV0sclszXSkscz1NYXRoLm1heChyWzBdLHJbMl0pLHU9TWF0aC5tYXgoclsxXSxyWzNdKSxjPU1hdGgubWluKG9bMF0sb1syXSksbD1NYXRoLm1pbihvWzFdLG9bM10pLGg9TWF0aC5tYXgob1swXSxvWzJdKSxmPU1hdGgubWF4KG9bMV0sb1szXSksZD0ocy1hKSoodS1pKSxwPShoLWMpKihmLWwpO2lmKGQ8PTB8fHA8PTApcmV0dXJuIDA7dmFyIHY9TWF0aC5tYXgoYSxjKSxtPU1hdGgubWF4KGksbCksZz1NYXRoLm1pbihzLGgpLHk9TWF0aC5taW4odSxmKSx4PU1hdGgubWF4KGctdiwwKSpNYXRoLm1heCh5LW0sMCk7cmV0dXJuIHgvKGQrcC14KX1mdW5jdGlvbiBRbyh0LGUsbil7dmFyIHI9TWF0aC5leHAoZSpuKm4pO3JldHVybiBuPD10P3I6MH1mdW5jdGlvbiBKbyh0LGUpe3JldHVybiB0LnNjb3JlLWUuc2NvcmV8fHQuc2NvcmU9PT1lLnNjb3JlJiZlLmJveEluZGV4LXQuYm94SW5kZXh9ZnVuY3Rpb24gWm8odCxlLG4pe3ZhciByPW5ldyBBcnJheSh0LnJhbmspLmZpbGwoMCksbz10LnNoYXBlLnNsaWNlKCk7cmV0dXJuIGUubWFwKChmdW5jdGlvbihlKXtvW25dPWU7dmFyIGE9dC5zbGljZShyLG8pO3JldHVybiByW25dKz1lLGF9KSl9ZnVuY3Rpb24gdGEodCxlKXtmb3IodmFyIG49bmV3IEFycmF5KHQucmFuaykscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09dC5zaGFwZVtyXSplW3JdO3ZhciBvPWRyKG4sdC5kdHlwZSk7Zm9yKHI9MDtyPG8udmFsdWVzLmxlbmd0aDsrK3Ipe2Zvcih2YXIgYT1vLmluZGV4VG9Mb2MociksaT1uZXcgQXJyYXkodC5yYW5rKSxzPTA7czxpLmxlbmd0aDtzKyspaVtzXT1hW3NdJXQuc2hhcGVbc107dmFyIHU9dC5sb2NUb0luZGV4KGkpO28udmFsdWVzW3JdPXQudmFsdWVzW3VdfXJldHVybiBvLnRvVGVuc29yKCl9ZnVuY3Rpb24gZWEodCxlLG4scixvKXtmb3IodmFyIGE9ZVtlLmxlbmd0aC0xXSxpPVt0Lmxlbmd0aC9hLGFdLHM9aVswXSx1PWlbMV0sYz1CKG4scypyKSxsPUIoXCJpbnQzMlwiLHMqciksaD0wO2g8cztoKyspe2Zvcih2YXIgZj1oKnUsZD10LnN1YmFycmF5KGYsZit1KSxwPVtdLHY9MDt2PGQubGVuZ3RoO3YrKylwLnB1c2goe3ZhbHVlOmRbdl0saW5kZXg6dn0pO3Auc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gZS52YWx1ZS10LnZhbHVlfSkpO3ZhciBtPWgqcixnPWMuc3ViYXJyYXkobSxtK3IpLHk9bC5zdWJhcnJheShtLG0rcik7Zm9yKHY9MDt2PHI7disrKWdbdl09cFt2XS52YWx1ZSx5W3ZdPXBbdl0uaW5kZXh9dmFyIHg9ZS5zbGljZSgpO3JldHVybiB4W3gubGVuZ3RoLTFdPXIsW0ZuKGMseCxuKSxGbihsLHgsXCJpbnQzMlwiKV19ZnVuY3Rpb24gbmEodCxlKXtmb3IodmFyIG49W10scj0wO3I8ZS5sZW5ndGg7cisrKWVbcl0mJm4ucHVzaChyKTt2YXIgbz1kcih0LFwiaW50MzJcIiksYT1kcihbbi5sZW5ndGgsdC5sZW5ndGhdLFwiaW50MzJcIik7Zm9yKHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIGk9by5pbmRleFRvTG9jKG5bcl0pLHM9cip0Lmxlbmd0aDthLnZhbHVlcy5zZXQoaSxzKX1yZXR1cm4gYS50b1RlbnNvcigpfXZhciByYT1mdW5jdGlvbih0LGUpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudmFyaWFibGVOYW1lcz1lLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5cIlRcIitlfSkpO3ZhciBuPVtdO3RoaXMudmFyaWFibGVOYW1lcy5mb3JFYWNoKChmdW5jdGlvbih0KXtuLnB1c2goXCJmbG9hdCB2XCIrdCtcIiA9IGdldFwiK3QrXCJBdE91dENvb3JkcygpO1wiKX0pKTt2YXIgcj10aGlzLnZhcmlhYmxlTmFtZXMubWFwKChmdW5jdGlvbih0KXtyZXR1cm5cInZcIit0fSkpLmpvaW4oXCIgKyBcIik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK24uam9pbihcIlxcbiAgICAgICAgXCIpK1wiXFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSBcIityK1wiO1xcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn0sb2E9ZnVuY3Rpb24odCxlKXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnZhcmlhYmxlTmFtZXM9ZS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJUXCIrZX0pKTt2YXIgbj1bXTt0aGlzLnZhcmlhYmxlTmFtZXMuZm9yRWFjaCgoZnVuY3Rpb24odCl7bi5wdXNoKFwidmVjNCB2XCIrdCtcIiA9IGdldFwiK3QrXCJBdE91dENvb3JkcygpO1wiKX0pKTt2YXIgcj10aGlzLnZhcmlhYmxlTmFtZXMubWFwKChmdW5jdGlvbih0KXtyZXR1cm5cInZcIit0fSkpLmpvaW4oXCIgKyBcIik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK24uam9pbihcIlxcbiAgICAgICAgXCIpK1wiXFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IFwiK3IrXCI7XFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSxhYT1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07dmFyIHI9dC53aW5kb3dTaXplLG89dC5iYXRjaFNpemUsYT10LmluU2l6ZSxpPU1hdGguY2VpbChhL3IpO258fHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmVzdEluZGljZXNBXCIpLHRoaXMub3V0cHV0U2hhcGU9W28saV07dmFyIHM9XCJtYXhcIj09PWU/XCI+XCI6XCI8XCIsdT1uP1wiaW5PZmZzZXQgKyBpO1wiOlwicm91bmQoZ2V0QmVzdEluZGljZXNBKGJhdGNoLCBpbk9mZnNldCArIGkpKTtcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIrcitcIjtcXG5cXG4gICAgICAgIGludCBiZXN0SW5kZXggPSBpbk9mZnNldDtcXG4gICAgICAgIGZsb2F0IGJlc3RWYWx1ZSA9IGdldEEoYmF0Y2gsIGJlc3RJbmRleCk7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3IrXCI7IGkrKykge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBcIit1K1wiO1xcbiAgICAgICAgICBmbG9hdCBjYW5kaWRhdGUgPSBnZXRBKGJhdGNoLCBpbklkeCk7XFxuICAgICAgICAgIGlmIChjYW5kaWRhdGUgXCIrcytcIiBiZXN0VmFsdWUpIHtcXG4gICAgICAgICAgICBiZXN0VmFsdWUgPSBjYW5kaWRhdGU7XFxuICAgICAgICAgICAgYmVzdEluZGV4ID0gaW5JZHg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChiZXN0SW5kZXgpKTtcXG4gICAgICB9XFxuICAgIFwifTtmdW5jdGlvbiBpYSh0LGUpe3JldHVybltcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl0uc2xpY2UoMCxlKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiB0K1wiLlwiK2V9KSl9ZnVuY3Rpb24gc2EodCxlKXtyZXR1cm4gMT09PWU/W3RdOmlhKHQsZSl9ZnVuY3Rpb24gdWEoKXt2YXIgdCxlLG4scixvLGEscyx1LGMsbDtyZXR1cm4gMj09PWkoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPyh0PVwiI3ZlcnNpb24gMzAwIGVzXCIsZT1cImluXCIsbj1cIm91dFwiLHI9XCJpblwiLG89XCJ0ZXh0dXJlXCIsYT1cIm91dHB1dENvbG9yXCIscz1cIm91dCB2ZWM0IG91dHB1dENvbG9yO1wiLHU9XCJcXG4gICAgICBib29sIGlzbmFuX2N1c3RvbShmbG9hdCB2YWwpIHtcXG4gICAgICAgIHJldHVybiAodmFsID4gMC4wIHx8IHZhbCA8IDAuMCkgPyBmYWxzZSA6IHZhbCAhPSAwLjA7XFxuICAgICAgfVxcblxcbiAgICAgIGJ2ZWM0IGlzbmFuX2N1c3RvbSh2ZWM0IHZhbCkge1xcbiAgICAgICAgcmV0dXJuIGJ2ZWM0KGlzbmFuX2N1c3RvbSh2YWwueCksXFxuICAgICAgICAgIGlzbmFuX2N1c3RvbSh2YWwueSksIGlzbmFuX2N1c3RvbSh2YWwueiksIGlzbmFuX2N1c3RvbSh2YWwudykpO1xcbiAgICAgIH1cXG5cXG4gICAgICAjZGVmaW5lIGlzbmFuKHZhbHVlKSBpc25hbl9jdXN0b20odmFsdWUpXFxuICAgIFwiLGM9XCJcIixsPVwiXFxuICAgICAgI2RlZmluZSByb3VuZCh2YWx1ZSkgbmV3Um91bmQodmFsdWUpXFxuICAgICAgaW50IG5ld1JvdW5kKGZsb2F0IHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gaW50KGZsb29yKHZhbHVlICsgMC41KSk7XFxuICAgICAgfVxcblxcbiAgICAgIGl2ZWM0IG5ld1JvdW5kKHZlYzQgdmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBpdmVjNChmbG9vcih2YWx1ZSArIHZlYzQoMC41KSkpO1xcbiAgICAgIH1cXG4gICAgXCIpOih0PVwiXCIsZT1cImF0dHJpYnV0ZVwiLG49XCJ2YXJ5aW5nXCIscj1cInZhcnlpbmdcIixvPVwidGV4dHVyZTJEXCIsYT1cImdsX0ZyYWdDb2xvclwiLHM9XCJcIix1PVwiXFxuICAgICAgI2RlZmluZSBpc25hbih2YWx1ZSkgaXNuYW5fY3VzdG9tKHZhbHVlKVxcbiAgICAgIGJvb2wgaXNuYW5fY3VzdG9tKGZsb2F0IHZhbCkge1xcbiAgICAgICAgcmV0dXJuICh2YWwgPiAwLiB8fCB2YWwgPCAxLiB8fCB2YWwgPT0gMC4pID8gZmFsc2UgOiB0cnVlO1xcbiAgICAgIH1cXG4gICAgICBidmVjNCBpc25hbl9jdXN0b20odmVjNCB2YWwpIHtcXG4gICAgICAgIHJldHVybiBidmVjNChpc25hbih2YWwueCksIGlzbmFuKHZhbC55KSwgaXNuYW4odmFsLnopLCBpc25hbih2YWwudykpO1xcbiAgICAgIH1cXG4gICAgXCIsYz1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgSU5GSU5JVFk7XFxuXFxuICAgICAgYm9vbCBpc2luZihmbG9hdCB2YWwpIHtcXG4gICAgICAgIHJldHVybiBhYnModmFsKSA9PSBJTkZJTklUWTtcXG4gICAgICB9XFxuICAgICAgYnZlYzQgaXNpbmYodmVjNCB2YWwpIHtcXG4gICAgICAgIHJldHVybiBlcXVhbChhYnModmFsKSwgdmVjNChJTkZJTklUWSkpO1xcbiAgICAgIH1cXG4gICAgXCIsbD1cIlxcbiAgICAgIGludCByb3VuZChmbG9hdCB2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGludChmbG9vcih2YWx1ZSArIDAuNSkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpdmVjNCByb3VuZCh2ZWM0IHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gaXZlYzQoZmxvb3IodmFsdWUgKyB2ZWM0KDAuNSkpKTtcXG4gICAgICB9XFxuICAgIFwiKSx7dmVyc2lvbjp0LGF0dHJpYnV0ZTplLHZhcnlpbmdWczpuLHZhcnlpbmdGczpyLHRleHR1cmUyRDpvLG91dHB1dDphLGRlZmluZU91dHB1dDpzLGRlZmluZVNwZWNpYWxOYU46dSxkZWZpbmVTcGVjaWFsSW5mOmMsZGVmaW5lUm91bmQ6bH19ZnVuY3Rpb24gY2EodCxlLG4pe3ZvaWQgMD09PW4mJihuPVwiaW5kZXhcIik7dmFyIHI9JChlKTtyZXR1cm4gci5tYXAoKGZ1bmN0aW9uKGUsbyl7cmV0dXJuXCJpbnQgXCIrdFtvXStcIiA9IFwiK24rXCIgLyBcIitlK1wiOyBcIisobz09PXIubGVuZ3RoLTE/XCJpbnQgXCIrdFtvKzFdK1wiID0gXCIrbitcIiAtIFwiK3Rbb10rXCIgKiBcIitlOlwiaW5kZXggLT0gXCIrdFtvXStcIiAqIFwiK2UpK1wiO1wifSkpLmpvaW4oXCJcIil9ZnVuY3Rpb24gbGEodCl7dmFyIGU9JCh0KS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvU3RyaW5nKCl9KSk7cmV0dXJuXCJcXG4gIGludCBnZXRGbGF0SW5kZXgoaXZlYzMgY29vcmRzKSB7XFxuICAgIHJldHVybiBjb29yZHMueCAqIFwiK2VbMF0rXCIgKyBjb29yZHMueSAqIFwiK2VbMV0rXCIgKyBjb29yZHMuejtcXG4gIH1cXG5cIn12YXIgaGE9XCJcXG4gIGNvbnN0IGZsb2F0IEZMT0FUX01BWCA9IDEuNzAxNDExODRlMzg7XFxuICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcXG5cXG4gIGxvd3AgdmVjNCBlbmNvZGVfZmxvYXQoaGlnaHAgZmxvYXQgdikge1xcbiAgICBpZiAoaXNuYW4odikpIHtcXG4gICAgICByZXR1cm4gdmVjNCgyNTUsIDI1NSwgMjU1LCAyNTUpO1xcbiAgICB9XFxuXFxuICAgIGhpZ2hwIGZsb2F0IGF2ID0gYWJzKHYpO1xcblxcbiAgICBpZihhdiA8IEZMT0FUX01JTikge1xcbiAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuICAgIH0gZWxzZSBpZih2ID4gRkxPQVRfTUFYKSB7XFxuICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDEyOC4wLCAxMjcuMCkgLyAyNTUuMDtcXG4gICAgfSBlbHNlIGlmKHYgPCAtRkxPQVRfTUFYKSB7XFxuICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsICAxMjguMCwgMjU1LjApIC8gMjU1LjA7XFxuICAgIH1cXG5cXG4gICAgaGlnaHAgdmVjNCBjID0gdmVjNCgwLDAsMCwwKTtcXG5cXG4gICAgaGlnaHAgZmxvYXQgZSA9IGZsb29yKGxvZzIoYXYpKTtcXG4gICAgaGlnaHAgZmxvYXQgbSA9IGV4cDIoZnJhY3QobG9nMihhdikpKSAtIDEuMDtcXG5cXG4gICAgY1syXSA9IGZsb29yKDEyOC4wICogbSk7XFxuICAgIG0gLT0gY1syXSAvIDEyOC4wO1xcbiAgICBjWzFdID0gZmxvb3IoMzI3NjguMCAqIG0pO1xcbiAgICBtIC09IGNbMV0gLyAzMjc2OC4wO1xcbiAgICBjWzBdID0gZmxvb3IoODM4ODYwOC4wICogbSk7XFxuXFxuICAgIGhpZ2hwIGZsb2F0IGViaWFzID0gZSArIDEyNy4wO1xcbiAgICBjWzNdID0gZmxvb3IoZWJpYXMgLyAyLjApO1xcbiAgICBlYmlhcyAtPSBjWzNdICogMi4wO1xcbiAgICBjWzJdICs9IGZsb29yKGViaWFzKSAqIDEyOC4wO1xcblxcbiAgICBjWzNdICs9IDEyOC4wICogc3RlcCgwLjAsIC12KTtcXG5cXG4gICAgcmV0dXJuIGMgLyAyNTUuMDtcXG4gIH1cXG5cIjtmdW5jdGlvbiBmYSh0LGUsbixyKXt2YXIgbz1bXTt0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPWsodC5zaGFwZUluZm8ubG9naWNhbFNoYXBlKTt0LnNoYXBlSW5mby5pc1VuaWZvcm0/by5wdXNoKFwidW5pZm9ybSBmbG9hdCBcIit0Lm5hbWUrKGU+MT9cIltcIitlK1wiXVwiOlwiXCIpK1wiO1wiKTooby5wdXNoKFwidW5pZm9ybSBzYW1wbGVyMkQgXCIrdC5uYW1lK1wiO1wiKSxvLnB1c2goXCJ1bmlmb3JtIGludCBvZmZzZXRcIit0Lm5hbWUrXCI7XCIpKX0pKTt2YXIgYSxpLHM9by5qb2luKFwiXFxuXCIpLHU9dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49ITEpO3ZhciByPVwiXCI7cis9bj9wYSh0KTpkYSh0KTt2YXIgbz10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsYT1lLmxvZ2ljYWxTaGFwZTtvLmxlbmd0aDw9YS5sZW5ndGgmJihyKz1uP2Z1bmN0aW9uKHQsZSl7dmFyIG4scj10Lm5hbWUsbz1yLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Iuc2xpY2UoMSksYT1cImdldFwiK28rXCJBdE91dENvb3Jkc1wiLGk9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aCxzPWUubG9naWNhbFNoYXBlLmxlbmd0aCx1PUNvKHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxlLmxvZ2ljYWxTaGFwZSksYz13YShzKSxsPXMtaSxoPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl07bj0wPT09aT9cIlwiOnM8MiYmdS5sZW5ndGg+PTE/XCJjb29yZHMgPSAwO1wiOnUubWFwKChmdW5jdGlvbih0KXtyZXR1cm5cImNvb3Jkcy5cIitoW3QrbF0rXCIgPSAwO1wifSkpLmpvaW4oXCJcXG5cIik7dmFyIGY9XCJcIjtmPXM8MiYmaT4wP1wiY29vcmRzXCI6dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5cImNvb3Jkcy5cIitoW2UrbF19KSkuam9pbihcIiwgXCIpO3ZhciBkPVwicmV0dXJuIG91dHB1dFZhbHVlO1wiLHA9MT09PWsodC5zaGFwZUluZm8ubG9naWNhbFNoYXBlKSx2PTE9PT1rKGUubG9naWNhbFNoYXBlKTtpZigxIT09aXx8cHx8dil7aWYocCYmIXYpZD0xPT09cz9cIlxcbiAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueCwgMC4sIDAuKTtcXG4gICAgICBcIjpcIlxcbiAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XFxuICAgICAgXCI7ZWxzZSBpZih1Lmxlbmd0aCl7dmFyIG09aS0yLGc9aS0xO3UuaW5kZXhPZihtKT4tMSYmdS5pbmRleE9mKGcpPi0xP2Q9XCJyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54KTtcIjp1LmluZGV4T2YobSk+LTE/ZD1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLnksIG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLnkpO1wiOnUuaW5kZXhPZihnKT4tMSYmKGQ9XCJyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eCwgb3V0cHV0VmFsdWUuenopO1wiKX19ZWxzZSBkPVwiXFxuICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueHksIG91dHB1dFZhbHVlLnh5KTtcXG4gICAgXCI7cmV0dXJuXCJcXG4gICAgdmVjNCBcIithK1wiKCkge1xcbiAgICAgIFwiK2MrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgXCIrbitcIlxcbiAgICAgIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRcIitvK1wiKFwiK2YrXCIpO1xcbiAgICAgIFwiK2QrXCJcXG4gICAgfVxcbiAgXCJ9KHQsZSk6ZnVuY3Rpb24odCxlKXt2YXIgbj10Lm5hbWUscj1uLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz1cImdldFwiK3IrXCJBdE91dENvb3Jkc1wiLGE9ZS50ZXhTaGFwZSxpPXQuc2hhcGVJbmZvLnRleFNoYXBlLHM9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aCx1PWUubG9naWNhbFNoYXBlLmxlbmd0aDtpZighdC5zaGFwZUluZm8uaXNVbmlmb3JtJiZzPT09dSYmbnVsbD09dC5zaGFwZUluZm8uZmxhdE9mZnNldCYmUyhpLGEpKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbytcIigpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHJlc3VsdFVWKTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBjLGw9d2EodSksaD1Dbyh0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsZS5sb2dpY2FsU2hhcGUpLGY9dS1zLGQ9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXTtjPTA9PT1zP1wiXCI6dTwyJiZoLmxlbmd0aD49MT9cImNvb3JkcyA9IDA7XCI6aC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblwiY29vcmRzLlwiK2RbdCtmXStcIiA9IDA7XCJ9KSkuam9pbihcIlxcblwiKTt2YXIgcD1cIlwiO3A9dTwyJiZzPjA/XCJjb29yZHNcIjp0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubWFwKChmdW5jdGlvbih0LGUpe3JldHVyblwiY29vcmRzLlwiK2RbZStmXX0pKS5qb2luKFwiLCBcIik7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrbytcIigpIHtcXG4gICAgICBcIitsK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIFwiK2MrXCJcXG4gICAgICByZXR1cm4gZ2V0XCIrcitcIihcIitwK1wiKTtcXG4gICAgfVxcbiAgXCJ9KHQsZSkpO3JldHVybiByfSh0LGUscil9KSkuam9pbihcIlxcblwiKSxjPWUudGV4U2hhcGUsbD11YSgpLGg9ZnVuY3Rpb24odCl7cmV0dXJuXCJcXG4gICAgZmxvYXQgc2FtcGxlVGV4dHVyZShzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXIsIHZlYzIgdXYpIHtcXG4gICAgICByZXR1cm4gXCIrdC50ZXh0dXJlMkQrXCIodGV4dHVyZVNhbXBsZXIsIHV2KS5yO1xcbiAgICB9XFxuICBcIn0obCksZj1mdW5jdGlvbih0KXtyZXR1cm4gdC52ZXJzaW9uK1wiXFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGludDtcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcXG4gICAgXCIrdC52YXJ5aW5nRnMrXCIgdmVjMiByZXN1bHRVVjtcXG4gICAgXCIrdC5kZWZpbmVPdXRwdXQrXCJcXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG4gICAgc3RydWN0IGl2ZWM1XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgfTtcXG5cXG4gICAgc3RydWN0IGl2ZWM2XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgICBpbnQgdjtcXG4gICAgfTtcXG5cXG4gICAgdW5pZm9ybSBmbG9hdCBOQU47XFxuICAgIFwiK3QuZGVmaW5lU3BlY2lhbE5hTitcIlxcbiAgICBcIit0LmRlZmluZVNwZWNpYWxJbmYrXCJcXG4gICAgXCIrdC5kZWZpbmVSb3VuZCtcIlxcblxcbiAgICBpbnQgaW1vZChpbnQgeCwgaW50IHkpIHtcXG4gICAgICByZXR1cm4geCAtIHkgKiAoeCAvIHkpO1xcbiAgICB9XFxuXFxuICAgIGludCBpZGl2KGludCBhLCBpbnQgYiwgZmxvYXQgc2lnbikge1xcbiAgICAgIGludCByZXMgPSBhIC8gYjtcXG4gICAgICBpbnQgbW9kID0gaW1vZChhLCBiKTtcXG4gICAgICBpZiAoc2lnbiA8IDAuICYmIG1vZCAhPSAwKSB7XFxuICAgICAgICByZXMgLT0gMTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlcztcXG4gICAgfVxcblxcbiAgICAvL0Jhc2VkIG9uIHRoZSB3b3JrIG9mIERhdmUgSG9za2luc1xcbiAgICAvL2h0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80ZGpTUldcXG4gICAgI2RlZmluZSBIQVNIU0NBTEUxIDQ0My44OTc1XFxuICAgIGZsb2F0IHJhbmRvbShmbG9hdCBzZWVkKXtcXG4gICAgICB2ZWMyIHAgPSByZXN1bHRVViAqIHNlZWQ7XFxuICAgICAgdmVjMyBwMyAgPSBmcmFjdCh2ZWMzKHAueHl4KSAqIEhBU0hTQ0FMRTEpO1xcbiAgICAgIHAzICs9IGRvdChwMywgcDMueXp4ICsgMTkuMTkpO1xcbiAgICAgIHJldHVybiBmcmFjdCgocDMueCArIHAzLnkpICogcDMueik7XFxuICAgIH1cXG5cXG4gICAgXCIrdmErXCJcXG4gICAgXCIrbWErXCJcXG4gICAgXCIrZ2ErXCJcXG4gIFwifShsKTtyZXR1cm4gZS5pc1BhY2tlZD8oYT1mdW5jdGlvbih0LGUpe3N3aXRjaCh0Lmxlbmd0aCl7Y2FzZSAwOnJldHVyblwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgcmV0dXJuIDA7XFxuICAgIH1cXG4gIFwiO2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgbj1bTWF0aC5jZWlsKGVbMF0vMiksTWF0aC5jZWlsKGVbMV0vMildO2lmKDE9PT1uWzBdKXJldHVyblwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAyICogaW50KHJlc3VsdFVWLnggKiBcIituWzFdK1wiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7aWYoMT09PW5bMV0pcmV0dXJuXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIDIgKiBpbnQocmVzdWx0VVYueSAqIFwiK25bMF0rXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtyZXR1cm5cIlxcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIituWzBdK1wiLCBcIituWzFdK1wiKSk7XFxuICAgICAgcmV0dXJuIDIgKiAocmVzVGV4UkMueCAqIFwiK25bMV0rXCIgKyByZXNUZXhSQy55KTtcXG4gICAgfVxcbiAgXCJ9KDAsZSk7Y2FzZSAyOnJldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPVtNYXRoLmNlaWwoZVswXS8yKSxNYXRoLmNlaWwoZVsxXS8yKV07aWYoUyh0LGUpKXJldHVyblwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIDIgKiBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoXCIrblswXStcIiwgXCIrblsxXStcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIHI9TWF0aC5jZWlsKHRbMV0vMik7cmV0dXJuXCJcXG4gICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIituWzBdK1wiLCBcIituWzFdK1wiKSk7XFxuXFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK25bMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIGludCByID0gMiAqIChpbmRleCAvIFwiK3IrXCIpO1xcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgXCIrcitcIikgKiAyO1xcblxcbiAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcXG4gICAgfVxcbiAgXCJ9KHQsZSk7Y2FzZSAzOnJldHVybiBuPXQscj1lLG89W01hdGguY2VpbChyWzBdLzIpLE1hdGguY2VpbChyWzFdLzIpXSxhPU1hdGguY2VpbChuWzJdLzIpLGk9YSpNYXRoLmNlaWwoblsxXS8yKSxcIlxcbiAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK29bMF0rXCIsIFwiK29bMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrb1sxXStcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgaW50IGIgPSBpbmRleCAvIFwiK2krXCI7XFxuICAgICAgaW5kZXggLT0gYiAqIFwiK2krXCI7XFxuXFxuICAgICAgaW50IHIgPSAyICogKGluZGV4IC8gXCIrYStcIik7XFxuICAgICAgaW50IGMgPSBpbW9kKGluZGV4LCBcIithK1wiKSAqIDI7XFxuXFxuICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xcbiAgICB9XFxuICBcIjtkZWZhdWx0OnJldHVybiBmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1bTWF0aC5jZWlsKGVbMF0vMiksTWF0aC5jZWlsKGVbMV0vMildLHI9TWF0aC5jZWlsKHRbdC5sZW5ndGgtMV0vMiksbz1yKk1hdGguY2VpbCh0W3QubGVuZ3RoLTJdLzIpLGE9byxpPVwiXCIscz1cImIsIHIsIGNcIix1PTI7dTx0Lmxlbmd0aC0xO3UrKylhKj10W3QubGVuZ3RoLXUtMV0saT1cIlxcbiAgICAgIGludCBiXCIrdStcIiA9IGluZGV4IC8gXCIrYStcIjtcXG4gICAgICBpbmRleCAtPSBiXCIrdStcIiAqIFwiK2ErXCI7XFxuICAgIFwiK2kscz1cImJcIit1K1wiLCBcIitzO3JldHVyblwiXFxuICAgIGl2ZWNcIit0Lmxlbmd0aCtcIiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK25bMF0rXCIsIFwiK25bMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrblsxXStcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgXCIraStcIlxcblxcbiAgICAgIGludCBiID0gaW5kZXggLyBcIitvK1wiO1xcbiAgICAgIGluZGV4IC09IGIgKiBcIitvK1wiO1xcblxcbiAgICAgIGludCByID0gMiAqIChpbmRleCAvIFwiK3IrXCIpO1xcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgXCIrcitcIikgKiAyO1xcblxcbiAgICAgIHJldHVybiBpdmVjXCIrdC5sZW5ndGgrXCIoXCIrcytcIik7XFxuICAgIH1cXG4gIFwifSh0LGUpfXZhciBuLHIsbyxhLGl9KGUubG9naWNhbFNoYXBlLGMpLGk9ZnVuY3Rpb24odCl7cmV0dXJuXCJcXG4gICAgdm9pZCBzZXRPdXRwdXQodmVjNCB2YWwpIHtcXG4gICAgICBcIit0Lm91dHB1dCtcIiA9IHZhbDtcXG4gICAgfVxcbiAgXCJ9KGwpKTooYT1mdW5jdGlvbih0LGUpe3N3aXRjaCh0Lmxlbmd0aCl7Y2FzZSAwOnJldHVyblwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgcmV0dXJuIDA7XFxuICAgIH1cXG4gIFwiO2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24odCxlKXtpZigxPT09ZVswXSlyZXR1cm5cIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnggKiBcIitlWzFdK1wiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7aWYoMT09PWVbMV0pcmV0dXJuXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGludChyZXN1bHRVVi55ICogXCIrZVswXStcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO3JldHVyblwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICByZXR1cm4gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICB9XFxuICBcIn0oMCxlKTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYoUyh0LGUpKXJldHVyblwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIjtpZigxPT09dFsxXSlyZXR1cm5cIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICAgIHJldHVybiBpdmVjMihpbmRleCwgMCk7XFxuICAgICAgfVxcbiAgICBcIjtpZigxPT09dFswXSlyZXR1cm5cIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICAgIHJldHVybiBpdmVjMigwLCBpbmRleCk7XFxuICAgICAgfVxcbiAgICBcIjtyZXR1cm5cIlxcbiAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgaW50IHIgPSBpbmRleCAvIFwiK3RbMV0rXCI7XFxuICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiBcIit0WzFdK1wiO1xcbiAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcXG4gICAgfVxcbiAgXCJ9KHQsZSk7Y2FzZSAzOnJldHVybiBuPWUscj1jYShbXCJyXCIsXCJjXCIsXCJkXCJdLHQpLFwiXFxuICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrblswXStcIiwgXCIrblsxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIituWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICBcIityK1wiXFxuICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xcbiAgICB9XFxuICBcIjtjYXNlIDQ6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49Y2EoW1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIl0sdCk7cmV0dXJuXCJcXG4gICAgaXZlYzQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIFwiK24rXCJcXG4gICAgICByZXR1cm4gaXZlYzQociwgYywgZCwgZDIpO1xcbiAgICB9XFxuICBcIn0odCxlKTtjYXNlIDU6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49Y2EoW1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCJdLHQpO3JldHVyblwiXFxuICAgIGl2ZWM1IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihcIitlWzBdK1wiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIrZVsxXStcIikpO1xcblxcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBcIituK1wiXFxuXFxuICAgICAgaXZlYzUgb3V0U2hhcGUgPSBpdmVjNShyLCBjLCBkLCBkMiwgZDMpO1xcbiAgICAgIHJldHVybiBvdXRTaGFwZTtcXG4gICAgfVxcbiAgXCJ9KHQsZSk7Y2FzZSA2OnJldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPWNhKFtcInJcIixcImNcIixcImRcIixcImQyXCIsXCJkM1wiLFwiZDRcIl0sdCk7cmV0dXJuXCJcXG4gICAgaXZlYzYgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIFwiK24rXCJcXG5cXG4gICAgICBpdmVjNiByZXN1bHQgPSBpdmVjNihyLCBjLCBkLCBkMiwgZDMsIGQ0KTtcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuICBcIn0odCxlKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcih0Lmxlbmd0aCtcIi1EIG91dHB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX12YXIgbixyfShlLmxvZ2ljYWxTaGFwZSxjKSxpPWZ1bmN0aW9uKHQpe3JldHVyblwiXFxuICAgIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHZhbCkge1xcbiAgICAgIFwiK3Qub3V0cHV0K1wiID0gdmVjNCh2YWwsIDAsIDAsIDApO1xcbiAgICB9XFxuICBcIn0obCkpLHImJihmKz15YSksW2YsaCxpLHMsYSx1LG5dLmpvaW4oXCJcXG5cIil9ZnVuY3Rpb24gZGEodCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlO3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10Lm5hbWUsbj1cImdldFwiK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKTtpZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJmbG9hdCBcIituK1wiKCkge3JldHVybiBcIitlK1wiO31cIjt2YXIgcj10LnNoYXBlSW5mby50ZXhTaGFwZSxvPXJbMF0sYT1yWzFdO2lmKDE9PT1vJiYxPT09YSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoKSB7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCBoYWxmQ1IpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGk9dC5zaGFwZUluZm8udGV4U2hhcGUscz1pWzBdLHU9aVsxXSxjPXhhKGUpO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK24rXCIoKSB7XFxuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrcytcIiwgXCIrdStcIiwgXCIrYytcIik7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrZStcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSAxOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10Lm5hbWUsbj1cImdldFwiK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKTtpZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIituK1wiKGludCBpbmRleCkge1xcbiAgICAgICAgXCIrYmEodCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciByPXQuc2hhcGVJbmZvLnRleFNoYXBlLG89clswXSxhPXJbMV07aWYoMT09PWEmJjE9PT1vKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIGhhbGZDUik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgaT14YShlKTtpZigxPT09YSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChmbG9hdChpbmRleCArIFwiK2krXCIpICsgMC41KSAvIFwiK28rXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtpZigxPT09bylyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXggKyBcIitpK1wiKSArIDAuNSkgLyBcIithK1wiLjAsIDAuNSk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIituK1wiKGludCBpbmRleCkge1xcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK28rXCIsIFwiK2ErXCIsIGluZGV4ICsgXCIraStcIik7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrZStcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSAyOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPXQuc2hhcGVJbmZvLnRleFNoYXBlO2lmKG51bGwhPW8mJlMoZSxvKSl7dmFyIGE9b1swXSxpPW9bMV07cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKFwiK2krXCIuMCwgXCIrYStcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifXZhciBzPU0oZSksdT1zLm5ld1NoYXBlLGM9cy5rZXB0RGltcyxsPXU7aWYobC5sZW5ndGg8ZS5sZW5ndGgpe3ZhciBoPUNhKHQsbCk7cmV0dXJuXCJcXG4gICAgICBcIitkYShoKStcIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrRWEoW1wicm93XCIsXCJjb2xcIl0sYykrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChkb3QodmVjMihyb3csIGNvbCksIHZlYzIoXCIrZVsxXStcIiwgMSkpKTtcXG4gICAgICAgIFwiK2JhKHQpK1wiXFxuICAgICAgfVxcbiAgICBcIjt2YXIgZj1vWzBdLGQ9b1sxXSxwPXhhKG4pO2lmKDE9PT1kKXJldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzMocm93LCBjb2wsIFwiK3ArXCIpLCB2ZWMzKFwiK2VbMV0rXCIsIDEsIDEpKTtcXG4gICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChpbmRleCArIDAuNSkgLyBcIitmK1wiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7aWYoMT09PWYpcmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgXCIrcCtcIiksIHZlYzMoXCIrZVsxXStcIiwgMSwgMSkpO1xcbiAgICAgIHZlYzIgdXYgPSB2ZWMyKChpbmRleCArIDAuNSkgLyBcIitkK1wiLjAsIDAuNSk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtyZXR1cm5cIlxcbiAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgaW50IGluZGV4ID0gcm93ICogXCIrZVsxXStcIiArIGNvbCArIFwiK3ArXCI7XFxuICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK2YrXCIsIFwiK2QrXCIsIGluZGV4KTtcXG4gICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgfVxcblwifSh0KTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89ZVsxXSplWzJdLGE9ZVsyXSxpPU0oZSkscz1pLm5ld1NoYXBlLHU9aS5rZXB0RGltcyxjPXM7aWYoYy5sZW5ndGg8ZS5sZW5ndGgpe3ZhciBsPUNhKHQsYyk7cmV0dXJuXCJcXG4gICAgICAgIFwiK2RhKGwpK1wiXFxuICAgICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgICByZXR1cm4gXCIrcitcIihcIitFYShbXCJyb3dcIixcImNvbFwiLFwiZGVwdGhcIl0sdSkrXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifWlmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChkb3QodmVjMyhyb3csIGNvbCwgZGVwdGgpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyhcIitvK1wiLCBcIithK1wiLCAxKSkpO1xcbiAgICAgICAgXCIrYmEodCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciBoPXQuc2hhcGVJbmZvLnRleFNoYXBlLGY9aFswXSxkPWhbMV0scD10LnNoYXBlSW5mby5mbGF0T2Zmc2V0O2lmKGQ9PT1vJiZudWxsPT1wKXJldHVyblwiXFxuICAgICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgICBmbG9hdCB0ZXhSID0gZmxvYXQocm93KTtcXG4gICAgICAgICAgZmxvYXQgdGV4QyA9IGRvdCh2ZWMyKGNvbCwgZGVwdGgpLCB2ZWMyKFwiK2ErXCIsIDEpKTtcXG4gICAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitkK1wiLjAsIFwiK2YrXCIuMCk7XFxuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtpZihkPT09YSYmbnVsbD09cClyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgIGZsb2F0IHRleFIgPSBkb3QodmVjMihyb3csIGNvbCksIHZlYzIoXCIrZVsxXStcIiwgMSkpO1xcbiAgICAgIGZsb2F0IHRleEMgPSBmbG9hdChkZXB0aCk7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIrZCtcIi4wLCBcIitmK1wiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7dmFyIHY9eGEobik7cmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICAgICAgaW50IGluZGV4ID0gcm93ICogXCIrbytcIiArIGNvbCAqIFwiK2ErXCIgKyBkZXB0aCArIFwiK3YrXCI7XFxuICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIitmK1wiLCBcIitkK1wiLCBpbmRleCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgXCJ9KHQpO2Nhc2UgNDpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz1lWzNdLGE9ZVsyXSpvLGk9ZVsxXSphLHM9TShlKSx1PXMubmV3U2hhcGUsYz1zLmtlcHREaW1zO2lmKHUubGVuZ3RoPGUubGVuZ3RoKXt2YXIgbD1DYSh0LHUpO3JldHVyblwiXFxuICAgICAgXCIrZGEobCkrXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrRWEoW1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIl0sYykrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGRvdCh2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQoXCIraStcIiwgXCIrYStcIiwgXCIrbytcIiwgMSkpKTtcXG4gICAgICAgIFwiK2JhKHQpK1wiXFxuICAgICAgfVxcbiAgICBcIjt2YXIgaD10LnNoYXBlSW5mby5mbGF0T2Zmc2V0LGY9dC5zaGFwZUluZm8udGV4U2hhcGUsZD1mWzBdLHA9ZlsxXTtpZihwPT09aSYmbnVsbD09aClyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICBmbG9hdCB0ZXhSID0gZmxvYXQocm93KTtcXG4gICAgICAgIGZsb2F0IHRleEMgPVxcbiAgICAgICAgICAgIGRvdCh2ZWMzKGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgICAgICAgIHZlYzMoXCIrYStcIiwgXCIrbytcIiwgMSkpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrcCtcIi4wLCBcIitkK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7aWYocD09PW8mJm51bGw9PWgpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgZmxvYXQgdGV4UiA9IGRvdCh2ZWMzKHJvdywgY29sLCBkZXB0aCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMoXCIrZVsxXSplWzJdK1wiLCBcIitlWzJdK1wiLCAxKSk7XFxuICAgICAgICBmbG9hdCB0ZXhDID0gZmxvYXQoZGVwdGgyKTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgIHZlYzIoXCIrcCtcIi4wLCBcIitkK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIHY9eGEobik7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICAgICAgaW50IGluZGV4ID0gcm93ICogXCIraStcIiArIGNvbCAqIFwiK2ErXCIgK1xcbiAgICAgICAgICBkZXB0aCAqIFwiK28rXCIgKyBkZXB0aDI7XFxuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrZCtcIiwgXCIrcCtcIiwgaW5kZXggKyBcIit2K1wiKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtjYXNlIDU6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89ZVs0XSxhPWVbM10qbyxpPWVbMl0qYSxzPWVbMV0qaSx1PU0oZSksYz11Lm5ld1NoYXBlLGw9dS5rZXB0RGltcztpZihjLmxlbmd0aDxlLmxlbmd0aCl7dmFyIGg9Q2EodCxjKTtyZXR1cm5cIlxcbiAgICAgIFwiK2RhKGgpK1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIHJldHVybiBcIityK1wiKFwiK0VhKFtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIl0sbCkrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4ID0gZG90KFxcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIitzK1wiLCBcIitpK1wiLCBcIithK1wiLCBcIitvK1wiKSkgK1xcbiAgICAgICAgICBkZXB0aDM7XFxuICAgICAgICBcIitiYSh0KStcIlxcbiAgICAgIH1cXG4gICAgXCI7dmFyIGY9dC5zaGFwZUluZm8uZmxhdE9mZnNldCxkPXQuc2hhcGVJbmZvLnRleFNoYXBlLHA9ZFswXSx2PWRbMV07aWYodj09PXMmJm51bGw9PWYpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgaW50IHRleFIgPSByb3c7XFxuICAgICAgICBmbG9hdCB0ZXhDID0gZG90KHZlYzQoY29sLCBkZXB0aCwgZGVwdGgyLCBkZXB0aDMpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICB2ZWM0KFwiK2krXCIsIFwiK2ErXCIsIFwiK28rXCIsIDEpKTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK3YrXCIuMCwgXCIrcCtcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO2lmKHY9PT1vJiZudWxsPT1mKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QoXFxuICAgICAgICAgIHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICB2ZWM0KFwiK2VbMV0qZVsyXSplWzNdK1wiLFxcbiAgICAgICAgICAgICAgIFwiK2VbMl0qZVszXStcIiwgXCIrZVszXStcIiwgMSkpO1xcbiAgICAgICAgaW50IHRleEMgPSBkZXB0aDM7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICB2ZWMyKFwiK3YrXCIuMCwgXCIrcCtcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBtPXhhKG4pO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiK3MrXCIgKyBjb2wgKiBcIitpK1wiICsgZGVwdGggKiBcIithK1wiICtcXG4gICAgICAgICAgZGVwdGgyICogXCIrbytcIiArIGRlcHRoMyArIFwiK20rXCI7XFxuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrcCtcIiwgXCIrditcIiwgaW5kZXgpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2Nhc2UgNjpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz1NKGUpLGE9by5uZXdTaGFwZSxpPW8ua2VwdERpbXM7aWYoYS5sZW5ndGg8ZS5sZW5ndGgpe3ZhciBzPUNhKHQsYSk7cmV0dXJuXCJcXG4gICAgICBcIitkYShzKStcIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrRWEoW1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiLFwiZGVwdGg0XCJdLGkpK1wiKTtcXG4gICAgICB9XFxuICAgIFwifXZhciB1PWVbNV0sYz1lWzRdKnUsbD1lWzNdKmMsaD1lWzJdKmwsZj1lWzFdKmg7aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZG90KFxcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIitmK1wiLCBcIitoK1wiLCBcIitsK1wiLCBcIitjK1wiKSkgK1xcbiAgICAgICAgICBkb3QoXFxuICAgICAgICAgICAgdmVjMihkZXB0aDMsIGRlcHRoNCksXFxuICAgICAgICAgICAgdmVjMihcIit1K1wiLCAxKSkpO1xcbiAgICAgICAgXCIrYmEodCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciBkPXQuc2hhcGVJbmZvLmZsYXRPZmZzZXQscD10LnNoYXBlSW5mby50ZXhTaGFwZSx2PXBbMF0sbT1wWzFdO2lmKG09PT1mJiZudWxsPT1kKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgIGZsb2F0IHRleEMgPSBkb3QodmVjNChjb2wsIGRlcHRoLCBkZXB0aDIsIGRlcHRoMyksXFxuICAgICAgICAgIHZlYzQoXCIraCtcIiwgXCIrbCtcIiwgXCIrYytcIiwgXCIrdStcIikpICtcXG4gICAgICAgICAgICAgICBmbG9hdChkZXB0aDQpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrbStcIi4wLCBcIit2K1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7aWYobT09PXUmJm51bGw9PWQpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QodmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgIHZlYzQoXCIrZVsxXSplWzJdKmVbM10qZVs0XStcIixcXG4gICAgICAgICAgICAgICBcIitlWzJdKmVbM10qZVs0XStcIixcXG4gICAgICAgICAgICAgICBcIitlWzNdKmVbNF0rXCIsXFxuICAgICAgICAgICAgICAgXCIrZVs0XStcIikpICsgZmxvYXQoZGVwdGgzKTtcXG4gICAgICAgIGludCB0ZXhDID0gZGVwdGg0O1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIittK1wiLjAsIFwiK3YrXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgZz14YShuKTtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiK2YrXCIgKyBjb2wgKiBcIitoK1wiICsgZGVwdGggKiBcIitsK1wiICtcXG4gICAgICAgICAgZGVwdGgyICogXCIrYytcIiArIGRlcHRoMyAqIFwiK3UrXCIgKyBkZXB0aDQgKyBcIitnK1wiO1xcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK3YrXCIsIFwiK20rXCIsIGluZGV4KTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihlLmxlbmd0aCtcIi1EIGlucHV0IHNhbXBsaW5nIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfX1mdW5jdGlvbiBwYSh0KXt2YXIgZSxuLHI7c3dpdGNoKHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gZT10Lm5hbWUsbj1cImdldFwiK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxyPXVhKCksXCJcXG4gICAgdmVjNCBcIituK1wiKCkge1xcbiAgICAgIHJldHVybiBcIityLnRleHR1cmUyRCtcIihcIitlK1wiLCBoYWxmQ1IpO1xcbiAgICB9XFxuICBcIjtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQubmFtZSxuPVwiZ2V0XCIrZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpLHI9dC5zaGFwZUluZm8udGV4U2hhcGUsbz1bTWF0aC5jZWlsKHJbMF0vMiksTWF0aC5jZWlsKHJbMV0vMildLGE9dWEoKTtyZXR1cm5cIlxcbiAgICB2ZWM0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTFEKFxcbiAgICAgICAgXCIrb1swXStcIiwgXCIrb1sxXStcIiwgaW5kZXgpO1xcbiAgICAgIHJldHVybiBcIithLnRleHR1cmUyRCtcIihcIitlK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89dC5zaGFwZUluZm8udGV4U2hhcGUsYT1vWzBdLGk9b1sxXSxzPXVhKCk7aWYobnVsbCE9byYmUyhlLG8pKXJldHVyblwiXFxuICAgICAgdmVjNCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMihcIitpK1wiLjAsIFwiK2ErXCIuMCk7XFxuXFxuICAgICAgICByZXR1cm4gXCIrcy50ZXh0dXJlMkQrXCIoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIHU9W01hdGguY2VpbChvWzBdLzIpLE1hdGguY2VpbChvWzFdLzIpXSxjPU1hdGguY2VpbChlWzFdLzIpO3JldHVyblwiXFxuICAgIHZlYzQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTJEKFwiK2MrXCIsIFwiK3VbMF0rXCIsIFwiK3VbMV0rXCIsIHJvdywgY29sKTtcXG4gICAgICByZXR1cm4gXCIrcy50ZXh0dXJlMkQrXCIoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSAzOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPXQuc2hhcGVJbmZvLnRleFNoYXBlLGE9W01hdGguY2VpbChvWzBdLzIpLE1hdGguY2VpbChvWzFdLzIpXTtpZigxPT09ZVswXSl7dmFyIGk9ZS5zbGljZSgxKSxzPUNhKHQsaSk7cmV0dXJuXCJcXG4gICAgICAgIFwiK3BhKHMpK1wiXFxuICAgICAgICB2ZWM0IFwiK3IrXCIoaW50IGIsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrRWEoW1wiYlwiLFwicm93XCIsXCJjb2xcIl0sWzEsMl0pK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn12YXIgdT1hWzBdLGM9YVsxXSxsPU1hdGguY2VpbChlWzJdLzIpLGg9bCpNYXRoLmNlaWwoZVsxXS8yKSxmPXVhKCk7cmV0dXJuXCJcXG4gICAgdmVjNCBcIityK1wiKGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTNEKFxcbiAgICAgICAgXCIrdStcIiwgXCIrYytcIiwgXCIraCtcIiwgXCIrbCtcIiwgYiwgcm93LCBjb2wpO1xcbiAgICAgIHJldHVybiBcIitmLnRleHR1cmUyRCtcIihcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtkZWZhdWx0OnJldHVybiBmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49ZS5sZW5ndGgscj10Lm5hbWUsbz1cImdldFwiK3IuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrci5zbGljZSgxKSxhPXQuc2hhcGVJbmZvLnRleFNoYXBlLGk9W01hdGguY2VpbChhWzBdLzIpLE1hdGguY2VpbChhWzFdLzIpXSxzPWlbMF0sdT1pWzFdLGM9TWF0aC5jZWlsKGVbbi0xXS8yKSxsPWMqTWF0aC5jZWlsKGVbbi0yXS8yKSxoPVwiaW50IGIsIGludCByb3csIGludCBjb2xcIixmPVwiYiAqIFwiK2wrXCIgKyAocm93IC8gMikgKiBcIitjK1wiICsgKGNvbCAvIDIpXCIsZD0yO2Q8bi0xO2QrKyloPVwiaW50IGJcIitkK1wiLCBcIitoLGwqPWVbbi1kLTFdLGY9XCJiXCIrZCtcIiAqIFwiK2wrXCIgKyBcIitmO3ZhciBwPXVhKCk7cmV0dXJuXCJcXG4gICAgdmVjNCBcIitvK1wiKFwiK2grXCIpIHtcXG4gICAgICBpbnQgaW5kZXggPSBcIitmK1wiO1xcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLyBcIit1K1wiO1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogXCIrdStcIjtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMihcIit1K1wiLCBcIitzK1wiKTtcXG4gICAgICByZXR1cm4gXCIrcC50ZXh0dXJlMkQrXCIoXCIrcitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCl9fXZhciB2YT1cIlxcbnZlYzIgdXZGcm9tRmxhdChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxudmVjMiBwYWNrZWRVVmZyb20xRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgaW50IHRleGVsSW5kZXggPSBpbmRleCAvIDI7XFxuICBpbnQgdGV4UiA9IHRleGVsSW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCIsbWE9XCJcXG52ZWMyIHBhY2tlZFVWZnJvbTJEKGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCB0ZXhOdW1SLFxcbiAgaW50IHRleE51bUMsIGludCByb3csIGludCBjb2wpIHtcXG4gIGludCB0ZXhlbEluZGV4ID0gKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiLGdhPVwiXFxudmVjMiBwYWNrZWRVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsXFxuICAgIGludCB0ZXhlbHNJbkJhdGNoLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgYixcXG4gICAgaW50IHJvdywgaW50IGNvbCkge1xcbiAgaW50IGluZGV4ID0gYiAqIHRleGVsc0luQmF0Y2ggKyAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIix5YT1cIlxcbiAgZmxvYXQgZ2V0Q2hhbm5lbCh2ZWM0IGZyYWcsIHZlYzIgaW5uZXJEaW1zKSB7XFxuICAgIHZlYzIgbW9kQ29vcmQgPSBtb2QoaW5uZXJEaW1zLCAyLik7XFxuICAgIHJldHVybiBtb2RDb29yZC54ID09IDAuID9cXG4gICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuciA6IGZyYWcuZykgOlxcbiAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5iIDogZnJhZy5hKTtcXG4gIH1cXG4gIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCBpbnQgZGltKSB7XFxuICAgIGZsb2F0IG1vZENvb3JkID0gbW9kKGZsb2F0KGRpbSksIDIuKTtcXG4gICAgcmV0dXJuIG1vZENvb3JkID09IDAuID8gZnJhZy5yIDogZnJhZy5nO1xcbiAgfVxcblwiO2Z1bmN0aW9uIHhhKHQpe3JldHVyblwib2Zmc2V0XCIrdH1mdW5jdGlvbiBiYSh0KXt2YXIgZT10Lm5hbWUsbj1rKHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk7cmV0dXJuIG48Mj9cInJldHVybiBcIitlK1wiO1wiOlwiXFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrbitcIjsgaSsrKSB7XFxuICAgICAgaWYgKGkgPT0gaW5kZXgpIHtcXG4gICAgICAgIHJldHVybiBcIitlK1wiW2ldO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gd2EodCl7aWYodDw9MSlyZXR1cm5cImludFwiO2lmKDI9PT10KXJldHVyblwiaXZlYzJcIjtpZigzPT09dClyZXR1cm5cIml2ZWMzXCI7aWYoND09PXQpcmV0dXJuXCJpdmVjNFwiO2lmKDU9PT10KXJldHVyblwiaXZlYzVcIjtpZig2PT09dClyZXR1cm5cIml2ZWM2XCI7dGhyb3cgRXJyb3IoXCJHUFUgZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX1mdW5jdGlvbiBDYSh0LGUpe3ZhciBuPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodCkpO3JldHVybiBuLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU9ZSxufWZ1bmN0aW9uIEVhKHQsZSl7cmV0dXJuIGUubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gdFtlXX0pKS5qb2luKFwiLCBcIil9dmFyIFJhPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLEModC5sZW5ndGg+MiwoZnVuY3Rpb24oKXtyZXR1cm5cIlBhY2tlZCBhcmdcIisobi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpKStcIiBzdXBwb3J0cyBvbmx5IGlucHV0cyB3aXRoIHJhbmsgYWJvdmUgMi5cIn0pKTt2YXIgbz10W3QubGVuZ3RoLTFdLGE9TWF0aC5jZWlsKG8vZSk7dGhpcy5vdXRwdXRTaGFwZT10LnNsaWNlKDAsLTEpLGE+MSYmdGhpcy5vdXRwdXRTaGFwZS5wdXNoKGEpLHJ8fHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmVzdEluZGljZXNBXCIpO3ZhciBpLHMsdT10aGlzLm91dHB1dFNoYXBlLGM9dS5sZW5ndGgsbD13YShjKSxoPXNhKFwiY29vcmRzXCIsYyk7aWYoMT09PWEpe3ZhciBmPXdhKHM9YysxKTtpPVwiXFxuICAgICAgICBcIitmK1wiIHNvdXJjZUxvY1IgPSBcIitmK1wiKFwiK2guam9pbigpK1wiLCAwKTtcXG4gICAgICAgICsrXCIraFtjLTFdK1wiO1xcbiAgICAgICAgXCIrZitcIiBzb3VyY2VMb2NHID0gXCIrZitcIihcIitoLmpvaW4oKStcIiwgMCk7XFxuICAgICAgICArK1wiK2hbYy0yXStcIjtcXG4gICAgICAgIFwiK2YrXCIgc291cmNlTG9jQSA9IFwiK2YrXCIoXCIraC5qb2luKCkrXCIsIDApO1xcbiAgICAgICAgLS1cIitoW2MtMV0rXCI7XFxuICAgICAgICBcIitmK1wiIHNvdXJjZUxvY0IgPSBcIitmK1wiKFwiK2guam9pbigpK1wiLCAwKTtcXG4gICAgICAgIC0tXCIraFtjLTJdK1wiO1wifWVsc2Ugcz1jLGk9XCJcXG4gICAgICAgIFwiK2wrXCIgc291cmNlTG9jUiA9IGNvb3JkcztcXG4gICAgICAgICsrXCIraFtjLTFdK1wiO1xcbiAgICAgICAgXCIrbCtcIiBzb3VyY2VMb2NHID0gY29vcmRzO1xcbiAgICAgICAgKytcIitoW2MtMl0rXCI7XFxuICAgICAgICBcIitsK1wiIHNvdXJjZUxvY0EgPSBjb29yZHM7XFxuICAgICAgICAtLVwiK2hbYy0xXStcIjtcXG4gICAgICAgIFwiK2wrXCIgc291cmNlTG9jQiA9IGNvb3JkcztcXG4gICAgICAgIC0tXCIraFtjLTJdK1wiO1wiO3ZhciBkPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl0uc2xpY2UoMCxzKSxwPVwiLlwiK2Rbcy0xXSx2PWQubWFwKChmdW5jdGlvbih0KXtyZXR1cm5cImludCBcIit0fSkpLG09c2EoXCJzb3VyY2VMb2NSXCIscy0xKS5jb25jYXQoXCJpbklkeC5yXCIpLGc9c2EoXCJzb3VyY2VMb2NHXCIscy0xKS5jb25jYXQoXCJpbklkeC5nXCIpLHk9c2EoXCJzb3VyY2VMb2NCXCIscy0xKS5jb25jYXQoXCJpbklkeC5iXCIpLHg9c2EoXCJzb3VyY2VMb2NBXCIscy0xKS5jb25jYXQoXCJpbklkeC5hXCIpLGI9XCJtYXhcIj09PW4/XCJncmVhdGVyVGhhblwiOlwibGVzc1RoYW5cIix3PXI/XCJcIjpcIlxcbiAgICAgICAgICBpbklkeCA9IHJvdW5kKHZlYzQoZ2V0QmVzdEluZGljZXNBQ2hhbm5lbChcIittLmpvaW4oKStcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiK2cuam9pbigpK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoXCIreS5qb2luKCkrXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QmVzdEluZGljZXNBQ2hhbm5lbChcIit4LmpvaW4oKStcIikpKTtcIixFPVwidmVjNChcXG4gICAgICAgICAgICBnZXRBQ2hhbm5lbChcIittLmpvaW4oKStcIiksXFxuICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFDaGFubmVsKFwiK2cuam9pbigpK1wiKSA6IDAuLFxcbiAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBQ2hhbm5lbChcIit5LmpvaW4oKStcIikgOiAwLixcXG4gICAgICAgICAgICBoYXNOZXh0Um93ICYmIGhhc05leHRDb2wgPyBnZXRBQ2hhbm5lbChcIit4LmpvaW4oKStcIikgOiAwLilcIixSPXI/XCJcIjpcIlxcbiAgICAgIGZsb2F0IGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoXCIrdi5qb2luKCkrXCIpIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldEJlc3RJbmRpY2VzQShcIitkLmpvaW4oKStcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitkLnNsaWNlKC0yKS5qb2luKCkrXCIpKTtcXG4gICAgICB9XCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IGdldEFDaGFubmVsKFwiK3Yuam9pbigpK1wiKSB7XFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRBKFwiK2Quam9pbigpK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitkLnNsaWNlKC0yKS5qb2luKCkrXCIpKTtcXG4gICAgICB9XFxuICAgICAgXCIrUitcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK2wrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBib29sIGhhc05leHRDb2wgPSBcIitoW2MtMV0rXCIgPCBcIisodVtjLTFdLTEpK1wiO1xcbiAgICAgICAgYm9vbCBoYXNOZXh0Um93ID0gXCIraFtjLTJdK1wiIDwgXCIrKHVbYy0yXS0xKStcIjtcXG4gICAgICAgIFwiK2krXCJcXG4gICAgICAgIGl2ZWM0IHNyY0lkeCA9IGl2ZWM0KHNvdXJjZUxvY1JcIitwK1wiLCBzb3VyY2VMb2NHXCIrcCtcIixcXG4gICAgICAgICAgc291cmNlTG9jQlwiK3ArXCIsIHNvdXJjZUxvY0FcIitwK1wiKSAqIFwiK2UrXCI7XFxuICAgICAgICBpdmVjNCBpbklkeCA9IHNyY0lkeDtcXG4gICAgICAgIHZlYzQgYmVzdEluZGV4ID0gdmVjNChpbklkeCk7XFxuICAgICAgICB2ZWM0IGJlc3RWYWx1ZSA9IFwiK0UrXCI7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK2UrXCI7IGkrKykge1xcbiAgICAgICAgICBpbklkeCA9IHNyY0lkeDtcXG4gICAgICAgICAgXCIrdytcIlxcbiAgICAgICAgICB2ZWM0IGNhbmRpZGF0ZSA9IFwiK0UrXCI7XFxuICAgICAgICAgIGJ2ZWM0IG5hbiA9IGlzbmFuKGNhbmRpZGF0ZSk7XFxuICAgICAgICAgIGJ2ZWM0IHJlcGxhY2UgPSBidmVjNChcXG4gICAgICAgICAgICB2ZWM0KFwiK2IrXCIoY2FuZGlkYXRlLCBiZXN0VmFsdWUpKSAqICh2ZWM0KDEuMCkgLSB2ZWM0KG5hbikpKTtcXG5cXG4gICAgICAgICAgYmVzdFZhbHVlID0gdmVjNChyZXBsYWNlLnggID8gY2FuZGlkYXRlLnggOiBiZXN0VmFsdWUueCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLnkgID8gY2FuZGlkYXRlLnkgOiBiZXN0VmFsdWUueSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLnogID8gY2FuZGlkYXRlLnogOiBiZXN0VmFsdWUueixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLncgID8gY2FuZGlkYXRlLncgOiBiZXN0VmFsdWUudyk7XFxuICAgICAgICAgIGJlc3RJbmRleCA9IG1peChiZXN0SW5kZXgsIHZlYzQoaW5JZHgpLCB2ZWM0KHJlcGxhY2UpKTtcXG4gICAgICAgICAgc3JjSWR4Kys7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoYmVzdEluZGV4KTtcXG4gICAgICB9XFxuICAgIFwifSxJYT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmluU2hhcGU7dmFyIGU9dC5maWx0ZXJIZWlnaHQsbj10LmZpbHRlcldpZHRoLHI9dC5zdHJpZGVIZWlnaHQsbz10LnN0cmlkZVdpZHRoLGE9dC5kaWxhdGlvbkhlaWdodCxpPXQuZGlsYXRpb25XaWR0aCxzPXQuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHU9dC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxjPXMtMS10LnBhZEluZm8udG9wLGw9dS0xLXQucGFkSW5mby5sZWZ0LGg9MS8oZSpuKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2MrXCIsIFwiK2wrXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IGF2Z011bHRpcGxpZXIgPSBmbG9hdChcIitoK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiBkeVJDQ29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeVJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZCkgd2l0aCBwb3MgbWFzayg6LCA6LCBkKSB0byBnZXQgZHgoeFIsIHhDLCBkKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitzK1wiO1xcbiAgICAgICAgICAgIHdSICs9IFwiK2ErXCIpIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrcitcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrdStcIjtcXG4gICAgICAgICAgICB3Qys9IFwiK2krXCIpIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIitvK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBpZHlSLCBpZHlDLCBkKTtcXG5cXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBhdmdNdWx0aXBsaWVyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0sa2E9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuZmlsdGVyRGVwdGgsbj10LmZpbHRlckhlaWdodCxyPXQuZmlsdGVyV2lkdGgsbz10LnN0cmlkZURlcHRoLGE9dC5zdHJpZGVIZWlnaHQsaT10LnN0cmlkZVdpZHRoLHM9dC5kaWxhdGlvbkRlcHRoLHU9dC5kaWxhdGlvbkhlaWdodCxjPXQuZGlsYXRpb25XaWR0aCxsPXQuZWZmZWN0aXZlRmlsdGVyRGVwdGgsaD10LmVmZmVjdGl2ZUZpbHRlckhlaWdodCxmPXQuZWZmZWN0aXZlRmlsdGVyV2lkdGgsZD1sLTEtdC5wYWRJbmZvLmZyb250LHA9aC0xLXQucGFkSW5mby50b3Asdj1mLTEtdC5wYWRJbmZvLmxlZnQsbT0xLyhlKm4qcik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMyhcIitkK1wiLCBcIitwK1wiLCBcIit2K1wiKTtcXG4gICAgICBjb25zdCBmbG9hdCBhdmdNdWx0aXBsaWVyID0gZmxvYXQoXCIrbStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGludCBjaCA9IGNvb3Jkcy51O1xcblxcbiAgICAgICAgaXZlYzMgZHlDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlEQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci55O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLno7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCA/LCBkKSB3aXRoIHBvcyBtYXNrKDosIDosIDosIGNoKSB0byBnZXRcXG4gICAgICAgIC8vIGR4KHhELCB4UiwgeEMsIGNoKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdEID0gMDsgd0QgPCBcIitsK1wiO1xcbiAgICAgICAgICAgIHdEICs9IFwiK3MrXCIpIHtcXG4gICAgICAgICAgZmxvYXQgZHlEID0gZmxvYXQoZHlEQ29ybmVyICsgd0QpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlEIDwgMC4wIHx8IGR5RCA+PSBcIit0Lm91dERlcHRoK1wiLjAgfHwgZnJhY3QoZHlEKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlEID0gaW50KGR5RCk7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitoK1wiO1xcbiAgICAgICAgICAgICAgd1IgKz0gXCIrdStcIikge1xcbiAgICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK2ErXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitmK1wiO1xcbiAgICAgICAgICAgICAgICB3QyArPSBcIitjK1wiKSB7XFxuICAgICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIitpK1wiLjA7XFxuXFxuICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIit0Lm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5RCwgaWR5UiwgaWR5QywgY2gpO1xcblxcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogYXZnTXVsdGlwbGllcjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifSxTYT1mdW5jdGlvbih0LGUsbixyLG8sYSl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwibWVhblwiLFwidmFyaWFuY2VcIl0sUm8odCxlKSxSbyh0LG4pO3ZhciBpPVwiMC4wXCI7bnVsbCE9ciYmKFJvKHQsciksdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJvZmZzZXRcIiksaT1cImdldE9mZnNldEF0T3V0Q29vcmRzKClcIik7dmFyIHM9XCIxLjBcIjtudWxsIT1vJiYoUm8odCxvKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInNjYWxlXCIpLHM9XCJnZXRTY2FsZUF0T3V0Q29vcmRzKClcIiksdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0WEF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBtZWFuID0gZ2V0TWVhbkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IGdldFZhcmlhbmNlQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IG9mZnNldCA9IFwiK2krXCI7XFxuICAgICAgICBmbG9hdCBzY2FsZSA9IFwiK3MrXCI7XFxuICAgICAgICBmbG9hdCBpbnYgPSBzY2FsZSAqIGludmVyc2VzcXJ0KHZhcmlhbmNlICsgZmxvYXQoXCIrYStcIikpO1xcbiAgICAgICAgc2V0T3V0cHV0KGRvdCh2ZWMzKHgsIC1tZWFuLCBvZmZzZXQpLCB2ZWMzKGludiwgaW52LCAxKSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9LEFhPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwibWVhblwiLFwidmFyaWFuY2VcIl0sUm8odCxlKSxSbyh0LG4pO3ZhciBpPVwidmVjNCgwLjApXCI7bnVsbCE9ciYmKFJvKHQsciksdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJvZmZzZXRcIiksaT1cImdldE9mZnNldEF0T3V0Q29vcmRzKClcIik7dmFyIHM9XCJ2ZWM0KDEuMClcIjtudWxsIT1vJiYoUm8odCxvKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInNjYWxlXCIpLHM9XCJnZXRTY2FsZUF0T3V0Q29vcmRzKClcIiksdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IG9mZnNldCA9IFwiK2krXCI7XFxuICAgICAgICB2ZWM0IHNjYWxlID0gXCIrcytcIjtcXG5cXG4gICAgICAgIHZlYzQgeCA9IGdldFhBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCBtZWFuID0gZ2V0TWVhbkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHZhcmlhbmNlID0gZ2V0VmFyaWFuY2VBdE91dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCBpbnYgPSBzY2FsZSAqIGludmVyc2VzcXJ0KHZhcmlhbmNlICsgdmVjNChcIithK1wiKSk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoKHggLSBtZWFuKSAqIGludiArIG9mZnNldCk7XFxuICAgICAgfVxcbiAgICBcIn0sRGE9XCJyZXR1cm4gYXJlYWwgKiBicmVhbCAtIGFpbWFnICogYmltYWc7XCIsVGE9XCJyZXR1cm4gYXJlYWwgKiBiaW1hZyArIGFpbWFnICogYnJlYWw7XCIsTmE9ZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBUmVhbFwiLFwiQUltYWdcIixcIkJSZWFsXCIsXCJCSW1hZ1wiXSx0aGlzLm91dHB1dFNoYXBlPVJvKGUsbiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IGJpbmFyeU9wQ29tcGxleChcXG4gICAgICAgICAgZmxvYXQgYXJlYWwsIGZsb2F0IGFpbWFnLCBmbG9hdCBicmVhbCwgZmxvYXQgYmltYWcpIHtcXG4gICAgICAgIFwiK3QrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgYXJlYWwgPSBnZXRBUmVhbEF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBhaW1hZyA9IGdldEFJbWFnQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGJyZWFsID0gZ2V0QlJlYWxBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYmltYWcgPSBnZXRCSW1hZ0F0T3V0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoYmluYXJ5T3BDb21wbGV4KGFyZWFsLCBhaW1hZywgYnJlYWwsIGJpbWFnKSk7XFxuICAgICAgfVxcbiAgICBcIn0sRmE9XCJyZXR1cm4gYSArIGI7XCIsX2E9XCJyZXR1cm4gYSAtIGI7XCIsT2E9XCJyZXR1cm4gYSAqIGI7XCIsTWE9XCJyZXR1cm4gKGEgPCAwLikgPyBiICogYSA6IGE7XCIsQmE9ZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCIsXCJCXCJdLHRoaXMub3V0cHV0U2hhcGU9Um8oZSxuKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgZmxvYXQgYmluYXJ5T3BlcmF0aW9uKGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgICAgIFwiK3QrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgYSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGJpbmFyeU9wZXJhdGlvbihhLCBiKSk7XFxuICAgICAgfVxcbiAgICBcIn0sUGE9XCJcXG4gIHZlYzQgYUxlc3NUaGFuWmVybyA9IHZlYzQobGVzc1RoYW4oYSwgdmVjNCgwLikpKTtcXG4gIHJldHVybiAoYUxlc3NUaGFuWmVybyAqIChiICogYSkpICsgKCh2ZWM0KDEuMCkgLSBhTGVzc1RoYW5aZXJvKSAqIGEpO1xcblwiLExhPWZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPSExKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiLFwiQlwiXSx0aGlzLnN1cHBvcnRzQnJvYWRjYXN0aW5nPSEwLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9Um8oZSxuKTt2YXIgbz10aGlzLm91dHB1dFNoYXBlLmxlbmd0aCxhPVwiXCI7aWYocilpZigwPT09b3x8MT09PWsodGhpcy5vdXRwdXRTaGFwZSkpYT1cIlxcbiAgICAgICAgICByZXN1bHQueSA9IDAuO1xcbiAgICAgICAgICByZXN1bHQueiA9IDAuO1xcbiAgICAgICAgICByZXN1bHQudyA9IDAuO1xcbiAgICAgICAgXCI7ZWxzZSBpZihhPVwiXFxuICAgICAgICAgIFwiK3dhKG8pK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgXCIsMT09PW8pYSs9XCJcXG4gICAgICAgICAgICByZXN1bHQueSA9IChjb29yZHMgKyAxKSA+PSBcIit0aGlzLm91dHB1dFNoYXBlWzBdK1wiID8gMC4gOiByZXN1bHQueTtcXG4gICAgICAgICAgICByZXN1bHQueiA9IDAuO1xcbiAgICAgICAgICAgIHJlc3VsdC53ID0gMC47XFxuICAgICAgICAgIFwiO2Vsc2V7dmFyIGk9c2EoXCJjb29yZHNcIixvKTthKz1cIlxcbiAgICAgICAgICAgIGJvb2wgbmV4dFJvd091dE9mQm91bmRzID1cXG4gICAgICAgICAgICAgIChcIitpW28tMl0rXCIgKyAxKSA+PSBcIit0aGlzLm91dHB1dFNoYXBlW28tMl0rXCI7XFxuICAgICAgICAgICAgYm9vbCBuZXh0Q29sT3V0T2ZCb3VuZHMgPVxcbiAgICAgICAgICAgICAgKFwiK2lbby0xXStcIiArIDEpID49IFwiK3RoaXMub3V0cHV0U2hhcGVbby0xXStcIjtcXG4gICAgICAgICAgICByZXN1bHQueSA9IG5leHRDb2xPdXRPZkJvdW5kcyA/IDAuIDogcmVzdWx0Lnk7XFxuICAgICAgICAgICAgcmVzdWx0LnogPSBuZXh0Um93T3V0T2ZCb3VuZHMgPyAwLiA6IHJlc3VsdC56O1xcbiAgICAgICAgICAgIHJlc3VsdC53ID0gbmV4dENvbE91dE9mQm91bmRzIHx8IG5leHRSb3dPdXRPZkJvdW5kcyA/IDAuIDogcmVzdWx0Lnc7XFxuICAgICAgICAgIFwifXRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2ZWM0IGJpbmFyeU9wZXJhdGlvbih2ZWM0IGEsIHZlYzQgYikge1xcbiAgICAgICAgXCIrdCtcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSBiaW5hcnlPcGVyYXRpb24oYSwgYik7XFxuICAgICAgICBcIithK1wiXFxuXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSxXYT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IG1pblZhbDtcXG4gICAgICB1bmlmb3JtIGZsb2F0IG1heFZhbDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgaWYgKGlzbmFuKHZhbHVlKSkge1xcbiAgICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoY2xhbXAodmFsdWUsIG1pblZhbCwgbWF4VmFsKSk7XFxuICAgICAgfVxcbiAgICBcIn1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztyZXR1cm4gZnVuY3Rpb24ocixvKXtudWxsPT1uLm1pbkxvYyYmKG4ubWluTG9jPXIuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhvLFwibWluVmFsXCIpLG4ubWF4TG9jPXIuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhvLFwibWF4VmFsXCIpKSxyLmdsLnVuaWZvcm0xZihuLm1pbkxvYyx0KSxyLmdsLnVuaWZvcm0xZihuLm1heExvYyxlKX19LHR9KCksVWE9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBtaW5WYWw7XFxuICAgICAgdW5pZm9ybSBmbG9hdCBtYXhWYWw7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCB2YWx1ZSA9IGdldEFBdE91dENvb3JkcygpO1xcblxcbiAgICAgICAgaWYgKGFueShpc25hbih2YWx1ZSkpKSB7XFxuICAgICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNldE91dHB1dChjbGFtcCh2YWx1ZSwgdmVjNChtaW5WYWwpLCB2ZWM0KG1heFZhbCkpKTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3JldHVybiBmdW5jdGlvbihyLG8pe251bGw9PW4ubWluTG9jJiYobi5taW5Mb2M9ci5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KG8sXCJtaW5WYWxcIiksbi5tYXhMb2M9ci5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KG8sXCJtYXhWYWxcIikpLHIuZ2wudW5pZm9ybTFmKG4ubWluTG9jLHQpLHIuZ2wudW5pZm9ybTFmKG4ubWF4TG9jLGUpfX0sdH0oKSxWYT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wicmVhbFwiLFwiaW1hZ1wiXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHJlID0gYWJzKGdldFJlYWxBdE91dENvb3JkcygpKTtcXG4gICAgICAgIGZsb2F0IGltID0gYWJzKGdldEltYWdBdE91dENvb3JkcygpKTtcXG4gICAgICAgIGZsb2F0IG14ID0gbWF4KHJlLCBpbSk7XFxuXFxuICAgICAgICAvLyBzYWRseSB0aGUgbGVuZ3RoIGZ1bmN0aW9uIGluIGdsc2wgaXMgbm90IHVuZGVyZmxvdy1zYWZlXFxuICAgICAgICAvLyAoYXQgbGVhc3Qgbm90IG9uIEludGVsIEdQVXMpLiBTbyB0aGUgc2FmZSBzb2x1dGlvbiBpc1xcbiAgICAgICAgLy8gdG8gZW5zdXJlIHVuZGVyZmxvdy1zYWZldHkgaW4gYWxsIGNhc2VzLlxcbiAgICAgICAgc2V0T3V0cHV0KFxcbiAgICAgICAgICBteCA9PSAwLjAgPyAwLjAgOiBteCAqIGxlbmd0aCh2ZWMyKDEsIG1pbihyZSwgaW0pL214KSlcXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICBcIn0semE9ZnVuY3Rpb24odCl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPVNuKHQsMSksdGhpcy52YXJpYWJsZU5hbWVzPXQubWFwKChmdW5jdGlvbih0LGUpe3JldHVyblwiVFwiK2V9KSk7dmFyIGU9bmV3IEFycmF5KHQubGVuZ3RoLTEpO2VbMF09dFswXVsxXTtmb3IodmFyIG49MTtuPGUubGVuZ3RoO24rKyllW25dPWVbbi0xXSt0W25dWzFdO3ZhciByPVtcImlmICh5QyA8IFwiK2VbMF0rXCIpIHNldE91dHB1dChnZXRUMCh5UiwgeUMpKTtcIl07Zm9yKG49MTtuPGUubGVuZ3RoO24rKyl7dmFyIG89ZVtuLTFdO3IucHVzaChcImVsc2UgaWYgKHlDIDwgXCIrZVtuXStcIikgc2V0T3V0cHV0KGdldFRcIituK1wiKHlSLCB5Qy1cIitvK1wiKSk7XCIpfXZhciBhPWUubGVuZ3RoLGk9ZVtlLmxlbmd0aC0xXTtyLnB1c2goXCJlbHNlIHNldE91dHB1dChnZXRUXCIrYStcIih5UiwgeUMtXCIraStcIikpO1wiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgeVIgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB5QyA9IGNvb3Jkcy55O1xcblxcbiAgICAgICAgXCIrci5qb2luKFwiXFxuICAgICAgICBcIikrXCJcXG4gICAgICB9XFxuICAgIFwifSxHYT1mdW5jdGlvbih0LGUpe3RoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1Tbih0LGUpO3ZhciBuPXRoaXMub3V0cHV0U2hhcGUscj1uLmxlbmd0aCxvPXdhKHIpLGE9c2EoXCJjb29yZHNcIixyKSxpPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl0uc2xpY2UoMCxyKTt0aGlzLnZhcmlhYmxlTmFtZXM9dC5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJUXCIrZX0pKTt2YXIgcz1uZXcgQXJyYXkodC5sZW5ndGgtMSk7c1swXT10WzBdW2VdO2Zvcih2YXIgdT0xO3U8cy5sZW5ndGg7dSsrKXNbdV09c1t1LTFdK3RbdV1bZV07dmFyIGM9aVtlXSxsPWkuc2xpY2UoLTIpLGg9aS5qb2luKCksZj1cImlmIChcIitjK1wiIDwgXCIrc1swXStcIikge1xcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXFxuICAgICAgICAgICAgZ2V0VDAoXCIraCtcIiksIHZlYzIoXCIrbC5qb2luKCkrXCIpKTtcXG4gICAgICAgIH1cIjtmb3IodT0xO3U8cy5sZW5ndGg7dSsrKXt2YXIgZD1zW3UtMV07Zis9XCJcXG4gICAgICAgIGlmIChcIitjK1wiIDwgXCIrc1t1XStcIiAgJiYgXCIrYytcIiA+PSBcIitzW3UtMV0rXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXFxuICAgICAgICAgICAgZ2V0VFwiK3UrXCIoXCIrSGEoaSxjLGQpK1wiKSxcXG4gICAgICAgICAgICB2ZWMyKFwiK0hhKGwsYyxkKStcIikpO1xcbiAgICAgICAgfVwifXZhciBwPXMubGVuZ3RoLHY9c1tzLmxlbmd0aC0xXTtmKz1cIlxcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXFxuICAgICAgICAgIGdldFRcIitwK1wiKFwiK0hhKGksYyx2KStcIiksXFxuICAgICAgICAgIHZlYzIoXCIrSGEobCxjLHYpK1wiKSk7XCIsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IGdldFZhbHVlKFwiK2kubWFwKChmdW5jdGlvbih0KXtyZXR1cm5cImludCBcIit0fSkpK1wiKSB7XFxuICAgICAgICBcIitmK1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoZ2V0VmFsdWUoXCIrYStcIiksIDAuLCAwLiwgMC4pO1xcblxcbiAgICAgICAgXCIrYVtyLTFdK1wiID0gXCIrYVtyLTFdK1wiICsgMTtcXG4gICAgICAgIGlmIChcIithW3ItMV0rXCIgPCBcIituW3ItMV0rXCIpIHtcXG4gICAgICAgICAgcmVzdWx0LmcgPSBnZXRWYWx1ZShcIithK1wiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFwiK2Fbci0yXStcIiA9IFwiK2Fbci0yXStcIiArIDE7XFxuICAgICAgICBpZiAoXCIrYVtyLTJdK1wiIDwgXCIrbltyLTJdK1wiKSB7XFxuICAgICAgICAgIHJlc3VsdC5hID0gZ2V0VmFsdWUoXCIrYStcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBcIithW3ItMV0rXCIgPSBcIithW3ItMV0rXCIgLSAxO1xcbiAgICAgICAgaWYgKFwiK2Fbci0yXStcIiA8IFwiK25bci0yXStcIiAmJlxcbiAgICAgICAgICAgIFwiK2Fbci0xXStcIiA8IFwiK25bci0xXStcIikge1xcbiAgICAgICAgICByZXN1bHQuYiA9IGdldFZhbHVlKFwiK2ErXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn07ZnVuY3Rpb24gSGEodCxlLG4pe3ZhciByPXQuaW5kZXhPZihlKTtyZXR1cm4gdC5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGU9PT1yP3QrXCIgLSBcIituOnR9KSkuam9pbigpfXZhciBxYT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmZpbHRlclNoYXBlO3ZhciBlPXQuc3RyaWRlSGVpZ2h0LG49dC5zdHJpZGVXaWR0aCxyPXQucGFkSW5mby50b3Asbz10LnBhZEluZm8ubGVmdCxhPVwiY2hhbm5lbHNMYXN0XCI9PT10LmRhdGFGb3JtYXQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHdSID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgd0MgPSBjb29yZHMueTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIGR5KDosIDosIGQyKSB0byBnZXQgZHcod1IsIHdDLCBkMSwgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCBcIit0LmJhdGNoU2l6ZStcIjsgYisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIit0Lm91dEhlaWdodCtcIjsgeVIrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIitlK1wiIC0gXCIrcitcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIrdC5vdXRXaWR0aCtcIjsgeUMrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiK24rXCIgLSBcIitvK1wiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBpZiAoXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIGQyLCB5UiwgeUMpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIGQxLCB4UiwgeEMpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifSxLYT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmluU2hhcGU7dmFyIGU9dC5maWx0ZXJIZWlnaHQsbj10LmZpbHRlcldpZHRoLHI9dC5zdHJpZGVIZWlnaHQsbz10LnN0cmlkZVdpZHRoLGE9XCJjaGFubmVsc0xhc3RcIj09PXQuZGF0YUZvcm1hdCxpPWUtMS10LnBhZEluZm8udG9wLHM9bi0xLXQucGFkSW5mby5sZWZ0LHU9YT8xOjIsYz1hPzI6MyxsPWE/MzoxO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIraStcIiwgXCIrcytcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHNbXCIrbCtcIl07XFxuXFxuICAgICAgICBpdmVjMiBkeUNvcm5lciA9IGl2ZWMyKGNvb3Jkc1tcIit1K1wiXSwgY29vcmRzW1wiK2MrXCJdKSAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrZStcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIityK1wiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiK3Qub3V0SGVpZ2h0K1wiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGludCB3UlBlcm0gPSBcIitlK1wiIC0gMSAtIHdSO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrbitcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK28rXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIit0Lm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgaW50IHdDUGVybSA9IFwiK24rXCIgLSAxIC0gd0M7XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8IFwiK3Qub3V0Q2hhbm5lbHMrXCI7IGQyKyspIHtcXG5cXG4gICAgICAgICAgICAgIGlmIChcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDLCBkMik7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGQyLCBpZHlSLCBpZHlDKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0samE9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9dC5maWx0ZXJTaGFwZTt2YXIgZT10LnN0cmlkZURlcHRoLG49dC5zdHJpZGVIZWlnaHQscj10LnN0cmlkZVdpZHRoLG89dC5wYWRJbmZvLmZyb250LGE9dC5wYWRJbmZvLnRvcCxpPXQucGFkSW5mby5sZWZ0O3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB3RiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHdSID0gY29vcmRzLnk7XFxuICAgICAgICBpbnQgd0MgPSBjb29yZHMuejtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnU7XFxuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCBcIit0LmJhdGNoU2l6ZStcIjsgYisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlGID0gMDsgeUYgPCBcIit0Lm91dERlcHRoK1wiOyB5RisrKSB7XFxuICAgICAgICAgICAgaW50IHhGID0gd0YgKyB5RiAqIFwiK2UrXCIgLSBcIitvK1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4RiA8IDAgfHwgeEYgPj0gXCIrdC5pbkRlcHRoK1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8IFwiK3Qub3V0SGVpZ2h0K1wiOyB5UisrKSB7XFxuICAgICAgICAgICAgICBpbnQgeFIgPSB3UiArIHlSICogXCIrbitcIiAtIFwiK2ErXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIrdC5vdXRXaWR0aCtcIjsgeUMrKykge1xcbiAgICAgICAgICAgICAgICBpbnQgeEMgPSB3QyArIHlDICogXCIrcitcIiAtIFwiK2krXCI7XFxuXFxuICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlGLCB5UiwgeUMsIGQyKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WChiLCB4RiwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFhhPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LmZpbHRlckRlcHRoLG49dC5maWx0ZXJIZWlnaHQscj10LmZpbHRlcldpZHRoLG89dC5zdHJpZGVEZXB0aCxhPXQuc3RyaWRlSGVpZ2h0LGk9dC5zdHJpZGVXaWR0aCxzPWUtMS10LnBhZEluZm8uZnJvbnQsdT1uLTEtdC5wYWRJbmZvLnRvcCxjPXItMS10LnBhZEluZm8ubGVmdDt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKFwiK3MrXCIsIFwiK3UrXCIsIFwiK2MrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMudTtcXG5cXG5cXG4gICAgICAgIGl2ZWMzIGR5Q29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgLSBwYWRzO1xcbiAgICAgICAgaW50IGR5RkNvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueTtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci56O1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdGID0gMDsgd0YgPCBcIitlK1wiOyB3RisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5RiA9IGZsb2F0KGR5RkNvcm5lciArIHdGKSAvIFwiK28rXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5RiA8IDAuMCB8fCBkeUYgPj0gXCIrdC5vdXREZXB0aCtcIi4wIHx8IGZyYWN0KGR5RikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5RiA9IGludChkeUYpO1xcblxcbiAgICAgICAgICBpbnQgd0ZQZXJtID0gXCIrZStcIiAtIDEgLSB3RjtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK24rXCI7IHdSKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIithK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fFxcbiAgICAgICAgICAgICAgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgICAgaW50IHdSUGVybSA9IFwiK24rXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK3IrXCI7IHdDKyspIHtcXG4gICAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK2krXCIuMDtcXG5cXG4gICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Qub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgICAgaW50IHdDUGVybSA9IFwiK3IrXCIgLSAxIC0gd0M7XFxuXFxuICAgICAgICAgICAgICBmb3IgKGludCBkMiA9IDA7IGQyIDwgXCIrdC5vdXRDaGFubmVscytcIjsgZDIrKykge1xcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5RiwgaWR5UiwgaWR5QywgZDIpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdGUGVybSwgd1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFlhPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPXQuZmlsdGVyU2hhcGU7dmFyIGU9dC5zdHJpZGVIZWlnaHQsbj10LnN0cmlkZVdpZHRoLHI9dC5wYWRJbmZvLnRvcCxvPXQucGFkSW5mby5sZWZ0LGE9dC5vdXRDaGFubmVscy90LmluQ2hhbm5lbHM7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHdSID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgd0MgPSBjb29yZHMueTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGRtID0gY29vcmRzLnc7XFxuICAgICAgICBpbnQgZDIgPSBkMSAqIFwiK2ErXCIgKyBkbTtcXG5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICAvLyBUTyBETzogVmVjNCBvdmVyIHRoZSBiYXRjaCBzaXplXFxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8IFwiK3QuYmF0Y2hTaXplK1wiOyBiKyspIHtcXG4gICAgICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8IFwiK3Qub3V0SGVpZ2h0K1wiOyB5UisrKSB7XFxuICAgICAgICAgICAgaW50IHhSID0gd1IgKyB5UiAqIFwiK2UrXCIgLSBcIityK1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIit0Lm91dFdpZHRoK1wiOyB5QysrKSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB3QyArIHlDICogXCIrbitcIiAtIFwiK28rXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCB5UiwgeUMsIGQyKTtcXG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifSwkYT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmluU2hhcGU7dmFyIGU9dC5maWx0ZXJIZWlnaHQsbj10LmZpbHRlcldpZHRoLHI9dC5zdHJpZGVIZWlnaHQsbz10LnN0cmlkZVdpZHRoLGE9ZS0xLXQucGFkSW5mby50b3AsaT1uLTEtdC5wYWRJbmZvLmxlZnQscz10Lm91dENoYW5uZWxzL3QuaW5DaGFubmVsczt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2ErXCIsIFwiK2krXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzWzNdO1xcbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcXG5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrZStcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIityK1wiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiK3Qub3V0SGVpZ2h0K1wiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGludCB3UlBlcm0gPSBcIitlK1wiIC0gMSAtIHdSO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrbitcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK28rXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIit0Lm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgaW50IHdDUGVybSA9IFwiK24rXCIgLSAxIC0gd0M7XFxuXFxuICAgICAgICAgICAgLy8gVE8gRE86IFZlYzQgb3ZlciB0aGUgY2hhbm5lbE11bFxcbiAgICAgICAgICAgIGZvciAoaW50IGRtID0gMDsgZG0gPCBcIitzK1wiOyBkbSsrKSB7XFxuICAgICAgICAgICAgICBpbnQgZDIgPSBkMSAqIFwiK3MrXCIgKyBkbTtcXG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZG0pO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0sUWE9ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ZSYmKGU9ITEpLHZvaWQgMD09PW4mJihuPW51bGwpLHZvaWQgMD09PXImJihyPSExKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXQub3V0U2hhcGU7dmFyIG89dC5wYWRJbmZvLnRvcCxhPXQucGFkSW5mby5sZWZ0LGk9dC5zdHJpZGVIZWlnaHQscz10LnN0cmlkZVdpZHRoLHU9dC5kaWxhdGlvbkhlaWdodCxjPXQuZGlsYXRpb25XaWR0aCxsPXQuZmlsdGVySGVpZ2h0LGg9dC5maWx0ZXJXaWR0aCxmPTQqTWF0aC5mbG9vcih0LmluQ2hhbm5lbHMvNCksZD10LmluQ2hhbm5lbHMlNCxwPVwiY2hhbm5lbHNMYXN0XCI9PT10LmRhdGFGb3JtYXQsdj1wPzE6MixtPXA/MjozLGc9cD8zOjEseT1cIlwiLHg9XCJcIjtuJiYoeT1yP1wiZmxvYXQgYWN0aXZhdGlvbihmbG9hdCBhKSB7XFxuICAgICAgICAgIGZsb2F0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcXG4gICAgICAgICAgXCIrbitcIlxcbiAgICAgICAgfVwiOlwiXFxuICAgICAgICAgIGZsb2F0IGFjdGl2YXRpb24oZmxvYXQgeCkge1xcbiAgICAgICAgICAgIFwiK24rXCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCIseD1cInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIik7dmFyIGI9ZT9cInJlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTtcIjpcIlwiO2UmJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmlhc1wiKSxyJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInByZWx1QWN0aXZhdGlvbldlaWdodHNcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK3krXCJcXG5cXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIraStcIiwgXCIrcytcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK28rXCIsIFwiK2ErXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzW1wiK2crXCJdO1xcblxcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID1cXG4gICAgICAgICAgICBpdmVjMihjb29yZHNbXCIrditcIl0sIGNvb3Jkc1tcIittK1wiXSkgKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBnZXQgeSh5UiwgeUMsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitsK1wiOyB3UisrKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1IgKiBcIit1K1wiO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIraCtcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBcIitjK1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgZDEgPSAwOyBkMSA8IFwiK2YrXCI7IGQxICs9IDQpIHtcXG4gICAgICAgICAgICAgIHZlYzQgd1ZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMywgZDIpXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgaWYgKFwiK3ArXCIpIHtcXG4gICAgICAgICAgICAgICAgdmVjNCB4VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMSksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEgKyAzKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHZlYzQgeFZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEsIHhSLCB4QyksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAxLCB4UiwgeEMpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMiwgeFIsIHhDKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDMsIHhSLCB4QylcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChcIisoMT09PWQpK1wiKSB7XFxuXFxuICAgICAgICAgICAgICBpZiAoXCIrcCtcIikge1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9XFxuICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2YrXCIpICpcXG4gICAgICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitmK1wiLCBkMik7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9XFxuICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBcIitmK1wiLCB4UiwgeEMpICpcXG4gICAgICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitmK1wiLCBkMik7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PWQpK1wiKSB7XFxuICAgICAgICAgICAgICB2ZWMyIHdWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrZitcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrZitcIiArIDEsIGQyKVxcbiAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgIGlmIChcIitwK1wiKSB7XFxuICAgICAgICAgICAgICAgIHZlYzIgeFZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitmK1wiKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2YrXCIgKyAxKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHZlYzIgeFZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgXCIrZitcIiwgeFIsIHhDKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBcIitmK1wiICsgMSwgeFIsIHhDKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiKygzPT09ZCkrXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzMgd1ZhbHVlcyA9IHZlYzMoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitmK1wiLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitmK1wiICsgMSwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrZitcIiArIDIsIGQyKVxcbiAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgIGlmIChcIitwK1wiKSB7XFxuICAgICAgICAgICAgICAgIHZlYzMgeFZhbHVlcyA9IHZlYzMoXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitmK1wiKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2YrXCIgKyAxKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2YrXCIgKyAyKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHZlYzMgeFZhbHVlcyA9IHZlYzMoXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgXCIrZitcIiwgeFIsIHhDKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBcIitmK1wiICsgMSwgeFIsIHhDKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBcIitmK1wiICsgMiwgeFIsIHhDKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IGRvdFByb2Q7XFxuICAgICAgICBcIitiK1wiXFxuICAgICAgICBcIit4K1wiXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSxKYT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXQub3V0U2hhcGU7dmFyIGU9dC5wYWRJbmZvLmZyb250LG49dC5wYWRJbmZvLnRvcCxyPXQucGFkSW5mby5sZWZ0LG89dC5zdHJpZGVEZXB0aCxhPXQuc3RyaWRlSGVpZ2h0LGk9dC5zdHJpZGVXaWR0aCxzPXQuZGlsYXRpb25EZXB0aCx1PXQuZGlsYXRpb25IZWlnaHQsYz10LmRpbGF0aW9uV2lkdGgsbD10LmZpbHRlckRlcHRoLGg9dC5maWx0ZXJIZWlnaHQsZj10LmZpbHRlcldpZHRoLGQ9NCpNYXRoLmZsb29yKHQuaW5DaGFubmVscy80KSxwPXQuaW5DaGFubmVscyU0O3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMyBzdHJpZGVzID0gaXZlYzMoXCIrbytcIiwgXCIrYStcIiwgXCIraStcIik7XFxuICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKFwiK2UrXCIsIFwiK24rXCIsIFwiK3IrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudTtcXG5cXG4gICAgICAgIGl2ZWMzIHhGUkNDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhGQ29ybmVyID0geEZSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geEZSQ0Nvcm5lci55O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geEZSQ0Nvcm5lci56O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCA/LCBkMSkgd2l0aCB3KDosIDosIDosIGQxLCBkMikgdG8gZ2V0XFxuICAgICAgICAvLyB5KHlGLCB5UiwgeUMsIGQyKS4gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsXFxuICAgICAgICAvLyB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdGID0gMDsgd0YgPCBcIitsK1wiOyB3RisrKSB7XFxuICAgICAgICAgIGludCB4RiA9IHhGQ29ybmVyICsgd0YgKiBcIitzK1wiO1xcblxcbiAgICAgICAgICBpZiAoeEYgPCAwIHx8IHhGID49IFwiK3QuaW5EZXB0aCtcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitoK1wiOyB3UisrKSB7XFxuICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqIFwiK3UrXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK2YrXCI7IHdDKyspIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBcIitjK1wiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgXCIrZCtcIjsgZDEgKz0gNCkge1xcbiAgICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDEpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAzKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIGQxICsgMSwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEgKyAyLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSArIDMsIGQyKVxcbiAgICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGlmIChcIisoMT09PXApK1wiKSB7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz1cXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIitkK1wiKSAqXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIitkK1wiLCBkMik7XFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT09cCkrXCIpIHtcXG4gICAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIitkK1wiKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIitkK1wiICsgMSlcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgdmVjMiB3VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2QrXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2QrXCIgKyAxLCBkMilcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwiKygzPT09cCkrXCIpIHtcXG4gICAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIitkK1wiKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIitkK1wiICsgMSksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgXCIrZCtcIiArIDIpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIHZlYzMgd1ZhbHVlcyA9IHZlYzMoXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIitkK1wiLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIitkK1wiICsgMSwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIrZCtcIiArIDIsIGQyKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifSxaYT1mdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1lJiYoZT0hMSksdm9pZCAwPT09biYmKG49bnVsbCksdm9pZCAwPT09ciYmKHI9ITEpLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTt2YXIgbz10LmluSGVpZ2h0LGE9dC5pbldpZHRoLGk9dC5wYWRJbmZvLnRvcCxzPXQucGFkSW5mby5sZWZ0LHU9dC5zdHJpZGVIZWlnaHQsYz10LnN0cmlkZVdpZHRoLGw9dC5kaWxhdGlvbkhlaWdodCxoPXQuZGlsYXRpb25XaWR0aCxmPXQuZmlsdGVySGVpZ2h0LGQ9dC5maWx0ZXJXaWR0aCxwPXQub3V0Q2hhbm5lbHMvdC5pbkNoYW5uZWxzLHY9XCJcIixtPVwiXCI7biYmKHY9cj9cImZsb2F0IGFjdGl2YXRpb24oZmxvYXQgYSkge1xcbiAgICAgICAgICBmbG9hdCBiID0gZ2V0UHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0F0T3V0Q29vcmRzKCk7XFxuICAgICAgICAgIFwiK24rXCJcXG4gICAgICAgIH1cIjpcIlxcbiAgICAgICAgICBmbG9hdCBhY3RpdmF0aW9uKGZsb2F0IHgpIHtcXG4gICAgICAgICAgICBcIituK1wiXFxuICAgICAgICAgIH1cXG4gICAgICAgIFwiLG09XCJyZXN1bHQgPSBhY3RpdmF0aW9uKHJlc3VsdCk7XCIpO3ZhciBnPWU/XCJyZXN1bHQgKz0gZ2V0Qmlhc0F0T3V0Q29vcmRzKCk7XCI6XCJcIjtlJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImJpYXNcIiksciYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJwcmVsdUFjdGl2YXRpb25XZWlnaHRzXCIpLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIit2K1wiXFxuXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiK3UrXCIsIFwiK2MrXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitpK1wiLCBcIitzK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMSA9IGQyIC8gXCIrcCtcIjtcXG4gICAgICAgIGludCBxID0gZDIgLSBkMSAqIFwiK3ArXCI7XFxuXFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCB3KDosIDosIGQxLCBxKSB0byBnZXQgeSh5UiwgeUMsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIC8vIFRPIERPKGRzbWlsa292KTogRmxhdHRlbiB0aGUgdHdvIGZvciBsb29wcyBhbmQgdmVjNCB0aGUgb3BlcmF0aW9ucy5cXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitmK1wiOyB3UisrKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1IgKiBcIitsK1wiO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK28rXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrZCtcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBcIitoK1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrYStcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICBmbG9hdCB3VmFsID0gZ2V0Vyh3Uiwgd0MsIGQxLCBxKTtcXG4gICAgICAgICAgICBkb3RQcm9kICs9IHhWYWwgKiB3VmFsO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSBkb3RQcm9kO1xcbiAgICAgICAgXCIrZytcIlxcbiAgICAgICAgXCIrbStcIlxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn0sdGk9ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ZSYmKGU9ITEpLHZvaWQgMD09PW4mJihuPW51bGwpLHZvaWQgMD09PXImJihyPSExKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiV1wiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPXQub3V0U2hhcGU7Zm9yKHZhciBvPXQuaW5IZWlnaHQsYT10LmluV2lkdGgsaT10LnBhZEluZm8udG9wLHM9dC5wYWRJbmZvLmxlZnQsdT10LnN0cmlkZUhlaWdodCxjPXQuc3RyaWRlV2lkdGgsbD10LmRpbGF0aW9uSGVpZ2h0LGg9dC5kaWxhdGlvbldpZHRoLGY9dC5maWx0ZXJIZWlnaHQsZD10LmZpbHRlcldpZHRoLHA9ZCx2PVwiaW50IHhSOyBpbnQgeEM7IGludCB4Q09mZnNldDtcIixtPTA7bTxmO20rKylmb3IodmFyIGc9MDtnPGQ7ZysrKXYrPVwiXFxuICAgICAgICAgIHZlYzQgeFRleGVsUlwiK20rXCJDXCIrMipnK1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgIHZlYzQgd1JcIittK1wiQ1wiK2crXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgdmVjNCB4UlwiK20rXCJDXCIrZytcIiA9IHZlYzQoMC4pO1wiO2ZvcihtPTA7bTxmO20rKylmb3IodmFyIHk9MDt5PHA7eSsrKXtpZih2Kz1cIlxcbiAgICAgICAgICB4UiA9IHhSQ29ybmVyICsgXCIrbSpsK1wiO1xcbiAgICAgICAgICB4QyA9IHhDQ29ybmVyICsgXCIrKGc9Mip5KSpoK1wiO1xcbiAgICAgICAgXCIsMT09PWMpe2lmKGc8ZCYmKHYrPXMlMj09MT9cIlxcbiAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMTtcXG4gICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK28rXCIgJiYgeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuXFxuICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBtYW51YWxseSBjbGVhciB1bnVzZWQgY2hhbm5lbHMgaW4gY2FzZVxcbiAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHJlYWRpbmcgZnJvbSByZWN5Y2xlZCB0ZXh0dXJlLlxcbiAgICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ICsgMSA+PSBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiLnp3ID0gdmVjMigwLik7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMSAtIDI7XFxuICAgICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitvK1wiICYmIHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgdmVjNCBwcmV2aW91cyA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcblxcbiAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcXG4gICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cXG4gICAgICAgICAgICAgICAgICBpZih4Q09mZnNldCArIDEgPj0gXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMuencgPSB2ZWMyKDAuKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgeFJcIittK1wiQ1wiK2crXCIgPSB2ZWM0KHByZXZpb3VzLnp3LCB4VGV4ZWxSXCIrbStcIkNcIitnK1wiLnh5KTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4UlwiK20rXCJDXCIrZytcIiA9IHZlYzQoMCwgMCwgeFRleGVsUlwiK20rXCJDXCIrZytcIi54eSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIFwiOlwiXFxuICAgICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitvK1wiICYmIHhDID49IDAgJiYgeEMgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIiA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB4UlwiK20rXCJDXCIrZytcIiA9IHhUZXhlbFJcIittK1wiQ1wiK2crXCI7XFxuICAgICAgICAgICAgICBcIixnKzE8ZCkpe3ZhciB4PXMlMj09MD9iKGgpOmg7aCUyPT0wJiZzJTI9PTF8fGglMiE9MCYmcyUyIT0xPyh2Kz1cIlxcbiAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyBcIitzJTIrXCIgKyBcIit4K1wiO1xcblxcbiAgICAgICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitvK1wiICYmXFxuICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrKGcrMikrXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFwiLGg+MSYmKHYrPVwiXFxuICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCAtPSAyO1xcbiAgICAgICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK28rXCIgJiZcXG4gICAgICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIFwiKSx2Kz1cIlxcbiAgICAgICAgICAgICAgICAgIHhSXCIrbStcIkNcIisoZysxKStcIiA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiLnp3LCB4VGV4ZWxSXCIrbStcIkNcIisoZysyKStcIi54eSk7XFxuICAgICAgICAgICAgICAgIFwiKTp2Kz1cIlxcbiAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyBcIit4K1wiO1xcblxcbiAgICAgICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitvK1wiICYmXFxuICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrKGcrMikrXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgeFJcIittK1wiQ1wiKyhnKzEpK1wiID0geFRleGVsUlwiK20rXCJDXCIrKGcrMikrXCI7XFxuICAgICAgICAgICAgICAgIFwifX1lbHNlIGc8ZCYmKHYrPVwiXFxuICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrbytcIikge1xcbiAgICAgICAgICAgIFwiLHMlMj09MT8odis9XCJcXG4gICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgLSBcIitjK1wiO1xcbiAgICAgICAgICAgICAgICBpZih4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaWYoeEMgKyAxID49IDAgJiYgeEMgKyAxIDwgXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiKyhnKzIpK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDICsgMSwgZDEpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiKyhnKzIpK1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgeFJcIittK1wiQ1wiK2crXCIgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIuencsIHhUZXhlbFJcIittK1wiQ1wiKyhnKzIpK1wiLnp3KTtcXG4gICAgICAgICAgICAgIFwiLGcrMTxkJiYodis9XCJcXG4gICAgICAgICAgICAgICAgICB2ZWM0IGZpbmFsID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgKyBcIitjK1wiO1xcbiAgICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICBmaW5hbCA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB4UlwiK20rXCJDXCIrKGcrMSkrXCIgPSB2ZWM0KHhUZXhlbFJcIittK1wiQ1wiKyhnKzIpK1wiLnh5LCBmaW5hbC54eSk7XFxuICAgICAgICAgICAgICAgIFwiKSk6KHYrPVwiXFxuICAgICAgICAgICAgICAgIGlmKHhDID49IDAgJiYgeEMgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIiA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgXCIrYytcIjtcXG4gICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIisoZysyKStcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiKyhnKzIpK1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgeFJcIittK1wiQ1wiK2crXCIgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIueHksIHhUZXhlbFJcIittK1wiQ1wiKyhnKzIpK1wiLnh5KTtcXG4gICAgICAgICAgICAgIFwiLGcrMTxkJiYodis9XCJcXG4gICAgICAgICAgICAgICAgICB4UlwiK20rXCJDXCIrKGcrMSkrXCIgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIi56dywgeFRleGVsUlwiK20rXCJDXCIrKGcrMikrXCIuencpO1xcbiAgICAgICAgICAgICAgICBcIikpLHYrPVwifVwiKTtnPGQmJih2Kz1cIlxcbiAgICAgICAgICAgIHZlYzQgd1RleGVsUlwiK20rXCJDXCIrZytcIiA9IGdldFcoXCIrbStcIiwgXCIrZytcIiwgZDEsIHEpO1xcbiAgICAgICAgICAgIHdSXCIrbStcIkNcIitnK1wiID0gdmVjNCh3VGV4ZWxSXCIrbStcIkNcIitnK1wiLnh6LCB3VGV4ZWxSXCIrbStcIkNcIitnK1wiLnh6KTtcXG4gICAgICAgICAgXCIsZysxPGQmJih2Kz1cIlxcbiAgICAgICAgICAgICAgdmVjNCB3VGV4ZWxSXCIrbStcIkNcIisoZysxKStcIiA9IGdldFcoXCIrbStcIiwgXCIrKGcrMSkrXCIsIGQxLCBxKTtcXG4gICAgICAgICAgICAgIHdSXCIrbStcIkNcIisoZysxKStcIiA9XFxuICAgICAgICAgICAgICAgIHZlYzQod1RleGVsUlwiK20rXCJDXCIrKGcrMSkrXCIueHosIHdUZXhlbFJcIittK1wiQ1wiKyhnKzEpK1wiLnh6KTtcIikpfWZvcihtPTA7bTxmO20rKylmb3IoZz0wO2c8ZDtnKyspdis9XCJkb3RQcm9kICs9IHhSXCIrbStcIkNcIitnK1wiICogd1JcIittK1wiQ1wiK2crXCI7XCI7dmFyIHc9XCJcIixDPVwiXCI7biYmKHc9cj9cInZlYzQgYWN0aXZhdGlvbih2ZWM0IGEpIHtcXG4gICAgICAgICAgdmVjNCBiID0gZ2V0UHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0F0T3V0Q29vcmRzKCk7XFxuICAgICAgICAgIFwiK24rXCJcXG4gICAgICAgIH1cIjpcInZlYzQgYWN0aXZhdGlvbih2ZWM0IHgpIHtcXG4gICAgICAgICAgXCIrbitcIlxcbiAgICAgICAgfVwiLEM9XCJyZXN1bHQgPSBhY3RpdmF0aW9uKHJlc3VsdCk7XCIpO3ZhciBFPWU/XCJyZXN1bHQgKz0gZ2V0Qmlhc0F0T3V0Q29vcmRzKCk7XCI6XCJcIjtlJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImJpYXNcIiksciYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJwcmVsdUFjdGl2YXRpb25XZWlnaHRzXCIpLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIit3K1wiXFxuXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiK3UrXCIsIFwiK2MrXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitpK1wiLCBcIitzK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuXFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMSA9IGQyO1xcbiAgICAgICAgaW50IHEgPSAwO1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIHZlYzQgZG90UHJvZCA9IHZlYzQoMC4pO1xcblxcbiAgICAgICAgXCIrditcIlxcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSBkb3RQcm9kO1xcbiAgICAgICAgXCIrRStcIlxcbiAgICAgICAgXCIrQytcIlxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn0sZWk9ZnVuY3Rpb24odCxlLG4scixvKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiSW1hZ2VcIixcIkJveGVzXCIsXCJCb3hJbmRcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTt2YXIgYT10WzBdLGk9dFsxXSxzPXRbMl0sdT10WzNdLGM9ZVswXSxsPW5bMF0saD1uWzFdO3RoaXMub3V0cHV0U2hhcGU9W2MsbCxoLHVdO3ZhciBmPVwiYmlsaW5lYXJcIj09PXI/MTowLGQ9W2ktMStcIi4wXCIscy0xK1wiLjBcIl0scD1kWzBdLHY9ZFsxXSxtPWw+MT9bXCJcIisoaS0xKS8obC0xKSxcIih5Mi15MSkgKiBoZWlnaHRfcmF0aW9cIixcInkxKlwiK3ArXCIgKyBmbG9hdCh5KSooaGVpZ2h0X3NjYWxlKVwiXTpbXCIwLjBcIixcIjAuMFwiLFwiMC41ICogKHkxK3kyKSAqIFwiK3BdLGc9bVswXSx5PW1bMV0seD1tWzJdLGI9aD4xP1tcIlwiKyhzLTEpLyhoLTEpLFwiKHgyLXgxKSAqIHdpZHRoX3JhdGlvXCIsXCJ4MSpcIit2K1wiICsgZmxvYXQoeCkqKHdpZHRoX3NjYWxlKVwiXTpbXCIwLjBcIixcIjAuMFwiLFwiMC41ICogKHgxK3gyKSAqIFwiK3ZdLHc9YlswXSxDPWJbMV0sRT1iWzJdO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBmbG9hdCBoZWlnaHRfcmF0aW8gPSBmbG9hdChcIitnK1wiKTtcXG4gICAgICBjb25zdCBmbG9hdCB3aWR0aF9yYXRpbyA9IGZsb2F0KFwiK3crXCIpO1xcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgeSA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCB4ID0gY29vcmRzWzJdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICAvLyBnZXQgYm94IHZhbHNcXG4gICAgICAgIGZsb2F0IHkxID0gZ2V0Qm94ZXMoYiwwKTtcXG4gICAgICAgIGZsb2F0IHgxID0gZ2V0Qm94ZXMoYiwxKTtcXG4gICAgICAgIGZsb2F0IHkyID0gZ2V0Qm94ZXMoYiwyKTtcXG4gICAgICAgIGZsb2F0IHgyID0gZ2V0Qm94ZXMoYiwzKTtcXG5cXG4gICAgICAgIC8vIGdldCBpbWFnZSBpbiBiYXRjaCBpbmRleFxcbiAgICAgICAgaW50IGJJbmQgPSByb3VuZChnZXRCb3hJbmQoYikpO1xcbiAgICAgICAgaWYoYkluZCA8IDAgfHwgYkluZCA+PSBcIithK1wiKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZsb2F0IGhlaWdodF9zY2FsZSA9IFwiK3krXCI7XFxuICAgICAgICBmbG9hdCB3aWR0aF9zY2FsZSA9IFwiK0MrXCI7XFxuXFxuICAgICAgICBmbG9hdCBpbl95ID0gXCIreCtcIjtcXG4gICAgICAgIGlmKCBpbl95IDwgMC4wIHx8IGluX3kgPiBcIitwK1wiICkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIrbytcIikpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBmbG9hdCBpbl94ID0gXCIrRStcIjtcXG4gICAgICAgIGlmKCBpbl94IDwgMC4wIHx8IGluX3ggPiBcIit2K1wiICkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIrbytcIikpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleENSID0gdmVjMihpbl94LGluX3kpO1xcbiAgICAgICAgaWYoXCIrZitcIiA9PSAxKSB7XFxuICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGZvdXIgaW50ZWdlciBpbmRpY2VzLlxcbiAgICAgICAgICBpdmVjMiBzb3VyY2VGbG9vckNSID0gaXZlYzIoc291cmNlRnJhY0luZGV4Q1IpO1xcbiAgICAgICAgICBpdmVjMiBzb3VyY2VDZWlsQ1IgPSBpdmVjMihjZWlsKHNvdXJjZUZyYWNJbmRleENSKSk7XFxuXFxuICAgICAgICAgIGZsb2F0IHRvcExlZnQgPSBnZXRJbWFnZShiLCBzb3VyY2VGbG9vckNSLnksIHNvdXJjZUZsb29yQ1IueCwgZCk7XFxuICAgICAgICAgIGZsb2F0IGJvdHRvbUxlZnQgPSBnZXRJbWFnZShiLCBzb3VyY2VDZWlsQ1IueSwgc291cmNlRmxvb3JDUi54LCBkKTtcXG4gICAgICAgICAgZmxvYXQgdG9wUmlnaHQgPSBnZXRJbWFnZShiLCBzb3VyY2VGbG9vckNSLnksIHNvdXJjZUNlaWxDUi54LCBkKTtcXG4gICAgICAgICAgZmxvYXQgYm90dG9tUmlnaHQgPSBnZXRJbWFnZShiLCBzb3VyY2VDZWlsQ1IueSwgc291cmNlQ2VpbENSLngsIGQpO1xcblxcbiAgICAgICAgICB2ZWMyIGZyYWNDUiA9IHNvdXJjZUZyYWNJbmRleENSIC0gdmVjMihzb3VyY2VGbG9vckNSKTtcXG5cXG4gICAgICAgICAgZmxvYXQgdG9wID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogZnJhY0NSLng7XFxuICAgICAgICAgIGZsb2F0IGJvdHRvbSA9IGJvdHRvbUxlZnQgKyAoYm90dG9tUmlnaHQgLSBib3R0b21MZWZ0KSAqIGZyYWNDUi54O1xcbiAgICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogZnJhY0NSLnk7XFxuICAgICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb29yZGluYXRvcnMgb2YgbmVhcmVzdCBuZWlnaGJvciBwb2ludC5cXG4gICAgICAgICAgaXZlYzIgc291cmNlTmVhcmVzdENSID0gaXZlYzIoZmxvb3IoXFxuICAgICAgICAgICAgc291cmNlRnJhY0luZGV4Q1IgKyB2ZWMyKDAuNSwwLjUpKSk7XFxuICAgICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gZ2V0SW1hZ2UoYiwgc291cmNlTmVhcmVzdENSLnksIHNvdXJjZU5lYXJlc3RDUi54LCBkKTtcXG4gICAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwifSxuaT1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT10O3ZhciByPXQubGVuZ3RoLG89dFt0Lmxlbmd0aC0xXSxhPW4/XCI8XCI6XCI+XCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGludCBnZXRJbmRleChpbnQgaSkge1xcbiAgICAgICAgXCIrKG4/XCJyZXR1cm4gXCIrbytcIiAtaSAtIDE7XCI6XCJyZXR1cm4gaTtcIikrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrd2EocikrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgZW5kID0gXCIrcmkocixcImNvb3Jkc1wiKStcIjtcXG4gICAgICAgIGZsb2F0IHZhbCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IGkgPSBcIitvK1wiIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcXG4gICAgICAgICAgaW50IGlkeCA9IGdldEluZGV4KGkpO1xcbiAgICAgICAgICBpZiAoaWR4IFwiK2ErXCIgZW5kKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGlkeCA9PSBlbmQgJiYgXCIrZStcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIFwiK3JpKHIsXCJjb29yZHNcIikrXCIgPSBpZHg7XFxuICAgICAgICAgIHZhbCArPSBnZXRYKFwiK2Z1bmN0aW9uKHQsZSl7aWYoMT09PXQpcmV0dXJuXCJcIitlO2lmKDI9PT10KXJldHVybiBlK1wiLngsIFwiK2UrXCIueVwiO2lmKDM9PT10KXJldHVybiBlK1wiLngsIFwiK2UrXCIueSwgXCIrZStcIi56XCI7aWYoND09PXQpcmV0dXJuIGUrXCIueCwgXCIrZStcIi55LCBcIitlK1wiLnosIFwiK2UrXCIud1wiO3Rocm93IEVycm9yKFwiQ3VtdWxhdGl2ZSBzdW0gZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX0ocixcImNvb3Jkc1wiKStcIik7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQodmFsKTtcXG4gICAgICB9XFxuICAgIFwifTtmdW5jdGlvbiByaSh0LGUpe2lmKDE9PT10KXJldHVyblwiXCIrZTtpZigyPT09dClyZXR1cm4gZStcIi55XCI7aWYoMz09PXQpcmV0dXJuIGUrXCIuelwiO2lmKDQ9PT10KXJldHVybiBlK1wiLndcIjt0aHJvdyBFcnJvcihcIkN1bXVsYXRpdmUgc3VtIGZvciByYW5rIFwiK3QrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIil9dmFyIG9pPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSExLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0UGFja2luZ1NjaGVtZT1WdC5ERU5TRTt2YXIgZT1ZdCh0KSxuPXVhKCk7dGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBpdmVjMyBvdXRDb29yZHNGcm9tRmxhdEluZGV4KGludCBpbmRleCkge1xcbiAgICAgICAgXCIrY2EoW1wiclwiLFwiY1wiLFwiZFwiXSx0KStcIlxcbiAgICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSA0ICogKHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueSk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcblxcbiAgICAgICAgZm9yIChpbnQgaT0wOyBpPDQ7IGkrKykge1xcbiAgICAgICAgICBpbnQgZmxhdEluZGV4ID0gaW5kZXggKyBpO1xcbiAgICAgICAgICBpdmVjMyByYyA9IG91dENvb3Jkc0Zyb21GbGF0SW5kZXgoZmxhdEluZGV4KTtcXG4gICAgICAgICAgcmVzdWx0W2ldID0gZ2V0QShyYy54LCByYy55LCByYy56KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFwiK24ub3V0cHV0K1wiID0gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgXCJ9LGFpPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0UGFja2luZ1NjaGVtZT1WdC5ERU5TRTt2YXIgZT1ZdCh0KSxuPXVhKCk7dGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBpdmVjMyBvdXRDb29yZHNGcm9tRmxhdEluZGV4KGludCBpbmRleCkge1xcbiAgICAgICAgXCIrY2EoW1wiclwiLFwiY1wiLFwiZFwiXSx0KStcIlxcbiAgICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSA0ICogKHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueSk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcblxcbiAgICAgICAgZm9yIChpbnQgaT0wOyBpPDQ7IGkrKykge1xcbiAgICAgICAgICBpbnQgZmxhdEluZGV4ID0gaW5kZXggKyBpO1xcbiAgICAgICAgICBpdmVjMyByYyA9IG91dENvb3Jkc0Zyb21GbGF0SW5kZXgoZmxhdEluZGV4KTtcXG4gICAgICAgICAgcmVzdWx0W2ldID0gZ2V0Q2hhbm5lbChnZXRBKHJjLngsIHJjLnksIHJjLnopLCB2ZWMyKHJjLnksIHJjLnopKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFwiK24ub3V0cHV0K1wiID0gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgXCJ9LGlpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy5ibG9ja1NpemU9ZSx0aGlzLmRhdGFGb3JtYXQ9bix0aGlzLnVzZXJDb2RlPVwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICBpbnQgaCA9IFwiK3RoaXMuZ2V0SGVpZ2h0Q29vcmRTdHJpbmcoKStcIjtcXG4gICAgICBpbnQgdyA9IFwiK3RoaXMuZ2V0V2lkdGhDb29yZFN0cmluZygpK1wiO1xcbiAgICAgIGludCBkID0gXCIrdGhpcy5nZXREZXB0aENvb3JkU3RyaW5nKCkrXCI7XFxuXFxuICAgICAgaW50IGluX2ggPSBoIC8gXCIrZStcIjtcXG4gICAgICBpbnQgb2Zmc2V0X2ggPSBpbW9kKGgsIFwiK2UrXCIpO1xcbiAgICAgIGludCBpbl93ID0gdyAvIFwiK2UrXCI7XFxuICAgICAgaW50IG9mZnNldF93ID0gaW1vZCh3LCBcIitlK1wiKTtcXG4gICAgICBpbnQgb2Zmc2V0X2QgPSAob2Zmc2V0X2ggKiBcIitlK1wiICsgb2Zmc2V0X3cpICpcXG4gICAgICAgIFwiK3RoaXMuZ2V0T3V0cHV0RGVwdGhTaXplKCkrXCI7XFxuICAgICAgaW50IGluX2QgPSBkICsgb2Zmc2V0X2Q7XFxuXFxuICAgICAgZmxvYXQgcmVzdWx0ID0gXCIrdGhpcy5nZXRJbnB1dFNhbXBsaW5nU3RyaW5nKCkrXCI7XFxuICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgIH1cXG4gIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRIZWlnaHRDb29yZFN0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTkhXQ1wiPT09dGhpcy5kYXRhRm9ybWF0P1wiY29vcmRzWzFdXCI6XCJjb29yZHNbMl1cIn0sdC5wcm90b3R5cGUuZ2V0V2lkdGhDb29yZFN0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTkhXQ1wiPT09dGhpcy5kYXRhRm9ybWF0P1wiY29vcmRzWzJdXCI6XCJjb29yZHNbM11cIn0sdC5wcm90b3R5cGUuZ2V0RGVwdGhDb29yZFN0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTkhXQ1wiPT09dGhpcy5kYXRhRm9ybWF0P1wiY29vcmRzWzNdXCI6XCJjb29yZHNbMV1cIn0sdC5wcm90b3R5cGUuZ2V0T3V0cHV0RGVwdGhTaXplPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/dGhpcy5vdXRwdXRTaGFwZVszXTp0aGlzLm91dHB1dFNoYXBlWzFdfSx0LnByb3RvdHlwZS5nZXRJbnB1dFNhbXBsaW5nU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJnZXRYKGIsIGluX2gsIGluX3csIGluX2QpXCI6XCJnZXRYKGIsIGluX2QsIGluX2gsIGluX3cpXCJ9LHR9KCksc2k9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIlhcIl0sdGhpcy5vdXRwdXRTaGFwZT1bdCx0XSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgZmxvYXQgdmFsID0gY29vcmRzWzBdID09IGNvb3Jkc1sxXSA/IGdldFgoY29vcmRzWzBdKSA6IDAuMDtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZhbCk7XFxuICAgICAgfVxcbiAgICBcIn0sdWk9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRUZXhVc2FnZT16dC5ET1dOTE9BRDt2YXIgZT11YSgpO3RoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIraGErXCJcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBcIitlLm91dHB1dCtcIiA9IGVuY29kZV9mbG9hdCh4KTtcXG4gICAgICB9XFxuICAgIFwifSxjaT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMSx0aGlzLm91dFRleFVzYWdlPXp0LkRPV05MT0FEO3ZhciBlPXVhKCk7dGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIitoYStcIlxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgeCA9IGdldENoYW5uZWwoZ2V0QUF0T3V0Q29vcmRzKCksIHZlYzIoY29vcmRzLnksIGNvb3Jkcy56KSk7XFxuICAgICAgICBcIitlLm91dHB1dCtcIiA9IGVuY29kZV9mbG9hdCh4KTtcXG4gICAgICB9XFxuICAgIFwifSxsaT1mdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49ITEpLHRoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO3ZhciByPXVhKCksbz1lWzBdLGE9ZVsxXTt0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIGk9XCJyZXN1bHRcIjtuJiYoaT1cImZsb29yKHJlc3VsdCAqIDI1NS4gKyAwLjUpXCIpLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIitsYSh0KStcIlxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgaW50IGZsYXRJbmRleCA9IGdldEZsYXRJbmRleChjb29yZHMpO1xcbiAgICAgICAgaW50IG9mZnNldCA9IGltb2QoZmxhdEluZGV4LCA0KTtcXG5cXG4gICAgICAgIGZsYXRJbmRleCA9IGlkaXYoZmxhdEluZGV4LCA0LCAxLik7XFxuICAgICAgICBcXG4gICAgICAgIGludCByID0gZmxhdEluZGV4IC8gXCIrYStcIjtcXG4gICAgICAgIGludCBjID0gaW1vZChmbGF0SW5kZXgsIFwiK2ErXCIpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGMsIHIpICsgaGFsZkNSKSAvIHZlYzIoXCIrYStcIi4wLCBcIitvK1wiLjApO1xcbiAgICAgICAgdmVjNCB2YWx1ZXMgPSBcIityLnRleHR1cmUyRCtcIihBLCB1dik7XFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQ7XFxuXFxuICAgICAgICBpZihvZmZzZXQgPT0gMCkge1xcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZXNbMF07XFxuICAgICAgICB9IGVsc2UgaWYob2Zmc2V0ID09IDEpIHtcXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWVzWzFdO1xcbiAgICAgICAgfSBlbHNlIGlmKG9mZnNldCA9PSAyKSB7XFxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlc1syXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlc1szXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFwiK3Iub3V0cHV0K1wiID0gdmVjNChcIitpK1wiLCAwLiwgMC4sIDAuKTtcXG4gICAgICB9XFxuICAgIFwifSxoaT1mdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49ITEpLHRoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSExLHRoaXMucGFja2VkT3V0cHV0PSEwO3ZhciByPXVhKCksbz1lWzBdLGE9ZVsxXTt0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIGk9XCJcIixzPVwicmVzdWx0XCI7biYmKHM9XCJmbG9vcihyZXN1bHQgKiAyNTUuICsgMC41KVwiKTtmb3IodmFyIHU9MDt1PD0xO3UrKylmb3IodmFyIGM9MDtjPD0xO2MrKyl7dmFyIGw9Mip1K2M7aSs9XCJcXG4gICAgICAgICAgbG9jYWxDb29yZHMgPSBjb29yZHM7XFxuICAgICAgICAgIGlmKGxvY2FsQ29vcmRzWzJdICsgXCIrYytcIiA8IFwiK3RbMl0rXCIpIHtcXG4gICAgICAgICAgICBsb2NhbENvb3Jkc1syXSArPSBcIitjK1wiO1xcbiAgICAgICAgICAgIGlmKGxvY2FsQ29vcmRzWzFdICsgXCIrdStcIiA8IFwiK3RbMV0rXCIpIHtcXG4gICAgICAgICAgICAgIGxvY2FsQ29vcmRzWzFdICs9IFwiK3UrXCI7XFxuXFxuICAgICAgICAgICAgICBmbGF0SW5kZXggPSBnZXRGbGF0SW5kZXgobG9jYWxDb29yZHMpO1xcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gaW1vZChmbGF0SW5kZXgsIDQpO1xcblxcbiAgICAgICAgICAgICAgZmxhdEluZGV4ID0gaWRpdihmbGF0SW5kZXgsIDQsIDEuKTtcXG5cXG4gICAgICAgICAgICAgIHIgPSBmbGF0SW5kZXggLyBcIithK1wiO1xcbiAgICAgICAgICAgICAgYyA9IGltb2QoZmxhdEluZGV4LCBcIithK1wiKTtcXG4gICAgICAgICAgICAgIHV2ID0gKHZlYzIoYywgcikgKyBoYWxmQ1IpIC8gdmVjMihcIithK1wiLjAsIFwiK28rXCIuMCk7XFxuICAgICAgICAgICAgICB2YWx1ZXMgPSBcIityLnRleHR1cmUyRCtcIihBLCB1dik7XFxuXFxuICAgICAgICAgICAgICBpZihvZmZzZXQgPT0gMCkge1xcbiAgICAgICAgICAgICAgICByZXN1bHRbXCIrbCtcIl0gPSB2YWx1ZXNbMF07XFxuICAgICAgICAgICAgICB9IGVsc2UgaWYob2Zmc2V0ID09IDEpIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0W1wiK2wrXCJdID0gdmFsdWVzWzFdO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmKG9mZnNldCA9PSAyKSB7XFxuICAgICAgICAgICAgICAgIHJlc3VsdFtcIitsK1wiXSA9IHZhbHVlc1syXTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJlc3VsdFtcIitsK1wiXSA9IHZhbHVlc1szXTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIFwifXRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIitsYSh0KStcIlxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICAgIGludCBmbGF0SW5kZXgsIHIsIGMsIG9mZnNldDtcXG4gICAgICAgIGl2ZWMzIGxvY2FsQ29vcmRzO1xcbiAgICAgICAgdmVjMiB1djtcXG4gICAgICAgIHZlYzQgdmFsdWVzO1xcblxcbiAgICAgICAgXCIraStcIlxcblxcbiAgICAgICAgXCIrci5vdXRwdXQrXCIgPSBcIitzK1wiO1xcbiAgICAgIH1cXG4gICAgXCJ9LGZpPVwicmV0dXJuIHJlYWwgKiBleHBSIC0gaW1hZyAqIGV4cEk7XCIsZGk9XCJyZXR1cm4gcmVhbCAqIGV4cEkgKyBpbWFnICogZXhwUjtcIixwaT1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInJlYWxcIixcImltYWdcIl07dmFyIHI9ZVsxXTt0aGlzLm91dHB1dFNoYXBlPWU7dmFyIG89bj9cIjIuMCAqIFwiK01hdGguUEk6XCItMi4wICogXCIrTWF0aC5QSSxhPW4/citcIi4wXCI6XCIxLjBcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgZXhwb25lbnRNdWx0aXBsaWVyID0gXCIrbytcIjtcXG5cXG4gICAgICBmbG9hdCB1bmFyeU9wQ29tcGxleChmbG9hdCByZWFsLCBmbG9hdCBleHBSLCBmbG9hdCBpbWFnLCBmbG9hdCBleHBJKSB7XFxuICAgICAgICBcIit0K1wiXFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IG11bE1hdERGVChpbnQgYmF0Y2gsIGludCBpbmRleCkge1xcbiAgICAgICAgZmxvYXQgaW5kZXhSYXRpbyA9IGZsb2F0KGluZGV4KSAvIGZsb2F0KFwiK3IrXCIpO1xcbiAgICAgICAgZmxvYXQgZXhwb25lbnRNdWx0aXBsaWVyVGltZXNJbmRleFJhdGlvID1cXG4gICAgICAgICAgICBleHBvbmVudE11bHRpcGxpZXIgKiBpbmRleFJhdGlvO1xcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIityK1wiOyBpKyspIHtcXG4gICAgICAgICAgLy8geCA9ICgtMnwyICogUEkgLyBOKSAqIGluZGV4ICogaTtcXG4gICAgICAgICAgZmxvYXQgeCA9IGV4cG9uZW50TXVsdGlwbGllclRpbWVzSW5kZXhSYXRpbyAqIGZsb2F0KGkpO1xcbiAgICAgICAgICBmbG9hdCBleHBSID0gY29zKHgpO1xcbiAgICAgICAgICBmbG9hdCBleHBJID0gc2luKHgpO1xcbiAgICAgICAgICBmbG9hdCByZWFsID0gZ2V0UmVhbChiYXRjaCwgaSk7XFxuICAgICAgICAgIGZsb2F0IGltYWcgPSBnZXRJbWFnKGJhdGNoLCBpKTtcXG5cXG4gICAgICAgICAgcmVzdWx0ICs9XFxuICAgICAgICAgICAgICB1bmFyeU9wQ29tcGxleChyZWFsLCBleHBSLCBpbWFnLCBleHBJKSAvIFwiK2ErXCI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChtdWxNYXRERlQoY29vcmRzWzBdLCBjb29yZHNbMV0pKTtcXG4gICAgICB9XFxuICAgIFwifSx2aT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCB2YWx1ZTtcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAvLyBJbnB1dCBjYW4gYmUgb2J0YWluZWQgZnJvbSB1bmlmb3JtIHZhbHVlLlxcbiAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gZnVuY3Rpb24obixyKXtudWxsPT1lLnZhbHVlTG9jJiYoZS52YWx1ZUxvYz1uLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cocixcInZhbHVlXCIpKSxuLmdsLnVuaWZvcm0xZihlLnZhbHVlTG9jLHQpfX0sdH0oKSxtaT1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIixcImluZGljZXNcIl07dmFyIHI9dC5zbGljZSgpO3Jbbl09ZSx0aGlzLm91dHB1dFNoYXBlPXIsdGhpcy5yYW5rPXIubGVuZ3RoO3ZhciBvPXdhKHRoaXMucmFuayksYT1mdW5jdGlvbih0LGUpe3ZhciBuPXQubGVuZ3RoO2lmKG4+NCl0aHJvdyBFcnJvcihcIkdhdGhlciBmb3IgcmFuayBcIituK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2lmKDE9PT1uKXJldHVyblwiaW50KGdldEluZGljZXMocmVzUkMpKVwiO2Zvcih2YXIgcj1bXCJyZXNSQy54XCIsXCJyZXNSQy55XCIsXCJyZXNSQy56XCIsXCJyZXNSQy53XCJdLG89W10sYT0wO2E8dC5sZW5ndGg7YSsrKWE9PT1lP28ucHVzaChcImludChnZXRJbmRpY2VzKFwiK3JbYV0rXCIpKVwiKTpvLnB1c2goXCJcIityW2FdKTtyZXR1cm4gby5qb2luKCl9KHQsbik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRBKFwiK2ErXCIpKTtcXG4gICAgICB9XFxuICAgIFwifTt2YXIgZ2k9ZnVuY3Rpb24odCxlLG4pe3RoaXMuc2xpY2VEaW09dCx0aGlzLnN0cmlkZXM9ZSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiaW5kaWNlc1wiXSx0aGlzLm91dHB1dFNoYXBlPW47dmFyIHI9d2EoZS5sZW5ndGgpLG89d2Eobi5sZW5ndGgpLGE9dGhpcy5zbGljZURpbT4xP1wic3RyaWRlc1tqXVwiOlwic3RyaWRlc1wiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIFwiK3IrXCIgc3RyaWRlcyA9IFwiK3IrXCIoXCIrdGhpcy5zdHJpZGVzK1wiKTtcXG4gICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIFwiK28rXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGludCBmbGF0dGVuSW5kZXggPSAwO1xcbiAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK3RoaXMuc2xpY2VEaW0rXCI7IGorKykge1xcbiAgICAgICAgICAgIGludCBpbmRleCA9IHJvdW5kKGdldEluZGljZXMoY29vcmRzWzBdLCBqKSk7XFxuICAgICAgICAgICAgZmxhdHRlbkluZGV4ICs9IGluZGV4ICogXCIrYStcIjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChmbGF0dGVuSW5kZXgsIGNvb3Jkc1sxXSkpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifTtmdW5jdGlvbiB5aSh0LGUpe3ZhciBuPXVhKCk7cmV0dXJuIG9lKHQsZSxuLnZlcnNpb24rXCJcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICBcIituLmF0dHJpYnV0ZStcIiB2ZWMzIGNsaXBTcGFjZVBvcztcXG4gICAgXCIrbi5hdHRyaWJ1dGUrXCIgdmVjMiB1djtcXG4gICAgXCIrbi52YXJ5aW5nVnMrXCIgdmVjMiByZXN1bHRVVjtcXG5cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2VQb3MsIDEpO1xcbiAgICAgIHJlc3VsdFVWID0gdXY7XFxuICAgIH1cIil9ZnVuY3Rpb24geGkodCxlKXtyZXR1cm4gZmUodCxlLG5ldyBGbG9hdDMyQXJyYXkoWy0xLDEsMCwwLDEsLTEsLTEsMCwwLDAsMSwxLDAsMSwxLDEsLTEsMCwxLDBdKSl9ZnVuY3Rpb24gYmkodCxlKXtyZXR1cm4gZGUodCxlLG5ldyBVaW50MTZBcnJheShbMCwxLDIsMiwxLDNdKSl9ZnVuY3Rpb24gd2kodCxlLG4scixvLGEsaSl7dmUobixyKTt2YXIgcz1wZSh0LGUpLHU9dC5URVhUVVJFXzJEO3JldHVybiBKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodSxzKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4UGFyYW1ldGVyaSh1LHQuVEVYVFVSRV9XUkFQX1MsdC5DTEFNUF9UT19FREdFKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4UGFyYW1ldGVyaSh1LHQuVEVYVFVSRV9XUkFQX1QsdC5DTEFNUF9UT19FREdFKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4UGFyYW1ldGVyaSh1LHQuVEVYVFVSRV9NSU5fRklMVEVSLHQuTkVBUkVTVCl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnRleFBhcmFtZXRlcmkodSx0LlRFWFRVUkVfTUFHX0ZJTFRFUix0Lk5FQVJFU1QpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhJbWFnZTJEKHUsMCxvLG4sciwwLGEsaSxudWxsKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpfSkpLHN9ZnVuY3Rpb24gQ2kodCxlLG4scixvKXt2YXIgYT1YdChuLHIpO3JldHVybiB3aSh0LGUsYVswXSxhWzFdLG8uaW50ZXJuYWxGb3JtYXRGbG9hdCxvLnRleHR1cmVGb3JtYXRGbG9hdCx0LkZMT0FUKX1mdW5jdGlvbiBFaSh0LGUsbixyLG8pe3ZhciBhPVh0KG4scik7cmV0dXJuIHdpKHQsZSxhWzBdLGFbMV0sby5pbnRlcm5hbEZvcm1hdEhhbGZGbG9hdCxvLnRleHR1cmVGb3JtYXRGbG9hdCxvLnRleHR1cmVUeXBlSGFsZkZsb2F0KX1mdW5jdGlvbiBSaSh0LGUsbixyLG8pe3ZhciBhPVh0KG4scik7cmV0dXJuIHdpKHQsZSxhWzBdLGFbMV0sdC5SR0JBLHQuUkdCQSx0LlVOU0lHTkVEX0JZVEUpfWZ1bmN0aW9uIElpKHQsZSxuLHIsbyl7dmFyIGE9JHQobixyKTtyZXR1cm4gd2kodCxlLGFbMF0sYVsxXSxvLmludGVybmFsRm9ybWF0UGFja2VkRmxvYXQsdC5SR0JBLHQuRkxPQVQpfWZ1bmN0aW9uIGtpKHQsZSxuLHIsbyl7dmFyIGE9JHQobixyKTtyZXR1cm4gd2kodCxlLGFbMF0sYVsxXSxvLmludGVybmFsRm9ybWF0UGFja2VkSGFsZkZsb2F0LHQuUkdCQSxvLnRleHR1cmVUeXBlSGFsZkZsb2F0KX1mdW5jdGlvbiBTaSh0LGUsbixyKXtyZXR1cm4gSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIscil9KSksZ2UodCxlLG4sXCJjbGlwU3BhY2VQb3NcIixyLDMsMjAsMCkmJmdlKHQsZSxuLFwidXZcIixyLDIsMjAsMTIpfWZ1bmN0aW9uIEFpKHQsZSxuLHIsbyxhLGkpe3ZhciBzLHUsYztKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG4pfSkpLGEgaW5zdGFuY2VvZiBVaW50OEFycmF5PyhzPW5ldyBVaW50OEFycmF5KHIqbyo0KSx1PXQuVU5TSUdORURfQllURSxjPXQuUkdCQSk6KHM9bmV3IEZsb2F0MzJBcnJheShyKm8qNCksdT10LkZMT0FULGM9aS5pbnRlcm5hbEZvcm1hdFBhY2tlZEZsb2F0KSxzLnNldChhKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsMCxjLHIsbywwLHQuUkdCQSx1LHMpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCl9KSl9ZnVuY3Rpb24gRGkodCxlLG4scil7SnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxuKX0pKSxyLmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5P0p0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhJbWFnZTJEKHQuVEVYVFVSRV8yRCwwLHQuUkdCQSxyLndpZHRoLHIuaGVpZ2h0LDAsdC5SR0JBLHQuVU5TSUdORURfQllURSxyLmRhdGEpfSkpOkp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhJbWFnZTJEKHQuVEVYVFVSRV8yRCwwLHQuUkdCQSx0LlJHQkEsdC5VTlNJR05FRF9CWVRFLHIpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCl9KSl9ZnVuY3Rpb24gVGkodCxlLG4scixvKXt2YXIgYT10LmNyZWF0ZUJ1ZmZlcigpO0p0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuUElYRUxfUEFDS19CVUZGRVIsYSl9KSk7dmFyIGk9MTYqbipyO3JldHVybiBKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYnVmZmVyRGF0YSh0LlBJWEVMX1BBQ0tfQlVGRkVSLGksdC5TVFJFQU1fUkVBRCl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnJlYWRQaXhlbHMoMCwwLHIsbix0LlJHQkEsdC5GTE9BVCwwKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEJ1ZmZlcih0LlBJWEVMX1BBQ0tfQlVGRkVSLG51bGwpfSkpLGF9ZnVuY3Rpb24gTmkodCxlLG4pe3ZhciByPXQsbz1uZXcgRmxvYXQzMkFycmF5KG4pO3JldHVybiByLmJpbmRCdWZmZXIoci5QSVhFTF9QQUNLX0JVRkZFUixlKSxyLmdldEJ1ZmZlclN1YkRhdGEoci5QSVhFTF9QQUNLX0JVRkZFUiwwLG8pLHIuYmluZEJ1ZmZlcihyLlBJWEVMX1BBQ0tfQlVGRkVSLG51bGwpLG99ZnVuY3Rpb24gRmkodCxlLG4scixvKXt2YXIgYT1YdChuLHIpLGk9YVswXSxzPWFbMV0sdT1uZXcgVWludDhBcnJheShuKnIqNCk7cmV0dXJuIEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5yZWFkUGl4ZWxzKDAsMCxpLHMsby5kb3dubG9hZFRleHR1cmVGb3JtYXQsdC5VTlNJR05FRF9CWVRFLHUpfSkpLG5ldyBGbG9hdDMyQXJyYXkodS5idWZmZXIpfWZ1bmN0aW9uIF9pKHQsZSxuLHIsbyxhLGkscyl7dmFyIHU9dCxjPW5ldyBGbG9hdDMyQXJyYXkoZnVuY3Rpb24odCxlKXt2YXIgbj0kdCh0LGUpO3JldHVybiBuWzBdKm5bMV0qNH0oYSxpKSk7cmV0dXJuIHUuYmluZEJ1ZmZlcih1LlBJWEVMX1BBQ0tfQlVGRkVSLGUpLHUuZ2V0QnVmZmVyU3ViRGF0YSh1LlBJWEVMX1BBQ0tfQlVGRkVSLDAsYyksdS5iaW5kQnVmZmVyKHUuUElYRUxfUEFDS19CVUZGRVIsbnVsbCksY31mdW5jdGlvbiBPaSh0LGUsbixyKXt2YXIgbz1uZXcgRmxvYXQzMkFycmF5KG4qcio0KTtyZXR1cm4gSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnJlYWRQaXhlbHMoMCwwLHIsbix0LlJHQkEsdC5GTE9BVCxvKX0pKSxvfXZhciBNaT1PYmplY3QuZnJlZXplKHtjcmVhdGVWZXJ0ZXhTaGFkZXI6eWksY3JlYXRlVmVydGV4QnVmZmVyOnhpLGNyZWF0ZUluZGV4QnVmZmVyOmJpLGNyZWF0ZUZsb2F0MzJNYXRyaXhUZXh0dXJlOkNpLGNyZWF0ZUZsb2F0MTZNYXRyaXhUZXh0dXJlOkVpLGNyZWF0ZVVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlOlJpLGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmU6SWksY3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmU6a2ksYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zOlNpLHVwbG9hZERlbnNlTWF0cml4VG9UZXh0dXJlOkFpLHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZTpEaSxjcmVhdGVCdWZmZXJGcm9tT3V0cHV0VGV4dHVyZTpUaSxkb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyOk5pLGRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlOkZpLGRvd25sb2FkUGFja2VkTWF0cml4RnJvbUJ1ZmZlcjpfaSxkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlOk9pfSksQmk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMub3V0cHV0VGV4dHVyZT1udWxsLHRoaXMucHJvZ3JhbT1udWxsLHRoaXMuZGlzcG9zZWQ9ITEsdGhpcy52ZXJ0ZXhBdHRyc0FyZUJvdW5kPSExLHRoaXMuaXRlbXNUb1BvbGw9W107dmFyIGU9aSgpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik7bnVsbCE9dD8odGhpcy5nbD10LEt0KGUsdCkpOnRoaXMuZ2w9anQoZSk7dmFyIG49XCJXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXRcIjtpZigxPT09aSgpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpe2lmKHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uPXJlKHRoaXMuZ2wsdGhpcy5kZWJ1ZyxcIk9FU190ZXh0dXJlX2Zsb2F0XCIpLFBlKHRoaXMuZ2wsXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpKXRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbj1yZSh0aGlzLmdsLHRoaXMuZGVidWcsXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpO2Vsc2UgaWYoaSgpLmdldChcIldFQkdMX0ZPUkNFX0YxNl9URVhUVVJFU1wiKSl0aHJvdyBuZXcgRXJyb3IoXCJHTCBjb250ZXh0IGRvZXMgbm90IHN1cHBvcnQgaGFsZiBmbG9hdCB0ZXh0dXJlcywgeWV0IHRoZSBlbnZpcm9ubWVudCBmbGFnIFdFQkdMX0ZPUkNFX0YxNl9URVhUVVJFUyBpcyBzZXQgdG8gdHJ1ZS5cIik7aWYodGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKG4pLFBlKHRoaXMuZ2wsXCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcIikpdGhpcy5jb2xvckJ1ZmZlckhhbGZGbG9hdEV4dGVuc2lvbj1yZSh0aGlzLmdsLHRoaXMuZGVidWcsXCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcIik7ZWxzZSBpZihpKCkuZ2V0KFwiV0VCR0xfRk9SQ0VfRjE2X1RFWFRVUkVTXCIpKXRocm93IG5ldyBFcnJvcihcIkdMIGNvbnRleHQgZG9lcyBub3Qgc3VwcG9ydCBjb2xvciByZW5kZXJhYmxlIGhhbGYgZmxvYXRzLCB5ZXQgdGhlIGVudmlyb25tZW50IGZsYWcgV0VCR0xfRk9SQ0VfRjE2X1RFWFRVUkVTIGlzIHNldCB0byB0cnVlLlwiKX1lbHNlIGlmKG49XCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIsUGUodGhpcy5nbCxuKSl0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24obik7ZWxzZXtpZighUGUodGhpcy5nbCxcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKSl0aHJvdyBuZXcgRXJyb3IoXCJHTCBjb250ZXh0IGRvZXMgbm90IHN1cHBvcnQgY29sb3IgcmVuZGVyYWJsZSBmbG9hdHNcIik7dGhpcy5jb2xvckJ1ZmZlckhhbGZGbG9hdEV4dGVuc2lvbj10aGlzLmdsLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKX10aGlzLnZlcnRleEJ1ZmZlcj14aSh0aGlzLmdsLHRoaXMuZGVidWcpLHRoaXMuaW5kZXhCdWZmZXI9YmkodGhpcy5nbCx0aGlzLmRlYnVnKSx0aGlzLmZyYW1lYnVmZmVyPW1lKHRoaXMuZ2wsdGhpcy5kZWJ1ZyksdGhpcy50ZXh0dXJlQ29uZmlnPVF0KHRoaXMuZ2wsdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uKX1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZGVidWdcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGkoKS5nZXRCb29sKFwiREVCVUdcIil9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYoIXRoaXMuZGlzcG9zZWQpe251bGwhPXRoaXMucHJvZ3JhbSYmY29uc29sZS53YXJuKFwiRGlzcG9zaW5nIGEgR1BHUFVDb250ZXh0IHRoYXQgc3RpbGwgaGFzIGEgYm91bmQgV2ViR0xQcm9ncmFtLiBUaGlzIGlzIHByb2JhYmx5IGEgcmVzb3VyY2UgbGVhaywgZGVsZXRlIHRoZSBwcm9ncmFtIHdpdGggR1BHUFVDb250ZXh0LmRlbGV0ZVByb2dyYW0gYmVmb3JlIGRpc3Bvc2luZy5cIiksbnVsbCE9dGhpcy5vdXRwdXRUZXh0dXJlJiZjb25zb2xlLndhcm4oXCJEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBvdXRwdXQgbWF0cml4IHRleHR1cmUuICBUaGlzIGlzIHByb2JhYmx5IGEgcmVzb3VyY2UgbGVhaywgZGVsZXRlIHRoZSBvdXRwdXQgbWF0cml4IHRleHR1cmUgd2l0aCBHUEdQVUNvbnRleHQuZGVsZXRlTWF0cml4VGV4dHVyZSBiZWZvcmUgZGlzcG9zaW5nLlwiKTt2YXIgZT10aGlzLmdsO0p0KGUsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5maW5pc2goKX0pKSxKdChlLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsbnVsbCl9KSksSnQoZSx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBlLmRlbGV0ZUZyYW1lYnVmZmVyKHQuZnJhbWVidWZmZXIpfSkpLEp0KGUsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kQnVmZmVyKGUuQVJSQVlfQlVGRkVSLG51bGwpfSkpLEp0KGUsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kQnVmZmVyKGUuRUxFTUVOVF9BUlJBWV9CVUZGRVIsbnVsbCl9KSksSnQoZSx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBlLmRlbGV0ZUJ1ZmZlcih0LmluZGV4QnVmZmVyKX0pKSx0aGlzLmRpc3Bvc2VkPSEwfX0sdC5wcm90b3R5cGUuY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxDaSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmNyZWF0ZUZsb2F0MTZNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksRWkodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5jcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFJpKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlPWZ1bmN0aW9uKHQsZSl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxEaSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlKX0sdC5wcm90b3R5cGUudXBsb2FkRGVuc2VNYXRyaXhUb1RleHR1cmU9ZnVuY3Rpb24odCxlLG4scil7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxBaSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlLG4scix0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5jcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGtpKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLElpKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuZGVsZXRlTWF0cml4VGV4dHVyZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5vdXRwdXRUZXh0dXJlPT09dCYmKEVlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0aGlzLmZyYW1lYnVmZmVyKSx0aGlzLm91dHB1dFRleHR1cmU9bnVsbCksSnQodGhpcy5nbCx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBlLmdsLmRlbGV0ZVRleHR1cmUodCl9KSl9LHQucHJvdG90eXBlLmRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzO3JldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKHQsKGZ1bmN0aW9uKCl7cmV0dXJuIEZpKHIuZ2wsci5kZWJ1ZyxlLG4sci50ZXh0dXJlQ29uZmlnKX0pKX0sdC5wcm90b3R5cGUuZG93bmxvYWRQYWNrZWRNYXRyaXhGcm9tQnVmZmVyPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gX2kodGhpcy5nbCx0LDAsMCwwLG8sYSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5kb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE5pKHRoaXMuZ2wsdCxlKX0sdC5wcm90b3R5cGUuY3JlYXRlQnVmZmVyRnJvbVRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKHQpO3ZhciByPVRpKHRoaXMuZ2wsdGhpcy5kZWJ1ZyxlLG4sdGhpcy50ZXh0dXJlQ29uZmlnKTtyZXR1cm4gdGhpcy51bmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcigpLHJ9LHQucHJvdG90eXBlLmNyZWF0ZUFuZFdhaXRGb3JGZW5jZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuY3JlYXRlRmVuY2UodGhpcy5nbCk7cmV0dXJuIHRoaXMucG9sbEZlbmNlKHQpfSx0LnByb3RvdHlwZS5jcmVhdGVGZW5jZT1mdW5jdGlvbih0KXt2YXIgZSxuLHI9dGhpcztpZihpKCkuZ2V0Qm9vbChcIldFQkdMX0ZFTkNFX0FQSV9FTkFCTEVEXCIpKXt2YXIgbz10LGE9by5mZW5jZVN5bmMoby5TWU5DX0dQVV9DT01NQU5EU19DT01QTEVURSwwKTt0LmZsdXNoKCksbj1mdW5jdGlvbigpe3ZhciB0PW8uY2xpZW50V2FpdFN5bmMoYSwwLDApO3JldHVybiB0PT09by5BTFJFQURZX1NJR05BTEVEfHx0PT09by5DT05ESVRJT05fU0FUSVNGSUVEfSxlPWF9ZWxzZSBpKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIik+MD8oZT10aGlzLmJlZ2luUXVlcnkoKSx0aGlzLmVuZFF1ZXJ5KCksbj1mdW5jdGlvbigpe3JldHVybiByLmlzUXVlcnlBdmFpbGFibGUoZSxpKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpfSk6bj1mdW5jdGlvbigpe3JldHVybiEwfTtyZXR1cm57cXVlcnk6ZSxpc0ZlbmNlUGFzc2VkOm59fSx0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzO3JldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKHQsKGZ1bmN0aW9uKCl7cmV0dXJuIE9pKHIuZ2wsci5kZWJ1ZyxlLG4pfSkpfSx0LnByb3RvdHlwZS5jcmVhdGVQcm9ncmFtPWZ1bmN0aW9uKHQpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7dmFyIGU9dGhpcy5nbCxuPWFlKGUsdGhpcy5kZWJ1Zyx0KSxyPXlpKGUsdGhpcy5kZWJ1Zyksbz1jZShlLHRoaXMuZGVidWcpO3JldHVybiBKdChlLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuYXR0YWNoU2hhZGVyKG8scil9KSksSnQoZSx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBlLmF0dGFjaFNoYWRlcihvLG4pfSkpLGxlKGUsdGhpcy5kZWJ1ZyxvKSx0aGlzLmRlYnVnJiZoZShlLHRoaXMuZGVidWcsbyksdGhpcy52ZXJ0ZXhBdHRyc0FyZUJvdW5kfHwodGhpcy5zZXRQcm9ncmFtKG8pLHRoaXMudmVydGV4QXR0cnNBcmVCb3VuZD1TaShlLHRoaXMuZGVidWcsdGhpcy5wcm9ncmFtLHRoaXMudmVydGV4QnVmZmVyKSksb30sdC5wcm90b3R5cGUuZGVsZXRlUHJvZ3JhbT1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdD09PXRoaXMucHJvZ3JhbSYmKHRoaXMucHJvZ3JhbT1udWxsKSxudWxsIT10JiZKdCh0aGlzLmdsLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuZ2wuZGVsZXRlUHJvZ3JhbSh0KX0pKX0sdC5wcm90b3R5cGUuc2V0UHJvZ3JhbT1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5wcm9ncmFtPXQsbnVsbCE9dGhpcy5wcm9ncmFtJiZ0aGlzLmRlYnVnJiZoZSh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5wcm9ncmFtKSxKdCh0aGlzLmdsLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuZ2wudXNlUHJvZ3JhbSh0KX0pKX0sdC5wcm90b3R5cGUuZ2V0VW5pZm9ybUxvY2F0aW9uPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49ITApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksbj94ZSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlKTpiZSh0aGlzLmdsLHQsZSl9LHQucHJvdG90eXBlLmdldEF0dHJpYnV0ZUxvY2F0aW9uPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxKdCh0aGlzLmdsLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIG4uZ2wuZ2V0QXR0cmliTG9jYXRpb24odCxlKX0pKX0sdC5wcm90b3R5cGUuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHQsZSl9LHQucHJvdG90eXBlLnNldElucHV0TWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnRocm93SWZOb1Byb2dyYW0oKSx3ZSh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5wcm9ncmFtLHQsZSxuKX0sdC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dGhpcy5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyKHQsbixlKX0sdC5wcm90b3R5cGUuc2V0T3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgcj0kdChlLG4pLG89clswXSxhPXJbMV07dGhpcy5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyKHQsbyxhKX0sdC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb249ZnVuY3Rpb24odCxlLG4scil7dGhpcy5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlcihuLHQscixlKX0sdC5wcm90b3R5cGUuc2V0T3V0cHV0UGFja2VkTWF0cml4V3JpdGVSZWdpb249ZnVuY3Rpb24odCxlLG4scil7dGhyb3cgbmV3IEVycm9yKFwic2V0T3V0cHV0UGFja2VkTWF0cml4V3JpdGVSZWdpb24gbm90IGltcGxlbWVudGVkLlwiKX0sdC5wcm90b3R5cGUuZGVidWdWYWxpZGF0ZT1mdW5jdGlvbigpe251bGwhPXRoaXMucHJvZ3JhbSYmaGUodGhpcy5nbCx0aGlzLmRlYnVnLHRoaXMucHJvZ3JhbSksUmUodGhpcy5nbCl9LHQucHJvdG90eXBlLmV4ZWN1dGVQcm9ncmFtPWZ1bmN0aW9uKCl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnRocm93SWZOb1Byb2dyYW0oKTt2YXIgdD10aGlzLmdsO3RoaXMuZGVidWcmJnRoaXMuZGVidWdWYWxpZGF0ZSgpLEp0KHQsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gdC5kcmF3RWxlbWVudHModC5UUklBTkdMRVMsNix0LlVOU0lHTkVEX1NIT1JULDApfSkpfSx0LnByb3RvdHlwZS5ibG9ja1VudGlsQWxsUHJvZ3JhbXNDb21wbGV0ZWQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksSnQodGhpcy5nbCx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiB0LmdsLmZpbmlzaCgpfSkpfSx0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PXRoaXMuZGlzam9pbnRRdWVyeVRpbWVyRXh0ZW5zaW9uJiYodGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb249cmUodGhpcy5nbCx0aGlzLmRlYnVnLDI9PT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIik/XCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyXCI6XCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlcIikpLHRoaXMuZGlzam9pbnRRdWVyeVRpbWVyRXh0ZW5zaW9ufSx0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbigpfSx0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbigpfSx0LnByb3RvdHlwZS5iZWdpblF1ZXJ5PWZ1bmN0aW9uKCl7aWYoMj09PWkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSl7dmFyIHQ9dGhpcy5nbCxlPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpLG49dC5jcmVhdGVRdWVyeSgpO3JldHVybiB0LmJlZ2luUXVlcnkoZS5USU1FX0VMQVBTRURfRVhULG4pLG59dmFyIHI9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCksbz1yLmNyZWF0ZVF1ZXJ5RVhUKCk7cmV0dXJuIHIuYmVnaW5RdWVyeUVYVChyLlRJTUVfRUxBUFNFRF9FWFQsbyksb30sdC5wcm90b3R5cGUuZW5kUXVlcnk9ZnVuY3Rpb24oKXtpZigyIT09aSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKXt2YXIgdD10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKTt0LmVuZFF1ZXJ5RVhUKHQuVElNRV9FTEFQU0VEX0VYVCl9ZWxzZXt2YXIgZT10aGlzLmdsLG49dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyKCk7ZS5lbmRRdWVyeShuLlRJTUVfRUxBUFNFRF9FWFQpfX0sdC5wcm90b3R5cGUud2FpdEZvclF1ZXJ5QW5kR2V0VGltZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybls0LEYoKGZ1bmN0aW9uKCl7cmV0dXJuIGUuZGlzcG9zZWR8fGUuaXNRdWVyeUF2YWlsYWJsZSh0LGkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSl9KSldO2Nhc2UgMTpyZXR1cm4gbi5zZW50KCksWzIsdGhpcy5nZXRRdWVyeVRpbWUodCxpKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpXX19KSl9KSl9LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZT1mdW5jdGlvbih0LGUpe2lmKDA9PT1lKXJldHVybiBudWxsO2lmKDI9PT1lKXt2YXIgbj10aGlzLmdsO3JldHVybiBuLmdldFF1ZXJ5UGFyYW1ldGVyKHQsbi5RVUVSWV9SRVNVTFQpLzFlNn12YXIgcj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKTtyZXR1cm4gci5nZXRRdWVyeU9iamVjdEVYVCh0LHIuUVVFUllfUkVTVUxUX0VYVCkvMWU2fSx0LnByb3RvdHlwZS5pc1F1ZXJ5QXZhaWxhYmxlPWZ1bmN0aW9uKHQsZSl7aWYoMD09PWUpcmV0dXJuITA7aWYoMj09PWUpe3ZhciBuPXRoaXMuZ2wscj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKSxvPW4uZ2V0UXVlcnlQYXJhbWV0ZXIodCxuLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEUpO3JldHVybiBudWxsPT10aGlzLmRpc2pvaW50JiYodGhpcy5kaXNqb2ludD10aGlzLmdsLmdldFBhcmFtZXRlcihyLkdQVV9ESVNKT0lOVF9FWFQpKSxvJiYhdGhpcy5kaXNqb2ludH1vPShyPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpKS5nZXRRdWVyeU9iamVjdEVYVCh0LHIuUVVFUllfUkVTVUxUX0FWQUlMQUJMRV9FWFQpO3JldHVybiBudWxsPT10aGlzLmRpc2pvaW50JiYodGhpcy5kaXNqb2ludD10aGlzLmdsLmdldFBhcmFtZXRlcihyLkdQVV9ESVNKT0lOVF9FWFQpKSxvJiYhdGhpcy5kaXNqb2ludH0sdC5wcm90b3R5cGUucG9sbEZlbmNlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihuKXtlLmFkZEl0ZW1Ub1BvbGwoKGZ1bmN0aW9uKCl7cmV0dXJuIHQuaXNGZW5jZVBhc3NlZCgpfSksKGZ1bmN0aW9uKCl7cmV0dXJuIG4oKX0pKX0pKX0sdC5wcm90b3R5cGUucG9sbEl0ZW1zPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7KytlKXtpZighdFtlXSgpKWJyZWFrfXJldHVybiBlLTF9KHRoaXMuaXRlbXNUb1BvbGwubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5pc0RvbmVGbn0pKSksZT0wO2U8PXQ7KytlKXsoMCx0aGlzLml0ZW1zVG9Qb2xsW2VdLnJlc29sdmVGbikoKX10aGlzLml0ZW1zVG9Qb2xsPXRoaXMuaXRlbXNUb1BvbGwuc2xpY2UodCsxKX0sdC5wcm90b3R5cGUuYWRkSXRlbVRvUG9sbD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7dGhpcy5pdGVtc1RvUG9sbC5wdXNoKHtpc0RvbmVGbjp0LHJlc29sdmVGbjplfSksdGhpcy5pdGVtc1RvUG9sbC5sZW5ndGg+MXx8RigoZnVuY3Rpb24oKXtyZXR1cm4gbi5wb2xsSXRlbXMoKSwwPT09bi5pdGVtc1RvUG9sbC5sZW5ndGh9KSl9LHQucHJvdG90eXBlLmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcj1mdW5jdGlvbih0KXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLENlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LHRoaXMuZnJhbWVidWZmZXIpLHRoaXMuZGVidWcmJlJlKHRoaXMuZ2wpfSx0LnByb3RvdHlwZS51bmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcj1mdW5jdGlvbigpe251bGwhPXRoaXMub3V0cHV0VGV4dHVyZT8oQ2UodGhpcy5nbCx0aGlzLmRlYnVnLHRoaXMub3V0cHV0VGV4dHVyZSx0aGlzLmZyYW1lYnVmZmVyKSx0aGlzLmRlYnVnJiZSZSh0aGlzLmdsKSk6RWUodGhpcy5nbCx0aGlzLmRlYnVnLHRoaXMuZnJhbWVidWZmZXIpfSx0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeERyaXZlcj1mdW5jdGlvbih0LGUpe3RoaXMuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKHQpO3ZhciBuPWUoKTtyZXR1cm4gdGhpcy51bmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcigpLG59LHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXI9ZnVuY3Rpb24odCxlLG4pe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7dmFyIHI9dGhpcy5nbDtDZShyLHRoaXMuZGVidWcsdCx0aGlzLmZyYW1lYnVmZmVyKSx0aGlzLmRlYnVnJiZSZShyKSx0aGlzLm91dHB1dFRleHR1cmU9dCxKdChyLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIHIudmlld3BvcnQoMCwwLGUsbil9KSksSnQocix0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiByLnNjaXNzb3IoMCwwLGUsbil9KSl9LHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxKdCh0aGlzLmdsLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIG8uZ2wuc2Npc3Nvcih0LGUsbixyKX0pKX0sdC5wcm90b3R5cGUudGhyb3dJZkRpc3Bvc2VkPWZ1bmN0aW9uKCl7aWYodGhpcy5kaXNwb3NlZCl0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gdXNlIGRpc3Bvc2VkIEdQR1BVQ29udGV4dC5cIil9LHQucHJvdG90eXBlLnRocm93SWZOb1Byb2dyYW09ZnVuY3Rpb24oKXtpZihudWxsPT10aGlzLnByb2dyYW0pdGhyb3cgbmV3IEVycm9yKFwiTm8gR1BVIHByb2dyYW0gaXMgY3VycmVudGx5IHNldC5cIil9LHR9KCk7ZnVuY3Rpb24gUGkodCxlKXtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIFwiK3QubGVuZ3RoK1wiIGlucHV0cywgYnV0IHdhcyBleGVjdXRlZCB3aXRoIFwiK2UubGVuZ3RoK1wiIGlucHV0c1wiKTt0LmZvckVhY2goKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5sb2dpY2FsU2hhcGUsbz1lW25dLGE9by5zaGFwZTtpZighUyhyLGEpKXRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCBzaGFwZXMgdGhhbiB0aGUgY3VycmVudCBhcmdzLiBTaGFwZXMgXCIrcitcIiBhbmQgXCIrYStcIiBtdXN0IG1hdGNoXCIpO2lmKCF0LmlzVW5pZm9ybXx8IW8uaXNVbmlmb3JtKXt2YXIgaT10LnRleFNoYXBlLHM9by5pc1VuaWZvcm0/bnVsbDpvLnRleERhdGEudGV4U2hhcGU7aWYoIVMoaSxzKSl0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgdGV4dHVyZSBzaGFwZXMgdGhhbiB0aGUgY3VycmVudCBhcmdzLiBTaGFwZSBcIitpK1wiIGFuZCBcIitzK1wiIG11c3QgbWF0Y2hcIil9fSkpfXZhciBMaT1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT10O2Zvcih2YXIgcj1uLmZpbHRlcldpZHRoLG89bi5pbkNoYW5uZWxzLGE9bi5zdHJpZGVXaWR0aCxpPW4uc3RyaWRlSGVpZ2h0LHM9bi5wYWRJbmZvLHU9bi5vdXRXaWR0aCxjPW4uZGlsYXRpb25XaWR0aCxsPW4uZGlsYXRpb25IZWlnaHQsaD1uLmRhdGFGb3JtYXQsZj1zLmxlZnQsZD1zLnRvcCxwPW8qcix2PXVhKCksbT1cImNoYW5uZWxzTGFzdFwiPT09aCxnPW0/MDoxLHk9bT8xOjIseD1cIlwiLGI9MDtiPD0xO2IrKylmb3IodmFyIHc9MDt3PD0xO3crKyl4Kz1cIlxcbiAgICAgICAgICBibG9ja0luZGV4ID0gcmMueSArIFwiK3crXCI7XFxuICAgICAgICAgIHBvcyA9IHJjLnggKyBcIitiK1wiO1xcblxcbiAgICAgICAgICBpZihibG9ja0luZGV4IDwgXCIrdFsxXStcIiAmJiBwb3MgPCBcIit0WzBdK1wiKSB7XFxuICAgICAgICAgICAgb2Zmc2V0WSA9IGludChibG9ja0luZGV4IC8gKFwiK3UrXCIpKSAqIFwiK2krXCIgLSBcIitkK1wiO1xcbiAgICAgICAgICAgIGQwID0gb2Zmc2V0WSArIFwiK2wrXCIgKiAocG9zIC8gXCIrcCtcIik7XFxuXFxuICAgICAgICAgICAgaWYoZDAgPCBcIitlW2ddK1wiICYmIGQwID49IDApIHtcXG5cXG4gICAgICAgICAgICAgIG9mZnNldFggPSBpbnQobW9kKGZsb2F0KGJsb2NrSW5kZXgpLCBcIit1K1wiLikgKiBcIithK1wiLiAtIFwiK2YrXCIuKTtcXG4gICAgICAgICAgICAgIGQxID0gb2Zmc2V0WCArIFwiK2MrXCIgKiAoaW50KG1vZChmbG9hdChwb3MpLCBcIitwK1wiLikgLyBcIitvK1wiLikpO1xcblxcbiAgICAgICAgICAgICAgaWYoZDEgPCBcIitlW3ldK1wiICYmIGQxID49IDApIHtcXG5cXG4gICAgICAgICAgICAgICAgY2ggPSBpbnQobW9kKGZsb2F0KHBvcyksIFwiK28rXCIuKSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChcIittK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgaW5uZXJEaW1zID0gdmVjMihkMSwgY2gpO1xcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFtcIisoMipiK3cpK1wiXSA9IGdldENoYW5uZWwoXFxuICAgICAgICAgICAgICAgICAgICBnZXRBKGQwLCBpbnQoaW5uZXJEaW1zLngpLFxcbiAgICAgICAgICAgICAgICAgICAgaW50KGlubmVyRGltcy55KSksIGlubmVyRGltcyk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgaW5uZXJEaW1zID0gdmVjMihkMCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFtcIisoMipiK3cpK1wiXSA9IGdldENoYW5uZWwoXFxuICAgICAgICAgICAgICAgICAgICBnZXRBKGNoLCBpbnQoaW5uZXJEaW1zLngpLFxcbiAgICAgICAgICAgICAgICAgICAgaW50KGlubmVyRGltcy55KSksIGlubmVyRGltcyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIFwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDApO1xcblxcbiAgICAgICAgaW50IGJsb2NrSW5kZXgsIHBvcywgb2Zmc2V0WSwgZDAsIG9mZnNldFgsIGQxLCBjaDtcXG4gICAgICAgIHZlYzIgaW5uZXJEaW1zO1xcblxcbiAgICAgICAgXCIreCtcIlxcblxcbiAgICAgICAgXCIrdi5vdXRwdXQrXCIgPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICBcIn0sV2k9ZnVuY3Rpb24odCxlLG4scixvKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPVtdO3ZhciBhLGk9ZSxzPXRbM10tMTt0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIHU9XCJmbG9hdChcIituK1wiKSArIGZsb2F0KFwiK3IrXCIpICogc3VtXCI7YT0uNT09PW8/XCJpbnZlcnNlc3FydChcIit1K1wiKVwiOjE9PT1vP1wiMS4wLyhcIit1K1wiKVwiOlwiZXhwKGxvZyhcIit1K1wiKSAqIGZsb2F0KC1cIitvK1wiKSk7XCIsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0WChiLCByLCBjLCBkKTtcXG4gICAgICAgIGZsb2F0IHN1bSA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IGogPSAtXCIraStcIjsgaiA8PSBcIitpK1wiOyBqKyspIHtcXG4gICAgICAgICAgaW50IGlkeCA9IGQgKyBqO1xcbiAgICAgICAgICBpZiAoaWR4ID49IDAgJiYgaWR4IDw9ICBcIitzK1wiKSB7XFxuICAgICAgICAgICAgZmxvYXQgeiA9IGdldFgoYiwgciwgYywgaWR4KTtcXG4gICAgICAgICAgICBzdW0gKz0geiAqIHo7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGZsb2F0IHZhbCA9IHggKiBcIithK1wiO1xcbiAgICAgICAgc2V0T3V0cHV0KHZhbCk7XFxuICAgICAgfVxcbiAgICBcIn0sVWk9ZnVuY3Rpb24odCxlLG4scixvKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiaW5wdXRJbWFnZVwiLFwib3V0cHV0SW1hZ2VcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMuZGVwdGg9dFszXSx0aGlzLmRlcHRoUmFkaXVzPWUsdGhpcy5iaWFzPW4sdGhpcy5hbHBoYT1yLHRoaXMuYmV0YT1vLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHIgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcXG5cXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IGQgPSAwOyBkIDwgXCIrdGhpcy5kZXB0aCtcIjsgKytkKSB7XFxuICAgICAgICAgIGludCBkZXB0aEJlZ2luID0gaW50KG1heCgwLjAsIGZsb2F0KGQgLSBcIitlK1wiKSkpO1xcbiAgICAgICAgICBpbnQgZGVwdGhFbmQgPSBpbnQobWluKGZsb2F0KFwiK3RoaXMuZGVwdGgrXCIpLFxcbiAgICAgICAgICAgICAgZmxvYXQoZCArIFwiK2UrXCIgKyAxKSkpO1xcblxcbiAgICAgICAgICBjb25zdCBpbnQgTUlOX0RFUFRIX0JFR0lOID0gMDtcXG4gICAgICAgICAgY29uc3QgaW50IE1BWF9ERVBUSF9FTkQgPSBcIit0aGlzLmRlcHRoK1wiO1xcblxcbiAgICAgICAgICBmbG9hdCBub3JtID0gMC4wO1xcbiAgICAgICAgICBmb3IgKGludCBrID0gTUlOX0RFUFRIX0JFR0lOOyBrIDwgTUFYX0RFUFRIX0VORDsgKytrKSB7XFxuICAgICAgICAgICAgaWYgKGsgPCBkZXB0aEJlZ2luKXtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChrID49IGRlcHRoQmVnaW4gJiYgayA8IGRlcHRoRW5kKSB7XFxuICAgICAgICAgICAgICBub3JtICs9IGdldElucHV0SW1hZ2UoYiwgciwgYywgaykgKiBnZXRJbnB1dEltYWdlKGIsIHIsIGMsIGspO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBub3JtID0gZmxvYXQoXCIrcitcIikgKiBub3JtICsgZmxvYXQoXCIrbitcIik7XFxuXFxuICAgICAgICAgIGZvcihpbnQgayA9IE1JTl9ERVBUSF9CRUdJTjsgayA8IE1BWF9ERVBUSF9FTkQ7ICsrayl7XFxuICAgICAgICAgICAgaWYgKGsgPCBkZXB0aEJlZ2luKXtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChrID49IGRlcHRoQmVnaW4gJiYgayA8IGRlcHRoRW5kKXtcXG4gICAgICAgICAgICAgIGZsb2F0IGR5aSA9IC0yLjAgKiBmbG9hdChcIityK1wiKVxcbiAgICAgICAgICAgICAgICAqIGZsb2F0KFwiK28rXCIpXFxuICAgICAgICAgICAgICAgICogZ2V0SW5wdXRJbWFnZShiICxyICxjLCBrKSAqIGdldE91dHB1dEltYWdlKGIsIHIsIGMsIGQpXFxuICAgICAgICAgICAgICAgIC8gbm9ybTtcXG4gICAgICAgICAgICAgIGlmIChrID09IGQpIHtcXG4gICAgICAgICAgICAgICAgZHlpICs9IHBvdyhub3JtLCAtMS4wICogXCIrbytcIik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBpZiAoayA9PSBjb29yZHNbM10pIHtcXG4gICAgICAgICAgICAgICAgZHlpICo9IGdldER5KGIsIHIsIGMsIGQpO1xcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZHlpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSxWaT1mdW5jdGlvbih0LGUsbixyLG8pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITA7dmFyIGEsaT1lLHM9dFszXS0xO3RoaXMub3V0cHV0U2hhcGU9dDt2YXIgdT1cImZsb2F0KFwiK24rXCIpICsgZmxvYXQoXCIrcitcIikgKiBzdW1cIjthPS41PT09bz9cImludmVyc2VzcXJ0KFwiK3UrXCIpXCI6MT09PW8/XCIxLjAvKFwiK3UrXCIpXCI6XCJleHAobG9nKFwiK3UrXCIpICogZmxvYXQoLVwiK28rXCIpKTtcIix0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHIgPSBjb29yZHMueTtcXG4gICAgICAgIGludCBjID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkcy53O1xcblxcbiAgICAgICAgYm9vbCBoYXNOZXh0Q29sID0gZCA8IFwiK3RoaXMub3V0cHV0U2hhcGVbM10rXCI7XFxuICAgICAgICBib29sIGhhc05leHRSb3cgPSBjIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVsyXStcIjtcXG5cXG4gICAgICAgIHZlYzQgc3VtID0gdmVjNCgwLik7XFxuICAgICAgICB2ZWM0IHhGcmFnQXRPdXRwdXRDb29yZHMgPSBnZXRYKGIsIHIsIGMsIGQpO1xcblxcbiAgICAgICAgdmVjNCB4QXRPdXRwdXRDb29yZHMgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRDaGFubmVsKHhGcmFnQXRPdXRwdXRDb29yZHMsIHZlYzIoYywgZCkpLFxcbiAgICAgICAgICBoYXNOZXh0Q29sID9cXG4gICAgICAgICAgICBnZXRDaGFubmVsKHhGcmFnQXRPdXRwdXRDb29yZHMsIHZlYzIoYywgZCArIDEpKSA6IDAuMCxcXG4gICAgICAgICAgaGFzTmV4dFJvdyA/XFxuICAgICAgICAgICAgZ2V0Q2hhbm5lbCh4RnJhZ0F0T3V0cHV0Q29vcmRzICwgdmVjMihjICsgMSwgZCkpIDogMC4wLFxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XFxuICAgICAgICAgICAgZ2V0Q2hhbm5lbCh4RnJhZ0F0T3V0cHV0Q29vcmRzLCB2ZWMyKGMgKyAxLCBkICsgMSkpIDogMC4wXFxuICAgICAgICApO1xcblxcbiAgICAgICAgaW50IGZpcnN0Q2hhbm5lbCA9IGQgLSBcIitpK1wiO1xcbiAgICAgICAgdmVjMiBjYWNoZSA9IHZlYzIoMC4pO1xcbiAgICAgICAgaWYoZmlyc3RDaGFubmVsID49IDApe1xcbiAgICAgICAgICB2ZWM0IGZpcnN0Q2hhbm5lbEZyYWcgPSBnZXRYKGIsIHIsIGMsIGZpcnN0Q2hhbm5lbCk7XFxuICAgICAgICAgIGNhY2hlLnggPSBnZXRDaGFubmVsKGZpcnN0Q2hhbm5lbEZyYWcsIHZlYzIoYywgZmlyc3RDaGFubmVsKSk7XFxuICAgICAgICAgICAgaWYoaGFzTmV4dFJvdyl7XFxuICAgICAgICAgICAgICBjYWNoZS55ID0gZ2V0Q2hhbm5lbChmaXJzdENoYW5uZWxGcmFnLCB2ZWMyKGMgKyAxLCBmaXJzdENoYW5uZWwpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpdmVjMiBkZXB0aCA9IGl2ZWMyKGQsIGQgKyAxKTtcXG4gICAgICAgIGZvciAoaW50IGogPSAtIFwiK2krXCI7IGogPD0gXCIraStcIjsgaisrKSB7XFxuICAgICAgICAgIGl2ZWMyIGlkeCA9IGRlcHRoICsgajtcXG4gICAgICAgICAgYnZlYzIgYWJvdmVMb3dlckJvdW5kID0gZ3JlYXRlclRoYW5FcXVhbChpZHgsIGl2ZWMyKDApKTtcXG4gICAgICAgICAgYnZlYzIgYmVsb3dVcHBlckJvdW5kID0gbGVzc1RoYW5FcXVhbChpZHgsIGl2ZWMyKFwiK3MrXCIpKTtcXG5cXG4gICAgICAgICAgYm9vbCBkZXB0aEluUmFuZ2UgPSBhYm92ZUxvd2VyQm91bmQueCAmJiBiZWxvd1VwcGVyQm91bmQueDtcXG4gICAgICAgICAgYm9vbCBkZXB0aFBsdXNPbmVJblJhbmdlID0gYWJvdmVMb3dlckJvdW5kLnkgJiYgYmVsb3dVcHBlckJvdW5kLnk7XFxuXFxuICAgICAgICAgIGlmKGRlcHRoSW5SYW5nZSB8fCBkZXB0aFBsdXNPbmVJblJhbmdlKXtcXG4gICAgICAgICAgICB2ZWM0IHogPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICB2ZWM0IHhGcmFnQXRDdXJyZW50RGVwdGg7XFxuICAgICAgICAgICAgei54eiA9IGNhY2hlLnh5O1xcbiAgICAgICAgICAgIGlmKGRlcHRoUGx1c09uZUluUmFuZ2UgJiYgaGFzTmV4dENvbCl7XFxuICAgICAgICAgICAgICB4RnJhZ0F0Q3VycmVudERlcHRoID0gaWR4LnkgIT0gZCA/XFxuICAgICAgICAgICAgICAgIGdldFgoYiwgciwgYywgaWR4LnkpIDogeEZyYWdBdE91dHB1dENvb3JkcztcXG4gICAgICAgICAgICAgIHoueSA9IGdldENoYW5uZWwoeEZyYWdBdEN1cnJlbnREZXB0aCwgdmVjMihjLCBpZHgueSkpO1xcbiAgICAgICAgICAgICAgaWYoaGFzTmV4dFJvdyl7XFxuICAgICAgICAgICAgICAgIHoudyA9IGdldENoYW5uZWwoeEZyYWdBdEN1cnJlbnREZXB0aCwgdmVjMihjICsgMSwgaWR4LnkpKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY2FjaGUueHkgPSB6Lnl3O1xcbiAgICAgICAgICAgIHN1bSArPSB6ICogejtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB4QXRPdXRwdXRDb29yZHMgKiBcIithK1wiO1xcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn0semk9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCIsXCJtYXhQb3NcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmluU2hhcGU7dmFyIGU9dC5zdHJpZGVIZWlnaHQsbj10LnN0cmlkZVdpZHRoLHI9dC5kaWxhdGlvbkhlaWdodCxvPXQuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGE9dC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxpPW8tMS10LnBhZEluZm8udG9wLHM9YS0xLXQucGFkSW5mby5sZWZ0LHU9byphLTE7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitpK1wiLCBcIitzK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiBkeVJDQ29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeVJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZCkgd2l0aCBwb3MgbWFzayg6LCA6LCBkKSB0byBnZXQgZHgoeFIsIHhDLCBkKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitvK1wiO1xcbiAgICAgICAgICB3UiArPSBcIityK1wiKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK2UrXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK2ErXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIituK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBpZHlSLCBpZHlDLCBkKTtcXG4gICAgICAgICAgICBpbnQgbWF4UG9zVmFsdWUgPSBcIit1K1wiIC0gaW50KGdldE1heFBvcyhiLCBpZHlSLCBpZHlDLCBkKSk7XFxuXFxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHZhbHVlLCBjaGVjayBpdCBhZ2FpbnN0IHRoZSB2YWx1ZSBmcm9tIHRoZVxcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIG1hdHJpeC5cXG4gICAgICAgICAgICBpbnQgY3VyUG9zVmFsdWUgPSB3UiAqIFwiK2ErXCIgKyB3QztcXG4gICAgICAgICAgICBmbG9hdCBtYXNrID0gZmxvYXQobWF4UG9zVmFsdWUgPT0gY3VyUG9zVmFsdWUgPyAxLjAgOiAwLjApO1xcblxcbiAgICAgICAgICAgIGRvdFByb2QgKz0gZHlWYWx1ZSAqIG1hc2s7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifSxHaT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIixcIm1heFBvc1wiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LnN0cmlkZURlcHRoLG49dC5zdHJpZGVIZWlnaHQscj10LnN0cmlkZVdpZHRoLG89dC5kaWxhdGlvbkRlcHRoLGE9dC5kaWxhdGlvbkhlaWdodCxpPXQuZGlsYXRpb25XaWR0aCxzPXQuZWZmZWN0aXZlRmlsdGVyRGVwdGgsdT10LmVmZmVjdGl2ZUZpbHRlckhlaWdodCxjPXQuZWZmZWN0aXZlRmlsdGVyV2lkdGgsbD1zLTEtdC5wYWRJbmZvLmZyb250LGg9dS0xLXQucGFkSW5mby50b3AsZj1jLTEtdC5wYWRJbmZvLmxlZnQsZD1zKnUqYy0xO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoXCIrbCtcIiwgXCIraCtcIiwgXCIrZitcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGludCBjaCA9IGNvb3Jkcy51O1xcblxcbiAgICAgICAgaXZlYzMgZHlDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlEQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci55O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLno7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCA/LCBjaCkgd2l0aCBwb3MgbWFzayg6LCA6LCA6LCBkKSB0byBnZXRcXG4gICAgICAgIC8vIGR4KHhELCB4UiwgeEMsIGNoKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdEID0gMDsgd0QgPCBcIitzK1wiO1xcbiAgICAgICAgICAgd0QgKz0gXCIrbytcIikge1xcbiAgICAgICAgICBmbG9hdCBkeUQgPSBmbG9hdChkeURDb3JuZXIgKyB3RCkgLyBcIitlK1wiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeUQgPCAwLjAgfHwgZHlEID49IFwiK3Qub3V0RGVwdGgrXCIuMCB8fCBmcmFjdChkeUQpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeUQgPSBpbnQoZHlEKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK3UrXCI7XFxuICAgICAgICAgICAgICB3UiArPSBcIithK1wiKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrbitcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiK3Qub3V0SGVpZ2h0K1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK2MrXCI7XFxuICAgICAgICAgICAgICAgIHdDICs9IFwiK2krXCIpIHtcXG4gICAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK3IrXCIuMDtcXG5cXG4gICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Qub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlELCBpZHlSLCBpZHlDLCBjaCk7XFxuICAgICAgICAgICAgICBpbnQgbWF4UG9zVmFsdWUgPSBcIitkK1wiIC1cXG4gICAgICAgICAgICAgICAgICBpbnQoZ2V0TWF4UG9zKGJhdGNoLCBpZHlELCBpZHlSLCBpZHlDLCBjaCkpO1xcblxcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHZhbHVlLCBjaGVjayBpdCBhZ2FpbnN0IHRoZSB2YWx1ZSBmcm9tIHRoZVxcbiAgICAgICAgICAgICAgLy8gcG9zaXRpb24gbWF0cml4LlxcbiAgICAgICAgICAgICAgaW50IGN1clBvc1ZhbHVlID1cXG4gICAgICAgICAgICAgICAgICB3RCAqIFwiK3UrXCIgKiBcIitjK1wiICtcXG4gICAgICAgICAgICAgICAgICB3UiAqIFwiK2MrXCIgKyB3QztcXG4gICAgICAgICAgICAgIGZsb2F0IG1hc2sgPSBmbG9hdChtYXhQb3NWYWx1ZSA9PSBjdXJQb3NWYWx1ZSA/IDEuMCA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBtYXNrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LEhpPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PW4mJihuPSExKSx2b2lkIDA9PT1yJiYocj0hMSksdm9pZCAwPT09byYmKG89ITEpLHZvaWQgMD09PWEmJihhPW51bGwpLHZvaWQgMD09PWkmJihpPSExKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wibWF0cml4QVwiLFwibWF0cml4QlwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPWU7dmFyIHM9bj90WzFdOnRbMl0sdT1NYXRoLmNlaWwocy8yKSxjPW4/XCJpICogMiwgcmMueVwiOlwicmMueSwgaSAqIDJcIixsPXI/XCJyYy56LCBpICogMlwiOlwiaSAqIDIsIHJjLnpcIixoPW4/W1wiYS54eHl5XCIsXCJhLnp6d3dcIl06W1wiYS54eHp6XCIsXCJhLnl5d3dcIl0sZj1yP1tcImIueHp4elwiLFwiYi55d3l3XCJdOltcImIueHl4eVwiLFwiYi56d3p3XCJdLGQ9XCJcIixwPVwiXCI7YSYmKGQ9aT9cInZlYzQgYWN0aXZhdGlvbih2ZWM0IGEpIHtcXG4gICAgICAgICAgdmVjNCBiID0gZ2V0UHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0F0T3V0Q29vcmRzKCk7XFxuICAgICAgICAgIFwiK2ErXCJcXG4gICAgICAgIH1cIjpcInZlYzQgYWN0aXZhdGlvbih2ZWM0IHgpIHtcXG4gICAgICAgICAgXCIrYStcIlxcbiAgICAgICAgfVwiLHA9XCJyZXN1bHQgPSBhY3RpdmF0aW9uKHJlc3VsdCk7XCIpO3ZhciB2PW8/XCJyZXN1bHQgKz0gZ2V0Qmlhc0F0T3V0Q29vcmRzKCk7XCI6XCJcIjtvJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImJpYXNcIiksaSYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJwcmVsdUFjdGl2YXRpb25XZWlnaHRzXCIpLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIitkK1wiXFxuXFxuICAgICAgY29uc3QgZmxvYXQgc2hhcmVkRGltZW5zaW9uID0gXCIrdStcIi4wO1xcblxcbiAgICAgIHZlYzQgZG90MngyQVJvd0JDb2woaXZlYzMgcmMpIHtcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwKTtcXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrdStcIjsgaSsrKSB7XFxuICAgICAgICAgIHZlYzQgYSA9IGdldE1hdHJpeEEocmMueCwgXCIrYytcIik7XFxuICAgICAgICAgIHZlYzQgYiA9IGdldE1hdHJpeEIocmMueCwgXCIrbCtcIik7XFxuXFxuICAgICAgICAgIC8vIFRoZXNlIHN3aXp6bGVkIHByb2R1Y3RzIG5lZWQgdG8gYmUgc2VwYXJhdGVseSBhZGRlZC5cXG4gICAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzL2lzc3Vlcy8xNzM1XFxuICAgICAgICAgIHJlc3VsdCArPSAoXCIraFswXStcIiAqIFwiK2ZbMF0rXCIpO1xcbiAgICAgICAgICByZXN1bHQgKz0gKFwiK2hbMV0rXCIgKiBcIitmWzFdK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IGRvdDJ4MkFSb3dCQ29sKHJjKTtcXG5cXG4gICAgICAgIFwiK3YrXCJcXG5cXG4gICAgICAgIFwiK3ArXCJcXG5cXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9LHFpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInByb2JzXCJdLHRoaXMub3V0cHV0U2hhcGU9W3Qsbl0sdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgc2VlZDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG5cXG4gICAgICAgIGZsb2F0IHIgPSByYW5kb20oc2VlZCk7XFxuICAgICAgICBmbG9hdCBjZGYgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiKyhlLTEpK1wiOyBpKyspIHtcXG4gICAgICAgICAgY2RmICs9IGdldFByb2JzKGJhdGNoLCBpKTtcXG5cXG4gICAgICAgICAgaWYgKHIgPCBjZGYpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoaSkpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gSWYgbm8gb3RoZXIgZXZlbnQgaGFwcGVuZWQsIGxhc3QgZXZlbnQgaGFwcGVuZWQuXFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIrKGUtMSkrXCIpKTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gZnVuY3Rpb24obixyKXtudWxsPT1lLnNlZWRMb2MmJihlLnNlZWRMb2M9bi5nZXRVbmlmb3JtTG9jYXRpb24ocixcInNlZWRcIikpLG4uZ2wudW5pZm9ybTFmKGUuc2VlZExvYyx0KX19LHR9KCksS2k9ZnVuY3Rpb24odCxlLG4scil7dGhpcy52YXJpYWJsZU5hbWVzPVtcImluZGljZXNcIl0sdGhpcy5vdXRwdXRTaGFwZT1bdCxlXSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChnZXRJbmRpY2VzKGNvb3Jkcy54KSk7XFxuICAgICAgICBzZXRPdXRwdXQobWl4KGZsb2F0KFwiK3IrXCIpLCBmbG9hdChcIituK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgZmxvYXQoaW5kZXggPT0gY29vcmRzLnkpKSk7XFxuICAgICAgfVxcbiAgICBcIn0samk9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITEsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT10O3ZhciBlPXQubGVuZ3RoO2lmKDA9PT1lKXRoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZlYzQoZ2V0QSgpLCAwLiwgMC4sIDAuKSk7XFxuICAgICAgICB9XFxuICAgICAgXCI7ZWxzZXt2YXIgbj1zYShcInJjXCIsZSkscj13YShlKSxvPWZ1bmN0aW9uKHQsZSxuKXtpZigxPT09dClyZXR1cm5cInJjID4gXCIrZVswXTtmb3IodmFyIHI9XCJcIixvPXQtMjtvPHQ7bysrKXIrPW5bb10rXCIgPj0gXCIrZVtvXSxvPHQtMSYmKHIrPVwifHxcIik7cmV0dXJuIHJ9KGUsdCxuKSxhPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKDE9PT10KXJldHVyblwiXCI7dmFyIG89ci5zbGljZSgtMik7cmV0dXJuXCJcXG4gICAgaW50IHIgPSBcIitvWzBdK1wiO1xcbiAgICBpbnQgYyA9IFwiK29bMV0rXCI7XFxuICAgIGludCBycDEgPSByICsgMTtcXG4gICAgaW50IGNwMSA9IGMgKyAxO1xcblxcbiAgICBib29sIGNFZGdlID0gY3AxID49IFwiK2UrXCI7XFxuICAgIGJvb2wgckVkZ2UgPSBycDEgPj0gXCIrbitcIjtcXG4gIFwifShlLHRbdC5sZW5ndGgtMV0sdFt0Lmxlbmd0aC0yXSxuKSxpPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5sZW5ndGgscj1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1bXSxyPTA7cjw9MTtyKyspZm9yKHZhciBvPTA7bzw9MTtvKyspe2Zvcih2YXIgYT0oMD09PXI/XCJyXCI6XCJycDFcIikrXCIsIFwiKygwPT09bz9cImNcIjpcImNwMVwiKSxpPTI7aTx0O2krKylhPWVbZS5sZW5ndGgtMS1pXStcIixcIithO24ucHVzaChhKX1yZXR1cm4gbn0obixlKTtyZXR1cm4gMT09PW4/XCJnZXRBKHJjKSxcXG4gICAgICAgICAgICByYyArIDEgPj0gXCIrdFswXStcIiA/IDAuIDogZ2V0QShyYyArIDEpLFxcbiAgICAgICAgICAgIDAsIDBcIjpcImdldEEoXCIrclswXStcIiksXFxuICAgICAgICAgIGNFZGdlID8gMC4gOiBnZXRBKFwiK3JbMV0rXCIpLFxcbiAgICAgICAgICByRWRnZSA/IDAuIDogZ2V0QShcIityWzJdK1wiKSxcXG4gICAgICAgICAgckVkZ2UgfHwgY0VkZ2UgPyAwLiA6IGdldEEoXCIrclszXStcIilcIn0odCxuKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIFwiK3IrXCIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgICAgaWYoXCIrbytcIikge1xcbiAgICAgICAgICAgIHNldE91dHB1dCh2ZWM0KDApKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBcIithK1wiXFxuXFxuICAgICAgICAgICAgc2V0T3V0cHV0KHZlYzQoXCIraStcIikpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgXCJ9fTt2YXIgWGk9ZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5tYXAoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGVbMF0rdFtuXStlWzFdfSkpO3ZhciByPXQubGVuZ3RoLG89d2EociksYT1lLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KSkuam9pbihcIixcIiksaT1lLm1hcCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVswXSt0W25dfSkpLmpvaW4oXCIsXCIpLHM9W1wiY29vcmRzWzBdXCIsXCJjb29yZHNbMV1cIixcImNvb3Jkc1syXVwiLFwiY29vcmRzWzNdXCJdLnNsaWNlKDAscik7dGhpcy51c2VyQ29kZT0xIT09cj9cIlxcbiAgICAgIFwiK28rXCIgc3RhcnQgPSBcIitvK1wiKFwiK2ErXCIpO1xcbiAgICAgIFwiK28rXCIgZW5kID0gXCIrbytcIihcIitpK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitvK1wiIG91dEMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGlmIChhbnkobGVzc1RoYW4ob3V0Qywgc3RhcnQpKSB8fCBhbnkoZ3JlYXRlclRoYW5FcXVhbChvdXRDLCBlbmQpKSkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIrbitcIikpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgXCIrbytcIiBjb29yZHMgPSBvdXRDIC0gc3RhcnQ7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRYKFwiK3MrXCIpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwiOlwiXFxuICAgICAgICBpbnQgc3RhcnQgPSBcIithK1wiO1xcbiAgICAgICAgaW50IGVuZCA9IFwiK2krXCI7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGludCBvdXRDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGlmIChvdXRDIDwgc3RhcnQgfHwgb3V0QyA+PSBlbmQpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIrbitcIikpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHNldE91dHB1dChnZXRYKG91dEMgLSBzdGFydCkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgXCJ9LFlpPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPWUubWFwKChmdW5jdGlvbihlLG4pe3JldHVybiBlWzBdK3Rbbl0rZVsxXX0pKTtmb3IodmFyIHI9dC5sZW5ndGgsbz13YShyKSxhPWUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pKS5qb2luKFwiLFwiKSxpPWUubWFwKChmdW5jdGlvbihlLG4pe3JldHVybiBlWzBdK3Rbbl19KSkuam9pbihcIixcIikscz1zYShcInJjXCIsciksdT1zYShcInNvdXJjZVwiLHIpLGM9c1tyLTFdK1wiIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVtyLTFdLGw9MT09PXI/XCJzb3VyY2VcIjpcInZlYzIoXCIrdS5zbGljZSgtMikuam9pbigpK1wiKVwiLGg9W28rXCIgcmMgPSBvdXRwdXRMb2M7XCIsc1tyLTFdK1wiICs9IDE7XFxuICAgICAgIGlmKFwiK2MrXCIpIHtcXG4gICAgICBcIiwxPT09cj9cIlwiOlwifVxcbiAgICAgICByYyA9IG91dHB1dExvYztcXG4gICAgICAgXCIrc1tyLTJdK1wiICs9IDE7XFxuICAgICAgIGlmKFwiK3Nbci0yXStcIiA8IFwiK3RoaXMub3V0cHV0U2hhcGVbci0yXStcIikge1wiLDE9PT1yP1wiXCI6XCIgIFwiK3Nbci0xXStcIiArPSAxO1xcbiAgICAgICAgIGlmKFwiK2MrXCIpIHtcIl0sZj0xPT09cj9cInJjIDwgc3RhcnQgfHwgcmMgPj0gZW5kXCI6XCJhbnkobGVzc1RoYW4ocmMsIHN0YXJ0KSkgfHwgYW55KGdyZWF0ZXJUaGFuRXF1YWwocmMsIGVuZCkpXCIsZD1cIlwiLHA9MCx2PTE9PT1yPzI6NDtwPHY7cCsrKWQrPVwiXFxuICAgICAgICBcIitoW3BdK1wiXFxuICAgICAgICBpZiAoXCIrZitcIikge1xcbiAgICAgICAgICByZXN1bHRbXCIrcCtcIl0gPSBmbG9hdChcIituK1wiKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIFwiK28rXCIgc291cmNlID0gcmMgLSBzdGFydDtcXG4gICAgICAgICAgcmVzdWx0W1wiK3ArXCJdID0gZ2V0Q2hhbm5lbChnZXRYKFwiK3Uuam9pbigpK1wiKSwgXCIrbCtcIik7XFxuICAgICAgICB9XFxuICAgICAgXCI7ZCs9MT09PXI/XCJ9IFwiOlwifX1cIix0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgXCIrbytcIiBzdGFydCA9IFwiK28rXCIoXCIrYStcIik7XFxuICAgICAgY29uc3QgXCIrbytcIiBlbmQgPSBcIitvK1wiKFwiK2krXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgb3V0cHV0TG9jID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcbiAgICAgICAgXCIrZCtcIlxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn0sJGk9ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLFwiYXZnXCI9PT1lJiZuKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIHBvc2l0aW9ucyBmb3IgYXZlcmFnZSBwb29sLlwiKTt2YXIgcj10LmZpbHRlcldpZHRoLG89dC5zdHJpZGVIZWlnaHQsYT10LnN0cmlkZVdpZHRoLGk9dC5kaWxhdGlvbkhlaWdodCxzPXQuZGlsYXRpb25XaWR0aCx1PXQuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGM9dC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxsPXQucGFkSW5mby50b3AsaD10LnBhZEluZm8ubGVmdDt0aGlzLm91dHB1dFNoYXBlPXQub3V0U2hhcGU7dmFyIGY9XCJhdmdcIj09PWUsZD1cIjAuMFwiO2lmKGZ8fChkPVwiLTEuMCAvIDFlLTIwXCIpLG4pdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiK28rXCIsIFwiK2ErXCIpO1xcbiAgICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2wrXCIsIFwiK2grXCIpO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZUZvdW5kID0gMC4wO1xcbiAgICAgICAgICBpbnQgbWluTWF4UG9zaXRpb24gPSAwO1xcbiAgICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK3UrXCI7XFxuICAgICAgICAgICAgICB3UiArPSBcIitpK1wiKSB7XFxuICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrYytcIjtcXG4gICAgICAgICAgICAgICAgd0MgKz0gXCIrcytcIikge1xcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQpO1xcblxcbiAgICAgICAgICAgICAgLy8gSWYgYSBtaW4gLyBtYXggdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBmb3VuZCwgdXNlIGl0LiBJZiBub3QsXFxuICAgICAgICAgICAgICAvLyB1c2UgdGhlIGN1cnJlbnQgdmFsdWUuXFxuICAgICAgICAgICAgICBmbG9hdCBjdXJyTWluTWF4VmFsdWUgPSBtaXgoXFxuICAgICAgICAgICAgICAgICAgdmFsdWUsIG1pbk1heFZhbHVlLCBtaW5NYXhWYWx1ZUZvdW5kKTtcXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBjdXJyTWluTWF4VmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSB2YWx1ZTtcXG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWVGb3VuZCA9IDEuMDtcXG4gICAgICAgICAgICAgICAgbWluTWF4UG9zaXRpb24gPSB3UiAqIFwiK2MrXCIgKyB3QztcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KG1pbk1heFBvc2l0aW9uKSk7XFxuICAgICAgICB9XFxuICAgICAgXCI7ZWxzZXt2YXIgcD1lK1wiKFwiK2UrXCIoXCIrZStcIihtaW5NYXhWYWx1ZVswXSwgbWluTWF4VmFsdWVbMV0pLCBtaW5NYXhWYWx1ZVsyXSksIG1pbk1heFZhbHVlWzNdKVwiO1wiYXZnXCI9PT1lJiYocD1cImF2Z1ZhbHVlIC8gY291bnRcIik7dmFyIHY9NCpNYXRoLmZsb29yKHIvNCksbT1yJTQsZz1cIlxcbiAgICAgIGlmIChcIitmK1wiKSB7XFxuICAgICAgICBhdmdWYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWluTWF4VmFsdWUgPSBtYXgodmFsdWVzLCBtaW5NYXhWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiK28rXCIsIFwiK2ErXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitsK1wiLCBcIitoK1wiKTtcXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gXCIrZCtcIjtcXG4gICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCk7XFxuXFxuICAgICAgZmxvYXQgY291bnQgPSAwLjA7XFxuXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgeFIsIGludCB4QywgaW50IGQpIHtcXG4gICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgY291bnQgKz0gMS4wO1xcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIHhSLCB4QywgZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgZCkgdG8gZ2V0IHkoeVIsIHlDLCBkKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNChcIitkK1wiKTtcXG4gICAgICAgIGZsb2F0IGF2Z1ZhbHVlID0gMC4wO1xcbiAgICAgICAgY291bnQgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrdStcIjtcXG4gICAgICAgICAgICB3UiArPSBcIitpK1wiKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIit2K1wiOyB3QyArPSA0KSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiK3MrXCI7XFxuXFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgXCIrcytcIiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMiAqIFwiK3MrXCIsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDMgKiBcIitzK1wiLCBkKVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIrZytcIlxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgXCIrditcIjtcXG4gICAgICAgICAgaWYgKFwiKygxPT09bSkrXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIrZytcIlxcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT09bSkrXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyBcIitzK1wiLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIitnK1wiXFxuICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT1tKStcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIFwiK3MrXCIsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDIgKiBcIitzK1wiLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiK2crXCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KFwiK3ArXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSxRaT1mdW5jdGlvbih0LGUsbil7aWYodGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sXCJhdmdcIj09PWUmJm4pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgcG9zaXRpb25zIGZvciBhdmVyYWdlIHBvb2wuXCIpO3ZhciByPXQuZmlsdGVyV2lkdGgsbz10LnN0cmlkZURlcHRoLGE9dC5zdHJpZGVIZWlnaHQsaT10LnN0cmlkZVdpZHRoLHM9dC5kaWxhdGlvbkRlcHRoLHU9dC5kaWxhdGlvbkhlaWdodCxjPXQuZGlsYXRpb25XaWR0aCxsPXQuZWZmZWN0aXZlRmlsdGVyRGVwdGgsaD10LmVmZmVjdGl2ZUZpbHRlckhlaWdodCxmPXQuZWZmZWN0aXZlRmlsdGVyV2lkdGgsZD10LnBhZEluZm8uZnJvbnQscD10LnBhZEluZm8udG9wLHY9dC5wYWRJbmZvLmxlZnQ7dGhpcy5vdXRwdXRTaGFwZT10Lm91dFNoYXBlO3ZhciBtPVwiYXZnXCI9PT1lLGc9XCIwLjBcIjtpZihtfHwoZz1cIi0xLjAgLyAxZS0yMFwiKSxuKXRoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIGNvbnN0IGl2ZWMzIHN0cmlkZXMgPVxcbiAgICAgICAgICAgIGl2ZWMzKFwiK28rXCIsIFwiK2ErXCIsIFwiK2krXCIpO1xcbiAgICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKFwiK2QrXCIsIFwiK3ArXCIsIFwiK3YrXCIpO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICAgIGludCBjaCA9IGNvb3Jkcy51O1xcblxcbiAgICAgICAgICBpdmVjMyB4Q29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgICAgaW50IHhEQ29ybmVyID0geENvcm5lci54O1xcbiAgICAgICAgICBpbnQgeFJDb3JuZXIgPSB4Q29ybmVyLnk7XFxuICAgICAgICAgIGludCB4Q0Nvcm5lciA9IHhDb3JuZXIuejtcXG5cXG4gICAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sID8sIGNoKSB0byBnZXQgeSh5RCwgeVIsIHlDLCBjaCkuXFxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZUZvdW5kID0gMC4wO1xcbiAgICAgICAgICBpbnQgbWluTWF4UG9zaXRpb24gPSAwO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3RCA9IDA7IHdEIDwgXCIrbCtcIjtcXG4gICAgICAgICAgICAgIHdEICs9IFwiK3MrXCIpIHtcXG4gICAgICAgICAgICBpbnQgeEQgPSB4RENvcm5lciArIHdEO1xcblxcbiAgICAgICAgICAgIGlmICh4RCA8IDAgfHwgeEQgPj0gXCIrdC5pbkRlcHRoK1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2grXCI7XFxuICAgICAgICAgICAgICAgIHdSICs9IFwiK3UrXCIpIHtcXG4gICAgICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrZitcIjtcXG4gICAgICAgICAgICAgICAgICB3QyArPSBcIitjK1wiKSB7XFxuICAgICAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XFxuXFxuICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRYKGJhdGNoLCB4RCwgeFIsIHhDLCBjaCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIElmIGEgbWluIC8gbWF4IHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZm91bmQsIHVzZSBpdC4gSWYgbm90LFxcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIGN1cnJlbnQgdmFsdWUuXFxuICAgICAgICAgICAgICAgIGZsb2F0IGN1cnJNaW5NYXhWYWx1ZSA9IG1peChcXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLCBtaW5NYXhWYWx1ZSwgbWluTWF4VmFsdWVGb3VuZCk7XFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBjdXJyTWluTWF4VmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IHZhbHVlO1xcbiAgICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlRm91bmQgPSAxLjA7XFxuICAgICAgICAgICAgICAgICAgbWluTWF4UG9zaXRpb24gPVxcbiAgICAgICAgICAgICAgICAgICAgICB3RCAqIFwiK2grXCIgKiBcIitmK1wiICtcXG4gICAgICAgICAgICAgICAgICAgICAgd1IgKiBcIitmK1wiICsgd0M7O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChtaW5NYXhQb3NpdGlvbikpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO2Vsc2V7dmFyIHk9ZStcIihcIitlK1wiKFwiK2UrXCIobWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSlcIjtcImF2Z1wiPT09ZSYmKHk9XCJhdmdWYWx1ZSAvIGNvdW50XCIpO3ZhciB4PTQqTWF0aC5mbG9vcihyLzQpLGI9ciU0LHc9XCJcXG4gICAgICBpZiAoXCIrbStcIikge1xcbiAgICAgICAgYXZnVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG1pbk1heFZhbHVlID0gbWF4KHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMzIHN0cmlkZXMgPVxcbiAgICAgICAgaXZlYzMoXCIrbytcIiwgXCIrYStcIiwgXCIraStcIik7XFxuICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKFwiK2QrXCIsIFwiK3ArXCIsIFwiK3YrXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSBcIitnK1wiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBjb3VudCA9IDAuMDtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCB4RCwgaW50IHhSLCBpbnQgeEMsIGludCBjaCkge1xcbiAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBjb3VudCArPSAxLjA7XFxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgeEQsIHhSLCB4QywgY2gpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IGNoID0gY29vcmRzLnU7XFxuXFxuICAgICAgICBpdmVjMyB4Q29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4RENvcm5lciA9IHhDb3JuZXIueDtcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhDb3JuZXIueTtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhDb3JuZXIuejtcXG5cXG4gICAgICAgIC8vIG1heC9taW4geCg/LCA/LCA/LCBkKSB0byBnZXQgeSh5RCwgeVIsIHlDLCBjaCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIrZytcIik7XFxuICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG4gICAgICAgIGNvdW50ID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd0QgPSAwOyB3RCA8IFwiK2wrXCI7XFxuICAgICAgICAgICAgd0QgKz0gXCIrcytcIikge1xcbiAgICAgICAgICBpbnQgeEQgPSB4RENvcm5lciArIHdEO1xcblxcbiAgICAgICAgICBpZiAoeEQgPCAwIHx8IHhEID49IFwiK3QuaW5EZXB0aCtcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitoK1wiO1xcbiAgICAgICAgICAgIHdSICs9IFwiK3UrXCIpIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIit4K1wiOyB3QyArPSA0KSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIrYytcIjtcXG5cXG4gICAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKSxcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyBcIitjK1wiLCBjaCksXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgMiAqIFwiK2MrXCIsIGNoKSxcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyAzICogXCIrYytcIiwgY2gpXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgXCIrdytcIlxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIFwiK3grXCI7XFxuICAgICAgICAgICAgaWYgKFwiKygxPT09YikrXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKSxcXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgIFwiK3crXCJcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT09YikrXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKSxcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyBcIitjK1wiLCBjaCksXFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBcIit3K1wiXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PWIpK1wiKSB7XFxuICAgICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDLCBjaCksXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgXCIrYytcIiwgY2gpLFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QyArIDIgKiBcIitjK1wiLCBjaCksXFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBcIit3K1wiXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChcIit5K1wiKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwifX0sSmk9ZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXTt2YXIgbj10LndpbmRvd1NpemUscj10LmJhdGNoU2l6ZSxvPXQuaW5TaXplLGE9TWF0aC5jZWlsKG8vbik7dGhpcy5vdXRwdXRTaGFwZT1bcixhXTt2YXIgaT1cIjAuMFwiLHM9XCJcIjtcInByb2RcIj09PWU/aT1cIjEuMFwiOlwibWluXCI9PT1lPyhpPVwiMS4wIC8gMWUtMjBcIixzPVwibWluXCIpOlwibWF4XCI9PT1lJiYoaT1cIi0xLjAgLyAxZS0yMFwiLHM9XCJtYXhcIik7dmFyIHU9ZStcIihcIitlK1wiKFwiK2UrXCIobWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSlcIjtcInN1bVwiPT09ZT91PVwic3VtVmFsdWVcIjpcInByb2RcIj09PWU/dT1cInByb2RWYWx1ZVwiOlwiYWxsXCI9PT1lP3U9XCJhbGxWYWx1ZVwiOlwiYW55XCI9PT1lJiYodT1cImFueVZhbHVlXCIpO3ZhciBjPTQqTWF0aC5mbG9vcihuLzQpLGw9biU0LGg9XCJcXG4gICAgICBpZiAoXCIrKFwic3VtXCI9PT1lKStcIikge1xcbiAgICAgICAgc3VtVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XFxuICAgICAgfSBlbHNlIGlmIChcIisoXCJwcm9kXCI9PT1lKStcIikge1xcbiAgICAgICAgdmVjMiB0bXAgPSB2ZWMyKHZhbHVlc1swXSwgdmFsdWVzWzFdKSAqIHZlYzIodmFsdWVzWzJdLCB2YWx1ZXNbM10pO1xcbiAgICAgICAgcHJvZFZhbHVlICo9IHRtcFswXSAqIHRtcFsxXTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWluTWF4VmFsdWUgPSBcIitzK1wiKHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCIsZj1cInZlYzRcIjtcImFsbFwiPT09ZT8oaT1cIjEuMFwiLGg9XCJcXG4gICAgICAgIGJvb2wgcmVkdWNlZEFsbFZhbHVlID0gYWxsKHZhbHVlcyk7XFxuICAgICAgICBmbG9hdCBmbG9hdGVkUmVkdWNlZEFsbFZhbHVlID0gZmxvYXQocmVkdWNlZEFsbFZhbHVlKTtcXG4gICAgICAgIGFsbFZhbHVlID0gZmxvYXQoYWxsVmFsdWUgPj0gMS4wICYmIGZsb2F0ZWRSZWR1Y2VkQWxsVmFsdWUgPj0gMS4wKTtcXG4gICAgICBcIixmPVwiYnZlYzRcIik6XCJhbnlcIj09PWUmJihpPVwiMC4wXCIsaD1cIlxcbiAgICAgICAgYm9vbCByZWR1Y2VkQW55VmFsdWUgPSBhbnkodmFsdWVzKTtcXG4gICAgICAgIGZsb2F0IGZsb2F0ZWRSZWR1Y2VkQW55VmFsdWUgPSBmbG9hdChyZWR1Y2VkQW55VmFsdWUpO1xcbiAgICAgICAgYW55VmFsdWUgPSBmbG9hdChhbnlWYWx1ZSA+PSAxLjAgfHwgZmxvYXRlZFJlZHVjZWRBbnlWYWx1ZSA+PSAxLjApO1xcbiAgICAgIFwiLGY9XCJidmVjNFwiKTt2YXIgZD1cIlwiO28lbj4wJiYoZD1cIlxcbiAgICAgICAgaWYgKGluSWR4IDwgMCB8fCBpbklkeCA+PSBcIitvK1wiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIFwiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiK2krXCI7XFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IGluSWR4KSB7XFxuICAgICAgICBcIitkK1wiXFxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgaW5JZHgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgaW5PZmZzZXQgPSBvdXRJZHggKiBcIituK1wiO1xcblxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIraStcIik7XFxuICAgICAgICBmbG9hdCBwcm9kVmFsdWUgPSAxLjA7XFxuICAgICAgICBmbG9hdCBzdW1WYWx1ZSA9IDAuMDtcXG4gICAgICAgIGZsb2F0IGFsbFZhbHVlID0gMS4wO1xcbiAgICAgICAgZmxvYXQgYW55VmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK2MrXCI7IGkgKz0gNCkge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIGk7XFxuICAgICAgICAgIFwiK2YrXCIgdmFsdWVzID0gXCIrZitcIihcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2grXCJcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgXCIrYytcIjtcXG4gICAgICAgIGlmIChcIisoMT09PWwpK1wiKSB7XFxuICAgICAgICAgIFwiK2YrXCIgdmFsdWVzID0gXCIrZitcIihcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2grXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PT1sKStcIikge1xcbiAgICAgICAgICBcIitmK1wiIHZhbHVlcyA9IFwiK2YrXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIraCtcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PWwpK1wiKSB7XFxuICAgICAgICAgIFwiK2YrXCIgdmFsdWVzID0gXCIrZitcIihcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIraCtcIlxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KFwiK3UrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFppPWZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT10O2Zvcih2YXIgbj1cIlwiLHI9MDtyPDQ7cisrKXt2YXIgbz1cInRoaXNSQyA9IHJjO1wiO3IlMj09MSYmKG8rPVwidGhpc1JDLnogKz0gMTtcIikscj4xJiYobys9XCJ0aGlzUkMueSArPSAxO1wiKSxuKz1cIlxcbiAgICAgICAgXCIrbytcIlxcbiAgICAgICAgXCIrKHI+MD9cImlmKHRoaXNSQy55IDwgcm93cyAmJiB0aGlzUkMueiA8IGNvbHMpe1wiOlwiXCIpK1wiXFxuICAgICAgICAgIGludCBmbGF0SW5kZXggPSBnZXRGbGF0SW5kZXgodGhpc1JDKTtcXG5cXG4gICAgICAgICAgaXZlYzMgaW5wdXRSQyA9IGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGZsYXRJbmRleCk7XFxuICAgICAgICAgIHZlYzIgaW5wdXRSQ0lubmVyRGltcyA9IHZlYzIoZmxvYXQoaW5wdXRSQy55KSxmbG9hdChpbnB1dFJDLnopKTtcXG5cXG4gICAgICAgICAgcmVzdWx0W1wiK3IrXCJdID1cXG4gICAgICAgICAgICBnZXRDaGFubmVsKGdldEEoaW5wdXRSQy54LCBpbnB1dFJDLnksIGlucHV0UkMueiksIGlucHV0UkNJbm5lckRpbXMpO1xcbiAgICAgICAgXCIrKHI+MD9cIn1cIjpcIlwiKStcIlxcbiAgICAgIFwifXRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcXG4gICAgaXZlYzMgaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoaW50IGluZGV4KSB7XFxuICAgICAgXCIrY2EoW1wiclwiLFwiY1wiLFwiZFwiXSxlKStcIlxcbiAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgfVxcbiAgXFxuICAgICAgXCIrbGEodCkrXCJcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG5cXG4gICAgICAgIGl2ZWMzIHRoaXNSQztcXG4gICAgICAgIGludCByb3dzID0gXCIrdFsxXStcIjtcXG4gICAgICAgIGludCBjb2xzID0gXCIrdFsyXStcIjtcXG5cXG4gICAgICAgIFwiK24rXCJcXG5cXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9O3ZhciB0cz1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1lLnNoYXBlO3ZhciByPWUuc2hhcGUsbz1yWzFdLGE9clsyXSxpPXQuc2hhcGUscz1pWzFdLHU9aVsyXSxjPVtuJiZzPjE/by0xOm8sbiYmdT4xP2EtMTphXSxsPVtuJiZzPjE/cy0xOnMsbiYmdT4xP3UtMTp1XSxoPWNbMF0vbFswXSxmPWNbMV0vbFsxXSxkPTEvaCxwPTEvZix2PTIqTWF0aC5jZWlsKGQpKzIsbT0yKk1hdGguY2VpbChwKSsyO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcblxcbiAgICAgICAgZmxvYXQgYWNjdW11bGF0b3IgPSAwLjA7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBoZWlnaHRTY2FsZSA9IGZsb2F0KFwiK2grXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgd2lkdGhTY2FsZSA9IGZsb2F0KFwiK2YrXCIpO1xcblxcbiAgICAgICAgY29uc3QgZmxvYXQgaW52SGVpZ2h0U2NhbGUgPSBmbG9hdChcIitkK1wiKTtcXG4gICAgICAgIGNvbnN0IGZsb2F0IGludldpZHRoU2NhbGUgPSBmbG9hdChcIitwK1wiKTtcXG5cXG4gICAgICAgIGNvbnN0IGludCB3aW5IZWlnaHQgPSBpbnQoXCIrditcIik7XFxuICAgICAgICBjb25zdCBpbnQgd2luV2lkdGggPSBpbnQoXCIrbStcIik7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIGJvdW5kcyBmb3Igd2hlcmUgaW4gZHkgd2Ugd2lsbCBsb29rXFxuICAgICAgICBmbG9hdCBzdGFydFJMZXJwID0gZmxvb3IoZmxvYXQocikgKiBpbnZIZWlnaHRTY2FsZSk7XFxuICAgICAgICBpbnQgc3RhcnREeVIgPSBpbnQoc3RhcnRSTGVycCAtIGZsb2F0KHdpbkhlaWdodCAvIDIpKTtcXG5cXG4gICAgICAgIGZsb2F0IHN0YXJ0Q0xlcnAgPSBmbG9vcihmbG9hdChjKSAqIGludldpZHRoU2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlDID0gaW50KHN0YXJ0Q0xlcnAgLSBmbG9hdCh3aW5XaWR0aCAvIDIpKTtcXG5cXG4gICAgICAgIC8vIExvb3Agb3ZlciBkeVxcbiAgICAgICAgZm9yIChpbnQgZHlST2Zmc2V0ID0gMDsgZHlST2Zmc2V0IDwgd2luSGVpZ2h0OyBkeVJPZmZzZXQrKykge1xcbiAgICAgICAgICBpbnQgZHlSID0gZHlST2Zmc2V0ICsgc3RhcnREeVI7XFxuXFxuICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICBpZiAoZHlSIDwgMCB8fCBkeVIgPj0gXCIrcytcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IGR5Q09mZnNldCA9IDA7IGR5Q09mZnNldCA8IHdpbldpZHRoOyBkeUNPZmZzZXQrKykge1xcbiAgICAgICAgICAgIGludCBkeUMgPSBkeUNPZmZzZXQgKyBzdGFydER5QztcXG5cXG4gICAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgICBpZiAoZHlDIDwgMCB8fCBkeUMgPj0gXCIrdStcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZsb2F0IGR4UiA9IGZsb2F0KGR5UikgKiBoZWlnaHRTY2FsZTtcXG4gICAgICAgICAgICBpbnQgdG9wRHhSSW5kZXggPSBpbnQoZmxvb3IoZHhSKSk7XFxuICAgICAgICAgICAgaW50IGJvdHRvbUR4UkluZGV4ID0gaW50KG1pbihjZWlsKGR4UiksIFwiKyhvLTEpK1wiLjApKTtcXG4gICAgICAgICAgICBmbG9hdCBkeFJMZXJwID0gZHhSIC0gZmxvYXQodG9wRHhSSW5kZXgpO1xcbiAgICAgICAgICAgIGZsb2F0IGludmVyc2VEeFJMZXJwID0gMS4wIC0gZHhSTGVycDtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeEMgPSBmbG9hdChkeUMpICogd2lkdGhTY2FsZTtcXG4gICAgICAgICAgICBpbnQgbGVmdER4Q0luZGV4ID0gaW50KGZsb29yKGR4QykpO1xcbiAgICAgICAgICAgIGludCByaWdodER4Q0luZGV4ID0gaW50KG1pbihjZWlsKGR4QyksIFwiKyhhLTEpK1wiLjApKTtcXG4gICAgICAgICAgICBmbG9hdCBkeENMZXJwID0gZHhDIC0gZmxvYXQobGVmdER4Q0luZGV4KTtcXG4gICAgICAgICAgICBmbG9hdCBpbnZlcnNlRHhDTGVycCA9IDEuMCAtIGR4Q0xlcnA7XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gdG9wRHhSSW5kZXggJiYgYyA9PSBsZWZ0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIHRvcExlZnRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9XFxuICAgICAgICAgICAgICAgIGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGludmVyc2VEeFJMZXJwICogaW52ZXJzZUR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChyID09IHRvcER4UkluZGV4ICYmIGMgPT0gcmlnaHREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gdG9wUmlnaHRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGludmVyc2VEeFJMZXJwICogZHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gYm90dG9tRHhSSW5kZXggJiYgYyA9PSBsZWZ0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIGJvdHRvbUxlZnRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGR4UkxlcnAgKiBpbnZlcnNlRHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gYm90dG9tRHhSSW5kZXggJiYgYyA9PSByaWdodER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyBib3R0b21SaWdodFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogZHhSTGVycCAqIGR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICAvLyBFbmQgbG9vcCBvdmVyIGR5XFxuXFxuICAgICAgICBzZXRPdXRwdXQoYWNjdW11bGF0b3IpO1xcbiAgICAgIH1cXG4gICAgXCJ9LGVzPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIG89dFswXSxhPXRbMV0saT10WzJdLHM9dFszXTt0aGlzLm91dHB1dFNoYXBlPVtvLGUsbixzXTt2YXIgdT1bciYmZT4xP2EtMTphLHImJm4+MT9pLTE6aV0sYz1bciYmZT4xP2UtMTplLHImJm4+MT9uLTE6bl07dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IHZlYzIgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzIoXFxuICAgICAgICAgIFwiK3VbMF0vY1swXStcIixcXG4gICAgICAgICAgXCIrdVsxXS9jWzFdK1wiKTtcXG4gICAgICBjb25zdCB2ZWMyIGlucHV0U2hhcGVSQyA9IHZlYzIoXCIrYStcIi4wLCBcIitpK1wiLjApO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGl2ZWMyIHlSQyA9IGNvb3Jkcy55ejtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzIoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkM7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgIGl2ZWMyIHNvdXJjZUZsb29yUkMgPSBpdmVjMihzb3VyY2VGcmFjSW5kZXhSQyk7XFxuICAgICAgICBpdmVjMiBzb3VyY2VDZWlsUkMgPSBpdmVjMihcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcExlZnQgPSBnZXRBKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbUxlZnQgPSBnZXRBKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgdG9wUmlnaHQgPSBnZXRBKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgYm90dG9tUmlnaHQgPSBnZXRBKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XFxuXFxuICAgICAgICB2ZWMyIGZyYWNSQyA9IHNvdXJjZUZyYWNJbmRleFJDIC0gdmVjMihzb3VyY2VGbG9vclJDKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcCA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY1JDLnk7XFxuICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogZnJhY1JDLng7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9LG5zPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIG89dFswXSxhPXRbMV0saT10WzJdLHM9dFszXTt0aGlzLm91dHB1dFNoYXBlPVtvLGUsbixzXTt2YXIgdT1bciYmZT4xP2EtMTphLHImJm4+MT9pLTE6aV0sYz1bciYmZT4xP2UtMTplLHImJm4+MT9uLTE6bl07dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IHZlYzMgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzMoXFxuICAgICAgICAgIFwiK3VbMF0vY1swXStcIixcXG4gICAgICAgICAgXCIrdVsxXS9jWzFdK1wiLFxcbiAgICAgICAgICBcIit1WzFdL2NbMV0rXCIpO1xcbiAgICAgIGNvbnN0IHZlYzMgaW5wdXRTaGFwZVJDID0gdmVjMyhcIithK1wiLjAsIFwiK2krXCIuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIraStcIi4wKTtcXG5cXG4gICAgICBmbG9hdCBnZXRBVmFsdWUoaW50IGIsIGludCByLCBpbnQgYywgaW50IGQpIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldEEoYiwgciwgYywgZCksIHZlYzIoYywgZCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICAvLyBDYWxjdWxhdGUgdmFsdWVzIGZvciBuZXh0IGNvbHVtbiBpbiB5UkMuei5cXG4gICAgICAgIGl2ZWMzIHlSQyA9IGNvb3Jkcy55enogKyBpdmVjMygwLCAwLCAxKTtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMyBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzMoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkM7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgIGl2ZWMzIHNvdXJjZUZsb29yUkMgPSBpdmVjMyhzb3VyY2VGcmFjSW5kZXhSQyk7XFxuICAgICAgICBpdmVjMyBzb3VyY2VDZWlsUkMgPSBpdmVjMyhcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpKTtcXG5cXG4gICAgICAgIC8vIFNob3VsZCB3ZSBjYWxjdWxhdGUgbmV4dCBjb2x1bW4gYW5kIHJvdyBlbGVtZW50cyBpbiAyeDIgcGFja2VkIGNlbGwuXFxuICAgICAgICBib29sIGhhc05leHRDb2wgPSBkIDwgXCIrKHMtMSkrXCI7XFxuICAgICAgICBib29sIGhhc05leHRSb3cgPSBjb29yZHMueiA8IFwiKyhuLTEpK1wiO1xcblxcbiAgICAgICAgLy8gSW4gcGFyYWxsZWwsIGNvbnN0cnVjdCBmb3VyIGNvcm5lcnMgZm9yIGFsbCBmb3VyIGNvbXBvbmVudHMgaW5cXG4gICAgICAgIC8vIHBhY2tlZCAyeDIgY2VsbC5cXG4gICAgICAgIHZlYzQgdG9wTGVmdCA9IHZlYzQoXFxuICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueSwgZCksXFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnksIGQgKyAxKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy56LCBkKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy56LCBkICsgMSkgOiAwLjApO1xcblxcbiAgICAgICAgdmVjNCBib3R0b21MZWZ0ID0gdmVjNChcXG4gICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpLFxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQgKyAxKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnosIGQpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cXG4gICAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueiwgZCArIDEpIDogMC4wKTtcXG5cXG4gICAgICAgIHZlYzQgdG9wUmlnaHQgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueSwgZCksXFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueSwgZCArIDEpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueiwgZClcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xcbiAgICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy56LCBkICsgMSkgOiAwLjApO1xcblxcbiAgICAgICAgdmVjNCBib3R0b21SaWdodCA9IHZlYzQoXFxuICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnksIGQpLFxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCArIDEpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy56LCBkKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueiwgZCArIDEpIDogMC4wKTtcXG5cXG4gICAgICAgIHZlYzMgZnJhY1JDID0gc291cmNlRnJhY0luZGV4UkMgLSB2ZWMzKHNvdXJjZUZsb29yUkMpO1xcblxcbiAgICAgICAgdmVjNCB0b3AgPSBtaXgodG9wTGVmdCwgdG9wUmlnaHQsIGZyYWNSQy55eXp6KTtcXG4gICAgICAgIHZlYzQgYm90dG9tID0gbWl4KGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCBmcmFjUkMueXl6eik7XFxuICAgICAgICB2ZWM0IG5ld1ZhbHVlID0gbWl4KHRvcCwgYm90dG9tLCBmcmFjUkMueCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9LHJzPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPWUuc2hhcGU7dmFyIHI9ZS5zaGFwZSxvPXJbMV0sYT1yWzJdLGk9dC5zaGFwZSxzPWlbMV0sdT1pWzJdLGM9W24mJnM+MT9vLTE6byxuJiZ1PjE/YS0xOmFdLGw9W24mJnM+MT9zLTE6cyxuJiZ1PjE/dS0xOnVdLGg9Y1swXS9sWzBdLGY9Y1sxXS9sWzFdLGQ9MS9oLHA9MS9mLHY9MipNYXRoLmNlaWwoZCkrMixtPTIqTWF0aC5jZWlsKHApKzI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuXFxuICAgICAgICBmbG9hdCBhY2N1bXVsYXRvciA9IDAuMDtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IGhlaWdodFNjYWxlID0gZmxvYXQoXCIraCtcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCB3aWR0aFNjYWxlID0gZmxvYXQoXCIrZitcIik7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZIZWlnaHRTY2FsZSA9IGZsb2F0KFwiK2QrXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgaW52V2lkdGhTY2FsZSA9IGZsb2F0KFwiK3ArXCIpO1xcblxcbiAgICAgICAgY29uc3QgaW50IHdpbkhlaWdodCA9IGludChcIit2K1wiKTtcXG4gICAgICAgIGNvbnN0IGludCB3aW5XaWR0aCA9IGludChcIittK1wiKTtcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgYm91bmRzIGZvciB3aGVyZSBpbiBkeSB3ZSB3aWxsIGxvb2tcXG4gICAgICAgIGZsb2F0IHN0YXJ0UkxlcnAgPSBmbG9vcihmbG9hdChyKSAqIGludkhlaWdodFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5UiA9IGludChmbG9vcihzdGFydFJMZXJwIC0gZmxvYXQod2luSGVpZ2h0IC8gMikpKTtcXG5cXG4gICAgICAgIGZsb2F0IHN0YXJ0Q0xlcnAgPSBmbG9vcihmbG9hdChjKSAqIGludldpZHRoU2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlDID0gaW50KGZsb29yKHN0YXJ0Q0xlcnAgLSBmbG9hdCh3aW5XaWR0aCAvIDIpKSk7XFxuXFxuICAgICAgICAvLyBMb29wIG92ZXIgZHlcXG4gICAgICAgIGZvciAoaW50IGR5Uk9mZnNldCA9IDA7IGR5Uk9mZnNldCA8IHdpbkhlaWdodDsgZHlST2Zmc2V0KyspIHtcXG4gICAgICAgICAgaW50IGR5UiA9IGR5Uk9mZnNldCArIHN0YXJ0RHlSO1xcblxcbiAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgaWYgKGR5UiA8IDAgfHwgZHlSID49IFwiK3MrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCBkeUNPZmZzZXQgPSAwOyBkeUNPZmZzZXQgPCB3aW5XaWR0aDsgZHlDT2Zmc2V0KyspIHtcXG4gICAgICAgICAgICBpbnQgZHlDID0gZHlDT2Zmc2V0ICsgc3RhcnREeUM7XFxuXFxuICAgICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49IFwiK3UrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCBzb3VyY2VGcmFjUm93ID1cXG4gICAgICAgICAgICAgIGZsb2F0KFwiK2NbMF0rXCIpICpcXG4gICAgICAgICAgICAgICAgKGZsb2F0KGR5UikgLyBmbG9hdChcIitsWzBdK1wiKSk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgc291cmNlRnJhY0NvbCA9XFxuICAgICAgICAgICAgICAgIGZsb2F0KFwiK2NbMV0rXCIpICpcXG4gICAgICAgICAgICAgICAgICAoZmxvYXQoZHlDKSAvIGZsb2F0KFwiK2xbMV0rXCIpKTtcXG5cXG4gICAgICAgICAgICBpbnQgc291cmNlTmVhcmVzdFJvdyA9IGludChtaW4oXFxuICAgICAgICAgICAgICAgIGZsb2F0KGludChcIitvK1wiKSAtIDEpLFxcbiAgICAgICAgICAgICAgICBcIituK1wiID8gZmxvYXQocm91bmQoc291cmNlRnJhY1JvdykpIDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQoZmxvb3Ioc291cmNlRnJhY1JvdykpKSk7XFxuXFxuICAgICAgICAgICAgaW50IHNvdXJjZU5lYXJlc3RDb2wgPSBpbnQobWluKFxcbiAgICAgICAgICAgICAgICBmbG9hdChpbnQoXCIrYStcIikgLSAxKSxcXG4gICAgICAgICAgICAgICAgXCIrbitcIiA/IGZsb2F0KHJvdW5kKHNvdXJjZUZyYWNDb2wpKSA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGZsb29yKHNvdXJjZUZyYWNDb2wpKSkpO1xcblxcbiAgICAgICAgICAgIGlmIChyID09IHNvdXJjZU5lYXJlc3RSb3cgJiYgYyA9PSBzb3VyY2VOZWFyZXN0Q29sKSB7XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICAvLyBFbmQgbG9vcCBvdmVyIGR5XFxuXFxuICAgICAgICBzZXRPdXRwdXQoYWNjdW11bGF0b3IpO1xcbiAgICAgIH1cXG4gICAgXCJ9LG9zPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIG89dFswXSxhPXRbMV0saT10WzJdLHM9dFszXTt0aGlzLm91dHB1dFNoYXBlPVtvLGUsbixzXTt2YXIgdT1bciYmZT4xP2EtMTphLHImJm4+MT9pLTE6aV0sYz1bciYmZT4xP2UtMTplLHImJm4+MT9uLTE6bl0sbD1yP1wiMC41XCI6XCIwLjBcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgdmVjMiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMihcXG4gICAgICAgICAgXCIrdVswXS9jWzBdK1wiLFxcbiAgICAgICAgICBcIit1WzFdL2NbMV0rXCIpO1xcbiAgICAgIGNvbnN0IHZlYzIgaW5wdXRTaGFwZVJDID0gdmVjMihcIithK1wiLjAsIFwiK2krXCIuMCk7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgaXZlYzIgeVJDID0gY29vcmRzLnl6O1xcblxcbiAgICAgICAgLy8gRnJhY3Rpb25hbCBzb3VyY2UgaW5kZXguXFxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleFJDID0gdmVjMih5UkMpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQztcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGNvb3JkaW5hdG9ycyBvZiBuZWFyZXN0IG5laWdoYm9yIHBvaW50LlxcbiAgICAgICAgaXZlYzIgc291cmNlTmVhcmVzdFJDID0gaXZlYzIoXFxuICAgICAgICAgIG1pbihpbnB1dFNoYXBlUkMgLSAxLjAsIGZsb29yKHNvdXJjZUZyYWNJbmRleFJDICsgXCIrbCtcIikpKTtcXG5cXG4gICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gZ2V0QShiLCBzb3VyY2VOZWFyZXN0UkMueCwgc291cmNlTmVhcmVzdFJDLnksIGQpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwifSxhcz1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdO3ZhciBuPXQubGVuZ3RoO2lmKG4+NCl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBiYWNrZW5kOiBSZXZlcnNlIG9mIHJhbmstXCIrbitcIiB0ZW5zb3IgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYodGhpcy5vdXRwdXRTaGFwZT10LDEhPT1uKXt2YXIgcj10Lm1hcCgoZnVuY3Rpb24obixyKXtyZXR1cm4gZnVuY3Rpb24obil7cmV0dXJuLTEhPT1lLmluZGV4T2YobikmJjEhPT10W25dP3Rbbl0rXCIgLSBjb29yZHNbXCIrbitcIl0gLSAxXCI6XCJjb29yZHNbXCIrbitcIl1cIn0ocil9KSkuam9pbihcIixcIiksbz13YShuKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRYKFwiK3IrXCIpKTtcXG4gICAgICB9XFxuICAgIFwifWVsc2UgdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpbnQgY29vcmQgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgoXCIrdFswXStcIiAtIGNvb3JkIC0gMSkpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifSxpcz1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwO3ZhciBuPXQubGVuZ3RoO2lmKG4+NCl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBiYWNrZW5kOiBSZXZlcnNlIG9mIHJhbmstXCIrbitcIiB0ZW5zb3IgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7dGhpcy5vdXRwdXRTaGFwZT10O3ZhciByPXNhKFwicmNcIixuKSxvPXJbbi0xXStcIiArIDEgPCBcIit0aGlzLm91dHB1dFNoYXBlW24tMV0sYT1yW24tMl0rXCIgKyAxIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVtuLTJdLGk9d2Eobik7ZnVuY3Rpb24gcyhuKXt2YXIgcj10Lm1hcCgoZnVuY3Rpb24ocixvKXtyZXR1cm4gZnVuY3Rpb24obixyKXtyZXR1cm4tMSE9PWUuaW5kZXhPZihuKSYmMSE9PXRbbl0/dFtuXStcIiAtIFwiK3Jbbl0rXCIgLSAxXCI6XCJcIityW25dfShvLG4pfSkpO3JldHVyblwiZ2V0Q2hhbm5lbChnZXRYKFwiK3Iuam9pbihcIixcIikrXCIpLCB2ZWMyKFwiK3Iuc2xpY2UoLTIpLmpvaW4oXCIsXCIpK1wiKSlcIn10aGlzLnVzZXJDb2RlPTE9PT1uP1wiXFxuICAgICAgICB2b2lkIG1haW4oKXtcXG4gICAgICAgICAgaW50IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgICAgIHJlc3VsdC5yID0gZ2V0Q2hhbm5lbChnZXRYKFwiK3RbMF0rXCIgLSByYyAtIDEpLFxcbiAgICAgICAgICAgIFwiK3RbMF0rXCIgLSByYyAtIDEpO1xcbiAgICAgICAgICBpZihcIitvK1wiKXtcXG4gICAgICAgICAgICAgIHJlc3VsdC5nID0gZ2V0Q2hhbm5lbChnZXRYKFwiK3RbMF0rXCIgLSAocmMgICsgMSkgLSAxKSxcXG4gICAgICAgICAgICAgICAgXCIrdFswXStcIiAtIChyYyAgKyAxKSAtIDEpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiOlwiXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIFwiK2krXCIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgcmVzdWx0LnIgPSBcIitmdW5jdGlvbih0KXtyZXR1cm4gcyh0KX0oci5zbGljZSgpKStcIjtcXG4gICAgICAgICAgaWYoXCIrbytcIil7XFxuICAgICAgICAgICAgcmVzdWx0LmcgPSBcIitmdW5jdGlvbih0KXtyZXR1cm4gdFtuLTFdPVwiKFwiK3Rbbi0xXStcIiArIDEpXCIscyh0KX0oci5zbGljZSgpKStcIjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZihcIithK1wiKSB7XFxuICAgICAgICAgICAgcmVzdWx0LmIgPSBcIitmdW5jdGlvbih0KXtyZXR1cm4gdFtuLTJdPVwiKFwiK3Rbbi0yXStcIiArIDEpXCIscyh0KX0oci5zbGljZSgpKStcIjtcXG4gICAgICAgICAgICBpZihcIitvK1wiKSB7XFxuICAgICAgICAgICAgICByZXN1bHQuYSA9IFwiK2Z1bmN0aW9uKHQpe3JldHVybiB0W24tMV09XCIoXCIrdFtuLTFdK1wiICsgMSlcIix0W24tMl09XCIoXCIrdFtuLTJdK1wiICsgMSlcIixzKHQpfShyLnNsaWNlKCkpK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICAgIH1cXG4gICAgXCJ9LHNzPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWkmJihpPSEwKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1widXBkYXRlc1wiLFwiaW5kaWNlc1wiLFwiZGVmYXVsdFZhbHVlXCJdLHRoaXMub3V0cHV0U2hhcGU9YTt2YXIgcz13YShvLmxlbmd0aCksdT13YShhLmxlbmd0aCksYz1cIlwiOzE9PT1uP2M9XCJpXCI6Mj09PW4mJihjPVwiaSwgalwiKTt2YXIgbD1cImdldEluZGljZXMoXCIrYytcIilcIixoPVwiXCI7MT09PXI/aD1cImlcIjoyPT09ciYmKGg9XCJpLCBjb29yZHNbMV1cIik7dmFyIGY9XCJnZXRVcGRhdGVzKFwiK2grXCIpXCIsZD1lPjE/XCJzdHJpZGVzW2pdXCI6XCJzdHJpZGVzXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgXCIrcytcIiBzdHJpZGVzID0gXCIrcytcIihcIitvK1wiKTtcXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIrdStcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgZmxvYXQgc3VtID0gMC4wO1xcbiAgICAgICAgICBib29sIGZvdW5kID0gZmFsc2U7XFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrdCtcIjsgaSsrKSB7XFxuICAgICAgICAgICAgaW50IGZsYXR0ZW5lZEluZGV4ID0gMDtcXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK2UrXCI7IGorKykge1xcbiAgICAgICAgICAgICAgaW50IGluZGV4ID0gcm91bmQoXCIrbCtcIik7XFxuICAgICAgICAgICAgICBmbGF0dGVuZWRJbmRleCArPSBpbmRleCAqIFwiK2QrXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChmbGF0dGVuZWRJbmRleCA9PSBjb29yZHNbMF0pIHtcXG4gICAgICAgICAgICAgIHN1bSArPSBcIitmK1wiO1xcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQobWl4KGdldERlZmF1bHRWYWx1ZSgpLCBzdW0sIGZsb2F0KGZvdW5kKSkpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifSx1cz1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJzZWdtZW50SWRzXCJdO3ZhciBuPXQud2luZG93U2l6ZSxyPXQuYmF0Y2hTaXplLG89dC5pblNpemUsYT10Lm51bVNlZ21lbnRzLGk9YSpNYXRoLmNlaWwoby9uKTt0aGlzLm91dHB1dFNoYXBlPVtyLGldO3ZhciBzPTQqTWF0aC5mbG9vcihuLzQpLHU9biU0LGM9XCJcXG4gICAgICAgIHN1bVZhbHVlICs9IGRvdCh2YWx1ZXMsIHNlZ0ZpbHRlcik7XFxuICAgIFwiLGw9XCJcIjtvJW4+MCYmKGw9XCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIrbytcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBcIik7dmFyIGg9XCJcIjtvJW4+MCYmKGg9XCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIrbytcIikge1xcbiAgICAgICAgICByZXR1cm4gLTEuMDtcXG4gICAgICAgIH1cXG4gICAgICBcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgaW5JZHgpIHtcXG4gICAgICAgIFwiK2wrXCJcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCBpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IGdldFNlZ21lbnRJZEF0SW5kZXgoaW50IGluSWR4KSB7XFxuICAgICAgICBcIitoK1wiXFxuICAgICAgICByZXR1cm4gZ2V0U2VnbWVudElkcyhpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBpbk9mZnNldCA9IGludChmbG9vcihmbG9hdChvdXRJZHgpIC8gZmxvYXQoXFxuICAgICAgICAgIFwiK2ErXCIpKSAqIGZsb2F0KFwiK24rXCIpKTtcXG4gICAgICAgIGludCBjdXJyZW50U2VnID0gaW50KG1vZChmbG9hdChvdXRJZHgpLCBmbG9hdChcIithK1wiKSkpO1xcblxcbiAgICAgICAgZmxvYXQgc3VtVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3MrXCI7IGkgKz0gNCkge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIGk7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDEpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAyKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMykpID09IGN1cnJlbnRTZWcgPyAxIDogMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitjK1wiXFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIFwiK3MrXCI7XFxuICAgICAgICBpZiAoXCIrKDE9PT11KStcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBpbnQgaW5JZHhTZWcgPSBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpO1xcblxcbiAgICAgICAgICB2ZWM0IHNlZ0ZpbHRlciA9IHZlYzQoXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgMCxcXG4gICAgICAgICAgICAwLFxcbiAgICAgICAgICAgIDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIrYytcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PXUpK1wiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICB2ZWM0IHNlZ0ZpbHRlciA9IHZlYzQoXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAxKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgICAgMCxcXG4gICAgICAgICAgICAgIDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIrYytcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PXUpK1wiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgdmVjNCBzZWdGaWx0ZXIgPSB2ZWM0KFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMSkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDIpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitjK1wiXFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoc3VtVmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9LGNzPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvO2lmKHRoaXMudmFyaWFibGVOYW1lcz1bXCJjXCIsXCJhXCIsXCJiXCJdLHRoaXMub3V0cHV0U2hhcGU9ZSxuPjQpdGhyb3cgRXJyb3IoXCJXaGVyZSBmb3IgcmFuayBcIituK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2lmKDE9PT1uKW89XCJyZXNSQ1wiLHI9XCJyZXNSQ1wiO2Vsc2V7Zm9yKHZhciBhPVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIl0saT1bXSxzPVtdLHU9MDt1PGUubGVuZ3RoO3UrKylzLnB1c2goXCJcIithW3VdKSx1PHQmJmkucHVzaChcIlwiK2FbdV0pO3I9aS5qb2luKCksbz1zLmpvaW4oKX12YXIgYz13YShuKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrYytcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgY1ZhbCA9IGdldEMoXCIrcitcIik7XFxuICAgICAgICBpZiAoY1ZhbCA+PSAxLjApIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIrbytcIikpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldEIoXCIrbytcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCJ9LGxzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wic291cmNlXCJdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnJhbms9dC5sZW5ndGg7dmFyIGUsbj13YSh0aGlzLnJhbmspLHI9XCJ1bmlmb3JtIGludCBzdGFydFtcIit0aGlzLnJhbmsrXCJdO1wiLG89ZnVuY3Rpb24odCl7aWYoMT09PXQpcmV0dXJuXCJzb3VyY2VMb2NcIjtpZih0PD02KXJldHVybiBocy5zbGljZSgwLHQpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuXCJzb3VyY2VMb2MuXCIrdH0pKS5qb2luKFwiLFwiKTt0aHJvdyBFcnJvcihcIlNsaWNpbmcgZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX0odGhpcy5yYW5rKTtlPVwiXFxuICAgICAgICBcIituK1wiIHNvdXJjZUxvYztcXG4gICAgICAgIFwiK24rXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBcIit0Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5cInNvdXJjZUxvYy5cIitoc1tlXStcIiA9IHN0YXJ0W1wiK2UrXCJdICsgY29vcmRzLlwiK2hzW2VdK1wiO1wifSkpLmpvaW4oXCJcXG5cIikrXCJcXG4gICAgICBcIix0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIrcitcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK2UrXCJcXG4gICAgICAgIHNldE91dHB1dChnZXRTb3VyY2UoXCIrbytcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKHQubGVuZ3RoIT09dGhpcy5yYW5rKXRocm93IEVycm9yKFwiVGhlIHJhbmsgKFwiK3RoaXMucmFuaytcIikgb2YgdGhlIHByb2dyYW0gbXVzdCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHN0YXJ0IChcIit0Lmxlbmd0aCtcIilcIik7cmV0dXJuIGZ1bmN0aW9uKG4scil7bnVsbD09ZS5zdGFydExvYyYmKGUuc3RhcnRMb2M9bi5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KHIsXCJzdGFydFwiKSxudWxsPT1lLnN0YXJ0TG9jKXx8bi5nbC51bmlmb3JtMWl2KGUuc3RhcnRMb2MsdCl9fSx0fSgpLGhzPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl07dmFyIGZzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wic291cmNlXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnJhbms9dC5sZW5ndGg7dmFyIGU9d2EodGhpcy5yYW5rKSxuPXNhKFwiY29vcmRzXCIsdGhpcy5yYW5rKSxyPXNhKFwic291cmNlTG9jXCIsdGhpcy5yYW5rKSxvPTE9PT10aGlzLnJhbms/XCJzb3VyY2VMb2NcIjpcInZlYzIoXCIrci5zbGljZSgtMikuam9pbigpK1wiKVwiLGE9XCJnZXRDaGFubmVsKGdldFNvdXJjZShcIityLmpvaW4oKStcIiksIFwiK28rXCIpXCIsaT1cIlxcbiAgICAgIHJlc3VsdC54ID0gXCIrYStcIjtcXG4gICAgICBpZiAoKytcIituW3RoaXMucmFuay0xXStcIiA8IFwiK3RbdGhpcy5yYW5rLTFdK1wiKSB7XFxuICAgICAgICArK1wiK3JbdGhpcy5yYW5rLTFdK1wiO1xcbiAgICAgICAgcmVzdWx0LnkgPSBcIithK1wiO1xcbiAgICAgICAgLS1cIityW3RoaXMucmFuay0xXStcIjtcXG4gICAgICB9XFxuICAgIFwiLHM9MT09PXRoaXMucmFuaz9cIlwiOlwiXFxuICAgICAgLS1cIituW3RoaXMucmFuay0xXStcIjtcXG4gICAgICBpZiAoKytcIituW3RoaXMucmFuay0yXStcIiA8IFwiK3RbdGhpcy5yYW5rLTJdK1wiKSB7XFxuICAgICAgICArK1wiK3JbdGhpcy5yYW5rLTJdK1wiO1xcbiAgICAgICAgcmVzdWx0LnogPSBcIithK1wiO1xcbiAgICAgICAgaWYgKCsrXCIrblt0aGlzLnJhbmstMV0rXCIgPCBcIit0W3RoaXMucmFuay0xXStcIikge1xcbiAgICAgICAgICArK1wiK3JbdGhpcy5yYW5rLTFdK1wiO1xcbiAgICAgICAgICByZXN1bHQudyA9IFwiK2ErXCI7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIix1PXRoaXMucmFuazw9ND9cInNvdXJjZUxvYyA9IGNvb3JkcyArXFxuICAgICAgICAgICAgXCIrZStcIihcIit0Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5cInN0YXJ0W1wiK2UrXCJdXCJ9KSkuam9pbigpK1wiKTtcIjp0Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gcltlXStcIiA9IFwiK25bZV0rXCIgKyBzdGFydFtcIitlK1wiXTtcIn0pKS5qb2luKFwiXFxuXCIpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGludCBzdGFydFtcIit0aGlzLnJhbmsrXCJdO1xcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK2UrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBcIitlK1wiIHNvdXJjZUxvYztcXG4gICAgICAgIFwiK3UrXCJcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgICBcIitpK1wiXFxuICAgICAgICBcIitzK1wiXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZih0Lmxlbmd0aCE9PXRoaXMucmFuayl0aHJvdyBFcnJvcihcIlRoZSByYW5rIChcIit0aGlzLnJhbmsrXCIpIG9mIHRoZSBwcm9ncmFtIG11c3QgbWF0Y2ggdGhlIGxlbmd0aCBvZiBzdGFydCAoXCIrdC5sZW5ndGgrXCIpXCIpO3JldHVybiBmdW5jdGlvbihuLHIpe251bGw9PWUuc3RhcnRMb2MmJihlLnN0YXJ0TG9jPW4uZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhyLFwic3RhcnRcIiksbnVsbD09ZS5zdGFydExvYyl8fG4uZ2wudW5pZm9ybTFpdihlLnN0YXJ0TG9jLHQpfX0sdH0oKSxkcz1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1uO3ZhciByPW4ubGVuZ3RoLG89d2Eobi5sZW5ndGgpLGE9d2Eobi5sZW5ndGgpLGk9XCJcIjtpZigxPT09cilpPVwiY29vcmRzICogc3RyaWRlcyArIGJlZ2luXCI7ZWxzZXt2YXIgcz0wO2k9bi5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHMrKywxPT09bi5sZW5ndGg/XCJjb29yZHMgKiBzdHJpZGVzW1wiK2UrXCJdICsgYmVnaW5bXCIrZStcIl1cIjpcImNvb3Jkc1tcIisocy0xKStcIl0gKiBzdHJpZGVzW1wiK2UrXCJdICsgYmVnaW5bXCIrZStcIl1cIn0pKS5qb2luKFwiLFwiKX10aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIrbytcIiBiZWdpbiA9IFwiK28rXCIoXCIrdCtcIik7XFxuICAgICAgXCIrbytcIiBzdHJpZGVzID0gXCIrbytcIihcIitlK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIithK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldFgoXCIraStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9LHBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmdwZ3B1PXQsdGhpcy5udW1Vc2VkVGV4dHVyZXM9MCx0aGlzLm51bUZyZWVUZXh0dXJlcz0wLHRoaXMuZnJlZVRleHR1cmVzPXt9LHRoaXMubG9nRW5hYmxlZD0hMSx0aGlzLnVzZWRUZXh0dXJlcz17fX1yZXR1cm4gdC5wcm90b3R5cGUuYWNxdWlyZVRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciByLG89dnMoZSxuKSxhPW1zKHQsbyxuKTtpZihhIGluIHRoaXMuZnJlZVRleHR1cmVzfHwodGhpcy5mcmVlVGV4dHVyZXNbYV09W10pLGEgaW4gdGhpcy51c2VkVGV4dHVyZXN8fCh0aGlzLnVzZWRUZXh0dXJlc1thXT1bXSksdGhpcy5mcmVlVGV4dHVyZXNbYV0ubGVuZ3RoPjApe3RoaXMubnVtRnJlZVRleHR1cmVzLS0sdGhpcy5udW1Vc2VkVGV4dHVyZXMrKyx0aGlzLmxvZygpO3ZhciBpPXRoaXMuZnJlZVRleHR1cmVzW2FdLnNoaWZ0KCk7cmV0dXJuIHRoaXMudXNlZFRleHR1cmVzW2FdLnB1c2goaSksaX1yZXR1cm4gdGhpcy5udW1Vc2VkVGV4dHVyZXMrKyx0aGlzLmxvZygpLG89PT1HdC5QQUNLRURfMlgyX0ZMT0FUMzI/cj10aGlzLmdwZ3B1LmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUodFswXSx0WzFdKTpvPT09R3QuUEFDS0VEXzJYMl9GTE9BVDE2P3I9dGhpcy5ncGdwdS5jcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZSh0WzBdLHRbMV0pOm89PT1HdC5VTlBBQ0tFRF9GTE9BVDMyP3I9dGhpcy5ncGdwdS5jcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZSh0WzBdLHRbMV0pOm89PT1HdC5VTlBBQ0tFRF9GTE9BVDE2P3I9dGhpcy5ncGdwdS5jcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZSh0WzBdLHRbMV0pOm89PT1HdC5QQUNLRURfNFgxX1VOU0lHTkVEX0JZVEUmJihyPXRoaXMuZ3BncHUuY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmUodFswXSx0WzFdKSksdGhpcy51c2VkVGV4dHVyZXNbYV0ucHVzaChyKSxyfSx0LnByb3RvdHlwZS5yZWxlYXNlVGV4dHVyZT1mdW5jdGlvbih0LGUsbixyKXtpZihudWxsIT10aGlzLmZyZWVUZXh0dXJlcyl7dmFyIG89bXMoZSx2cyhuLHIpLHIpO28gaW4gdGhpcy5mcmVlVGV4dHVyZXN8fCh0aGlzLmZyZWVUZXh0dXJlc1tvXT1bXSksdGhpcy5mcmVlVGV4dHVyZXNbb10ucHVzaCh0KSx0aGlzLm51bUZyZWVUZXh0dXJlcysrLHRoaXMubnVtVXNlZFRleHR1cmVzLS07dmFyIGE9dGhpcy51c2VkVGV4dHVyZXNbb10saT1hLmluZGV4T2YodCk7aWYoaTwwKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWxlYXNlIGEgdGV4dHVyZSB0aGF0IHdhcyBuZXZlciBwcm92aWRlZCBieSB0aGlzIHRleHR1cmUgbWFuYWdlclwiKTthLnNwbGljZShpLDEpLHRoaXMubG9nKCl9fSx0LnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oKXtpZih0aGlzLmxvZ0VuYWJsZWQpe3ZhciB0PXRoaXMubnVtRnJlZVRleHR1cmVzK3RoaXMubnVtVXNlZFRleHR1cmVzO2NvbnNvbGUubG9nKFwiRnJlZS9Vc2VkXCIsdGhpcy5udW1GcmVlVGV4dHVyZXMrXCIgLyBcIit0aGlzLm51bVVzZWRUZXh0dXJlcyxcIihcIit0K1wiKVwiKX19LHQucHJvdG90eXBlLmdldE51bVVzZWRUZXh0dXJlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm51bVVzZWRUZXh0dXJlc30sdC5wcm90b3R5cGUuZ2V0TnVtRnJlZVRleHR1cmVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubnVtRnJlZVRleHR1cmVzfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZihudWxsIT10aGlzLmZyZWVUZXh0dXJlcyl7Zm9yKHZhciBlIGluIHRoaXMuZnJlZVRleHR1cmVzKXRoaXMuZnJlZVRleHR1cmVzW2VdLmZvckVhY2goKGZ1bmN0aW9uKGUpe3QuZ3BncHUuZGVsZXRlTWF0cml4VGV4dHVyZShlKX0pKTtmb3IodmFyIGUgaW4gdGhpcy51c2VkVGV4dHVyZXMpdGhpcy51c2VkVGV4dHVyZXNbZV0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7dC5ncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKGUpfSkpO3RoaXMuZnJlZVRleHR1cmVzPW51bGwsdGhpcy51c2VkVGV4dHVyZXM9bnVsbCx0aGlzLm51bVVzZWRUZXh0dXJlcz0wLHRoaXMubnVtRnJlZVRleHR1cmVzPTB9fSx0fSgpO2Z1bmN0aW9uIHZzKHQsZSl7aWYodD09PXp0LlVQTE9BRClyZXR1cm4gR3QuUEFDS0VEXzJYMl9GTE9BVDMyO2lmKHQ9PT16dC5SRU5ERVJ8fG51bGw9PXQpcmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBpKCkuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIik/dD9HdC5QQUNLRURfMlgyX0ZMT0FUMzI6R3QuVU5QQUNLRURfRkxPQVQzMjp0P0d0LlBBQ0tFRF8yWDJfRkxPQVQxNjpHdC5VTlBBQ0tFRF9GTE9BVDE2fShlKTtpZih0PT09enQuRE9XTkxPQUR8fHQ9PT16dC5QSVhFTFMpcmV0dXJuIEd0LlBBQ0tFRF80WDFfVU5TSUdORURfQllURTt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGxvZ2ljYWwgdGV4dHVyZSB0eXBlIFwiK3QpfWZ1bmN0aW9uIG1zKHQsZSxuKXtyZXR1cm4gdFswXStcIl9cIit0WzFdK1wiX1wiK2UrXCJfXCIrbn12YXIgZ3M9ZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTtmb3IodmFyIG49bmV3IEFycmF5KHQubGVuZ3RoKSxyPTA7cjxuLmxlbmd0aDtyKyspbltyXT10W3JdKmVbcl07dGhpcy5vdXRwdXRTaGFwZT1uLHRoaXMucmFuaz1uLmxlbmd0aDt2YXIgbz13YSh0aGlzLnJhbmspLGE9ZnVuY3Rpb24odCl7dmFyIGU9dC5sZW5ndGg7aWYoZT41KXRocm93IEVycm9yKFwiVGlsZSBmb3IgcmFuayBcIitlK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2lmKDE9PT1lKXJldHVyblwiaW1vZChyZXNSQywgXCIrdFswXStcIilcIjtmb3IodmFyIG49W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiLFwicmVzUkMudVwiXSxyPVtdLG89MDtvPHQubGVuZ3RoO28rKylyLnB1c2goXCJpbW9kKFwiK25bb10rXCIsIFwiK3Rbb10rXCIpXCIpO3JldHVybiByLmpvaW4oKX0odCk7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRBKFwiK2ErXCIpKTtcXG4gICAgICB9XFxuICAgIFwifTt2YXIgeXM9ZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTtmb3IodmFyIG49bmV3IEFycmF5KHQubGVuZ3RoKSxyPTA7cjxuLmxlbmd0aDtyKyspbltyXT10W2Vbcl1dO3RoaXMub3V0cHV0U2hhcGU9bix0aGlzLnJhbms9bi5sZW5ndGg7dmFyIG89d2EodGhpcy5yYW5rKSxhPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoO2lmKGU+Nil0aHJvdyBFcnJvcihcIlRyYW5zcG9zZSBmb3IgcmFuayBcIitlK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2Zvcih2YXIgbj1bXCJyZXNSQy54XCIsXCJyZXNSQy55XCIsXCJyZXNSQy56XCIsXCJyZXNSQy53XCIsXCJyZXNSQy51XCIsXCJyZXNSQy52XCJdLHI9bmV3IEFycmF5KGUpLG89MDtvPHQubGVuZ3RoO28rKylyW3Rbb11dPW5bb107cmV0dXJuIHIuam9pbigpfShlKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBcIitvK1wiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgc2V0T3V0cHV0KGdldEEoXCIrYStcIikpO1xcbiAgICB9XFxuICAgIFwifTt2YXIgeHM9ZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMDtmb3IodmFyIG49bmV3IEFycmF5KHQubGVuZ3RoKSxyPTA7cjxuLmxlbmd0aDtyKyspbltyXT10W2Vbcl1dO2lmKHRoaXMub3V0cHV0U2hhcGU9bix0aGlzLnJhbms9bi5sZW5ndGgsdGhpcy5yYW5rPjYpdGhyb3cgRXJyb3IoXCJQYWNrZWQgdHJhbnNwb3NlIGZvciByYW5rIFwiK3RoaXMucmFuaytcIiBpcyBub3QgeWV0IHN1cHBvcnRlZC5cIik7dmFyIG89d2EodGhpcy5yYW5rKSxhPWlhKFwicmNcIix0aGlzLnJhbmspLGk9bmV3IEFycmF5KHRoaXMucmFuayk7Zm9yKHI9MDtyPGUubGVuZ3RoO3IrKylpW2Vbcl1dPWFbcl07dmFyIHM9XCJ2ZWMyKFwiK2kuc2xpY2UoLTIpLmpvaW4oKStcIilcIix1PVwiKytcIithW3RoaXMucmFuay0xXStcIiA8IFwiK25bdGhpcy5yYW5rLTFdLGM9XCJnZXRDaGFubmVsKGdldEEoXCIraS5qb2luKCkrXCIpLCBcIitzK1wiKVwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIFwiK28rXCIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcbiAgICAgIHJlc3VsdFswXSA9IFwiK2MrXCI7XFxuICAgICAgaWYoXCIrdStcIikge1xcbiAgICAgICAgcmVzdWx0WzFdID0gXCIrYytcIjtcXG4gICAgICB9XFxuICAgICAgLS1cIithW3RoaXMucmFuay0xXStcIjtcXG4gICAgICBpZigrK1wiK2FbdGhpcy5yYW5rLTJdK1wiIDwgXCIrblt0aGlzLnJhbmstMl0rXCIpIHtcXG4gICAgICAgIHJlc3VsdFsyXSA9IFwiK2MrXCI7XFxuICAgICAgICBpZihcIit1K1wiKSB7XFxuICAgICAgICAgIHJlc3VsdFszXSA9IFwiK2MrXCI7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICB9XFxuICAgIFwifSxicz0xLjc1ODA5OTM0MDg0NzM3Njgsd3M9MS4wNTA3MDA5ODczNTU0ODA1LENzPWZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBmbG9hdCB1bmFyeU9wZXJhdGlvbihmbG9hdCB4KSB7XFxuICAgICAgICBcIitlK1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHkgPSB1bmFyeU9wZXJhdGlvbih4KTtcXG5cXG4gICAgICAgIHNldE91dHB1dCh5KTtcXG4gICAgICB9XFxuICAgIFwifSxFcz1cImlmIChpc25hbih4KSkgcmV0dXJuIHg7XCIsUnM9XCJyZXR1cm4geDtcIixJcz1cInJldHVybiBhYnMoeCk7XCIsa3M9RXMrXCJcXG4gIHJldHVybiAoeCA8IDAuMCkgPyAwLjAgOiB4O1xcblwiLFNzPUVzK1wiXFxuICByZXR1cm4gKHggPCAwLjApID8gMC4wIDogbWluKDYuMCwgeCk7XFxuXCIsQXM9XCJyZXR1cm4gKHggPj0gMC4wKSA/IHggOiAoZXhwKHgpIC0gMS4wKTtcIixEcz1cIlxcbiAgLy8gU3RhYmxlIGFuZCBBdHRyYWN0aW5nIEZpeGVkIFBvaW50ICgwLCAxKSBmb3IgTm9ybWFsaXplZCBXZWlnaHRzLlxcbiAgLy8gc2VlOiBodHRwczovL2FyeGl2Lm9yZy9hYnMvMTcwNi4wMjUxNVxcbiAgZmxvYXQgc2NhbGVBbHBoYSA9IFwiK2JzK1wiO1xcbiAgZmxvYXQgc2NhbGUgPSBcIit3cytcIjtcXG4gIHJldHVybiAoeCA+PSAwLjApID8gc2NhbGUgKiB4IDogc2NhbGVBbHBoYSAqIChleHAoeCkgLSAxLjApO1xcblwiO3ZhciBUcz1cInJldHVybiAteDtcIixOcz1cInJldHVybiBjZWlsKHgpO1wiLEZzPVwicmV0dXJuIGZsb29yKHgpO1wiLF9zPVwicmV0dXJuIGV4cCh4KTtcIixPcz1cInJldHVybiBleHAoeCkgLSAxLjA7XCIsTXM9RXMrXCJcXG4gIHJldHVybiBzaW4oeCk7XFxuXCIsQnM9RXMrXCJcXG4gIHJldHVybiBjb3MoeCk7XFxuXCIsUHM9RXMrXCJcXG4gIGlmIChhYnMoeCkgPiAxLikge1xcbiAgICByZXR1cm4gTkFOO1xcbiAgfVxcbiAgcmV0dXJuIGFzaW4oeCk7XFxuXCIsTHM9RXMrXCJcXG4gIGlmIChhYnMoeCkgPiAxLikge1xcbiAgICByZXR1cm4gTkFOO1xcbiAgfVxcbiAgcmV0dXJuIGFjb3MoeCk7XFxuXCIsV3M9RXMrXCJcXG4gIHJldHVybiBhdGFuKHgpO1xcblwiLFVzPUVzK1wicmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCArIDEuMCkpO1wiLFZzPUVzK1wiXFxuICBpZiAoeCA8IDEuMCkgcmV0dXJuIE5BTjtcXG4gIHJldHVybiBsb2coeCArIHNxcnQoeCAqIHggLSAxLjApKTtcIix6cz1FcytcIlxcbiAgaWYgKCh4IDwgLTEuMCkgfHwgKHggPiAxLjApKSByZXR1cm4gTkFOO1xcbiAgcmV0dXJuIChsb2coMS4wICsgeCkgLSBsb2coMS4wIC0geCkpIC8gMi4wO1wiLEdzPVwicmV0dXJuIHg7XCIsSHM9XCJyZXR1cm4geDtcIixxcz1cIlxcbiAgdmVjNCByZXN1bHQgPSB4ICogdmVjNChncmVhdGVyVGhhbkVxdWFsKHgsIHZlYzQoMC4wKSkpO1xcbiAgYnZlYzQgaXNOYU4gPSBpc25hbih4KTtcXG5cXG4gIHJlc3VsdC5yID0gaXNOYU4uciA/IHguciA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID8geC5nIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPyB4LmIgOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA/IHguYSA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIixLcz1cIlxcbiAgdmVjNCByZXN1bHQgPSBtaW4oeCwgdmVjNCg2LikpICogdmVjNChncmVhdGVyVGhhbkVxdWFsKHgsIHZlYzQoMC4wKSkpO1xcbiAgYnZlYzQgaXNOYU4gPSBpc25hbih4KTtcXG5cXG4gIHJlc3VsdC5yID0gaXNOYU4uciA/IHguciA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID8geC5nIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPyB4LmIgOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA/IHguYSA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIixqcz1cIlxcbiAgdmVjNCByZXN1bHQ7XFxuXFxuICByZXN1bHQuciA9ICh4LnIgPj0gMC4wKSA/IHguciA6IChleHAoeC5yKSAtIDEuMCk7XFxuICByZXN1bHQuZyA9ICh4LmcgPj0gMC4wKSA/IHguZyA6IChleHAoeC5nKSAtIDEuMCk7XFxuICByZXN1bHQuYiA9ICh4LmIgPj0gMC4wKSA/IHguYiA6IChleHAoeC5iKSAtIDEuMCk7XFxuICByZXN1bHQuYSA9ICh4LmEgPj0gMC4wKSA/IHguYSA6IChleHAoeC5hKSAtIDEuMCk7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLFhzPWZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2ZWM0IHVuYXJ5T3BlcmF0aW9uKHZlYzQgeCkge1xcbiAgICAgICAgXCIrZStcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IHggPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgeSA9IHVuYXJ5T3BlcmF0aW9uKHgpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KHkpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFlzPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSExLHRoaXMub3V0cHV0U2hhcGU9dDt2YXIgZT10Lmxlbmd0aCxuPXNhKFwicmNcIixlKSxyPXdhKGUpLG89ZnVuY3Rpb24odCxlKXtpZigxPT09dClyZXR1cm5cInJjXCI7Zm9yKHZhciBuPVwiXCIscj0wO3I8dDtyKyspbis9ZVtyXSxyPHQtMSYmKG4rPVwiLFwiKTtyZXR1cm4gbn0oZSxuKSxhPW4uc2xpY2UoLTIpLGk9ZTw9MT9cInJjXCI6XCJ2ZWMyKFwiK2Euam9pbihcIixcIikrXCIpXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK3IrXCIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgcGFja2VkSW5wdXQgPSBnZXRBKFwiK28rXCIpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KGdldENoYW5uZWwocGFja2VkSW5wdXQsIFwiK2krXCIpKTtcXG4gICAgICB9XFxuICAgIFwifSwkcz17fTtmdW5jdGlvbiBRcyh0LGUpe2lmKHZvaWQgMD09PWUmJihlPSExKSxcImxpbmVhclwiPT09dClyZXR1cm4gZT9IczpScztpZihcInJlbHVcIj09PXQpcmV0dXJuIGU/cXM6a3M7aWYoXCJlbHVcIj09PXQpcmV0dXJuIGU/anM6QXM7aWYoXCJyZWx1NlwiPT09dClyZXR1cm4gZT9LczpTcztpZihcInByZWx1XCI9PT10KXJldHVybiBlP1BhOk1hO3Rocm93IG5ldyBFcnJvcihcIkFjdGl2YXRpb24gXCIrdCtcIiBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgZm9yIHRoZSBXZWJHTCBiYWNrZW5kLlwiKX12YXIgSnM9NjAwO3ZhciBacz1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKGUpe3ZhciBuLHI9dC5jYWxsKHRoaXMpfHx0aGlzO2lmKHIucGVuZGluZ1JlYWQ9bmV3IFdlYWtNYXAsci5wZW5kaW5nRGlzcG9zYWw9bmV3IFdlYWtTZXQsci5kYXRhUmVmQ291bnQ9bmV3IFdlYWtNYXAsci5udW1CeXRlc0luR1BVPTAsci51cGxvYWRXYWl0TXM9MCxyLmRvd25sb2FkV2FpdE1zPTAsci53YXJuZWRBYm91dE1lbW9yeT0hMSxyLnBlbmRpbmdEZWxldGVzPTAsci5kaXNwb3NlZD0hMSwhaSgpLmdldEJvb2woXCJIQVNfV0VCR0xcIikpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZVwiKTtpZihudWxsPT1lKXt2YXIgbz1qdChpKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSk7ci5iaW5hcnlDYWNoZT0obj1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSlpbiAkcz8kc1tuXTooJHNbbl09e30sJHNbbl0pLHIuZ3BncHU9bmV3IEJpKG8pLHIuY2FudmFzPW8uY2FudmFzLHIuZ3BncHVDcmVhdGVkTG9jYWxseT0hMH1lbHNlIHIuZ3BncHU9ZSxyLmJpbmFyeUNhY2hlPXt9LHIuZ3BncHVDcmVhdGVkTG9jYWxseT0hMSxyLmNhbnZhcz1lLmdsLmNhbnZhcztyZXR1cm4gci50ZXh0dXJlTWFuYWdlcj1uZXcgcHMoci5ncGdwdSksci5udW1NQkJlZm9yZVdhcm5pbmc9bnVsbD09aSgpLmdsb2JhbC5zY3JlZW4/MTAyNDppKCkuZ2xvYmFsLnNjcmVlbi5oZWlnaHQqaSgpLmdsb2JhbC5zY3JlZW4ud2lkdGgqd2luZG93LmRldmljZVBpeGVsUmF0aW8qSnMvMTAyNC8xMDI0LHIudGV4RGF0YT1uZXcgeG8ocixMdCkscn1yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLm51bURhdGFJZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZXhEYXRhLm51bURhdGFJZHMoKSsodGhpcy5jcHVCYWNrZW5kP3RoaXMuY3B1QmFja2VuZC5udW1EYXRhSWRzKCk6MCktdGhpcy5wZW5kaW5nRGVsZXRlc30sby5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCxlLG4pe2lmKGkoKS5nZXRCb29sKFwiREVCVUdcIikmJnRoaXMuY2hlY2tOdW1lcmljYWxQcm9ibGVtcyh0KSxcImNvbXBsZXg2NFwiPT09biYmbnVsbCE9dCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgd3JpdGUgdG8gYSBjb21wbGV4NjQgZHR5cGUuIFBsZWFzZSB1c2UgdGYuY29tcGxleChyZWFsLCBpbWFnKS5cIik7dmFyIHI9e307cmV0dXJuIHRoaXMudGV4RGF0YS5zZXQocix7c2hhcGU6ZSxkdHlwZTpuLHZhbHVlczp0LHVzYWdlOnp0LlVQTE9BRH0pLHJ9LG8ucHJvdG90eXBlLm1vdmU9ZnVuY3Rpb24odCxlLG4scil7aWYoaSgpLmdldEJvb2woXCJERUJVR1wiKSYmdGhpcy5jaGVja051bWVyaWNhbFByb2JsZW1zKGUpLFwiY29tcGxleDY0XCI9PT1yKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB3cml0ZSB0byBhIGNvbXBsZXg2NCBkdHlwZS4gUGxlYXNlIHVzZSB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLlwiKTt0aGlzLnRleERhdGEuc2V0KHQse3NoYXBlOm4sZHR5cGU6cix2YWx1ZXM6ZSx1c2FnZTp6dC5VUExPQUR9KX0sby5wcm90b3R5cGUucmVhZFN5bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy50ZXhEYXRhLmdldCh0KSxuPWUudmFsdWVzLHI9ZS5kdHlwZSxvPWUuY29tcGxleFRlbnNvcnMsYT1lLnNsaWNlLGk9ZS5zaGFwZSxzPWUuaXNQYWNrZWQ7aWYobnVsbCE9YSl7dmFyIHU9dm9pZCAwO3U9cz9uZXcgWHMoaSxHcyk6bmV3IENzKGksR3MpO3ZhciBjPXRoaXMucnVuV2ViR0xQcm9ncmFtKHUsW3tkYXRhSWQ6dCxzaGFwZTppLGR0eXBlOnJ9XSxyKSxsPXRoaXMucmVhZFN5bmMoYy5kYXRhSWQpO3JldHVybiB0aGlzLmRpc3Bvc2VEYXRhKGMuZGF0YUlkKSxsfWlmKG51bGwhPW4pcmV0dXJuIHRoaXMuY29udmVydEFuZENhY2hlT25DUFUodCk7aWYoXCJzdHJpbmdcIj09PXIpcmV0dXJuIG47dmFyIGgsZixkPW51bGwhPXRoaXMuYWN0aXZlVGltZXJzOyhkJiYoaD1ldCgpKSxcImNvbXBsZXg2NFwiPT09cik/Zj1WbyhvLnJlYWwuZGF0YVN5bmMoKSxvLmltYWcuZGF0YVN5bmMoKSk6Zj10aGlzLmdldFZhbHVlc0Zyb21UZXh0dXJlKHQpO3JldHVybiBkJiYodGhpcy5kb3dubG9hZFdhaXRNcys9ZXQoKS1oKSx0aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKHQsZil9LG8ucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG4sbyxhLHMsdSxjLGwsaCxmLGQscCx2LG0sZyx5LHgsYix3LEMsRSxSO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYodGhpcy5wZW5kaW5nUmVhZC5oYXModCkpcmV0dXJuIGU9dGhpcy5wZW5kaW5nUmVhZC5nZXQodCksWzIsbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnB1c2godCl9KSldO2lmKG49dGhpcy50ZXhEYXRhLmdldCh0KSxvPW4udmFsdWVzLGE9bi5zaGFwZSxzPW4uc2xpY2UsdT1uLmR0eXBlLGM9bi5jb21wbGV4VGVuc29ycyxsPW4uaXNQYWNrZWQsbnVsbCE9cylyZXR1cm4gaD12b2lkIDAsaD1sP25ldyBYcyhhLEdzKTpuZXcgQ3MoYSxHcyksZj10aGlzLnJ1bldlYkdMUHJvZ3JhbShoLFt7ZGF0YUlkOnQsc2hhcGU6YSxkdHlwZTp1fV0sdSksZD10aGlzLnJlYWQoZi5kYXRhSWQpLHRoaXMuZGlzcG9zZURhdGEoZi5kYXRhSWQpLFsyLGRdO2lmKG51bGwhPW8pcmV0dXJuWzIsdGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVSh0KV07aWYoIWkoKS5nZXRCb29sKFwiV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRFwiKSYmMj09PWkoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKXRocm93IG5ldyBFcnJvcihcInRlbnNvci5kYXRhKCkgd2l0aCBXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEPWZhbHNlIGFuZCBXRUJHTF9WRVJTSU9OPTIgbm90IHlldCBzdXBwb3J0ZWQuXCIpO3JldHVybiBwPW51bGwsXCJjb21wbGV4NjRcIiE9PXUmJmkoKS5nZXQoXCJXRUJHTF9CVUZGRVJfU1VQUE9SVEVEXCIpJiYodj10aGlzLmRlY29kZSh0KSxtPXRoaXMudGV4RGF0YS5nZXQodi5kYXRhSWQpLHA9KFI9dGhpcy5ncGdwdSkuY3JlYXRlQnVmZmVyRnJvbVRleHR1cmUuYXBwbHkoUixbbS50ZXh0dXJlXS5jb25jYXQoWXQoYSkpKSksdGhpcy5wZW5kaW5nUmVhZC5zZXQodCxbXSksXCJjb21wbGV4NjRcIj09PXU/WzMsMl06WzQsdGhpcy5ncGdwdS5jcmVhdGVBbmRXYWl0Rm9yRmVuY2UoKV07Y2FzZSAxOnIuc2VudCgpLHIubGFiZWw9MjtjYXNlIDI6cmV0dXJuXCJjb21wbGV4NjRcIiE9PXU/WzMsNF06WzQsUHJvbWlzZS5hbGwoW2MucmVhbC5kYXRhKCksYy5pbWFnLmRhdGEoKV0pXTtjYXNlIDM6cmV0dXJuIHk9ci5zZW50KCkseD15WzBdLGI9eVsxXSxnPVZvKHgsYiksWzMsNV07Y2FzZSA0Om51bGw9PXA/Zz10aGlzLmdldFZhbHVlc0Zyb21UZXh0dXJlKHQpOih3PWsoYSksZz10aGlzLmdwZ3B1LmRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXIocCx3KSksci5sYWJlbD01O2Nhc2UgNTpyZXR1cm4gbnVsbCE9diYmdGhpcy5kaXNwb3NlRGF0YSh2LmRhdGFJZCksQz10aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKHQsZyksRT10aGlzLnBlbmRpbmdSZWFkLmdldCh0KSx0aGlzLnBlbmRpbmdSZWFkLmRlbGV0ZSh0KSxFLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiB0KEMpfSkpLHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmhhcyh0KSYmKHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmRlbGV0ZSh0KSx0aGlzLmRpc3Bvc2VEYXRhKHQpLHRoaXMucGVuZGluZ0RlbGV0ZXMtLSksWzIsQ119fSkpfSkpfSxvLnByb3RvdHlwZS5jaGVja051bWVyaWNhbFByb2JsZW1zPWZ1bmN0aW9uKHQpe2lmKG51bGwhPXQpZm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciBuPXRbZV07aWYoIWVlKG4pKXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0NBUEFCTEVcIikpdGhyb3cgRXJyb3IoXCJUaGUgdmFsdWUgXCIrbitcIiBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgd2l0aCB5b3VyIGN1cnJlbnQgc2V0dGluZ3MuIENvbnNpZGVyIGVuYWJsaW5nIGZsb2F0MzIgcmVuZGVyaW5nOiAndGYuZW52KCkuc2V0KCdXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEJywgdHJ1ZSk7J1wiKTt0aHJvdyBFcnJvcihcIlRoZSB2YWx1ZSBcIituK1wiIGNhbm5vdCBiZSByZXByZXNlbnRlZCBvbiB0aGlzIGRldmljZS5cIil9fX0sby5wcm90b3R5cGUuZ2V0VmFsdWVzRnJvbVRleHR1cmU9ZnVuY3Rpb24odCl7dmFyIGUsbj10aGlzLnRleERhdGEuZ2V0KHQpLHI9bi5zaGFwZSxvPW4uZHR5cGUsYT1uLmlzUGFja2VkLHM9ayhyKTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRURcIikpe3ZhciB1PXRoaXMuZGVjb2RlKHQpLGM9dGhpcy50ZXhEYXRhLmdldCh1LmRhdGFJZCksbD0oZT10aGlzLmdwZ3B1KS5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRUZXh0dXJlLmFwcGx5KGUsW2MudGV4dHVyZV0uY29uY2F0KFl0KHIpKSkuc3ViYXJyYXkoMCxzKTtyZXR1cm4gdGhpcy5kaXNwb3NlRGF0YSh1LmRhdGFJZCksbH12YXIgaD1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIikmJiEwPT09YSxmPWg/VGUocik6cixkPWg/bmV3IGNpKGYpOm5ldyB1aShmKSxwPXRoaXMucnVuV2ViR0xQcm9ncmFtKGQsW3tzaGFwZTpmLGR0eXBlOm8sZGF0YUlkOnR9XSxcImZsb2F0MzJcIiksdj10aGlzLnRleERhdGEuZ2V0KHAuZGF0YUlkKSxtPXRoaXMuZ3BncHUuZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmUodi50ZXh0dXJlLHYudGV4U2hhcGVbMF0sdi50ZXhTaGFwZVsxXSkuc3ViYXJyYXkoMCxzKTtyZXR1cm4gdGhpcy5kaXNwb3NlRGF0YShwLmRhdGFJZCksbX0sby5wcm90b3R5cGUudGltZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixvLGEscyx1LGM7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gZT10aGlzLmFjdGl2ZVRpbWVycyxuPVtdLG89ITEsbnVsbD09dGhpcy5wcm9ncmFtVGltZXJzU3RhY2s/KHRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrPW4sbz0hMCk6dGhpcy5hY3RpdmVUaW1lcnMucHVzaChuKSx0aGlzLmFjdGl2ZVRpbWVycz1uLHQoKSxhPUkodGhpcy5hY3RpdmVUaW1lcnMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5xdWVyeX0pKSkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dH0pKSxzPUkodGhpcy5hY3RpdmVUaW1lcnMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSkpKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10fSkpLHRoaXMuYWN0aXZlVGltZXJzPWUsbyYmKHRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrPW51bGwpLHU9e3VwbG9hZFdhaXRNczp0aGlzLnVwbG9hZFdhaXRNcyxkb3dubG9hZFdhaXRNczp0aGlzLmRvd25sb2FkV2FpdE1zLGtlcm5lbE1zOm51bGwsd2FsbE1zOm51bGx9LGkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEVcIik+MD9bNCxQcm9taXNlLmFsbChhKV06WzMsMl07Y2FzZSAxOnJldHVybiBjPXIuc2VudCgpLHUua2VybmVsTXM9dyhjKSx1LmdldEV4dHJhUHJvZmlsZUluZm89ZnVuY3Rpb24oKXtyZXR1cm4gYy5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJue25hbWU6c1tlXSxtczp0fX0pKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWUrXCI6IFwiK3QubXN9KSkuam9pbihcIiwgXCIpfSxbMywzXTtjYXNlIDI6dS5rZXJuZWxNcz17ZXJyb3I6XCJXZWJHTCBxdWVyeSB0aW1lcnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC5cIn0sci5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gdGhpcy51cGxvYWRXYWl0TXM9MCx0aGlzLmRvd25sb2FkV2FpdE1zPTAsWzIsdV19fSkpfSkpfSxvLnByb3RvdHlwZS5tZW1vcnk9ZnVuY3Rpb24oKXtyZXR1cm57dW5yZWxpYWJsZTohMSxudW1CeXRlc0luR1BVOnRoaXMubnVtQnl0ZXNJbkdQVX19LG8ucHJvdG90eXBlLnN0YXJ0VGltZXI9ZnVuY3Rpb24oKXtyZXR1cm4gaSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRVwiKT4wP3RoaXMuZ3BncHUuYmVnaW5RdWVyeSgpOntzdGFydE1zOmV0KCksZW5kTXM6bnVsbH19LG8ucHJvdG90eXBlLmVuZFRpbWVyPWZ1bmN0aW9uKHQpe3JldHVybiBpKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFXCIpPjA/KHRoaXMuZ3BncHUuZW5kUXVlcnkoKSx0KToodC5lbmRNcz1ldCgpLHQpfSxvLnByb3RvdHlwZS5nZXRRdWVyeVRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3JldHVybiBpKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFXCIpPjA/WzIsdGhpcy5ncGdwdS53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHQpXTpbMiwoZT10KS5lbmRNcy1lLnN0YXJ0TXNdfSkpfSkpfSxvLnByb3RvdHlwZS5kaXNwb3NlRGF0YT1mdW5jdGlvbih0KXtpZighdGhpcy5wZW5kaW5nRGlzcG9zYWwuaGFzKHQpKXtpZih0aGlzLnBlbmRpbmdSZWFkLmhhcyh0KSlyZXR1cm4gdGhpcy5wZW5kaW5nRGlzcG9zYWwuYWRkKHQpLHZvaWQgdGhpcy5wZW5kaW5nRGVsZXRlcysrO2lmKHRoaXMudGV4RGF0YS5oYXModCkpe3RoaXMucmVsZWFzZUdQVURhdGEodCk7dmFyIGU9dGhpcy50ZXhEYXRhLmdldCh0KS5jb21wbGV4VGVuc29ycztudWxsIT1lJiYoZS5yZWFsLmRpc3Bvc2UoKSxlLmltYWcuZGlzcG9zZSgpKSx0aGlzLnRleERhdGEuZGVsZXRlKHQpfX19LG8ucHJvdG90eXBlLnJlbGVhc2VHUFVEYXRhPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMudGV4RGF0YS5nZXQodCksbj1lLnRleHR1cmUscj1lLmR0eXBlLG89ZS50ZXhTaGFwZSxhPWUudXNhZ2UsaT1lLmlzUGFja2VkLHM9ZS5zbGljZSx1PXMmJnMub3JpZ0RhdGFJZHx8dCxjPXRoaXMuZGF0YVJlZkNvdW50LmdldCh1KTtjPjE/dGhpcy5kYXRhUmVmQ291bnQuc2V0KHUsYy0xKToodGhpcy5kYXRhUmVmQ291bnQuZGVsZXRlKHUpLG51bGwhPW4mJih0aGlzLm51bUJ5dGVzSW5HUFUtPXRoaXMuY29tcHV0ZUJ5dGVzKG8sciksdGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZShuLG8sYSxpKSkpO3ZhciBsPXRoaXMudGV4RGF0YS5nZXQodCk7bC50ZXh0dXJlPW51bGwsbC50ZXhTaGFwZT1udWxsLGwuaXNQYWNrZWQ9ITEsbC5zbGljZT1udWxsfSxvLnByb3RvdHlwZS5nZXRUZXh0dXJlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnVwbG9hZFRvR1BVKHQpLHRoaXMudGV4RGF0YS5nZXQodCkudGV4dHVyZX0sby5wcm90b3R5cGUuZ2V0RGF0YUluZm89ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQodCl9LG8ucHJvdG90eXBlLmdldENQVUJhY2tlbmQ9ZnVuY3Rpb24oKXtyZXR1cm4gaSgpLmdldEJvb2woXCJXRUJHTF9DUFVfRk9SV0FSRFwiKT8obnVsbD09dGhpcy5jcHVCYWNrZW5kJiYodGhpcy5jcHVCYWNrZW5kPUx0LmZpbmRCYWNrZW5kKFwiY3B1XCIpKSx0aGlzLmNwdUJhY2tlbmQpOm51bGx9LG8ucHJvdG90eXBlLnNob3VsZEV4ZWN1dGVPbkNQVT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7cmV0dXJuIHZvaWQgMD09PWUmJihlPTEyOCksbnVsbCE9dGhpcy5nZXRDUFVCYWNrZW5kKCkmJnQuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT1uLnRleERhdGEuZ2V0KHQuZGF0YUlkKS50ZXh0dXJlJiZ0LnNpemU8ZX0pKX0sby5wcm90b3R5cGUuZ2V0R1BHUFVDb250ZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3BncHV9LG8ucHJvdG90eXBlLmNvbXBsZXg9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLm1ha2VPdXRwdXQodC5zaGFwZSxcImNvbXBsZXg2NFwiKTtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldChuLmRhdGFJZCkuY29tcGxleFRlbnNvcnM9e3JlYWw6THQua2VlcCh0LmNsb25lKCkpLGltYWc6THQua2VlcChlLmNsb25lKCkpfSxufSxvLnByb3RvdHlwZS5yZWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5yZWFsLmNsb25lKCl9LG8ucHJvdG90eXBlLmltYWc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLmltYWcuY2xvbmUoKX0sby5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5zbGljZSh0LGUsbik7aWYoMD09PWsobikpcmV0dXJuIEZuKFtdLG4sdC5kdHlwZSk7dmFyIHI9dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkuaXNQYWNrZWQsbz1pbyh0LnNoYXBlLGUsbik7aWYocnx8IW8pe3ZhciBhPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpP25ldyBmcyhuKTpuZXcgbHMobikscz1hLmdldEN1c3RvbVNldHVwRnVuYyhlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGEsW3RdLG51bGwscyl9cmV0dXJuIHRoaXMudXBsb2FkVG9HUFUodC5kYXRhSWQpLHRoaXMuc2hhbGxvd1NsaWNlKHQsZSxuKX0sby5wcm90b3R5cGUuc2hhbGxvd1NsaWNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxvPXRoaXMubWFrZU91dHB1dChuLHQuZHR5cGUpLGE9dGhpcy50ZXhEYXRhLmdldChvLmRhdGFJZCk7T2JqZWN0LmFzc2lnbihhLHIpLGEuc2hhcGU9bixhLmR0eXBlPXQuZHR5cGU7dmFyIGk9c28oZSx0LnN0cmlkZXMpO3Iuc2xpY2UmJihpKz1yLnNsaWNlLmZsYXRPZmZzZXQpLGEuc2xpY2U9e2ZsYXRPZmZzZXQ6aSxvcmlnRGF0YUlkOnIuc2xpY2UmJnIuc2xpY2Uub3JpZ0RhdGFJZHx8dC5kYXRhSWR9O3ZhciBzPXRoaXMuZGF0YVJlZkNvdW50LmdldChhLnNsaWNlLm9yaWdEYXRhSWQpfHwxO3JldHVybiB0aGlzLmRhdGFSZWZDb3VudC5zZXQoYS5zbGljZS5vcmlnRGF0YUlkLHMrMSksb30sby5wcm90b3R5cGUuc3RyaWRlZFNsaWNlPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5zdHJpZGVkU2xpY2UodCxlLG4scik7dmFyIG89cm8oZSxuLHIpO2lmKG8uc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10fSkpKXJldHVybiBGbihbXSxvKTt2YXIgYT1uZXcgZHMoZSxyLG8pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oYSxbdF0pfSxvLnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIik/bmV3IGlzKHQuc2hhcGUsZSk6bmV3IGFzKHQuc2hhcGUsZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0XSl9LG8ucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbih0LGUpe2lmKFwiY29tcGxleDY0XCI9PT10WzBdLmR0eXBlKXt2YXIgbj10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIFRuKHQpfSkpLHI9dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBObih0KX0pKTtyZXR1cm4gRG4odGhpcy5jb25jYXQobixlKSx0aGlzLmNvbmNhdChyLGUpKX1pZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVSh0KSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmNvbmNhdCh0LGUpO2lmKDE9PT10Lmxlbmd0aClyZXR1cm4gdFswXTtpZih0Lmxlbmd0aD5pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfTUFYX1RFWFRVUkVTX0lOX1NIQURFUlwiKSl7dmFyIG89TWF0aC5mbG9vcih0Lmxlbmd0aC8yKSxhPXRoaXMuY29uY2F0KHQuc2xpY2UoMCxvKSxlKSxzPXRoaXMuY29uY2F0KHQuc2xpY2UobyksZSk7cmV0dXJuIHRoaXMuY29uY2F0KFthLHNdLGUpfWlmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpJiZ0WzBdLnJhbms+MSl7dmFyIHU9bmV3IEdhKHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pKSxlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHUsdCl9dmFyIGM9U24odC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkpLGUpLGw9dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFzMkQoLTEsayh0LnNoYXBlLnNsaWNlKGUpKSl9KSksaD1uZXcgemEobC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGgsbCkucmVzaGFwZShjKX0sby5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5uZWcodCk7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX1VOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkVW5hcnlPcCh0LFRzLHQuZHR5cGUpO3ZhciBlPW5ldyBDcyh0LnNoYXBlLFRzKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuYmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89bj90LnNoYXBlWzJdOnQuc2hhcGVbMV0sYT1yP2Uuc2hhcGVbMV06ZS5zaGFwZVsyXSxpPW4/dC5zaGFwZVsxXTp0LnNoYXBlWzJdLHM9dC5zaGFwZVswXTtpZigoMT09PW98fDE9PT1hKSYmaT4xZTMpe24mJih0PXQudHJhbnNwb3NlKFswLDIsMV0pKSxyJiYoZT1lLnRyYW5zcG9zZShbMCwyLDFdKSk7dmFyIHU9MT09PWE/dDp0LmFzM0QocyxpLDEpLGM9MT09PWE/MjoxLGw9MT09PWE/ZS5hczNEKHMsMSxpKTplO3JldHVybiB0aGlzLm11bHRpcGx5KHUsbCkuc3VtKGMsITApfXZhciBoPUR0KHQuZHR5cGUsZS5kdHlwZSksZj1uZXcgSGkodC5zaGFwZSxbcyxvLGFdLG4scik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihmLFt0LGVdLGgpfSxvLnByb3RvdHlwZS5mdXNlZEJhdGNoTWF0TXVsPWZ1bmN0aW9uKHQpe3ZhciBlPXQuYSxuPXQuYixyPXQudHJhbnNwb3NlQSxvPXQudHJhbnNwb3NlQixhPXQuYmlhcyxpPXQuYWN0aXZhdGlvbixzPXQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyx1PXI/ZS5zaGFwZVsyXTplLnNoYXBlWzFdLGM9bz9uLnNoYXBlWzFdOm4uc2hhcGVbMl0sbD1lLnNoYXBlWzBdLGg9RHQoZS5kdHlwZSxuLmR0eXBlKSxmPW51bGwhPWEsZD1udWxsIT1zLHA9aT9RcyhpLCEwKTpudWxsLHY9bmV3IEhpKGUuc2hhcGUsW2wsdSxjXSxyLG8sZixwLGQpLG09W2Usbl07cmV0dXJuIGEmJm0ucHVzaChhKSxzJiZtLnB1c2gocyksdGhpcy5jb21waWxlQW5kUnVuKHYsbSxoKX0sby5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24odCxlKXtpZihcImNvbXBsZXg2NFwiPT09dC5kdHlwZSl7dmFyIG49dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkscj10aGlzLnRleERhdGEuZ2V0KGUuZGF0YUlkKSxvPW5ldyBOYShEYSx0LnNoYXBlLGUuc2hhcGUpLGE9bmV3IE5hKFRhLHQuc2hhcGUsZS5zaGFwZSkscz1bdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm8odCxuLmNvbXBsZXhUZW5zb3JzLnJlYWwpLHRoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvKHQsbi5jb21wbGV4VGVuc29ycy5pbWFnKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyhlLHIuY29tcGxleFRlbnNvcnMucmVhbCksdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm8oZSxyLmNvbXBsZXhUZW5zb3JzLmltYWcpXSx1PXRoaXMuY29tcGlsZUFuZFJ1bihvLHMpLGM9dGhpcy5jb21waWxlQW5kUnVuKGEscyksbD10aGlzLmNvbXBsZXgodSxjKTtyZXR1cm4gdS5kaXNwb3NlKCksYy5kaXNwb3NlKCksbH1pZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5tdWx0aXBseSh0LGUpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsT2EsdC5kdHlwZSk7dmFyIGg9bmV3IEJhKE9hLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihoLFt0LGVdLHQuZHR5cGUpfSxvLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb249ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBzPVt0LGUsbl0sdT1udWxsO251bGwhPWEmJih1PWEuc2hhcGUscy5wdXNoKGEpKTt2YXIgYz1udWxsO2lmKG51bGwhPW8mJihjPW8uc2hhcGUscy5wdXNoKG8pKSxpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfTk9STUFMSVpBVElPTlwiKSl7dmFyIGw9bmV3IEFhKHQuc2hhcGUsZS5zaGFwZSxuLnNoYXBlLHUsYyxyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGwscyl9dmFyIGg9bmV3IFNhKHQuc2hhcGUsZS5zaGFwZSxuLnNoYXBlLHUsYyxyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGgscyl9LG8ucHJvdG90eXBlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQ9ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgYT1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfTk9STUFMSVpBVElPTlwiKT9uZXcgVmkodC5zaGFwZSxlLG4scixvKTpuZXcgV2kodC5zaGFwZSxlLG4scixvKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGEsW3RdKX0sby5wcm90b3R5cGUuTFJOR3JhZD1mdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2YXIgcz1uZXcgVWkoZS5zaGFwZSxyLG8sYSxpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHMsW2Usbix0XSl9LG8ucHJvdG90eXBlLnRpbGU9ZnVuY3Rpb24odCxlKXtpZihcInN0cmluZ1wiPT09dC5kdHlwZSl7dmFyIG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gb3QodCl9KSk7cmV0dXJuIHRhKGRyKHQuc2hhcGUsdC5kdHlwZSxuKSxlKX12YXIgcj1uZXcgZ3ModC5zaGFwZSxlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdKX0sby5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgWWkodC5zaGFwZSxlLG4pOm5ldyBYaSh0LnNoYXBlLGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSl9LG8ucHJvdG90eXBlLnRyYW5zcG9zZT1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC50cmFuc3Bvc2UodCxlKTt2YXIgbj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgeHModC5zaGFwZSxlKTpuZXcgeXModC5zaGFwZSxlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdKX0sby5wcm90b3R5cGUuZ2F0aGVyPWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5nYXRoZXIodCxlLG4pO3ZhciByPW5ldyBtaSh0LnNoYXBlLGUuc2l6ZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSxvLnByb3RvdHlwZS5iYXRjaFRvU3BhY2VORD1mdW5jdGlvbih0LGUsbil7Qyh0LnJhbms8PTQsKGZ1bmN0aW9uKCl7cmV0dXJuXCJiYXRjaFRvU3BhY2VORCBmb3IgcmFuayA+IDQgd2l0aCBhIFdlYkdMIGJhY2tlbmQgbm90IGltcGxlbWVudGVkIHlldFwifSkpO3ZhciByPWUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSksbz16cih0LnNoYXBlLGUsciksYT1HcihvLmxlbmd0aCxlLmxlbmd0aCksaT1Icih0LnNoYXBlLGUscikscz1xcihuLGUubGVuZ3RoKSx1PUtyKGksbixlLmxlbmd0aCk7cmV0dXJuIHQucmVzaGFwZShvKS50cmFuc3Bvc2UoYSkucmVzaGFwZShpKS5zbGljZShzLHUpfSxvLnByb3RvdHlwZS5zcGFjZVRvQmF0Y2hORD1mdW5jdGlvbih0LGUsbil7Qyh0LnJhbms8PTQsKGZ1bmN0aW9uKCl7cmV0dXJuXCJzcGFjZVRvQmF0Y2hORCBmb3IgcmFuayA+IDQgd2l0aCBhIFdlYkdMIGJhY2tlbmQgbm90IGltcGxlbWVudGVkIHlldFwifSkpO3ZhciByPWUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSksbz1bWzAsMF1dO28ucHVzaC5hcHBseShvLG4pO2Zvcih2YXIgYT0xK2UubGVuZ3RoO2E8dC5zaGFwZS5sZW5ndGg7KythKW8ucHVzaChbMCwwXSk7dmFyIGk9dC5wYWQobykscz16cihpLnNoYXBlLGUsciwhMSksdT1HcihzLmxlbmd0aCxlLmxlbmd0aCwhMSksYz1IcihpLnNoYXBlLGUsciwhMSk7cmV0dXJuIGkucmVzaGFwZShzKS50cmFuc3Bvc2UodSkucmVzaGFwZShjKX0sby5wcm90b3R5cGUucmVkdWNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10LnNoYXBlWzBdLG89dC5zaGFwZVsxXSxhPSRyKG8pLGk9bmV3IEppKHt3aW5kb3dTaXplOmEsaW5TaXplOm8sYmF0Y2hTaXplOnJ9LGUpLHM9dGhpcy5jb21waWxlQW5kUnVuKGksW3RdLG4pO3JldHVybiAxPT09cy5zaGFwZVsxXT9zOnRoaXMucmVkdWNlKHMsZSxuKX0sby5wcm90b3R5cGUuYXJnUmVkdWNlPWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1udWxsKTt2YXIgcj10LnNoYXBlWzBdLG89dC5zaGFwZVsxXTtudWxsIT1uJiYocj1uLnNoYXBlWzBdLG89bi5zaGFwZVsxXSk7dmFyIGE9JHIobyksaT1uZXcgYWEoe3dpbmRvd1NpemU6YSxpblNpemU6byxiYXRjaFNpemU6cn0sZSxudWxsPT1uKSxzPVt0XTtudWxsIT1uJiZzLnB1c2gobik7dmFyIHU9dGhpcy5jb21waWxlQW5kUnVuKGkscyxcImludDMyXCIpO3JldHVybiAxPT09dS5zaGFwZVsxXT91OnRoaXMuYXJnUmVkdWNlKHQsZSx1KX0sby5wcm90b3R5cGUuYXJnUmVkdWNlUGFja2VkPWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1udWxsKTt2YXIgcj1udWxsIT1uP24uc2hhcGU6dC5zaGFwZSxvPSRyKHJbci5sZW5ndGgtMV0pLGE9bmV3IFJhKHIsbyxlLG51bGw9PW4pLGk9bnVsbD09bj9bdF06W3Qsbl0scz10aGlzLmNvbXBpbGVBbmRSdW4oYSxpLFwiaW50MzJcIik7cmV0dXJuIHMucmFuaz09PXQucmFuaz90aGlzLmFyZ1JlZHVjZVBhY2tlZCh0LGUscyk6c30sby5wcm90b3R5cGUuc3VtPWZ1bmN0aW9uKHQsZSl7Q24oXCJzdW1cIixlLHQucmFuayk7dmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1rKG5bMV0pLGE9dC5hczJEKC0xLG8pLGk9VHQodC5kdHlwZSk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJzdW1cIixpKS5yZXNoYXBlKHIpfSxvLnByb3RvdHlwZS5wcm9kPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnByb2QodCxlKTt2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPWsoblsxXSksYT10LmFzMkQoLTEsbyksaT1UdCh0LmR0eXBlKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcInByb2RcIixpKS5yZXNoYXBlKHIpfSxvLnByb3RvdHlwZS51bnNvcnRlZFNlZ21lbnRTdW09ZnVuY3Rpb24odCxlLG4pe3ZhciByPTAsbz1Fbihbcl0sdC5yYW5rKSxhPXQ7bnVsbCE9byYmKGE9dC50cmFuc3Bvc2Uobykscj1JbigxLHQucmFuaylbMF0pO3ZhciBpPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9W10sbz10Lmxlbmd0aCxhPTA7YTxvO2ErKylhIT09ZT9yLnB1c2godFthXSk6ci5wdXNoKG4pO3JldHVybiByfShhLnNoYXBlLHIsbikscz1rKFthLnNoYXBlW3JdXSksdT1hLmFzMkQoLTEscyksYz1UdCh0LmR0eXBlKSxsPXRoaXMuc2VnT3BDb21wdXRlKHUsXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIixlLGMsbikucmVzaGFwZShpKTtyZXR1cm4gbnVsbCE9byYmKGw9bC50cmFuc3Bvc2UoUm4obykpKSxsfSxvLnByb3RvdHlwZS5zZWdPcENvbXB1dGU9ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgYT10LnNoYXBlWzBdLGk9dC5zaGFwZVsxXSxzPWZ1bmN0aW9uKHQsZSl7dmFyIG4scj0hMTtmb3IodDw9WXI/KG49dCxyPSEwKTpuPVkodCxNYXRoLmZsb29yKE1hdGguc3FydCh0KSkpOyFyOyluPmV8fG49PT10P3I9ITA6bj1ZKHQsbisxKTtyZXR1cm4gbn0oaSxvKSx1PW5ldyB1cyh7d2luZG93U2l6ZTpzLGluU2l6ZTppLGJhdGNoU2l6ZTphLG51bVNlZ21lbnRzOm99LGUpLGM9dGhpcy5jb21waWxlQW5kUnVuKHUsW3Qsbl0scik7cmV0dXJuIGMuc2hhcGVbMV09PT1vP2M6KG49S24oMCxvKS50aWxlKFtpL3NdKSx0aGlzLnNlZ09wQ29tcHV0ZShjLGUsbixyLG8pKX0sby5wcm90b3R5cGUuYXJnTWluTWF4UmVkdWNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1bZV07aWYoQ24oXCJhcmdcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSkscix0LnJhbmspLCFpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfUkVEVUNFXCIpfHx0LnJhbms8PTIpe3ZhciBvPWJuKHQuc2hhcGUsciksYT1vWzBdLHM9ayhvWzFdKSx1PXQuYXMyRCgtMSxzKTtyZXR1cm4gdGhpcy5hcmdSZWR1Y2UodSxuKS5yZXNoYXBlKGEpfXJldHVybiB0aGlzLmFyZ1JlZHVjZVBhY2tlZCh0LG4pfSxvLnByb3RvdHlwZS5hcmdNaW49ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hcmdNaW5NYXhSZWR1Y2UodCxlLFwibWluXCIpfSxvLnByb3RvdHlwZS5hcmdNYXg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hcmdNaW5NYXhSZWR1Y2UodCxlLFwibWF4XCIpfSxvLnByb3RvdHlwZS5jdW1zdW09ZnVuY3Rpb24odCxlLG4scil7aWYoZSE9PXQucmFuay0xKXRocm93IG5ldyBFcnJvcihcIldlYkdMIGN1bXN1bSBzaGFkZXIgZXhwZWN0cyBhbiBpbm5lci1tb3N0IGF4aXM9XCIrKHQucmFuay0xKStcIiBidXQgZ290IGF4aXM9XCIrZSk7dmFyIG89bmV3IG5pKHQuc2hhcGUsbixyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW3RdKX0sby5wcm90b3R5cGUuZXF1YWw9ZnVuY3Rpb24odCxlKXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChlcXVhbChhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBCYShcInJldHVybiBmbG9hdChhID09IGIpO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUubm90RXF1YWw9ZnVuY3Rpb24odCxlKXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChub3RFcXVhbChhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBCYShcInJldHVybiBmbG9hdChhICE9IGIpO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUubGVzcz1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmxlc3ModCxlKTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChsZXNzVGhhbihhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBCYShcInJldHVybiBmbG9hdChhIDwgYik7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5sZXNzRXF1YWw9ZnVuY3Rpb24odCxlKXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChsZXNzVGhhbkVxdWFsKGEsIGIpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IEJhKFwicmV0dXJuIGZsb2F0KGEgPD0gYik7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5ncmVhdGVyPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuZ3JlYXRlcih0LGUpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KGdyZWF0ZXJUaGFuKGEsIGIpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IEJhKFwicmV0dXJuIGZsb2F0KGEgPiBiKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxcImJvb2xcIil9LG8ucHJvdG90eXBlLmdyZWF0ZXJFcXVhbD1mdW5jdGlvbih0LGUpe2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYSwgYikpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgQmEoXCJyZXR1cm4gZmxvYXQoYSA+PSBiKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxcImJvb2xcIil9LG8ucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJyZXR1cm4gZmxvYXQoISh4ID49IDEuMCkpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUubG9naWNhbEFuZD1mdW5jdGlvbih0LGUpe2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KFxcbiAgICB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYSwgdmVjNCgxLjApKSkgKlxcbiAgICB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYiwgdmVjNCgxLjApKSkpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgQmEoXCJyZXR1cm4gZmxvYXQoYSA+PSAxLjAgJiYgYiA+PSAxLjApO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKHQsZSl7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIG1pbihcXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGEsIHZlYzQoMS4wKSkpICtcXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGIsIHZlYzQoMS4wKSkpLFxcbiAgICB2ZWM0KDEuMCkpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgQmEoXCJyZXR1cm4gZmxvYXQoYSA+PSAxLjAgfHwgYiA+PSAxLjApO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUuc2VsZWN0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgY3ModC5yYW5rLGUuc2hhcGUsZS5yYW5rKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZSxuXSxEdChlLmR0eXBlLG4uZHR5cGUpKX0sby5wcm90b3R5cGUud2hlcmU9ZnVuY3Rpb24odCl7ZG4oXCJ0Zi53aGVyZSgpIGluIHdlYmdsIGxvY2tzIHRoZSBVSSB0aHJlYWQuIENhbGwgdGYud2hlcmVBc3luYygpIGluc3RlYWRcIik7dmFyIGU9dC5kYXRhU3luYygpO3JldHVybiBuYSh0LnNoYXBlLGUpfSxvLnByb3RvdHlwZS50b3BrPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gZWEodC5kYXRhU3luYygpLHQuc2hhcGUsdC5kdHlwZSxlKX0sby5wcm90b3R5cGUubWluPWZ1bmN0aW9uKHQsZSl7Q24oXCJtaW5cIixlLHQucmFuayk7dmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1rKG5bMV0pLGE9dC5hczJEKC0xLG8pO3JldHVybiB0aGlzLnJlZHVjZShhLFwibWluXCIsYS5kdHlwZSkucmVzaGFwZShyKX0sby5wcm90b3R5cGUubWluaW11bT1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLm1pbmltdW0odCxlKTt2YXIgbj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IExhKFwiXFxuICB2ZWM0IHJlc3VsdCA9IHZlYzQobWluKGEsIGIpKTtcXG4gIHZlYzQgaXNOYU4gPSBtaW4odmVjNChpc25hbihhKSkgKyB2ZWM0KGlzbmFuKGIpKSwgdmVjNCgxLjApKTtcXG4gIFxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID4gMC4gPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA+IDAuID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPiAwLiA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID4gMC4gPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgQmEoXCJcXG4gIGlmIChpc25hbihhKSkgcmV0dXJuIGE7XFxuICBpZiAoaXNuYW4oYikpIHJldHVybiBiO1xcblxcbiAgcmV0dXJuIG1pbihhLCBiKTtcXG5cIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LG8ucHJvdG90eXBlLm1vZD1mdW5jdGlvbih0LGUpe3ZhciBuPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgTGEoXCJcXG4gIHZlYzQgcmVzdWx0ID0gbW9kKGEsIGIpO1xcbiAgdmVjNCBpc05hTiA9IHZlYzQoZXF1YWwoYiwgdmVjNCgwLjApKSk7XFxuICBcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA+IDAuID8gTkFOIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPiAwLiA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID4gMC4gPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA+IDAuID8gTkFOIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IEJhKFwiaWYgKGIgPT0gMC4wKSByZXR1cm4gTkFOO1xcbiAgcmV0dXJuIG1vZChhLCBiKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LG8ucHJvdG90eXBlLm1heD1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5tYXgodCxlKTtDbihcIm1heFwiLGUsdC5yYW5rKTt2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPWsoblsxXSksYT10LmFzMkQoLTEsbyk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJtYXhcIixhLmR0eXBlKS5yZXNoYXBlKHIpfSxvLnByb3RvdHlwZS5tYXhpbXVtPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubWF4aW11bSh0LGUpO3ZhciBuPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgTGEoXCJcXG4gIHZlYzQgcmVzdWx0ID0gdmVjNChtYXgoYSwgYikpO1xcbiAgdmVjNCBpc05hTiA9IG1pbih2ZWM0KGlzbmFuKGEpKSArIHZlYzQoaXNuYW4oYikpLCB2ZWM0KDEuMCkpO1xcbiAgXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPiAwLiA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID4gMC4gPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA+IDAuID8gTkFOIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPiAwLiA/IE5BTiA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBCYShcIlxcbiAgaWYgKGlzbmFuKGEpKSByZXR1cm4gYTtcXG4gIGlmIChpc25hbihiKSkgcmV0dXJuIGI7XFxuXFxuICByZXR1cm4gbWF4KGEsIGIpO1xcblwiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sby5wcm90b3R5cGUuYWxsPWZ1bmN0aW9uKHQsZSl7Q24oXCJhbGxcIixlLHQucmFuayk7dmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1rKG5bMV0pLGE9dC5hczJEKC0xLG8pO3JldHVybiB0aGlzLnJlZHVjZShhLFwiYWxsXCIsYS5kdHlwZSkucmVzaGFwZShyKX0sby5wcm90b3R5cGUuYW55PWZ1bmN0aW9uKHQsZSl7Q24oXCJhbnlcIixlLHQucmFuayk7dmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1rKG5bMV0pLGE9dC5hczJEKC0xLG8pO3JldHVybiB0aGlzLnJlZHVjZShhLFwiYW55XCIsYS5kdHlwZSkucmVzaGFwZShyKX0sby5wcm90b3R5cGUucmVhbERpdmlkZT1mdW5jdGlvbih0LGUpe2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSl7cmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICAvLyB2ZWM0IG9uZSA9IHZlYzQoZXF1YWwoYSwgYikpO1xcbiAgLy8gcmV0dXJuIG9uZSArICh2ZWM0KDEuMCkgLSBvbmUpICogYSAvIGI7XFxuICB2ZWM0IHJlc3VsdCA9IGEgLyBiO1xcbiAgaWYoYS54ID09IGIueCkge1xcbiAgICByZXN1bHQueCA9IDEuO1xcbiAgfVxcbiAgaWYoYS55ID09IGIueSkge1xcbiAgICByZXN1bHQueSA9IDEuO1xcbiAgfVxcbiAgaWYoYS56ID09IGIueikge1xcbiAgICByZXN1bHQueiA9IDEuO1xcbiAgfVxcbiAgaWYoYS53ID09IGIudykge1xcbiAgICByZXN1bHQudyA9IDEuO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIixcImZsb2F0MzJcIiwhMCl9dmFyIG49bmV3IEJhKFwiXFxuaWYgKGEgPT0gYikge1xcbiAgcmV0dXJuIDEuMDtcXG59O1xcbnJldHVybiBhIC8gYjtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmZsb29yRGl2PWZ1bmN0aW9uKHQsZSl7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgaXZlYzQgaWEgPSByb3VuZChhKTtcXG4gIGl2ZWM0IGliID0gcm91bmQoYik7XFxuICBidmVjNCBjb25kID0gbm90RXF1YWwoaWIsIGl2ZWM0KDApKTtcXG4gIGl2ZWM0IHJlc3VsdCA9IGl2ZWM0KDApO1xcbiAgdmVjNCBzID0gc2lnbihhKSAqIHNpZ24oYik7XFxuXFxuICAvLyBXaW5kb3dzIChEM0QpIHdhbnRzIGd1YXJhbnRlZWQgbm9uLXplcm8gaW50IGRpdmlzaW9uIGF0IGNvbXBpbGUtdGltZS5cXG4gIGlmIChjb25kWzBdKSB7XFxuICAgIHJlc3VsdFswXSA9IGlkaXYoaWFbMF0sIGliWzBdLCBzWzBdKTtcXG4gIH1cXG4gIGlmIChjb25kWzFdKSB7XFxuICAgIHJlc3VsdFsxXSA9IGlkaXYoaWFbMV0sIGliWzFdLCBzWzFdKTtcXG4gIH1cXG4gIGlmIChjb25kWzJdKSB7XFxuICAgIHJlc3VsdFsyXSA9IGlkaXYoaWFbMl0sIGliWzJdLCBzWzJdKTtcXG4gIH1cXG4gIGlmIChjb25kWzNdKSB7XFxuICAgIHJlc3VsdFszXSA9IGlkaXYoaWFbM10sIGliWzNdLCBzWzNdKTtcXG4gIH1cXG4gIHJldHVybiB2ZWM0KHJlc3VsdCk7XFxuXCIsXCJpbnQzMlwiKTt2YXIgbj1uZXcgQmEoXCJcXG4gIGZsb2F0IHMgPSBzaWduKGEpICogc2lnbihiKTtcXG4gIGludCBpYSA9IHJvdW5kKGEpO1xcbiAgaW50IGliID0gcm91bmQoYik7XFxuICBpZiAoaWIgIT0gMCkge1xcbiAgICAvLyBXaW5kb3dzIChEM0QpIHdhbnRzIGd1YXJhbnRlZWQgbm9uLXplcm8gaW50IGRpdmlzaW9uIGF0IGNvbXBpbGUtdGltZS5cXG4gICAgcmV0dXJuIGZsb2F0KGlkaXYoaWEsIGliLCBzKSk7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gTkFOO1xcbiAgfVxcblwiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLFwiaW50MzJcIil9LG8ucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0LGUpe2lmKFwiY29tcGxleDY0XCI9PT10LmR0eXBlJiZcImNvbXBsZXg2NFwiPT09ZS5kdHlwZSlyZXR1cm4gdGhpcy5jb21wbGV4U2VwYXJhYmxlQmluYXJ5T3AodCxlLEZhKTtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5hZGQodCxlKTt2YXIgbj1EdCh0LmR0eXBlLGUuZHR5cGUpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsRmEsbik7dmFyIHI9bmV3IEJhKEZhLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdLG4pfSxvLnByb3RvdHlwZS5wYWNrZWRVbmFyeU9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgWHModC5zaGFwZSxlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdLG4pfSxvLnByb3RvdHlwZS5wYWNrZWRCaW5hcnlPcD1mdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PW8mJihvPSExKTt2YXIgYT1uZXcgTGEobix0LnNoYXBlLGUuc2hhcGUsbyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihhLFt0LGVdLHIpfSxvLnByb3RvdHlwZS5jb21wbGV4U2VwYXJhYmxlQmluYXJ5T3A9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMsbz10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxhPXRoaXMudGV4RGF0YS5nZXQoZS5kYXRhSWQpLGk9W1tvLmNvbXBsZXhUZW5zb3JzLnJlYWwsYS5jb21wbGV4VGVuc29ycy5yZWFsXSxbby5jb21wbGV4VGVuc29ycy5pbWFnLGEuY29tcGxleFRlbnNvcnMuaW1hZ11dLm1hcCgoZnVuY3Rpb24obyl7dmFyIGE9b1swXSxpPW9bMV0scz1yLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyh0LGEpLHU9ci5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm8oZSxpKSxjPW5ldyBCYShuLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHIuY29tcGlsZUFuZFJ1bihjLFtzLHVdLER0KGEuZHR5cGUsaS5kdHlwZSkpfSkpLHM9aVswXSx1PWlbMV0sYz10aGlzLmNvbXBsZXgocyx1KTtyZXR1cm4gcy5kaXNwb3NlKCksdS5kaXNwb3NlKCksY30sby5wcm90b3R5cGUubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvPWZ1bmN0aW9uKHQsZSl7cmV0dXJue2RhdGFJZDplLmRhdGFJZCxkdHlwZTplLmR0eXBlLHNoYXBlOnQuc2hhcGV9fSxvLnByb3RvdHlwZS5hZGROPWZ1bmN0aW9uKHQpe2lmKDE9PT10Lmxlbmd0aClyZXR1cm4gdFswXTtpZih0Lmxlbmd0aD5pKCkuZ2V0KFwiV0VCR0xfTUFYX1RFWFRVUkVTX0lOX1NIQURFUlwiKSl7dmFyIGU9TWF0aC5mbG9vcih0Lmxlbmd0aC8yKSxuPXRoaXMuYWRkTih0LnNsaWNlKDAsZSkpLHI9dGhpcy5hZGROKHQuc2xpY2UoZSkpO3JldHVybiB0aGlzLmFkZE4oW24scl0pfXZhciBvPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5kdHlwZX0pKS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIER0KHQsZSl9KSksYT10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSkscz1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIik/bmV3IG9hKHRbMF0uc2hhcGUsYSk6bmV3IHJhKHRbMF0uc2hhcGUsYSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihzLHQsbyl9LG8ucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKHQsZSl7aWYoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUmJlwiY29tcGxleDY0XCI9PT1lLmR0eXBlKXJldHVybiB0aGlzLmNvbXBsZXhTZXBhcmFibGVCaW5hcnlPcCh0LGUsX2EpO2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnN1YnRyYWN0KHQsZSk7dmFyIG49RHQodC5kdHlwZSxlLmR0eXBlKTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLF9hLHQuZHR5cGUpO3ZhciByPW5ldyBCYShfYSx0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSxuKX0sby5wcm90b3R5cGUucG93PWZ1bmN0aW9uKHQsZSl7dmFyIG49aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBMYShcIlxcbiAgLy8gaXNNb2RSb3VuZDEgaGFzIDEgZm9yIGNvbXBvbmVudHMgd2l0aCByb3VuZChtb2QoYiwgMi4wKSkgPT0gMSwgMCBvdGhlcndpc2UuXFxuICB2ZWM0IGlzTW9kUm91bmQxID0gdmVjNChlcXVhbChyb3VuZChtb2QoYiwgMi4wKSksIGl2ZWM0KDEpKSk7XFxuICB2ZWM0IG11bHRpcGxpZXIgPSBzaWduKGEpICogaXNNb2RSb3VuZDEgKyAodmVjNCgxLjApIC0gaXNNb2RSb3VuZDEpO1xcbiAgdmVjNCByZXN1bHQgPSBtdWx0aXBsaWVyICogcG93KGFicyhhKSwgYik7XFxuXFxuICAvLyBFbnN1cmUgdGhhdCBhXjAgPSAxLCBpbmNsdWRpbmcgMF4wID0gMSBhcyB0aGlzIGNvcnJlc3BvbmQgdG8gVEYgYW5kIEpTXFxuICBidmVjNCBpc0V4cFplcm8gPSBlcXVhbChiLCB2ZWM0KDAuMCkpO1xcbiAgcmVzdWx0LnIgPSBpc0V4cFplcm8uciA/IDEuMCA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc0V4cFplcm8uZyA/IDEuMCA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc0V4cFplcm8uYiA/IDEuMCA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc0V4cFplcm8uYSA/IDEuMCA6IHJlc3VsdC5hO1xcblxcbiAgdmVjNCBpc05hTiA9IHZlYzQobGVzc1RoYW4oYSwgdmVjNCgwLjApKSkgKiB2ZWM0KGxlc3NUaGFuKGZsb29yKGIpLCBiKSk7XFxuICBcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA+IDAuID8gTkFOIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPiAwLiA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID4gMC4gPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA+IDAuID8gTkFOIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IEJhKFwiXFxuaWYoYSA8IDAuMCAmJiBmbG9vcihiKSA8IGIpe1xcbiAgcmV0dXJuIE5BTjtcXG59XFxuaWYgKGIgPT0gMC4wKSB7XFxuICByZXR1cm4gMS4wO1xcbn1cXG5yZXR1cm4gKHJvdW5kKG1vZChiLCAyLjApKSAhPSAxKSA/XFxuICAgIHBvdyhhYnMoYSksIGIpIDogc2lnbihhKSAqIHBvdyhhYnMoYSksIGIpO1xcblwiLHQuc2hhcGUsZS5zaGFwZSkscj1EdCh0LmR0eXBlLGUuZHR5cGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxyKX0sby5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbih0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuY2VpbCh0KTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHQsTnMsdC5kdHlwZSk7dmFyIGU9bmV3IENzKHQuc2hhcGUsTnMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbih0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuZmxvb3IodCk7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX1VOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkVW5hcnlPcCh0LEZzLHQuZHR5cGUpO3ZhciBlPW5ldyBDcyh0LnNoYXBlLEZzKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcIlxcbiAgaWYgKGlzbmFuKHgpKSB7IHJldHVybiAwLjA7IH1cXG4gIHJldHVybiBzaWduKHgpO1xcblwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuaXNOYU49ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJyZXR1cm4gZmxvYXQoaXNuYW4oeCkpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUuaXNJbmY9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJyZXR1cm4gZmxvYXQoaXNpbmYoeCkpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUuaXNGaW5pdGU9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJyZXR1cm4gZmxvYXQoIWlzbmFuKHgpICYmICFpc2luZih4KSk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcIlxcbiAgLy8gT3BlbkdMIEVTIGRvZXMgbm90IHN1cHBvcnQgcm91bmQgZnVuY3Rpb24uXFxuICAvLyBUaGUgYWxnb3JpdGhtIGlzIGJhc2VkIG9uIGJhbmtlcidzIHJvdW5kaW5nLlxcbiAgZmxvYXQgYmFzZSA9IGZsb29yKHgpO1xcbiAgaWYgKCh4IC0gYmFzZSkgPCAwLjUpIHtcXG4gICAgcmV0dXJuIGZsb29yKHgpO1xcbiAgfSBlbHNlIGlmICgoeCAtIGJhc2UpID4gMC41KSB7XFxuICAgIHJldHVybiBjZWlsKHgpO1xcbiAgfSBlbHNlIHtcXG4gICAgaWYgKG1vZChiYXNlLCAyLjApID09IDAuMCkge1xcbiAgICAgIHJldHVybiBiYXNlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBiYXNlICsgMS4wO1xcbiAgICB9XFxuICB9XFxuXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5leHA9ZnVuY3Rpb24odCl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmV4cCh0KTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHQsX3MsdC5kdHlwZSk7dmFyIGU9bmV3IENzKHQuc2hhcGUsX3MpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5leHBtMT1mdW5jdGlvbih0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuZXhwbTEodCk7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX1VOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkVW5hcnlPcCh0LE9zLHQuZHR5cGUpO3ZhciBlPW5ldyBDcyh0LnNoYXBlLE9zKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuc29mdG1heD1mdW5jdGlvbih0LGUpe3ZhciBuPU8oW2VdLHQuc2hhcGUpLHI9dGhpcy5tYXgodCxuKSxvPXduKHIuc2hhcGUsbiksYT10aGlzLnN1YnRyYWN0KHQsci5yZXNoYXBlKG8pKSxpPXRoaXMuZXhwKGEpLHM9dGhpcy5zdW0oaSxuKS5yZXNoYXBlKG8pO3JldHVybiB0aGlzLnJlYWxEaXZpZGUoaSxzKX0sby5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5sb2codCk7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX1VOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkVW5hcnlPcCh0LFwiXFxuICB2ZWM0IHJlc3VsdCA9IGxvZyh4KTtcXG4gIHZlYzQgaXNOYU4gPSB2ZWM0KGxlc3NUaGFuKHgsIHZlYzQoMC4wKSkpO1xcbiAgcmVzdWx0LnIgPSBpc05hTi5yID09IDEuMCA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID09IDEuMCA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID09IDEuMCA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID09IDEuMCA/IE5BTiA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIix0LmR0eXBlKTt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcImlmICh4IDwgMC4wKSByZXR1cm4gTkFOO1xcbiAgcmV0dXJuIGxvZyh4KTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmxvZzFwPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwicmV0dXJuIGxvZygxLjAgKyB4KTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJyZXR1cm4gc3FydCh4KTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnJzcXJ0PWZ1bmN0aW9uKHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5yc3FydCh0KTt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcInJldHVybiBpbnZlcnNlc3FydCh4KTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnJlY2lwcm9jYWw9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJyZXR1cm4gMS4wIC8geDtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnJlbHU9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpP25ldyBYcyh0LnNoYXBlLHFzKTpuZXcgQ3ModC5zaGFwZSxrcyksdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUucmVsdTY9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpP25ldyBYcyh0LnNoYXBlLEtzKTpuZXcgQ3ModC5zaGFwZSxTcyksdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUucHJlbHU9ZnVuY3Rpb24odCxlKXt2YXIgbj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IExhKFBhLHQuc2hhcGUsZS5zaGFwZSk6bmV3IEJhKE1hLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sby5wcm90b3R5cGUuZWx1PWZ1bmN0aW9uKHQpe2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZFVuYXJ5T3AodCxqcyx0LmR0eXBlKTt2YXIgZT1uZXcgQ3ModC5zaGFwZSxBcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmVsdURlcj1mdW5jdGlvbih0LGUpe3ZhciBuPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgTGEoXCJcXG4gIHZlYzQgYkdURVplcm8gPSB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYiwgdmVjNCgwLikpKTtcXG4gIHJldHVybiAoYkdURVplcm8gKiBhKSArICgodmVjNCgxLjApIC0gYkdURVplcm8pICogKGEgKiAoYiArIHZlYzQoMS4wKSkpKTtcXG5cIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBCYShcInJldHVybiAoYiA+PSAxLjApID8gYSA6IGEgKiAoYiArIDEuMCk7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0pfSxvLnByb3RvdHlwZS5zZWx1PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLERzKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuaW50PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwicmV0dXJuIGZsb2F0KGludCh4KSk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0sXCJpbnQzMlwiKX0sby5wcm90b3R5cGUuY2xpcD1mdW5jdGlvbih0LGUsbil7dmFyIHIsbz0ocj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQ0xJUFwiKT9uZXcgVWEodC5zaGFwZSk6bmV3IFdhKHQuc2hhcGUpKS5nZXRDdXN0b21TZXR1cEZ1bmMoZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdLG51bGwsbyl9LG8ucHJvdG90eXBlLmFicz1mdW5jdGlvbih0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuYWJzKHQpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZFVuYXJ5T3AodCxJcyx0LmR0eXBlKTt2YXIgZT1uZXcgQ3ModC5zaGFwZSxJcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmNvbXBsZXhBYnM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCksbj1uZXcgVmEodC5zaGFwZSkscj1bdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm8odCxlLmNvbXBsZXhUZW5zb3JzLnJlYWwpLHRoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvKHQsZS5jb21wbGV4VGVuc29ycy5pbWFnKV07cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLHIpfSxvLnByb3RvdHlwZS5zaWdtb2lkPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwicmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLTEuMCAqIHgpKTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnNvZnRwbHVzPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwiXFxuICBmbG9hdCBlcHNpbG9uID0gMS4xOTIwOTI4OTU1MDc4MTI1ZS03O1xcbiAgZmxvYXQgdGhyZXNob2xkID0gbG9nKGVwc2lsb24pICsgMi4wO1xcblxcbiAgYm9vbCB0b29fbGFyZ2UgPSB4ID4gLXRocmVzaG9sZDtcXG4gIGJvb2wgdG9vX3NtYWxsID0geCA8IHRocmVzaG9sZDtcXG5cXG4gIGZsb2F0IHJlc3VsdDtcXG4gIGZsb2F0IGV4cF94ID0gZXhwKHgpO1xcblxcbiAgaWYgKHRvb19sYXJnZSl7XFxuICAgIHJlc3VsdCA9IHg7XFxuICB9XFxuICBlbHNlIGlmICh0b29fc21hbGwpe1xcbiAgICByZXN1bHQgPSBleHBfeDtcXG4gIH1cXG4gIGVsc2V7XFxuICAgIHJlc3VsdCA9IGxvZyhleHBfeCArIDEuMCk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcblwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuc2luPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLE1zKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLEJzKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwicmV0dXJuIHRhbih4KTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsUHMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLExzKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxXcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmF0YW4yPWZ1bmN0aW9uKHQsZSl7dmFyIG49aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBMYShcIlxcbiAgdmVjNCByZXN1bHQgPSBhdGFuKGEsIGIpO1xcbiAgdmVjNCBpc05hTiA9IG1pbih2ZWM0KGlzbmFuKGEpKSArIHZlYzQoaXNuYW4oYikpLCB2ZWM0KDEuMCkpO1xcbiAgXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPiAwLiA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID4gMC4gPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA+IDAuID8gTkFOIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPiAwLiA/IE5BTiA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBCYShcIlxcbiAgaWYgKGlzbmFuKGEpKSByZXR1cm4gYTtcXG4gIGlmIChpc25hbihiKSkgcmV0dXJuIGI7XFxuXFxuICByZXR1cm4gYXRhbihhLCBiKTtcXG5cIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LG8ucHJvdG90eXBlLnNpbmg9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCh4KTtcXG4gIHJldHVybiAoZTJ4IC0gMS4wIC8gZTJ4KSAvIDIuMDtcXG5cIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCgteCk7XFxuICByZXR1cm4gKGUyeCArIDEuMCAvIGUyeCkgLyAyLjA7XFxuXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwiXFxuICBmbG9hdCBlMnggPSBleHAoLTIuMCAqIGFicyh4KSk7XFxuICByZXR1cm4gc2lnbih4KSAqICgxLjAgLSBlMngpIC8gKDEuMCArIGUyeCk7XFxuXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5hc2luaD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxVcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFZzKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsenMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5lcmY9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsJ1xcbiAgLy8gRXJyb3IgZnVuY3Rpb24gaXMgY2FsY3VsYXRlZCBhcHByb3hpbWF0ZWx5IHdpdGggZWxlbWVudGFyeSBmdW5jdGlvbi5cXG4gIC8vIFNlZSBcIkhhbmRib29rIG9mIE1hdGhlbWF0aWNhbCBGdW5jdGlvbnMgd2l0aCBGb3JtdWxhcyxcXG4gIC8vIEdyYXBocywgYW5kIE1hdGhlbWF0aWNhbCBUYWJsZXNcIiwgQWJyYW1vd2l0eiBhbmQgU3RlZ3VuLlxcbiAgZmxvYXQgcCA9IDAuMzI3NTkxMTtcXG4gIGZsb2F0IGExID0gMC4yNTQ4Mjk1OTI7XFxuICBmbG9hdCBhMiA9IC0wLjI4NDQ5NjczNjtcXG4gIGZsb2F0IGEzID0gMS40MjE0MTM3NDE7XFxuICBmbG9hdCBhNCA9IC0xLjQ1MzE1MjAyNztcXG4gIGZsb2F0IGE1ID0gMS4wNjE0MDU0Mjk7XFxuXFxuICBmbG9hdCBzaWduID0gc2lnbih4KTtcXG4gIHggPSBhYnMoeCk7XFxuICBmbG9hdCB0ID0gMS4wIC8gKDEuMCArIHAgKiB4KTtcXG4gIHJldHVybiBzaWduICogKDEuMCAtICgoKCgoYTUqdCArIGE0KSp0KSArIGEzKSp0ICsgYTIpKnQgKyBhMSkqdCpleHAoLXgqeCkpO1xcbicpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5zdGVwPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IENzKHQuc2hhcGUsZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLEVzK1wiXFxuICAgIHJldHVybiB4ID4gMC4wID8gMS4wIDogZmxvYXQoXCIrdCtcIik7XFxuICBcIn0oZSkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0pfSxvLnByb3RvdHlwZS5jb252MmRCeU1hdE11bD1mdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIHM9dC5zaGFwZSx1PXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLGM9bi5pbkNoYW5uZWxzLGw9c1swXSpzWzFdKnNbMl0saD1uLm91dENoYW5uZWxzLGY9XCJjaGFubmVsc0xhc3RcIj09PW4uZGF0YUZvcm1hdCxkPSgxPT09bHx8MT09PWgpJiZjPjFlMyxwPXNbMl0lMiE9MCYmISF1LmlzUGFja2VkO2lmKGR8fCFpKCkuZ2V0Qm9vbChcIldFQkdMX0xBWklMWV9VTlBBQ0tcIil8fCFpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIil8fCFwKXt2YXIgdj1mP3NbMF0qc1sxXSpzWzJdOnNbMF0qc1syXSpzWzNdLG09dGhpcy5yZXNoYXBlKHQsWzEsdixuLmluQ2hhbm5lbHNdKSxnPXRoaXMucmVzaGFwZShlLFsxLG4uaW5DaGFubmVscyxuLm91dENoYW5uZWxzXSk7cmV0dXJuIHRoaXMucmVzaGFwZSh0aGlzLmZ1c2VkQmF0Y2hNYXRNdWwoe2E6bSxiOmcsdHJhbnNwb3NlQTohMSx0cmFuc3Bvc2VCOiExLGJpYXM6cixhY3RpdmF0aW9uOm8scHJlbHVBY3RpdmF0aW9uV2VpZ2h0czphfSksbi5vdXRTaGFwZSl9dmFyIHk9Zj9zWzBdKnNbMV0qKHNbMl0rMSk6c1swXSpzWzJdKihzWzNdKzEpLHg9e2RhdGFJZDp0LmRhdGFJZCxzaGFwZTpbMSx5LG4uaW5DaGFubmVsc10sZHR5cGU6dC5kdHlwZX0sYj11LnNoYXBlO3Uuc2hhcGU9dS5zaGFwZS5zbGljZSgpLHUuc2hhcGVbdS5zaGFwZS5sZW5ndGgtMl0rKyxDKF9lKHUuc2hhcGUseC5zaGFwZSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJwYWNrZWQgcmVzaGFwZSBcIit1LnNoYXBlK1wiIHRvIFwiK3guc2hhcGUrXCIgaXNuJ3QgZnJlZVwifSkpO3ZhciB3PXRoaXMucmVzaGFwZShlLFsxLG4uaW5DaGFubmVscyxuLm91dENoYW5uZWxzXSksRT10aGlzLmZ1c2VkQmF0Y2hNYXRNdWwoe2E6eCxiOncsdHJhbnNwb3NlQTohMSx0cmFuc3Bvc2VCOiExLGJpYXM6cixhY3RpdmF0aW9uOm8scHJlbHVBY3RpdmF0aW9uV2VpZ2h0czphfSksUj10aGlzLnRleERhdGEuZ2V0KEUuZGF0YUlkKTtyZXR1cm4gQyhSLmlzUGFja2VkLChmdW5jdGlvbigpe3JldHVyblwiYmF0Y2hNYXRNdWwgcmVzdWx0IGlzIGV4cGVjdGVkIHRvIGJlIHBhY2tlZFwifSkpLHUuc2hhcGU9YixSLnNoYXBlPW4ub3V0U2hhcGUsTHQubWFrZVRlbnNvckZyb21EYXRhSWQoRS5kYXRhSWQsbi5vdXRTaGFwZSxFLmR0eXBlKX0sby5wcm90b3R5cGUuY29udjJkV2l0aEltMlJvdz1mdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9bi5maWx0ZXJXaWR0aCxzPW4uZmlsdGVySGVpZ2h0LHU9bi5pbkNoYW5uZWxzLGM9bi5vdXRXaWR0aCxsPW4ub3V0SGVpZ2h0LGg9XCJjaGFubmVsc0xhc3RcIj09PW4uZGF0YUZvcm1hdCxmPWkqcyp1LGQ9bCpjLHA9W2YsZF0sdj10LnNxdWVlemUoWzBdKSxtPWUucmVzaGFwZShbMSxmLC0xXSksZz1uZXcgTGkocCx2LnNoYXBlLG4pLHk9dGhpcy5jb21waWxlQW5kUnVuKGcsW3ZdKS5yZXNoYXBlKFsxLHBbMF0scFsxXV0pLHg9bnVsbCE9cixiPW51bGwhPWEsdz1vP1FzKG8sITApOm51bGwsQz1uZXcgSGkoeS5zaGFwZSxbMSxkLG4ub3V0Q2hhbm5lbHNdLCEwLCExLHgsdyxiKSxFPVt5LG1dO3ImJkUucHVzaChyKSxiJiZFLnB1c2goYSk7dmFyIFI9dGhpcy5jb21waWxlQW5kUnVuKEMsRSk7cmV0dXJuIGg/Ui5yZXNoYXBlKFsxLGwsYyxuLm91dENoYW5uZWxzXSk6Ui5yZXNoYXBlKFsxLG4ub3V0Q2hhbm5lbHMsbCxjXSl9LG8ucHJvdG90eXBlLmZ1c2VkQ29udjJkPWZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5wdXQsbj10LmZpbHRlcixyPXQuY29udkluZm8sbz10LmJpYXMsYT10LmFjdGl2YXRpb24scz10LnByZWx1QWN0aXZhdGlvbldlaWdodHM7aWYoMT09PXIuZmlsdGVySGVpZ2h0JiYxPT09ci5maWx0ZXJXaWR0aCYmMT09PXIuZGlsYXRpb25IZWlnaHQmJjE9PT1yLmRpbGF0aW9uV2lkdGgmJjE9PT1yLnN0cmlkZUhlaWdodCYmMT09PXIuc3RyaWRlV2lkdGgmJihcIlNBTUVcIj09PXIucGFkSW5mby50eXBlfHxcIlZBTElEXCI9PT1yLnBhZEluZm8udHlwZSkpcmV0dXJuIHRoaXMuY29udjJkQnlNYXRNdWwoZSxuLHIsbyxhLHMpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfQ09OVl9JTTJDT0xcIikmJjE9PT1lLnNoYXBlWzBdKXJldHVybiB0aGlzLmNvbnYyZFdpdGhJbTJSb3coZSxuLHIsbyxhLHMpO3ZhciB1PW51bGwhPW8sYz1udWxsIT1zLGw9YT9RcyhhLCExKTpudWxsLGg9bmV3IFFhKHIsdSxsLGMpLGY9W2Usbl07cmV0dXJuIG8mJmYucHVzaChvKSxzJiZmLnB1c2gocyksdGhpcy5jb21waWxlQW5kUnVuKGgsZil9LG8ucHJvdG90eXBlLmNvbnYyZD1mdW5jdGlvbih0LGUsbil7aWYoMT09PW4uZmlsdGVySGVpZ2h0JiYxPT09bi5maWx0ZXJXaWR0aCYmMT09PW4uZGlsYXRpb25IZWlnaHQmJjE9PT1uLmRpbGF0aW9uV2lkdGgmJjE9PT1uLnN0cmlkZUhlaWdodCYmMT09PW4uc3RyaWRlV2lkdGgmJihcIlNBTUVcIj09PW4ucGFkSW5mby50eXBlfHxcIlZBTElEXCI9PT1uLnBhZEluZm8udHlwZSkpcmV0dXJuIHRoaXMuY29udjJkQnlNYXRNdWwodCxlLG4pO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfQ09OVl9JTTJDT0xcIikmJjE9PT10LnNoYXBlWzBdKXJldHVybiB0aGlzLmNvbnYyZFdpdGhJbTJSb3codCxlLG4pO3ZhciByPW5ldyBRYShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSxvLnByb3RvdHlwZS5jb252MmREZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IEthKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LG8ucHJvdG90eXBlLmNvbnYyZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IHFhKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LG8ucHJvdG90eXBlLmZ1c2VkRGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKHQpe3ZhciBlLG49dC5pbnB1dCxyPXQuZmlsdGVyLG89dC5jb252SW5mbyxhPXQuYmlhcyxzPXQuYWN0aXZhdGlvbix1PXQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyxjPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19ERVBUSFdJU0VDT05WXCIpJiZvLnN0cmlkZVdpZHRoPD0yJiZvLm91dENoYW5uZWxzL28uaW5DaGFubmVscz09MSxsPXM/UXMocyxjKTpudWxsLGg9W24scl0sZj1udWxsIT1hLGQ9bnVsbCE9dTtyZXR1cm4gZiYmaC5wdXNoKGEpLGQmJmgucHVzaCh1KSxjPyhlPW5ldyB0aShvLGYsbCxkKSx0aGlzLmNvbXBpbGVBbmRSdW4oZSxoKSk6KGU9bmV3IFphKG8sZixsLGQpLHRoaXMuY29tcGlsZUFuZFJ1bihlLGgpKX0sby5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcjtyZXR1cm4gaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0RFUFRIV0lTRUNPTlZcIikmJm4uc3RyaWRlV2lkdGg8PTImJm4ub3V0Q2hhbm5lbHMvbi5pbkNoYW5uZWxzPT0xPyhyPW5ldyB0aShuKSx0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSkpOihyPW5ldyBaYShuKSx0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSkpfSxvLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3ICRhKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LG8ucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IFlhKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LG8ucHJvdG90eXBlLmNvbnYzZD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IEphKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LG8ucHJvdG90eXBlLmNvbnYzZERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgWGEobik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sby5wcm90b3R5cGUuY29udjNkRGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgamEobik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sby5wcm90b3R5cGUubWF4UG9vbD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyAkaShlLFwibWF4XCIsITEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0pfSxvLnByb3RvdHlwZS5hdmdQb29sPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3ICRpKGUsXCJhdmdcIiwhMSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0XSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLm1heFBvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uZXcgJGkocixcIm1heFwiLCEwKSxhPXRoaXMuY29tcGlsZUFuZFJ1bihvLFtlXSksaT1uZXcgemkocikscz10aGlzLmNvbXBpbGVBbmRSdW4oaSxbdCxhXSxlLmR0eXBlKTtyZXR1cm4gYS5kaXNwb3NlKCksc30sby5wcm90b3R5cGUuYXZnUG9vbEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgSWEobik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSxlLmR0eXBlKX0sby5wcm90b3R5cGUuY2FzdD1mdW5jdGlvbih0LGUpe3JldHVybiBQbyh0LGUsdGhpcyl9LG8ucHJvdG90eXBlLnVuc3RhY2s9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5zaGFwZVtlXSxyPW5ldyBBcnJheSh0LnJhbmstMSksbz0wLGE9MDthPHQucmFuazthKyspYSE9PWUmJihyW28rK109dC5zaGFwZVthXSk7dmFyIGk9bmV3IEFycmF5KHQucmFuaykuZmlsbCgwKSxzPXQuc2hhcGUuc2xpY2UoKTtzW2VdPTE7dmFyIHU9bmV3IEFycmF5KG4pO2ZvcihhPTA7YTx1Lmxlbmd0aDthKyspaVtlXT1hLHVbYV09dGhpcy5zbGljZSh0LGkscykucmVzaGFwZShyKTtyZXR1cm4gdX0sby5wcm90b3R5cGUuYXZnUG9vbDNkPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IFFpKGUsXCJhdmdcIiwhMSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0XSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmF2Z1Bvb2wzZEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcga2Eobik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSxlLmR0eXBlKX0sby5wcm90b3R5cGUubWF4UG9vbDNkPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IFFpKGUsXCJtYXhcIiwhMSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0XSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLm1heFBvb2wzZEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPW5ldyBRaShyLFwibWF4XCIsITApLGE9dGhpcy5jb21waWxlQW5kUnVuKG8sW2VdKSxpPW5ldyBHaShyKSxzPXRoaXMuY29tcGlsZUFuZFJ1bihpLFt0LGFdLGUuZHR5cGUpO3JldHVybiBhLmRpc3Bvc2UoKSxzfSxvLnByb3RvdHlwZS5yZXNoYXBlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCk7aWYobi5pc1BhY2tlZCYmIV9lKHQuc2hhcGUsZSkmJihudWxsPT09bi50ZXh0dXJlfHwhX2Uobi5zaGFwZSxlKSkpe3ZhciByPXRoaXMucGFja2VkUmVzaGFwZSh0LGUpO3JldHVybiBMdC5tYWtlVGVuc29yRnJvbURhdGFJZChyLmRhdGFJZCxyLnNoYXBlLHIuZHR5cGUpfXJldHVybiBMbyh0LGUpfSxvLnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcj1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfSU1BR0VfT1BFUkFUSU9OU1wiKT9uZXcgbnModC5zaGFwZSxlLG4scik6bmV3IGVzKHQuc2hhcGUsZSxuLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obyxbdF0sXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5yZXNpemVCaWxpbmVhckJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgdHModCxlLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0pfSxvLnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3I9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89bmV3IG9zKHQuc2hhcGUsZSxuLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obyxbdF0pfSxvLnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IHJzKHQsZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdKX0sby5wcm90b3R5cGUubXVsdGlub21pYWw9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89ZT90OmdvKHQpLGE9by5zaGFwZVswXSxpPW8uc2hhcGVbMV0scz1uZXcgcWkoYSxpLG4pLHU9cy5nZXRDdXN0b21TZXR1cEZ1bmMocik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihzLFtvXSxcImludDMyXCIsdSl9LG8ucHJvdG90eXBlLm9uZUhvdD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uZXcgS2kodC5zaXplLGUsbixyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW3RdKX0sby5wcm90b3R5cGUuZGlhZz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgc2kodC5zaXplKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUubm9uTWF4U3VwcHJlc3Npb249ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gZG4oXCJ0Zi5ub25NYXhTdXBwcmVzc2lvbigpIGluIHdlYmdsIGxvY2tzIHRoZSBVSSB0aHJlYWQuIENhbGwgdGYubm9uTWF4U3VwcHJlc3Npb25Bc3luYygpIGluc3RlYWRcIiksam8odC5kYXRhU3luYygpLGUuZGF0YVN5bmMoKSxuLHIsbyl9LG8ucHJvdG90eXBlLmNyb3BBbmRSZXNpemU9ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPW5ldyBlaSh0LnNoYXBlLGUuc2hhcGUscixvLGEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaSxbdCxlLG5dLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuZGVwdGhUb1NwYWNlPWZ1bmN0aW9uKHQsZSxuKXtDKGU+MSwoZnVuY3Rpb24oKXtyZXR1cm5cImJsb2NrU2l6ZSBzaG91bGQgYmUgPiAxIGZvciBkZXB0aFRvU3BhY2UsIGJ1dCB3YXM6IFwiK2V9KSk7dmFyIHI9dC5zaGFwZVswXSxvPVwiTkhXQ1wiPT09bj90LnNoYXBlWzFdOnQuc2hhcGVbMl0sYT1cIk5IV0NcIj09PW4/dC5zaGFwZVsyXTp0LnNoYXBlWzNdLGk9XCJOSFdDXCI9PT1uP3Quc2hhcGVbM106dC5zaGFwZVsxXSxzPW8qZSx1PWEqZSxjPWkvKGUqZSksbD1uZXcgaWkoXCJOSFdDXCI9PT1uP1tyLHMsdSxjXTpbcixjLHMsdV0sZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGwsW3RdKX0sby5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBabyh0LGUsbil9LG8ucHJvdG90eXBlLnNjYXR0ZXJORD1mdW5jdGlvbih0LGUsbil7dmFyIHI9WnIoMCx0LG4pLG89ci5zbGljZVJhbmssYT1yLm51bVVwZGF0ZXMsaT1yLnNsaWNlU2l6ZSxzPXIuc3RyaWRlcyx1PXIub3V0cHV0U2l6ZSxjPVt1L2ksaV0sbD10LnJlc2hhcGUoW2Esb10pLGg9ZS5yZXNoYXBlKFthLGldKTtpZigwPT09dSlyZXR1cm4gTG8oRm4oW10pLG4pO3ZhciBmPU9uKDApLGQ9bmV3IHNzKGEsbyxsLnJhbmssaC5yYW5rLHMsYyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihkLFtoLGwsZl0pLnJlc2hhcGUobil9LG8ucHJvdG90eXBlLnNwYXJzZVRvRGVuc2U9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89WnIoMCx0LG4pLGE9by5zbGljZVJhbmssaT1vLm51bVVwZGF0ZXMscz1vLnN0cmlkZXMsdT1vLm91dHB1dFNpemUsYz1uZXcgc3MoaSxhLHQucmFuayxlLnJhbmsscyxbdSwxXSwhMSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihjLFtlLHQscl0pLnJlc2hhcGUobil9LG8ucHJvdG90eXBlLmZmdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mZnRJbXBsKHQsITEpfSxvLnByb3RvdHlwZS5pZmZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZmdEltcGwodCwhMCl9LG8ucHJvdG90eXBlLmZmdEltcGw9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxyPW5ldyBwaShmaSx0LnNoYXBlLGUpLG89bmV3IHBpKGRpLHQuc2hhcGUsZSksYT1bdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm8odCxuLmNvbXBsZXhUZW5zb3JzLnJlYWwpLHRoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvKHQsbi5jb21wbGV4VGVuc29ycy5pbWFnKV0saT10aGlzLmNvbXBpbGVBbmRSdW4ocixhKSxzPXRoaXMuY29tcGlsZUFuZFJ1bihvLGEpLHU9dGhpcy5jb21wbGV4KGkscykuYXMyRCh0LnNoYXBlWzBdLHQuc2hhcGVbMV0pO3JldHVybiBpLmRpc3Bvc2UoKSxzLmRpc3Bvc2UoKSx1fSxvLnByb3RvdHlwZS5nYXRoZXJORD1mdW5jdGlvbih0LGUpe3ZhciBuPWUuc2hhcGUscj1uW24ubGVuZ3RoLTFdLG89anIodCxlKSxhPW9bMF0saT1vWzFdLHM9b1syXSx1PW9bM10sYz1lLnJlc2hhcGUoW2kscl0pLGw9dC5yZXNoYXBlKFt0LnNpemUvcyxzXSksaD1uZXcgZ2kocix1LFtpLHNdKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGgsW2wsY10pLnJlc2hhcGUoYSl9LG8ucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24odCxlLG4pe2lmKFwic3RyaW5nXCI9PT0obj1ufHxqKGUpKSl7dmFyIHI9UChuLGsodCkpO3JldHVybiByLmZpbGwoZSksTHQubWFrZVRlbnNvcihyLHQsbix0aGlzKX12YXIgbz1uZXcgdmkodCxlKSxhPW8uZ2V0Q3VzdG9tU2V0dXBGdW5jKGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obyxbXSxuLGEpfSxvLnByb3RvdHlwZS5vbmVzTGlrZT1mdW5jdGlvbih0KXtpZihcInN0cmluZ1wiPT09dC5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJvbmVzTGlrZSBpcyBub3Qgc3VwcG9ydGVkIHVuZGVyIHN0cmluZyBkdHlwZVwiKTtyZXR1cm4gdGhpcy5maWxsKHQuc2hhcGUsMSx0LmR0eXBlKX0sby5wcm90b3R5cGUuemVyb3NMaWtlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZpbGwodC5zaGFwZSxcInN0cmluZ1wiPT09dC5kdHlwZT9cIlwiOjAsdC5kdHlwZSl9LG8ucHJvdG90eXBlLmxpbnNwYWNlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gV28odCxlLG4pfSxvLnByb3RvdHlwZS5tYWtlVGVuc29ySW5mbz1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMud3JpdGUobnVsbCx0LGUpO3JldHVybiB0aGlzLnRleERhdGEuZ2V0KG4pLnVzYWdlPW51bGwse2RhdGFJZDpuLHNoYXBlOnQsZHR5cGU6ZX19LG8ucHJvdG90eXBlLm1ha2VPdXRwdXQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLm1ha2VUZW5zb3JJbmZvKHQsZSkuZGF0YUlkO3JldHVybiBMdC5tYWtlVGVuc29yRnJvbURhdGFJZChuLHQsZSx0aGlzKX0sby5wcm90b3R5cGUudW5wYWNrVGVuc29yPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBZcyh0LnNoYXBlKTtyZXR1cm4gdGhpcy5ydW5XZWJHTFByb2dyYW0oZSxbdF0sdC5kdHlwZSl9LG8ucHJvdG90eXBlLnBhY2tUZW5zb3I9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGppKHQuc2hhcGUpO3JldHVybiB0aGlzLnJ1bldlYkdMUHJvZ3JhbShlLFt0XSx0LmR0eXBlLG51bGwsITApfSxvLnByb3RvdHlwZS5wYWNrZWRSZXNoYXBlPWZ1bmN0aW9uKHQsZSl7dmFyIG49W0FlKHQuc2hhcGUpXS5jb25jYXQoRGUodC5zaGFwZSkpLHI9e2R0eXBlOnQuZHR5cGUsc2hhcGU6bixkYXRhSWQ6dC5kYXRhSWR9LG89W0FlKGUpXS5jb25jYXQoRGUoZSkpLGE9bmV3IFppKG8sbiksaT10aGlzLnJ1bldlYkdMUHJvZ3JhbShhLFtyXSx0LmR0eXBlLG51bGwsITApO3JldHVybntkYXRhSWQ6aS5kYXRhSWQsc2hhcGU6ZSxkdHlwZTppLmR0eXBlfX0sby5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKHQpe3ZhciBlLG49dGhpcy50ZXhEYXRhLmdldCh0KSxyPW4uaXNQYWNrZWQsbz1uLnNoYXBlLGE9bi5kdHlwZSxpPVRlKG8pO2U9cj9uZXcgYWkoaSk6bmV3IG9pKGkpO3JldHVybntkdHlwZTphLHNoYXBlOm8sZGF0YUlkOnRoaXMucnVuV2ViR0xQcm9ncmFtKGUsW3tzaGFwZTppLGR0eXBlOmEsZGF0YUlkOnR9XSxhLG51bGwsITApLmRhdGFJZH19LG8ucHJvdG90eXBlLnJ1bldlYkdMUHJvZ3JhbT1mdW5jdGlvbih0LGUsbixyLG8pe3ZhciBhPXRoaXM7dm9pZCAwPT09byYmKG89ITEpO3ZhciBzPXRoaXMubWFrZVRlbnNvckluZm8odC5vdXRwdXRTaGFwZSxuKSx1PXRoaXMudGV4RGF0YS5nZXQocy5kYXRhSWQpO2lmKHQucGFja2VkT3V0cHV0JiYodS5pc1BhY2tlZD0hMCksdC5vdXRQYWNraW5nU2NoZW1lPT09VnQuREVOU0Upe3ZhciBjPVl0KHQub3V0cHV0U2hhcGUpO3UudGV4U2hhcGU9Yy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiAyKnR9KSl9aWYobnVsbCE9dC5vdXRUZXhVc2FnZSYmKHUudXNhZ2U9dC5vdXRUZXhVc2FnZSksMD09PWsocy5zaGFwZSkpcmV0dXJuIHUudmFsdWVzPUIocy5kdHlwZSwwKSxzO3ZhciBsPVtdLGg9ZS5tYXAoKGZ1bmN0aW9uKGUpe2lmKFwiY29tcGxleDY0XCI9PT1lLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIkdQR1BVUHJvZ3JhbSBkb2VzIG5vdCBzdXBwb3J0IGNvbXBsZXg2NCBpbnB1dC4gRm9yIGNvbXBsZXg2NCBkdHlwZXMsIHBsZWFzZSBzZXBhcmF0ZSB0aGUgcHJvZ3JhbSBpbnRvIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0cy5cIik7dmFyIG49YS50ZXhEYXRhLmdldChlLmRhdGFJZCk7aWYobnVsbD09bi50ZXh0dXJlKXtpZighdC5wYWNrZWRJbnB1dHMmJmsoZS5zaGFwZSk8PWkoKS5nZXROdW1iZXIoXCJXRUJHTF9TSVpFX1VQTE9BRF9VTklGT1JNXCIpKXJldHVybntzaGFwZTplLnNoYXBlLHRleERhdGE6bnVsbCxpc1VuaWZvcm06ITAsdW5pZm9ybVZhbHVlczpuLnZhbHVlc307dC5wYWNrZWRJbnB1dHMmJihuLmlzUGFja2VkPSEwLG4uc2hhcGU9ZS5zaGFwZSl9ZWxzZSBpZighIW4uaXNQYWNrZWQhPSEhdC5wYWNrZWRJbnB1dHMpZT1uLmlzUGFja2VkP2EudW5wYWNrVGVuc29yKGUpOmEucGFja1RlbnNvcihlKSxsLnB1c2goZSksbj1hLnRleERhdGEuZ2V0KGUuZGF0YUlkKTtlbHNlIGlmKG4uaXNQYWNrZWQmJiFfZShuLnNoYXBlLGUuc2hhcGUpKXt2YXIgcj1lLG89ZS5zaGFwZTtlLnNoYXBlPW4uc2hhcGUsZT1hLnBhY2tlZFJlc2hhcGUoZSxvKSxsLnB1c2goZSksbj1hLnRleERhdGEuZ2V0KGUuZGF0YUlkKSxyLnNoYXBlPW99cmV0dXJuIGEudXBsb2FkVG9HUFUoZS5kYXRhSWQpLHtzaGFwZTplLnNoYXBlLHRleERhdGE6bixpc1VuaWZvcm06ITF9fSkpO3RoaXMudXBsb2FkVG9HUFUocy5kYXRhSWQpO3ZhciBmLGQ9e3NoYXBlOnMuc2hhcGUsdGV4RGF0YTp1LGlzVW5pZm9ybTohMX0scD1mdW5jdGlvbih0LGUsbil7dmFyIHI9XCJcIjtlLmNvbmNhdChuKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT1udWxsIT10LnRleERhdGEmJm51bGwhPXQudGV4RGF0YS5zbGljZSYmdC50ZXhEYXRhLnNsaWNlLmZsYXRPZmZzZXQ+MCxuPXQuaXNVbmlmb3JtP1widW5pZm9ybVwiOnQudGV4RGF0YS50ZXhTaGFwZTtyKz10LnNoYXBlK1wiX1wiK24rXCJfXCIrZX0pKTt2YXIgbz10LnVzZXJDb2RlLGE9dC5jb25zdHJ1Y3Rvci5uYW1lO3JldHVybiBhKz1cIl9cIityK1wiX1wiK299KHQsaCxkKSx2PXRoaXMuZ2V0QW5kU2F2ZUJpbmFyeShwLChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyKXt2YXIgbz1lLnVzZXJDb2RlLGE9bi5tYXAoKGZ1bmN0aW9uKHQsbil7dmFyIHI9e2xvZ2ljYWxTaGFwZTp0LnNoYXBlLHRleFNoYXBlOnQuaXNVbmlmb3JtP251bGw6dC50ZXhEYXRhLnRleFNoYXBlLGlzVW5pZm9ybTp0LmlzVW5pZm9ybSxpc1BhY2tlZDohdC5pc1VuaWZvcm0mJnQudGV4RGF0YS5pc1BhY2tlZCxmbGF0T2Zmc2V0Om51bGx9O3JldHVybiBudWxsIT10LnRleERhdGEmJm51bGwhPXQudGV4RGF0YS5zbGljZSYmdC50ZXhEYXRhLnNsaWNlLmZsYXRPZmZzZXQ+MCYmKHIuZmxhdE9mZnNldD10LnRleERhdGEuc2xpY2UuZmxhdE9mZnNldCkse25hbWU6ZS52YXJpYWJsZU5hbWVzW25dLHNoYXBlSW5mbzpyfX0pKSxzPWEubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZUluZm99KSksdT17bG9naWNhbFNoYXBlOnIuc2hhcGUsdGV4U2hhcGU6ci50ZXhEYXRhLnRleFNoYXBlLGlzVW5pZm9ybTohMSxpc1BhY2tlZDpyLnRleERhdGEuaXNQYWNrZWQsZmxhdE9mZnNldDpudWxsfSxjPWZhKGEsdSxvLGUucGFja2VkSW5wdXRzKSxsPXQuY3JlYXRlUHJvZ3JhbShjKSxoPW51bGwsZj10LmdldFVuaWZvcm1Mb2NhdGlvbihsLFwiTkFOXCIsITEpOzE9PT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSYmKGg9dC5nZXRVbmlmb3JtTG9jYXRpb24obCxcIklORklOSVRZXCIsITEpKTtmb3IodmFyIGQ9e30scD0wO3A8ZS52YXJpYWJsZU5hbWVzLmxlbmd0aDtwKyspe3ZhciB2PWUudmFyaWFibGVOYW1lc1twXTtkW3ZdPXQuZ2V0VW5pZm9ybUxvY2F0aW9uKGwsdiwhMSksZFtcIm9mZnNldFwiK3ZdPXQuZ2V0VW5pZm9ybUxvY2F0aW9uKGwsXCJvZmZzZXRcIit2LCExKX1yZXR1cm57cHJvZ3JhbTplLHNvdXJjZTpjLHdlYkdMUHJvZ3JhbTpsLHVuaWZvcm1Mb2NhdGlvbnM6ZCxpblNoYXBlSW5mb3M6cyxvdXRTaGFwZUluZm86dSxpbmZMb2M6aCxuYW5Mb2M6Zn19KGEuZ3BncHUsdCxoLGQpfSkpLG09bnVsbCE9dGhpcy5hY3RpdmVUaW1lcnM7aWYobSYmKGY9dGhpcy5zdGFydFRpbWVyKCkpLGZ1bmN0aW9uKHQsZSxuLHIsbyl7UGkoZS5pblNoYXBlSW5mb3MsbiksUGkoW2Uub3V0U2hhcGVJbmZvXSxbcl0pO3ZhciBhPXIudGV4RGF0YS50ZXh0dXJlLHM9ci50ZXhEYXRhLnRleFNoYXBlO3IudGV4RGF0YS5pc1BhY2tlZD90LnNldE91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUoYSxzWzBdLHNbMV0pOnQuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShhLHNbMF0sc1sxXSksdC5zZXRQcm9ncmFtKGUud2ViR0xQcm9ncmFtKSwxPT09aSgpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikmJm51bGwhPT1lLmluZkxvYyYmdC5nbC51bmlmb3JtMWYoZS5pbmZMb2MsMS8wKSxudWxsIT09ZS5uYW5Mb2MmJnQuZ2wudW5pZm9ybTFmKGUubmFuTG9jLE5hTiksbi5mb3JFYWNoKChmdW5jdGlvbihuLHIpe3ZhciBvPWUucHJvZ3JhbS52YXJpYWJsZU5hbWVzW3JdLGE9ZS51bmlmb3JtTG9jYXRpb25zW29dLGk9ZS51bmlmb3JtTG9jYXRpb25zW1wib2Zmc2V0XCIrb107aWYobnVsbCE9YSlpZihuLmlzVW5pZm9ybSlpZihrKG4uc2hhcGUpPDIpdC5nbC51bmlmb3JtMWYoYSxuLnVuaWZvcm1WYWx1ZXNbMF0pO2Vsc2V7dmFyIHM9bi51bmlmb3JtVmFsdWVzO3MgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fChzPW5ldyBGbG9hdDMyQXJyYXkocykpLHQuZ2wudW5pZm9ybTFmdihhLHMpfWVsc2UgbnVsbCE9bi50ZXhEYXRhLnNsaWNlJiZudWxsIT1pJiZ0LmdsLnVuaWZvcm0xaShpLG4udGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0KSx0LnNldElucHV0TWF0cml4VGV4dHVyZShuLnRleERhdGEudGV4dHVyZSxhLHIpfSkpLG51bGwhPW8mJm8odCxlLndlYkdMUHJvZ3JhbSksdC5leGVjdXRlUHJvZ3JhbSgpfSh0aGlzLmdwZ3B1LHYsaCxkLHIpLGwuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGEuZGlzcG9zZURhdGEodC5kYXRhSWQpfSkpLG0mJihmPXRoaXMuZW5kVGltZXIoZiksdGhpcy5hY3RpdmVUaW1lcnMucHVzaCh7bmFtZTp0LmNvbnN0cnVjdG9yLm5hbWUscXVlcnk6dGhpcy5nZXRRdWVyeVRpbWUoZil9KSksIWkoKS5nZXRCb29sKFwiV0VCR0xfTEFaSUxZX1VOUEFDS1wiKSYmdS5pc1BhY2tlZCYmITE9PT1vKXt2YXIgZz10aGlzLnVucGFja1RlbnNvcihzKTtyZXR1cm4gdGhpcy5kaXNwb3NlRGF0YShzLmRhdGFJZCksZ31yZXR1cm4gc30sby5wcm90b3R5cGUuY29tcGlsZUFuZFJ1bj1mdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PW8mJihvPSExKSxuPW58fGVbMF0uZHR5cGU7dmFyIGE9dGhpcy5ydW5XZWJHTFByb2dyYW0odCxlLG4scixvKTtyZXR1cm4gTHQubWFrZVRlbnNvckZyb21EYXRhSWQoYS5kYXRhSWQsYS5zaGFwZSxhLmR0eXBlKX0sby5wcm90b3R5cGUuZ2V0QW5kU2F2ZUJpbmFyeT1mdW5jdGlvbih0LGUpe3JldHVybiB0IGluIHRoaXMuYmluYXJ5Q2FjaGV8fCh0aGlzLmJpbmFyeUNhY2hlW3RdPWUoKSksdGhpcy5iaW5hcnlDYWNoZVt0XX0sby5wcm90b3R5cGUuZ2V0VGV4dHVyZU1hbmFnZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZXh0dXJlTWFuYWdlcn0sby5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYoIXRoaXMuZGlzcG9zZWQpe2lmKCFpKCkuZ2V0Qm9vbChcIklTX1RFU1RcIikpT2JqZWN0LmtleXModGhpcy5iaW5hcnlDYWNoZSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dC5ncGdwdS5kZWxldGVQcm9ncmFtKHQuYmluYXJ5Q2FjaGVbZV0ud2ViR0xQcm9ncmFtKSxkZWxldGUgdC5iaW5hcnlDYWNoZVtlXX0pKTt0aGlzLnRleHR1cmVNYW5hZ2VyLmRpc3Bvc2UoKSxudWxsIT10aGlzLmNhbnZhcyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50JiZ0aGlzLmNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50P3RoaXMuY2FudmFzLnJlbW92ZSgpOnRoaXMuY2FudmFzPW51bGwsdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5JiYodGhpcy5ncGdwdS5wcm9ncmFtPW51bGwsdGhpcy5ncGdwdS5kaXNwb3NlKCkpLHRoaXMuZGlzcG9zZWQ9ITB9fSxvLnByb3RvdHlwZS5mbG9hdFByZWNpc2lvbj1mdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIG51bGw9PXRoaXMuZmxvYXRQcmVjaXNpb25WYWx1ZSYmKHRoaXMuZmxvYXRQcmVjaXNpb25WYWx1ZT1aZSgoZnVuY3Rpb24oKXtpZighaSgpLmdldChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIikpe3ZhciBlPWkoKS5nZXRCb29sKFwiREVCVUdcIik7aSgpLnNldChcIkRFQlVHXCIsITEpO3ZhciBuPXQuYWJzKE9uKDFlLTgpKS5kYXRhU3luYygpWzBdO2lmKGkoKS5zZXQoXCJERUJVR1wiLGUpLG4+MClyZXR1cm4gMzJ9cmV0dXJuIDE2fSkpKSx0aGlzLmZsb2F0UHJlY2lzaW9uVmFsdWV9LG8ucHJvdG90eXBlLmVwc2lsb249ZnVuY3Rpb24oKXtyZXR1cm4gMzI9PT10aGlzLmZsb2F0UHJlY2lzaW9uKCk/MWUtNzoxZS00fSxvLnByb3RvdHlwZS51cGxvYWRUb0dQVT1mdW5jdGlvbih0KXt2YXIgZSxuPXRoaXMudGV4RGF0YS5nZXQodCkscj1uLnNoYXBlLG89bi5kdHlwZSxhPW4udmFsdWVzLGk9bi50ZXh0dXJlLHM9bi51c2FnZSx1PW4uaXNQYWNrZWQ7aWYobnVsbD09aSl7dmFyIGMsbD1udWxsIT10aGlzLmFjdGl2ZVRpbWVycztsJiYoYz1ldCgpKTt2YXIgaD1uLnRleFNoYXBlO2lmKG51bGw9PWgmJihoPU5lKHIsdSksbi50ZXhTaGFwZT1oKSxudWxsIT1hKXt2YXIgZj1UZShyKSxkPXZvaWQgMCxwPWhbMV0sdj1oWzBdLG09YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7dT8ocD0oZT0kdChoWzBdLGhbMV0pKVswXSx2PWVbMV0sZD1uZXcgaGkoZixbdixwXSxtKSk6ZD1uZXcgbGkoZixbdixwXSxtKTt2YXIgZz10aGlzLm1ha2VUZW5zb3JJbmZvKFt2LHBdLG8pO3RoaXMudGV4RGF0YS5nZXQoZy5kYXRhSWQpLnVzYWdlPW0/enQuUElYRUxTOnp0LlVQTE9BRCx0aGlzLmdwZ3B1LnVwbG9hZERlbnNlTWF0cml4VG9UZXh0dXJlKHRoaXMuZ2V0VGV4dHVyZShnLmRhdGFJZCkscCx2LGEpO3ZhciB5PXRoaXMucnVuV2ViR0xQcm9ncmFtKGQsW2ddLG8sbnVsbCwhMCkseD10aGlzLnRleERhdGEuZ2V0KHkuZGF0YUlkKTtuLnRleHR1cmU9eC50ZXh0dXJlLG4udGV4U2hhcGU9eC50ZXhTaGFwZSxuLmlzUGFja2VkPXguaXNQYWNrZWQsbi51c2FnZT14LnVzYWdlLHRoaXMuZGlzcG9zZURhdGEoZy5kYXRhSWQpLHRoaXMudGV4RGF0YS5kZWxldGUoeS5kYXRhSWQpLG4udmFsdWVzPW51bGwsbCYmKHRoaXMudXBsb2FkV2FpdE1zKz1ldCgpLWMpfWVsc2V7dmFyIGI9dGhpcy5hY3F1aXJlVGV4dHVyZShoLHMsbyx1KTtuLnRleHR1cmU9Yn19fSxvLnByb3RvdHlwZS5jb252ZXJ0QW5kQ2FjaGVPbkNQVT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMudGV4RGF0YS5nZXQodCkscj1uLmR0eXBlO3JldHVybiB0aGlzLnJlbGVhc2VHUFVEYXRhKHQpLG51bGwhPWUmJihuLnZhbHVlcz1mdW5jdGlvbih0LGUpe2lmKFwiZmxvYXQzMlwiPT09ZXx8XCJjb21wbGV4NjRcIj09PWUpcmV0dXJuIHQ7aWYoXCJpbnQzMlwiPT09ZXx8XCJib29sXCI9PT1lKXtmb3IodmFyIG49XCJpbnQzMlwiPT09ZT9uZXcgSW50MzJBcnJheSh0Lmxlbmd0aCk6bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpLHI9MDtyPG4ubGVuZ3RoOysrciluW3JdPU1hdGgucm91bmQodFtyXSk7cmV0dXJuIG59dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIitlKX0oZSxyKSksbi52YWx1ZXN9LG8ucHJvdG90eXBlLmFjcXVpcmVUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKHRoaXMubnVtQnl0ZXNJbkdQVSs9dGhpcy5jb21wdXRlQnl0ZXModCxuKSwhdGhpcy53YXJuZWRBYm91dE1lbW9yeSYmdGhpcy5udW1CeXRlc0luR1BVPjEwMjQqdGhpcy5udW1NQkJlZm9yZVdhcm5pbmcqMTAyNCl7dmFyIG89KHRoaXMubnVtQnl0ZXNJbkdQVS8xMDI0LzEwMjQpLnRvRml4ZWQoMik7dGhpcy53YXJuZWRBYm91dE1lbW9yeT0hMCxjb25zb2xlLndhcm4oXCJIaWdoIG1lbW9yeSB1c2FnZSBpbiBHUFU6IFwiK28rXCIgTUIsIG1vc3QgbGlrZWx5IGR1ZSB0byBhIG1lbW9yeSBsZWFrXCIpfXJldHVybiB0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKHQsZSxyKX0sby5wcm90b3R5cGUuY29tcHV0ZUJ5dGVzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbMF0qdFsxXSp6KGUpfSxvfShibyk7V3QoKSYmTHQucmVnaXN0ZXJCYWNrZW5kKFwid2ViZ2xcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFpzfSksMik7dmFyIHR1PUFuKHtzcXVhcmVfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJzcXVhcmVcIiksbj1bZV07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7cmV0dXJuIG4oW2VdKSx0LnNxdWFyZShlKX0pLHt4OmV9LG51bGwsXCJTcXVhcmVcIix7fSxuLFtdKX19KSxldT1cIlNxdWFyZWREaWZmZXJlbmNlXCI7dmFyIG51PUFuKHtzcXVhcmVkRGlmZmVyZW5jZV86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJzcXVhcmVkRGlmZmVyZW5jZVwiKSxvPW1uKGUsXCJiXCIsXCJzcXVhcmVkRGlmZmVyZW5jZVwiKTtuPU50KHIsbykscj1uWzBdLG89blsxXSxSbyhyLnNoYXBlLG8uc2hhcGUpO3ZhciBhPXthOnIsYjpvfSxpPVtyLG9dO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuc3F1YXJlZERpZmZlcmVuY2UocixvKTtyZXR1cm4gZShbcixvXSksbn0pLGEsKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV0sbz1PbigyKTtyZXR1cm57YTpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLnN1YihyKS5tdWwobykpfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKHIuc3ViKG4pLm11bChvKSl9fX0pLGV1LHt9LGksW10pfX0pO3ZhciBydT1Bbih7YWJzXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiYWJzXCIpO3JldHVyblwiY29tcGxleDY0XCI9PT1lLmR0eXBlP0x0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbXBsZXhBYnMoZSl9KSx7JHg6ZX0pOkx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hYnMoZSk7cmV0dXJuIG4oW2VdKSxyfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLnRvRmxvYXQoKS5zdGVwKC0xKSl9fX0pLFwiQWJzXCIpfX0pLG91PUFuKHthY29zXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiYWNvc1wiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmFjb3MoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2U3RyaWN0KE9uKDEpLnN1YihuLnRvRmxvYXQoKS5zcXVhcmUoKSkuc3FydCgpKS5uZWcoKX19fSkpfX0pLGF1PUFuKHthY29zaF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImFjb3NoXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuYWNvc2goZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2U3RyaWN0KG4udG9GbG9hdCgpLnNxdWFyZSgpLnN1YigxKS5zcXJ0KCkpfX19KSl9fSksaXU9QW4oe2FzaW5fOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJhc2luXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuYXNpbihlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXZTdHJpY3QoT24oMSkuc3ViKG4udG9GbG9hdCgpLnNxdWFyZSgpKS5zcXJ0KCkpfX19KSl9fSksc3U9QW4oe2FzaW5oXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiYXNpbmhcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hc2luaChlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXZTdHJpY3QoT24oMSkuYWRkKG4udG9GbG9hdCgpLnNxdWFyZSgpKS5zcXJ0KCkpfX19KSl9fSksdXU9QW4oe2F0YW5fOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJhdGFuXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuYXRhbihlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi50b0Zsb2F0KCkuc3F1YXJlKCkuYWRkKDEpKX19fSkpfX0pLGN1PUFuKHthdGFuaF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImF0YW5oXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuYXRhbmgoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KE9uKDEpLnN1YihuLnRvRmxvYXQoKS5zcXVhcmUoKSkpfX19KSl9fSksbHU9QW4oe2NlaWxfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJjZWlsXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jZWlsKGUpfSkseyR4OmV9LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pKX19KSxodT1Bbih7Y2xpcEJ5VmFsdWVfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1tbih0LFwieFwiLFwiY2xpcEJ5VmFsdWVcIik7QyhlPD1uLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY2xpcDogbWluIChcIitlK1wiKSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBtYXggKFwiK24rXCIpLlwifSkpO3ZhciBvPVtyXSxhPXttaW46ZSxtYXg6bn07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbyl7dmFyIGE9dC5jbGlwKHIsZSxuKTtyZXR1cm4gbyhbcl0pLGF9KSx7eDpyfSwoZnVuY3Rpb24odCxyKXt2YXIgbz1yWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQud2hlcmUoby5ncmVhdGVyRXF1YWwoZSkubG9naWNhbEFuZChvLmxlc3NFcXVhbChuKSksWG4odCkpfX19KSxcIkNsaXBCeVZhbHVlXCIsYSxvKX19KSxmdT1Bbih7Y29zXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiY29zXCIpLG49W2VdO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuY29zKGUpO3JldHVybiBuKFtlXSkscn0pLHt4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gbi50b0Zsb2F0KCkuc2luKCkubmVnKCkubXVsKHQpfX19KSxcIkNvc1wiLHt9LG4pfX0pLGR1PUFuKHtjb3NoXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiY29zaFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmNvc2goZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIG4udG9GbG9hdCgpLnNpbmgoKS5tdWxTdHJpY3QodCl9fX0pKX19KSxwdT1Bbih7ZXJmXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiZXJmXCIpO3JldHVybiBDKFwiaW50MzJcIj09PWUuZHR5cGV8fFwiZmxvYXQzMlwiPT09ZS5kdHlwZSwoZnVuY3Rpb24oKXtyZXR1cm5cIklucHV0IGR0eXBlIG11c3QgYmUgYGludDMyYCBvciBgZmxvYXQzMmAuXCJ9KSksXCJpbnQzMlwiPT09ZS5kdHlwZSYmKGU9ZS50b0Zsb2F0KCkpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5lcmYoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uc3F1YXJlKCkubmVnKCkuZXhwKCkubXVsKDIvTWF0aC5zcXJ0KE1hdGguUEkpKSl9fX0pKX19KSx2dT1Bbih7ZXhwXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiZXhwXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuZXhwKGUpO3JldHVybiBuKFtyXSkscn0pLHt4OmV9LChmdW5jdGlvbih0LGUpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsU3RyaWN0KGVbMF0pfX19KSxcIkV4cFwiLHt9LFtdLFshMF0pfX0pLG11PUFuKHtleHBtMV86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImV4cG0xXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuZXhwbTEoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uZXhwKCkpfX19KSl9fSksZ3U9QW4oe2Zsb29yXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiZmxvb3JcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmZsb29yKGUpfSkseyR4OmV9LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pKX19KSx5dT1Bbih7bG9nXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwibG9nXCIpLG49W2VdO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQubG9nKGUpO3JldHVybiBuKFtlXSkscn0pLHt4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi50b0Zsb2F0KCkpfX19KSxcIkxvZ1wiLHt9LG4pfX0pLHh1PUFuKHtsb2cxcF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImxvZzFwXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQubG9nMXAoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4uYWRkKDEpKX19fSkpfX0pLGJ1PUFuKHtsb2dTaWdtb2lkXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwibG9nU2lnbW9pZFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNvZnRwbHVzKGUubmVnKCkpLm5lZygpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLm5lZygpLnNpZ21vaWQoKSl9fX0pKX19KSx3dT1Bbih7bmVnXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwibmVnXCIpLG49W2VdO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uZWcoZSl9KSx7eDplfSwoZnVuY3Rpb24odCl7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5uZWcoKX19fSksXCJOZWdcIix7fSxuKX19KSxDdT1Bbih7cmVjaXByb2NhbF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInJlY2lwcm9jYWxcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5yZWNpcHJvY2FsKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLnNxdWFyZSgpLm5lZygpKX19fSkpfX0pLEV1PUFuKHtyb3VuZF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInJvdW5kXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5yb3VuZChlKX0pLHskeDplfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KSl9fSksUnU9QW4oe3JzcXJ0XzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwicnNxcnRcIiksbj1bZV07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5yc3FydChlKTtyZXR1cm4gbihbZV0pLHJ9KSx7eDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4ucG93KDEuNSkubXVsKDIpKS5uZWcoKX19fSksXCJSc3FydFwiLHt9LG4pfX0pLEl1PUFuKHtzaWdtb2lkXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwic2lnbW9pZFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNpZ21vaWQoZSk7cmV0dXJuIG4oW3JdKSxyfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLm11bChPbigxKS5zdWIobikpKX19fSksXCJTaWdtb2lkXCIpfX0pLGt1PUFuKHtzaWduXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwic2lnblwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2lnbihlKX0pLHskeDplfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KSl9fSksU3U9QW4oe2lzTmFOXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiaXNOYU5cIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlzTmFOKGUpfSkseyR4OmV9LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pKX19KSxBdT1Bbih7aXNJbmZfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJpc0luZlwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNJbmYoZSl9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSkpfX0pLER1PUFuKHtpc0Zpbml0ZV86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImlzRmluaXRlXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5pc0Zpbml0ZShlKX0pLHskeDplfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KSl9fSksVHU9QW4oe3Npbl86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInNpblwiKSxuPVtlXTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNpbihlKTtyZXR1cm4gbihbZV0pLHJ9KSx7eDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIG4udG9GbG9hdCgpLmNvcygpLm11bCh0KX19fSksXCJTaW5cIix7fSxuKX19KSxOdT1Bbih7c2luaF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInNpbmhcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zaW5oKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBuLnRvRmxvYXQoKS5jb3NoKCkubXVsU3RyaWN0KHQpfX19KSl9fSksRnU9QW4oe3NvZnRwbHVzXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwic29mdHBsdXNcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zb2Z0cGx1cyhlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5zaWdtb2lkKCkpfX19KSl9fSksX3U9QW4oe3NxcnRfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJzcXJ0XCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuc3FydChlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi50b0Zsb2F0KCkuc3FydCgpLm11bCgyKSl9fX0pKX19KSxPdT1Bbih7c3RlcF86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKTt2YXIgbj1tbih0LFwieFwiLFwic3RlcFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3RlcChuLGUpfSkseyR4Om59LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pKX19KSxNdT1Bbih7dGFuXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwidGFuXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQudGFuKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLmNvcygpLnNxdWFyZSgpKX19fSkpfX0pLEJ1PUFuKHt0YW5oXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwidGFuaFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnRhbmgoZSk7cmV0dXJuIG4oW3JdKSxyfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBPbigxKS5zdWIobi5zcXVhcmUoKSkubXVsU3RyaWN0KHQpfX19KSxcIlRhbmhcIix7fSxudWxsLFshMF0pfX0pO2Z1bmN0aW9uIFB1KHQsZSxuLHIsbyxhKXt2YXIgaSxzLHU9bW4odCxcInhcIixcImJhdGNoTm9ybVwiKSxjPW1uKGUsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksbD1tbihuLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybVwiKTtyZXR1cm4gbnVsbCE9byYmKGk9bW4obyxcInNjYWxlXCIsXCJiYXRjaE5vcm1cIikpLG51bGwhPXImJihzPW1uKHIsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksQygyPT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKDI9PT1jLnJhbmt8fDE9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0yRDogbWVhbiBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pKSxDKDI9PT1sLnJhbmt8fDE9PT1sLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0yRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSksbnVsbCE9aSYmQygyPT09aS5yYW5rfHwxPT09aS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtMkQ6IHNjYWxlIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIraS5yYW5rK1wiLlwifSkpLG51bGwhPXMmJkMoMj09PXMucmFua3x8MT09PXMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTJEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSksVXUodSxjLGwscyxpLGEpfWZ1bmN0aW9uIEx1KHQsZSxuLHIsbyxhKXt2YXIgaSxzLHU9bW4odCxcInhcIixcImJhdGNoTm9ybVwiKSxjPW1uKGUsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksbD1tbihuLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybVwiKTtyZXR1cm4gbnVsbCE9byYmKGk9bW4obyxcInNjYWxlXCIsXCJiYXRjaE5vcm1cIikpLG51bGwhPXImJihzPW1uKHIsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksQygzPT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKDM9PT1jLnJhbmt8fDE9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0zRDogbWVhbiBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pKSxDKDM9PT1sLnJhbmt8fDE9PT1sLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0zRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSksbnVsbCE9aSYmQygzPT09aS5yYW5rfHwxPT09aS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IHNjYWxlIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIraS5yYW5rK1wiLlwifSkpLG51bGwhPXMmJkMoMz09PXMucmFua3x8MT09PXMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTNEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSksVXUodSxjLGwscyxpLGEpfWZ1bmN0aW9uIFd1KHQsZSxuLHIsbyxhKXt2YXIgaSxzLHU9bW4odCxcInhcIixcImJhdGNoTm9ybVwiKSxjPW1uKGUsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksbD1tbihuLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybVwiKTtyZXR1cm4gbnVsbCE9byYmKGk9bW4obyxcInNjYWxlXCIsXCJiYXRjaE5vcm1cIikpLG51bGwhPXImJihzPW1uKHIsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksQyg0PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKDQ9PT1jLnJhbmt8fDE9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm00RDogbWVhbiBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pKSxDKDQ9PT1sLnJhbmt8fDE9PT1sLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm00RDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSksbnVsbCE9aSYmQyg0PT09aS5yYW5rfHwxPT09aS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IHNjYWxlIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIraS5yYW5rK1wiLlwifSkpLG51bGwhPXMmJkMoND09PXMucmFua3x8MT09PXMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTREOiBvZmZzZXQgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSksVXUodSxjLGwscyxpLGEpfWZ1bmN0aW9uIFV1KHQsZSxuLHIsbyxhKXtudWxsPT1hJiYoYT0uMDAxKTt2YXIgaSxzLHUsYz1tbih0LFwieFwiLFwiYmF0Y2hOb3JtXCIpLGw9bW4oZSxcIm1lYW5cIixcImJhdGNoTm9ybVwiKSxoPW1uKG4sXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtXCIpO251bGwhPW8mJihpPW1uKG8sXCJzY2FsZVwiLFwiYmF0Y2hOb3JtXCIpKSxudWxsIT1yJiYocz1tbihyLFwib2Zmc2V0XCIsXCJiYXRjaE5vcm1cIikpLEMobC5yYW5rPT09aC5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCB2YXJpYW5jZSB0byBoYXZlIGVxdWFsIHJhbmtzLlwifSkpLEMobnVsbD09c3x8bC5yYW5rPT09cy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBvZmZzZXQgdG8gaGF2ZSBlcXVhbCByYW5rcy5cIn0pKSxDKG51bGw9PWl8fGwucmFuaz09PWkucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkJhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgc2NhbGUgdG8gaGF2ZSBlcXVhbCByYW5rcy5cIn0pKSx1PTA9PT1jLnJhbmt8fDE9PT1jLnJhbms/Yy5hczREKDEsMSwxLGMuc2l6ZSk6Mj09PWMucmFuaz9jLmFzNEQoMSwxLGMuc2hhcGVbMF0sYy5zaGFwZVsxXSk6Mz09PWMucmFuaz9jLmFzNEQoMSxjLnNoYXBlWzBdLGMuc2hhcGVbMV0sYy5zaGFwZVsyXSk6Yzt2YXIgZj1bYyxsLGgsaV07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5iYXRjaE5vcm1hbGl6YXRpb24odSxWdShsKSxWdShoKSxhLFZ1KGkpLFZ1KHMpKTtyZXR1cm4gZShbYyxsLGgsaV0pLG59KSx7eDpjLG1lYW46bCx2YXJpYW5jZTpoLHNjYWxlOmksb2Zmc2V0OnN9LChmdW5jdGlvbih0LGUpe3ZhciBuPWUscj1uWzBdLG89blsxXSxpPW5bMl0scz1uWzNdLGM9bnVsbD09cz9PbigxKTpzLGw9RW8oby5zaGFwZSx1LnNoYXBlKSxoPVtdO2lmKDE9PT1vLnJhbmspe2Zvcih2YXIgZj0wO2Y8dS5zaGFwZS5sZW5ndGgtMTsrK2YpaC5wdXNoKHUuc2hhcGVbZl0pO2gucHVzaCgxKX12YXIgZD1yLnN1YihvKSxwPXQubXVsKGMpLHY9UnUoaS5hZGQoT24oYSkpKSxtPXYubXVsKHYpLm11bCh2KS5tdWwoT24oLS41KSk7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gMT09PW8ucmFuaz90Lm11bChMcih2LmFzNEQoMSwxLDEsby5zaGFwZVswXSksaCkpLm11bChjKS5yZXNoYXBlKHIuc2hhcGUpOnQubXVsKHYpLm11bChjKS5yZXNoYXBlKHIuc2hhcGUpfSxtZWFuOmZ1bmN0aW9uKCl7dmFyIHQ9di5tdWwoT24oLTEpKS5tdWwocCk7cmV0dXJuIDE9PT1vLnJhbmsmJih0PXQuc3VtKGwpKSx0LnJlc2hhcGUoby5zaGFwZSl9LHZhcmlhbmNlOmZ1bmN0aW9uKCl7dmFyIHQ9bS5tdWwoZCkubXVsKHApO3JldHVybiAxPT09by5yYW5rJiYodD10LnN1bShsKSksdC5yZXNoYXBlKG8uc2hhcGUpfSxzY2FsZTpmdW5jdGlvbigpe3ZhciBlPWQubXVsKHYpLG49dC5tdWwoZSk7cmV0dXJuIDE9PT1vLnJhbmsmJihuPW4uc3VtKGwpKSxuLnJlc2hhcGUoby5zaGFwZSl9LG9mZnNldDpmdW5jdGlvbigpe3ZhciBlPXQ7cmV0dXJuIDE9PT1vLnJhbmsmJihlPWUuc3VtKGwpKSxlLnJlc2hhcGUoby5zaGFwZSl9fX0pLFwiQmF0Y2hOb3JtYWxpemF0aW9uXCIse3ZhcmlhbmNlRXBzaWxvbjphfSxmKS5yZXNoYXBlKGMuc2hhcGUpfWZ1bmN0aW9uIFZ1KHQpe3JldHVybiBudWxsPT10P251bGw6MD09PXQucmFuaz90LmFzMUQoKToxPT09dC5yYW5rP3Q6Mj09PXQucmFuaz90LmFzNEQoMSwxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSk6Mz09PXQucmFuaz90LmFzNEQoMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXSk6dH1mdW5jdGlvbiB6dSgpe1hlKFwidGYuYmF0Y2hOb3JtYWxpemF0aW9uKCkgaXMgZ29pbmcgYXdheS4gVXNlIHRmLmJhdGNoTm9ybSgpIGluc3RlYWQsIGFuZCBub3RlIHRoZSBwb3NpdGlvbmFsIGFyZ3VtZW50IGNoYW5nZSBvZiBzY2FsZSwgb2Zmc2V0LCBhbmQgdmFyaWFuY2VFcHNpbG9uXCIpfXZhciBHdT1Bbih7YmF0Y2hOb3JtYWxpemF0aW9uMmRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjAwMSksenUoKSxQdSh0LGUsbixhLG8scil9fSksSHU9QW4oe2JhdGNoTm9ybWFsaXphdGlvbjNkXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPS4wMDEpLHp1KCksTHUodCxlLG4sYSxvLHIpfX0pLHF1PUFuKHtiYXRjaE5vcm1hbGl6YXRpb240ZF86ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj0uMDAxKSx6dSgpLFd1KHQsZSxuLGEsbyxyKX19KSxLdT1Bbih7YmF0Y2hOb3JtYWxpemF0aW9uXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPS4wMDEpLHp1KCksVXUodCxlLG4sYSxvLHIpfX0pLGp1PUFuKHtiYXRjaE5vcm1fOlV1fSksWHU9QW4oe2JhdGNoTm9ybTJkXzpQdX0pLFl1PUFuKHtiYXRjaE5vcm0zZF86THV9KSwkdT1Bbih7YmF0Y2hOb3JtNGRfOld1fSk7dmFyIFF1PUFuKHtsb2dpY2FsQW5kXzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJsb2dpY2FsQW5kXCIsXCJib29sXCIpLHI9bW4oZSxcImJcIixcImxvZ2ljYWxBbmRcIixcImJvb2xcIik7cmV0dXJuIFJvKG4uc2hhcGUsci5zaGFwZSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubG9naWNhbEFuZChuLHIpfSkse2E6bixiOnJ9LG51bGwsXCJMb2dpY2FsQW5kXCIpfX0pLEp1PUFuKHtsb2dpY2FsTm90XzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwibG9naWNhbE5vdFwiLFwiYm9vbFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubG9naWNhbE5vdChlKX0pLHskeDplfSl9fSksWnU9QW4oe2xvZ2ljYWxPcl86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwibG9naWNhbE9yXCIsXCJib29sXCIpLHI9bW4oZSxcImJcIixcImxvZ2ljYWxPclwiLFwiYm9vbFwiKTtyZXR1cm4gUm8obi5zaGFwZSxyLnNoYXBlKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5sb2dpY2FsT3IobixyKX0pLHskYTpuLCRiOnJ9KX19KSx0Yz1Bbih7bG9naWNhbFhvcl86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwibG9naWNhbFhvclwiLFwiYm9vbFwiKSxyPW1uKGUsXCJiXCIsXCJsb2dpY2FsWG9yXCIsXCJib29sXCIpO3JldHVybiBSbyhuLnNoYXBlLHIuc2hhcGUpLFp1KHQsZSkubG9naWNhbEFuZChRdSh0LGUpLmxvZ2ljYWxOb3QoKSl9fSksZWM9QW4oe3doZXJlXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9bW4oZSxcImFcIixcIndoZXJlXCIpLG89bW4obixcImJcIixcIndoZXJlXCIpLGE9bW4odCxcImNvbmRpdGlvblwiLFwid2hlcmVcIixcImJvb2xcIik7cmV0dXJuIEUoci5zaGFwZSxvLnNoYXBlLFwiRXJyb3IgaW4gd2hlcmU6IFwiKSwxPT09YS5yYW5rP0MoYS5zaGFwZVswXT09PXIuc2hhcGVbMF0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZmlyc3QgZGltZW5zaW9uIG9mIGBhYCBtdXN0IG1hdGNoIHRoZSBzaXplIG9mIGBjb25kaXRpb25gLlwifSkpOkUoYS5zaGFwZSxvLnNoYXBlLFwiRXJyb3IgaW4gd2hlcmU6IFwiKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuc2VsZWN0KGEscixvKTtyZXR1cm4gZShbYV0pLG59KSx7JGNvbmRpdGlvbjphLCRhOnIsJGI6b30sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JGNvbmRpdGlvbjpmdW5jdGlvbigpe3JldHVybiBYbihuKS50b0Zsb2F0KCl9LCRhOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uY2FzdCh0LmR0eXBlKSl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4ubG9naWNhbE5vdCgpLmNhc3QodC5kdHlwZSkpfX19KSl9fSksbmM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG4sbztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LChlPW1uKHQsXCJjb25kaXRpb25cIixcIndoZXJlQXN5bmNcIixcImJvb2xcIikpLmRhdGEoKV07Y2FzZSAxOnJldHVybiBuPXIuc2VudCgpLG89bmEoZS5zaGFwZSxuKSx0IT09ZSYmZS5kaXNwb3NlKCksWzIsb119fSkpfSkpfTt2YXIgcmM9QW4oe2FkZF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJhZGRcIiksbz1tbihlLFwiYlwiLFwiYWRkXCIpO249TnQocixvKSxyPW5bMF0sbz1uWzFdO3ZhciBhPVJvKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFkZChyLG8pfSkse2E6cixiOm99LChmdW5jdGlvbih0KXtyZXR1cm57YTpmdW5jdGlvbigpe3ZhciBlPXQsbj1FbyhyLnNoYXBlLGEpO3JldHVybiBuLmxlbmd0aD4wJiYoZT1lLnN1bShuKSksZS5yZXNoYXBlKHIuc2hhcGUpfSxiOmZ1bmN0aW9uKCl7dmFyIGU9dCxuPUVvKG8uc2hhcGUsYSk7cmV0dXJuIG4ubGVuZ3RoPjAmJihlPWUuc3VtKG4pKSxlLnJlc2hhcGUoby5zaGFwZSl9fX0pLFwiQWRkXCIpfX0pLG9jPUFuKHthZGROXzpmdW5jdGlvbih0KXtDKEFycmF5LmlzQXJyYXkodCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgYXJndW1lbnQgcGFzc2VkIHRvIHRmLmFkZE4oKSBtdXN0IGJlIGEgbGlzdCBvZiB0ZW5zb3JzXCJ9KSksQyh0Lmxlbmd0aD49MSwoZnVuY3Rpb24oKXtyZXR1cm5cIk11c3QgcGFzcyBhdCBsZWFzdCBvbmUgdGVuc29yIHRvIHRmLmFkZE4oKSwgYnV0IGdvdCBcIit0Lmxlbmd0aH0pKTt2YXIgZT10Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gbW4odCxcInRlbnNvcnNcIitlLFwiYWRkTlwiKX0pKSxuPWVbMF07ZS5mb3JFYWNoKChmdW5jdGlvbih0KXtpZih0LmR0eXBlIT09bi5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gdGYuYWRkTigpIG11c3QgaGF2ZSB0aGUgc2FtZSBkdHlwZVwiKX0pKSxlLmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKCFTKHQuc2hhcGUsbi5zaGFwZSkpdGhyb3cgbmV3IEVycm9yKFwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHRmLmFkZE4oKSBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGVcIil9KSk7dmFyIHI9ZTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuYWRkTihlKX0pLHIsKGZ1bmN0aW9uKHQpe3ZhciBuPXt9O3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKGUscil7bltyXT1mdW5jdGlvbigpe3JldHVybiB0LmNsb25lKCl9fSkpLG59KSxcIkFkZE5cIil9fSksYWM9QW4oe2FkZFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwiYWRkU3RyaWN0XCIpLHI9bW4oZSxcImJcIixcImFkZFN0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBhZGRTdHJpY3Q6IFwiKSxuLmFkZChyKX19KSxpYz1Bbih7YXRhbjJfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwiYXRhbjJcIiksbz1tbihlLFwiYlwiLFwiYXRhbjJcIik7bj1OdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9Um8oci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LmF0YW4yKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59KSx7JGE6ciwkYjpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgZT1yYyhuLnNxdWFyZSgpLHIuc3F1YXJlKCkpLG89dC5tdWwoci5kaXYoZSkpLGk9RW8obi5zaGFwZSxhKTtyZXR1cm4gaS5sZW5ndGg+MCYmKG89by5zdW0oaSkpLG8ucmVzaGFwZShuLnNoYXBlKX0sJGI6ZnVuY3Rpb24oKXt2YXIgZT1yYyhuLnNxdWFyZSgpLHIuc3F1YXJlKCkpLG89d3UodC5tdWwobi5kaXYoZSkpKSxpPUVvKHIuc2hhcGUsYSk7cmV0dXJuIGkubGVuZ3RoPjAmJihvPW8uc3VtKGkpKSxvLnJlc2hhcGUoci5zaGFwZSl9fX0pKX19KSxzYz1Bbih7ZGl2XzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcImRpdlwiKSxvPW1uKGUsXCJiXCIsXCJkaXZcIik7aWYobj1OdChyLG8pLHI9blswXSxvPW5bMV0sXCJpbnQzMlwiPT09ci5kdHlwZSYmXCJpbnQzMlwiPT09by5kdHlwZSlyZXR1cm4gbGMocixvKTt2YXIgYT1SbyhyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQucmVhbERpdmlkZShyLG8pO3JldHVybiBlKFtyLG9dKSxufSkse2E6cixiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnthOmZ1bmN0aW9uKCl7dmFyIGU9dC5kaXYoci50b0Zsb2F0KCkpLG89RW8obi5zaGFwZSxhKTtyZXR1cm4gby5sZW5ndGg+MD9lLnN1bShvKS5yZXNoYXBlKG4uc2hhcGUpOmV9LGI6ZnVuY3Rpb24oKXt2YXIgZT10Lm11bChuLnRvRmxvYXQoKSksbz1FbyhyLnNoYXBlLGEpO28ubGVuZ3RoPjAmJihlPWUuc3VtKG8pLnJlc2hhcGUoci5zaGFwZSkpO3ZhciBpPXIuc3F1YXJlKCk7cmV0dXJuIGUuZGl2KGkudG9GbG9hdCgpKS5uZWcoKX19fSksXCJEaXZcIil9fSksdWM9QW4oe2Rpdk5vTmFuXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcImRpdlwiKSxvPW1uKGUsXCJiXCIsXCJkaXZcIik7cj0obj1OdChyLG8pKVswXSxvPW5bMV07dmFyIGE9c2MocixvKSxpPVhuKGEpLHM9by5lcXVhbChpKTtyZXR1cm4gZWMocyxpLGEpfX0pLGNjPUFuKHtkaXZTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcImRpdlwiKSxyPW1uKGUsXCJiXCIsXCJkaXZcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gZGl2aWRlU3RyaWN0OiBcIiksbi5kaXYocil9fSksbGM9QW4oe2Zsb29yRGl2XzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcImZsb29yRGl2XCIpLG89bW4oZSxcImJcIixcImZsb29yRGl2XCIpO249TnQocixvKSxyPW5bMF0sbz1uWzFdO3ZhciBhPVJvKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5mbG9vckRpdihyLG8pO3JldHVybiBlKFtyLG9dKSxufSkse2E6cixiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnthOmZ1bmN0aW9uKCl7dmFyIGU9dC5kaXYoci50b0Zsb2F0KCkpLG89RW8obi5zaGFwZSxhKTtyZXR1cm4gby5sZW5ndGg+MD9lLnN1bShvKS5yZXNoYXBlKG4uc2hhcGUpOmV9LGI6ZnVuY3Rpb24oKXt2YXIgZT10Lm11bChuLnRvRmxvYXQoKSksbz1FbyhyLnNoYXBlLGEpO28ubGVuZ3RoPjAmJihlPWUuc3VtKG8pLnJlc2hhcGUoci5zaGFwZSkpO3ZhciBpPXIuc3F1YXJlKCk7cmV0dXJuIGUuZGl2KGkudG9GbG9hdCgpKS5uZWcoKX19fSksXCJGbG9vckRpdlwiKX19KSxoYz1Bbih7bWF4aW11bV86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJtYXhpbXVtXCIpLG89bW4oZSxcImJcIixcIm1heGltdW1cIik7cmV0dXJuIG49TnQocixvKSxyPW5bMF0sbz1uWzFdLFwiYm9vbFwiPT09ci5kdHlwZSYmKHI9ci50b0ludCgpLG89by50b0ludCgpKSxSbyhyLnNoYXBlLG8uc2hhcGUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tYXhpbXVtKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59KSx7YTpyLGI6b30sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJue2E6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5ncmVhdGVyRXF1YWwocikudG9GbG9hdCgpKX0sYjpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmxlc3MocikudG9GbG9hdCgpKX19fSksXCJNYXhpbXVtXCIpfX0pLGZjPUFuKHttYXhpbXVtU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJtYXhpbXVtU3RyaWN0XCIpLHI9bW4oZSxcImJcIixcIm1heGltdW1TdHJpY3RcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbWF4aW11bVN0cmljdDogXCIpLG4ubWF4aW11bShyKX19KSxkYz1Bbih7bWluaW11bV86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJtaW5pbXVtXCIpLG89bW4oZSxcImJcIixcIm1pbmltdW1cIik7cmV0dXJuIG49TnQocixvKSxyPW5bMF0sbz1uWzFdLFwiYm9vbFwiPT09ci5kdHlwZSYmKHI9ci50b0ludCgpLG89by50b0ludCgpKSxSbyhyLnNoYXBlLG8uc2hhcGUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5taW5pbXVtKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59KSx7YTpyLGI6b30sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJue2E6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5sZXNzRXF1YWwocikudG9GbG9hdCgpKX0sYjpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmdyZWF0ZXIocikudG9GbG9hdCgpKX19fSksXCJNaW5pbXVtXCIpfX0pLHBjPUFuKHttaW5pbXVtU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJtaW5pbXVtU3RyaWN0XCIpLHI9bW4oZSxcImJcIixcIm1pbmltdW1TdHJpY3RcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbWluaW11bVN0cmljdDogXCIpLG4ubWluaW11bShyKX19KSx2Yz1Bbih7bW9kXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcIm1vZFwiKSxvPW1uKGUsXCJiXCIsXCJtb2RcIik7bj1OdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9Um8oci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1vZChyLG8pO3JldHVybiBlKFtyLG9dKSxufSkseyRhOnIsJGI6b30sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJueyRhOmZ1bmN0aW9uKCl7dmFyIGU9RW8obi5zaGFwZSxhKTtyZXR1cm4gZS5sZW5ndGg+MD90LnN1bShlKS5yZXNoYXBlKG4uc2hhcGUpOnR9LCRiOmZ1bmN0aW9uKCl7dmFyIGU9dC5tdWwobi5kaXYocikuZmxvb3IoKS5uZWcoKSksbz1FbyhyLnNoYXBlLGEpO3JldHVybiBvLmxlbmd0aD4wP2Uuc3VtKG8pLnJlc2hhcGUoci5zaGFwZSk6ZX19fSkpfX0pLG1jPUFuKHttb2RTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcIm1vZFN0cmljdFwiKSxyPW1uKGUsXCJiXCIsXCJtb2RTdHJpY3RcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbW9kU3RyaWN0OiBcIiksbi5tb2Qocil9fSksZ2M9QW4oe211bF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJtdWxcIiksbz1tbihlLFwiYlwiLFwibXVsXCIpO249TnQocixvKSxyPW5bMF0sbz1uWzFdO3ZhciBhPVJvKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tdWx0aXBseShyLG8pO3JldHVybiBlKFtyLG9dKSxufSkse2E6cixiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnthOmZ1bmN0aW9uKCl7dmFyIGU9dC5tdWwoci50b0Zsb2F0KCkpLG89RW8obi5zaGFwZSxhKTtyZXR1cm4gby5sZW5ndGg+MD9lLnN1bShvKS5yZXNoYXBlKG4uc2hhcGUpOmV9LGI6ZnVuY3Rpb24oKXt2YXIgZT10Lm11bChuLnRvRmxvYXQoKSksbz1FbyhyLnNoYXBlLGEpO3JldHVybiBvLmxlbmd0aD4wP2Uuc3VtKG8pLnJlc2hhcGUoci5zaGFwZSk6ZX19fSksXCJNdWxcIil9fSkseWM9QW4oe211bFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwibXVsXCIpLHI9bW4oZSxcImJcIixcIm11bFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBtdWx0aXBseVN0cmljdDogXCIpLG4ubXVsKHIpfX0pLHhjPUFuKHtwb3dfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYmFzZVwiLFwicG93XCIpLG89bW4oZSxcImV4cFwiLFwicG93XCIpO249TnQocixvKSxyPW5bMF0sbz1uWzFdO3ZhciBhPVJvKHIuc2hhcGUsby5zaGFwZSksaT1bcixvXTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LnBvdyhyLG8pO3JldHVybiBlKFtyLG8sbl0pLG59KSx7YTpyLGI6b30sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV0sbz1lWzJdO3JldHVybnthOmZ1bmN0aW9uKCl7dmFyIGU9ci50b0Zsb2F0KCksbz10Lm11bChlLm11bChuLnBvdyhlLnN1YihPbigxKSkpKSksaT1FbyhuLnNoYXBlLGEpO3JldHVybiBpLmxlbmd0aD4wJiYobz1vLnN1bShpKSksby5yZXNoYXBlKG4uc2hhcGUpfSxiOmZ1bmN0aW9uKCl7dmFyIGU9bi5ncmVhdGVyKDApLGk9bi5sb2coKS53aGVyZShlLFhuKG4pKSxzPXQubXVsKG8ubXVsKGkpKSx1PUVvKHIuc2hhcGUsYSk7cmV0dXJuIHUubGVuZ3RoPjAmJihzPXMuc3VtKHUpKSxzLnJlc2hhcGUoci5zaGFwZSl9fX0pLFwiUG93XCIse30saSxbITBdKX19KSxiYz1Bbih7cG93U3RyaWN0XzpmdW5jdGlvbih0LGUpe3JldHVybiBFKHQuc2hhcGUsZS5zaGFwZSxcIkVycm9yIGluIHBvd1N0cmljdDogXCIpLHQucG93KGUpfX0pLHdjPUFuKHtzcXVhcmVkRGlmZmVyZW5jZVN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwic3F1YXJlZERpZmZlcmVuY2VTdHJpY3RcIikscj1tbihlLFwiYlwiLFwic3F1YXJlZERpZmZlcmVuY2VTdHJpY3RcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gc3F1YXJlZERpZmZlcmVuY2VTdHJpY3Q6IFwiKSxuLnNxdWFyZWREaWZmZXJlbmNlKHIpfX0pLENjPUFuKHtzdWJfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwic3ViXCIpLG89bW4oZSxcImJcIixcInN1YlwiKTtuPU50KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1SbyhyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zdWJ0cmFjdChyLG8pfSkse2E6cixiOm99LChmdW5jdGlvbih0KXtyZXR1cm57YTpmdW5jdGlvbigpe3ZhciBlPXQsbj1FbyhyLnNoYXBlLGEpO3JldHVybiBuLmxlbmd0aD4wJiYoZT1lLnN1bShuKSksZS5yZXNoYXBlKHIuc2hhcGUpfSxiOmZ1bmN0aW9uKCl7dmFyIGU9dCxuPUVvKG8uc2hhcGUsYSk7cmV0dXJuIG4ubGVuZ3RoPjAmJihlPWUuc3VtKG4pKSxlLm5lZygpLnJlc2hhcGUoby5zaGFwZSl9fX0pLFwiU3ViXCIpfX0pLEVjPUFuKHtzdWJTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcInN1YlN0cmljdFwiKSxyPW1uKGUsXCJiXCIsXCJzdWJTdHJpY3RcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gc3ViU3RyaWN0OiBcIiksbi5zdWIocil9fSk7dmFyIFJjPUFuKHtlcXVhbF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJlcXVhbFwiKSxvPW1uKGUsXCJiXCIsXCJlcXVhbFwiKTtyZXR1cm4gbj1OdChyLG8pLHI9blswXSxvPW5bMV0sUm8oci5zaGFwZSxvLnNoYXBlKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5lcXVhbChyLG8pfSkseyRhOnIsJGI6b30pfX0pLEljPUFuKHtlcXVhbFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwiZXF1YWxTdHJpY3RcIikscj1tbihlLFwiYlwiLFwiZXF1YWxTdHJpY3RcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gZXF1YWxTdHJpY3Q6IFwiKSxuLmVxdWFsKHIpfX0pLGtjPUFuKHtncmVhdGVyXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcImdyZWF0ZXJcIiksbz1tbihlLFwiYlwiLFwiZ3JlYXRlclwiKTtyZXR1cm4gbj1OdChyLG8pLHI9blswXSxvPW5bMV0sUm8oci5zaGFwZSxvLnNoYXBlKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5ncmVhdGVyKHIsbyl9KSx7YTpyLGI6b30sbnVsbCxcIkdyZWF0ZXJcIil9fSksU2M9QW4oe2dyZWF0ZXJFcXVhbF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJncmVhdGVyRXF1YWxcIiksbz1tbihlLFwiYlwiLFwiZ3JlYXRlckVxdWFsXCIpO3JldHVybiBuPU50KHIsbykscj1uWzBdLG89blsxXSxSbyhyLnNoYXBlLG8uc2hhcGUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5ncmVhdGVyRXF1YWwocixvKTtyZXR1cm4gZShbcixvXSksbn0pLHthOnIsYjpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57YTpmdW5jdGlvbigpe3JldHVybiBYbihuKX0sYjpmdW5jdGlvbigpe3JldHVybiBYbihyKX19fSksXCJHcmVhdGVyRXF1YWxcIil9fSksQWM9QW4oe2dyZWF0ZXJFcXVhbFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwiZ3JlYXRlckVxdWFsU3RyaWN0XCIpLHI9bW4oZSxcImJcIixcImdyZWF0ZXJFcXVhbFN0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBncmVhdGVyRXF1YWxTdHJpY3Q6IFwiKSxuLmdyZWF0ZXJFcXVhbChyKX19KSxEYz1Bbih7Z3JlYXRlclN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwiZ3JlYXRlclN0cmljdFwiKSxyPW1uKGUsXCJiXCIsXCJncmVhdGVyU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGdyZWF0ZXJTdHJpY3Q6IFwiKSxuLmdyZWF0ZXIocil9fSksVGM9QW4oe2xlc3NfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwibGVzc1wiKSxvPW1uKGUsXCJiXCIsXCJsZXNzXCIpO3JldHVybiBuPU50KHIsbykscj1uWzBdLG89blsxXSxSbyhyLnNoYXBlLG8uc2hhcGUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lmxlc3MocixvKX0pLHthOnIsYjpvfSxudWxsLFwiTGVzc1wiKX19KSxOYz1Bbih7bGVzc0VxdWFsXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcImxlc3NFcXVhbFwiKSxvPW1uKGUsXCJiXCIsXCJsZXNzRXF1YWxcIik7cmV0dXJuIG49TnQocixvKSxyPW5bMF0sbz1uWzFdLFJvKHIuc2hhcGUsby5zaGFwZSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10Lmxlc3NFcXVhbChyLG8pO3JldHVybiBlKFtyLG9dKSxufSkse2E6cixiOm99LG51bGwsXCJMZXNzRXF1YWxcIil9fSksRmM9QW4oe2xlc3NFcXVhbFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwibGVzc0VxdWFsU3RyaWN0XCIpLHI9bW4oZSxcImJcIixcImxlc3NFcXVhbFN0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBsZXNzRXF1YWxTdHJpY3Q6IFwiKSxuLmxlc3NFcXVhbChyKX19KSxfYz1Bbih7bGVzc1N0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwibGVzc1N0cmljdFwiKSxyPW1uKGUsXCJiXCIsXCJsZXNzU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGxlc3NTdHJpY3Q6IFwiKSxuLmxlc3Mocil9fSksT2M9QW4oe25vdEVxdWFsXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcIm5vdEVxdWFsXCIpLG89bW4oZSxcImJcIixcIm5vdEVxdWFsXCIpO3JldHVybiBuPU50KHIsbykscj1uWzBdLG89blsxXSxSbyhyLnNoYXBlLG8uc2hhcGUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5vdEVxdWFsKHIsbyl9KSx7YTpyLGI6b30sbnVsbCxcIk5vdEVxdWFsXCIpfX0pLE1jPUFuKHtub3RFcXVhbFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwibm90RXF1YWxTdHJpY3RcIikscj1tbihlLFwiYlwiLFwibm90RXF1YWxTdHJpY3RcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbm90RXF1YWxTdHJpY3Q6IFwiKSxuLm5vdEVxdWFsKHIpfX0pO2Z1bmN0aW9uIEJjKHQsZSl7Zm9yKHZhciBuPVtdLHI9dDtyPGU7KytyKW4ucHVzaChyKTtyZXR1cm4gbn1mdW5jdGlvbiBQYyh0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7KytuKWZvcih2YXIgcj0wO3I8dFtuXS5sZW5ndGg7KytyKWUucHVzaCh0W25dW3JdKTtyZXR1cm4gZX12YXIgTGM9QW4oe2dhdGhlcl86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPTApO3ZhciByPW1uKHQsXCJ4XCIsXCJnYXRoZXJcIiksbz1tbihlLFwiaW5kaWNlc1wiLFwiZ2F0aGVyXCIsXCJpbnQzMlwiKTtuPU8obixyLnNoYXBlKVswXTt2YXIgYT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPXQuc2hhcGVbbl0sbz1bXSxhPTEsaT0xLHM9MDtzPG47cysrKW8ucHVzaCh0LnNoYXBlW3NdKSxhKj10LnNoYXBlW3NdO2ZvcihzPTA7czxlLnJhbms7cysrKW8ucHVzaChlLnNoYXBlW3NdKTtmb3Iocz1uKzE7czx0LnJhbms7cysrKW8ucHVzaCh0LnNoYXBlW3NdKSxpKj10LnNoYXBlW3NdO3JldHVybntiYXRjaFNpemU6YSxzbGljZVNpemU6aSxkaW1TaXplOnIsb3V0cHV0U2hhcGU6b319KHIsbyxuKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgYT10LmdhdGhlcihyLG8uZmxhdHRlbigpLG4pO3JldHVybiBlKFtvXSksYX0pLHt4OnIsaW5kaWNlczpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbz1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7dmFyIGU9ci5zaGFwZSxhPW8uc2l6ZSxpPWUuc2xpY2UoMCxuKSxzPWkubGVuZ3RoLHU9ZS5zbGljZShuLGUubGVuZ3RoKS5zbGljZSgxKSxjPXUubGVuZ3RoLGw9QmMoMCxzKSxoPUJjKHMrMSxzKzErYyksZj1QYyhbaSxbYV0sdV0pLGQ9dC5yZXNoYXBlKGYpLHA9by5yZXNoYXBlKFthXSksdj1QYyhbW3NdLGwsaF0pLG09ZC50cmFuc3Bvc2UodiksZz1XYyhtLHAsci5zaGFwZVtuXSkseT1Sbih2KTtyZXR1cm4gZz1nLnRyYW5zcG9zZSh5KX0saW5kaWNlczpmdW5jdGlvbigpe3JldHVybiBvfX19KSxcIkdhdGhlclwiLHtheGlzOm59KS5yZXNoYXBlKGEub3V0cHV0U2hhcGUpfX0pLFdjPUFuKHt1bnNvcnRlZFNlZ21lbnRTdW1fOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1tbih0LFwieFwiLFwidW5zb3J0ZWRTZWdtZW50U3VtXCIpLG89bW4oZSxcInNlZ21lbnRJZHNcIixcInVuc29ydGVkU2VnbWVudFN1bVwiLFwiaW50MzJcIik7cmV0dXJuIEMoQShuKSwoZnVuY3Rpb24oKXtyZXR1cm5cIm51bVNlZ21lbnRzIG11c3QgYmUgb2YgZHR5cGUgaW50XCJ9KSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgYT10LnVuc29ydGVkU2VnbWVudFN1bShyLG8sbik7cmV0dXJuIGUoW29dKSxhfSkseyR4OnJ9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWhjKGUsWG4oZSkpLHI9TGModCxuKSxvPVNjKGUsT24oMCxcImludDMyXCIpKSxhPXIucmFuay1vLnJhbmssaT0wO2k8YTsrK2kpbz13cihvLGkrMSk7bz1RdShvLHpuKHIuc2hhcGUsXCJib29sXCIpKTt2YXIgcz1YbihyKTtyZXR1cm4gZWMobyxyLHMpfSh0LG4pfX19KSl9fSk7dmFyIFVjPWZ1bmN0aW9uKHQsZSxvKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sYSxpLHMsdSxjLGwsaCxmLGQscCx2LG07cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpmb3Iobj1tbih0LFwidGVuc29yXCIsXCJib29sTWFza1wiKSxhPW1uKGUsXCJtYXNrXCIsXCJib29sTWFza1wiLFwiYm9vbFwiKSxpPW51bGw9PW8/MDpvLHM9YS5yYW5rLHU9bi5zaGFwZSxDKHM+MCwoZnVuY3Rpb24oKXtyZXR1cm5cIm1hc2sgY2Fubm90IGJlIHNjYWxhclwifSkpLEUodS5zbGljZShpLGkrcyksYS5zaGFwZSxcIm1hc2sncyBzaGFwZSBtdXN0IG1hdGNoIHRoZSBmaXJzdCBLIGRpbWVuc2lvbnMgb2YgdGVuc29yJ3Mgc2hhcGUsXCIpLGM9MSxsPWk7bDxpK3M7bCsrKWMqPXVbbF07cmV0dXJuIGg9dS5zbGljZSgwLGkpLmNvbmNhdChbY10sdS5zbGljZShpK3MpKSxmPW4ucmVzaGFwZShoKSxkPWEucmVzaGFwZShbLTFdKSxbNCxuYyhkKV07Y2FzZSAxOnJldHVybiBwPXIuc2VudCgpLHY9cC5zcXVlZXplKFsxXSksbT1MYyhmLHYsaSksdCE9PW4mJm4uZGlzcG9zZSgpLGUhPT1hJiZhLmRpc3Bvc2UoKSx2LmRpc3Bvc2UoKSxmLmRpc3Bvc2UoKSxkLmRpc3Bvc2UoKSxwLmRpc3Bvc2UoKSxbMixtXX19KSl9KSl9O2Z1bmN0aW9uIFZjKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWEmJihhPVwiTkhXQ1wiKSxDKHQubGVuZ3RoPT09ZS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiTGVuZ3RoIG9mIGluU2hhcGUgKFwiK3QubGVuZ3RoK1wiKSBhbmQgcmFuayBvZiBkeSAoXCIrZS5yYW5rK1wiKSBtdXN0IG1hdGNoXCJ9KSk7dmFyIHM9dCx1PWUsYz0hMTszPT09ZS5yYW5rJiYoYz0hMCx1PWUuYXM0RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdKSxzPVsxLHRbMF0sdFsxXSx0WzJdXSksQyg0PT09cy5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogaW5TaGFwZSBtdXN0IGJlIGxlbmd0aCA0LCBidXQgZ290IGxlbmd0aCBcIitzLmxlbmd0aCtcIi5cIn0pKSxDKDQ9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZHkgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmt9KSksQyg0PT09bi5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK24ucmFua30pKTt2YXIgbD1cIk5IV0NcIj09PWE/c1szXTpzWzFdLGg9XCJOSFdDXCI9PT1hP3Uuc2hhcGVbM106dS5zaGFwZVsxXTtDKGw9PT1uLnNoYXBlWzJdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGRlcHRoIG9mIGlucHV0IChcIitsK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrbi5zaGFwZVsyXStcIi5cIn0pKSxDKGg9PT1uLnNoYXBlWzNdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGRlcHRoIG9mIG91dHB1dCAoXCIraCtcIikgbXVzdCBtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciBcIituLnNoYXBlWzNdK1wiLlwifSkpLG51bGwhPWkmJkMoQShvKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitpK1wiIGJ1dCBnb3QgcGFkIFwiK28rXCIuXCJ9KSk7dmFyIGY9Qm8oYSksZD1TbyhzLG4uc2hhcGUsciwxLG8saSwhMSxmKSxwPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIHI9dC5jb252MmREZXJJbnB1dCh1LG4sZCk7cmV0dXJuIGUoW24sdV0pLHJ9KSx7ZHk0RDp1LGZpbHRlcjpufSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHM9ZVsxXTtyZXR1cm57ZHk0RDpmdW5jdGlvbigpe3JldHVybiBxYyh0LG4scixvLGEsMSxpKX0sZmlsdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIGpjKHQscyxuLnNoYXBlLHIsbyxhLGkpfX19KSk7cmV0dXJuIGM/cC5hczNEKHAuc2hhcGVbMV0scC5zaGFwZVsyXSxwLnNoYXBlWzNdKTpwfWZ1bmN0aW9uIHpjKHQpe3ZhciBlPWZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P1t0LHQsdF06Mj09PXQubGVuZ3RoP1t0WzBdLHRbMV0sMV06dH0odCksbj1lWzBdLHI9ZVsxXSxvPWVbMl07cmV0dXJuIDE9PT1uJiYxPT09ciYmMT09PW99ZnVuY3Rpb24gR2ModCxlLG4scixvKXtDKHQubGVuZ3RoPT09ZS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiTGVuZ3RoIG9mIGluU2hhcGUgKFwiK3QubGVuZ3RoK1wiKSBhbmQgcmFuayBvZiBkeSAoXCIrZS5yYW5rK1wiKSBtdXN0IG1hdGNoXCJ9KSk7dmFyIGE9dCxpPWUscz0hMTs0PT09ZS5yYW5rJiYocz0hMCxpPWUuYXM1RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdLGUuc2hhcGVbM10pLGE9WzEsdFswXSx0WzFdLHRbMl0sdFszXV0pO3ZhciB1PWFbNF0sYz1pLnNoYXBlWzRdO0MoNT09PWEubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGluU2hhcGUgbXVzdCBiZSBsZW5ndGggNSwgYnV0IGdvdCBsZW5ndGggXCIrYS5sZW5ndGgrXCIuXCJ9KSksQyg1PT09aS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGR5IG11c3QgYmUgcmFuayA1LCBidXQgZ290IHJhbmsgXCIraS5yYW5rfSkpLEMoNT09PW4ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlcklucHV0OiBmaWx0ZXIgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3QgcmFuayBcIituLnJhbmt9KSksQyh1PT09bi5zaGFwZVszXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlcklucHV0OiBkZXB0aCBvZiBpbnB1dCAoXCIrdStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK24uc2hhcGVbM10rXCIuXCJ9KSksQyhjPT09bi5zaGFwZVs0XSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlcklucHV0OiBkZXB0aCBvZiBvdXRwdXQgKFwiK2MrXCIpIG11c3QgbWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrbi5zaGFwZVs0XStcIi5cIn0pKTt2YXIgbD1BbyhhLG4uc2hhcGUsciwxLG8pLGg9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29udjNkRGVySW5wdXQoaSxuLGwpfSkse2R5NUQ6aX0pO3JldHVybiBzP2guYXM0RChoLnNoYXBlWzFdLGguc2hhcGVbMl0saC5zaGFwZVszXSxoLnNoYXBlWzRdKTpofXZhciBIYz1Bbih7Y29udjFkXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1vJiYobz1cIk5XQ1wiKSx2b2lkIDA9PT1hJiYoYT0xKTt2YXIgcz1tbih0LFwieFwiLFwiY29udjFkXCIpLHU9bW4oZSxcImZpbHRlclwiLFwiY29udjFkXCIpLGM9cyxsPSExOzI9PT1zLnJhbmsmJihsPSEwLGM9cy5hczNEKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdKSksQygzPT09Yy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjFkOiBpbnB1dCBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pKSxDKDM9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MWQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxudWxsIT1pJiZDKEEociksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MWQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2krXCIgYnV0IGdvdCBwYWQgXCIrcitcIi5cIn0pKSxDKGMuc2hhcGVbMl09PT11LnNoYXBlWzFdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjFkOiBkZXB0aCBvZiBpbnB1dCAoXCIrYy5zaGFwZVsyXStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK3Uuc2hhcGVbMV0rXCIuXCJ9KSksQyhNbyhuLGEpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjFEOiBFaXRoZXIgc3RyaWRlIG9yIGRpbGF0aW9uIG11c3QgYmUgMS4gR290IHN0cmlkZSBcIituK1wiIGFuZCBkaWxhdGlvbiAnXCIrYStcIidcIn0pKSxDKFwiTldDXCI9PT1vLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjFkOiBnb3QgZGF0YUZvcm1hdCBvZiBcIitvK1wiIGJ1dCBvbmx5IE5XQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlwifSkpO3ZhciBoPXUuYXM0RCgxLHUuc2hhcGVbMF0sdS5zaGFwZVsxXSx1LnNoYXBlWzJdKSxmPWMuYXM0RChjLnNoYXBlWzBdLDEsYy5zaGFwZVsxXSxjLnNoYXBlWzJdKSxkPXFjKGYsaCxbMSxuXSxyLFwiTkhXQ1wiLFsxLGFdLGkpO3JldHVybiBsP2QuYXMyRChkLnNoYXBlWzJdLGQuc2hhcGVbM10pOmQuYXMzRChkLnNoYXBlWzBdLGQuc2hhcGVbMl0sZC5zaGFwZVszXSl9fSkscWM9QW4oe2NvbnYyZF86ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09byYmKG89XCJOSFdDXCIpLHZvaWQgMD09PWEmJihhPVsxLDFdKTt2YXIgcz1tbih0LFwieFwiLFwiY29udjJkXCIpLHU9bW4oZSxcImZpbHRlclwiLFwiY29udjJkXCIpLGM9cyxsPSExOzM9PT1zLnJhbmsmJihsPSEwLGM9cy5hczREKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0pKSxDKDQ9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwifSkpLEMoND09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpLG51bGwhPWkmJkMoQShyKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIraStcIiBidXQgZ290IHBhZCBcIityK1wiLlwifSkpO3ZhciBoPVwiTkhXQ1wiPT09bz9jLnNoYXBlWzNdOmMuc2hhcGVbMV07QyhoPT09dS5zaGFwZVsyXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZDogZGVwdGggb2YgaW5wdXQgKFwiK2grXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIit1LnNoYXBlWzJdK1wiLlwifSkpLEMoTW8obixhKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyRDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbitcIiBhbmQgZGlsYXRpb25zICdcIithK1wiJ1wifSkpO3ZhciBmPUJvKG8pLGQ9U28oYy5zaGFwZSx1LnNoYXBlLG4sYSxyLGksITEsZikscD1bdSxjXSx2PUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5jb252MmQoYyx1LGQpO3JldHVybiBlKFt1LGNdKSxufSkse3g6YyxmaWx0ZXI6dX0sKGZ1bmN0aW9uKHQsZSl7dmFyIGk9ZSxzPWlbMF0sdT1pWzFdO3JldHVybiBDKE9vKGEpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZ3JhZGllbnQgb2YgY29udjJEOiBkaWxhdGlvbiByYXRlcyBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gZ3JhZGllbnRzLiBHb3QgZGlsYXRpb25zICdcIithK1wiJ1wifSkpLHt4OmZ1bmN0aW9uKCl7cmV0dXJuIFhjKHUuc2hhcGUsdCxzLG4scixvKX0sZmlsdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIGpjKHUsdCxzLnNoYXBlLG4scixvKX19fSksXCJDb252MkRcIixkLHApO3JldHVybiBsP3YuYXMzRCh2LnNoYXBlWzFdLHYuc2hhcGVbMl0sdi5zaGFwZVszXSk6dn19KSxLYz1Bbih7Y29udjNkXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7dm9pZCAwPT09byYmKG89XCJOREhXQ1wiKSx2b2lkIDA9PT1hJiYoYT1bMSwxLDFdKTt2YXIgaT1tbih0LFwieFwiLFwiY29udjNkXCIpLHM9bW4oZSxcImZpbHRlclwiLFwiY29udjNkXCIpLHU9aSxjPSExOzQ9PT1pLnJhbmsmJihjPSEwLHU9aS5hczVEKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0saS5zaGFwZVszXSkpLEMoNT09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZDogaW5wdXQgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksQyg1PT09cy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSksQyh1LnNoYXBlWzRdPT09cy5zaGFwZVszXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZDogZGVwdGggb2YgaW5wdXQgKFwiK3Uuc2hhcGVbNF0rXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIitzLnNoYXBlWzNdK1wiLlwifSkpLEMoZnVuY3Rpb24odCxlKXtyZXR1cm4gemModCl8fHpjKGUpfShuLGEpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNEOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSksQyhcIk5ESFdDXCI9PT1vLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkOiBnb3QgZGF0YUZvcm1hdCBvZiBcIitvK1wiIGJ1dCBvbmx5IE5ESFdDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXCJ9KSk7dmFyIGw9QW8odS5zaGFwZSxzLnNoYXBlLG4sYSxyKSxoPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5jb252M2QodSxzLGwpO3JldHVybiBlKFt1LHNdKSxufSkse3g6dSwkZmlsdGVyOnN9LChmdW5jdGlvbih0LGUpe0MoemMoYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBncmFkaWVudCBvZiBjb252M0Q6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZCBpbiBncmFkaWVudHMuIEdvdCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSk7dmFyIG89ZVswXSxpPWVbMV07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gR2Moby5zaGFwZSx0LGksbixyKX0sJGZpbHRlcjpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8pe3ZhciBhPXQ7ND09PXQucmFuayYmKGE9dC5hczVEKDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0sdC5zaGFwZVszXSkpO3ZhciBpPWU7ND09PWkucmFuayYmKGk9ZS5hczVEKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0sZS5zaGFwZVszXSkpO0MoNT09PWEucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlckZpbHRlcjogaW5wdXQgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3Qgc2hhcGUgXCIrYS5zaGFwZStcIi5cIn0pKSxDKDU9PT1pLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGR5IG11c3QgYmUgcmFuayA1LCBidXQgZ290IHNoYXBlIFwiK2kuc2hhcGUrXCIuXCJ9KSksQyg1PT09bi5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGZpbHRlclNoYXBlIG11c3QgYmUgbGVuZ3RoIDUsIGJ1dCBnb3QgXCIrbitcIi5cIn0pKSxDKGEuc2hhcGVbNF09PT1uWzNdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVyRmlsdGVyOiBkZXB0aCBvZiBpbnB1dCBcIithLnNoYXBlWzRdK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGluIGZpbHRlciAoXCIrblszXStcIi5cIn0pKSxDKGkuc2hhcGVbNF09PT1uWzRdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVyRmlsdGVyOiBkZXB0aCBvZiBkeSAoXCIraS5zaGFwZVs0XStcIikgbXVzdCBtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciAoXCIrbls0XStcIikuXCJ9KSk7dmFyIHM9QW8oYS5zaGFwZSxuLHIsMSxvKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29udjNkRGVyRmlsdGVyKGEsaSxzKX0pLHt4NUQ6YSxkeTVEOml9KX0obyx0LGkuc2hhcGUsbixyKX19fSkpO3JldHVybiBjP2guYXM0RChoLnNoYXBlWzFdLGguc2hhcGVbMl0saC5zaGFwZVszXSxoLnNoYXBlWzRdKTpofX0pLGpjPUFuKHtjb252MmREZXJGaWx0ZXJfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWEmJihhPVwiTkhXQ1wiKTt2YXIgcz10OzM9PT10LnJhbmsmJihzPXQuYXM0RCgxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSx0LnNoYXBlWzJdKSk7dmFyIHU9ZTszPT09dS5yYW5rJiYodT1lLmFzNEQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSkpLEMoND09PXMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3Qgc2hhcGUgXCIrcy5zaGFwZStcIi5cIn0pKSxDKDQ9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGR5IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHNoYXBlIFwiK3Uuc2hhcGUrXCIuXCJ9KSksQyg0PT09bi5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGZpbHRlclNoYXBlIG11c3QgYmUgbGVuZ3RoIDQsIGJ1dCBnb3QgXCIrbitcIi5cIn0pKTt2YXIgYz1cIk5IV0NcIj09PWE/cy5zaGFwZVszXTpzLnNoYXBlWzFdLGw9XCJOSFdDXCI9PT1hP3Uuc2hhcGVbM106dS5zaGFwZVsxXTtDKGM9PT1uWzJdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkZXB0aCBvZiBpbnB1dCBcIitjK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGluIGZpbHRlciAoXCIrblsyXStcIi5cIn0pKSxDKGw9PT1uWzNdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkZXB0aCBvZiBkeSAoXCIrbCtcIikgbXVzdCBtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciAoXCIrblszXStcIikuXCJ9KSksbnVsbCE9aSYmQyhBKG8pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitpK1wiIGJ1dCBnb3QgcGFkIFwiK28rXCIuXCJ9KSk7dmFyIGg9Qm8oYSksZj1TbyhzLnNoYXBlLG4sciwxLG8saSwhMSxoKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29udjJkRGVyRmlsdGVyKHMsdSxmKX0pLHt4NEQ6cyxkeTREOnV9KX19KSxYYz1Bbih7Y29udjJkRGVySW5wdXRfOlZjfSksWWM9QW4oe2RlcHRod2lzZUNvbnYyZF86ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09byYmKG89XCJOSFdDXCIpLHZvaWQgMD09PWEmJihhPVsxLDFdKTt2YXIgcz1tbih0LFwieFwiLFwiZGVwdGh3aXNlQ29udjJkXCIpLHU9bW4oZSxcImZpbHRlclwiLFwiZGVwdGh3aXNlQ29udjJkXCIpLGM9cyxsPSExOzM9PT1zLnJhbmsmJihsPSEwLGM9cy5hczREKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0pKSxDKDQ9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwifSkpLEMoND09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpLEMoYy5zaGFwZVszXT09PXUuc2hhcGVbMl0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IG51bWJlciBvZiBpbnB1dCBjaGFubmVscyAoXCIrYy5zaGFwZVszXStcIikgbXVzdCBtYXRjaCB0aGUgaW5DaGFubmVscyBkaW1lbnNpb24gaW4gZmlsdGVyIFwiK3Uuc2hhcGVbMl0rXCIuXCJ9KSksbnVsbD09YSYmKGE9WzEsMV0pLEMoTW8obixhKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbitcIiBhbmQgZGlsYXRpb25zICdcIithK1wiJ1wifSkpLG51bGwhPWkmJkMoQShyKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIraStcIiBidXQgZ290IHBhZCBcIityK1wiLlwifSkpO3ZhciBoPVNvKGMuc2hhcGUsdS5zaGFwZSxuLGEscixpLCEwKSxmPVtjLHVdLGQ9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LmRlcHRod2lzZUNvbnYyRChjLHUsaCk7cmV0dXJuIGUoW2MsdV0pLG59KSx7eDpjLGZpbHRlcjp1fSwoZnVuY3Rpb24odCxlKXtDKE9vKGEpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZ3JhZGllbnQgb2YgZGVwdGh3aXNlQ29udjJkOiBkaWxhdGlvbiByYXRlcyBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHlldCBzdXBwb3J0ZWQuIEdvdCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSk7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gJGMobi5zaGFwZSx0LHIsaCl9LGZpbHRlcjpmdW5jdGlvbigpe3JldHVybiBRYyhuLHQsci5zaGFwZSxoKX19fSksXCJEZXB0aHdpc2VDb252MmROYXRpdmVcIixoLGYpO3JldHVybiBsP2QuYXMzRChkLnNoYXBlWzFdLGQuc2hhcGVbMl0sZC5zaGFwZVszXSk6ZH19KSwkYz1Bbih7ZGVwdGh3aXNlQ29udjJkRGVySW5wdXRfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPWUsYT0hMTszPT09ZS5yYW5rJiYoYT0hMCxvPWUuYXM0RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdKSk7dmFyIGk9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGVwdGh3aXNlQ29udjJERGVySW5wdXQobyxuLHIpfSkse2R5NEQ6b30pO3JldHVybiBhP2kuYXMzRChpLnNoYXBlWzFdLGkuc2hhcGVbMl0saS5zaGFwZVszXSk6aX19KSxRYz1Bbih7ZGVwdGh3aXNlQ29udjJkRGVyRmlsdGVyXzpmdW5jdGlvbih0LGUsbixyKXt2YXIgbz10OzM9PT10LnJhbmsmJihvPXQuYXM0RCgxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSx0LnNoYXBlWzJdKSk7dmFyIGE9ZTtyZXR1cm4gMz09PWEucmFuayYmKGE9ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5kZXB0aHdpc2VDb252MkREZXJGaWx0ZXIobyxhLHIpfSkse3g0RDpvLGR5NEQ6YX0pfX0pLEpjPUFuKHtzZXBhcmFibGVDb252MmRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWEmJihhPVsxLDFdKSx2b2lkIDA9PT1pJiYoaT1cIk5IV0NcIik7dmFyIHM9bW4odCxcInhcIixcInNlcGFyYWJsZUNvbnYyZFwiKSx1PW1uKGUsXCJkZXB0aHdpc2VGaWx0ZXJcIixcInNlcGFyYWJsZUNvbnYyZFwiKSxjPW1uKG4sXCJwb2ludHdpc2VGaWx0ZXJcIixcInNlcGFyYWJsZUNvbnYyZFwiKSxsPXMsaD0hMTtpZigzPT09cy5yYW5rJiYoaD0hMCxsPXMuYXM0RCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdKSksXCJOQ0hXXCI9PT1pKXRocm93IG5ldyBFcnJvcihcInNlcGFyYWJsZUNvbnYyZCBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCBkYXRhRm9ybWF0IE5DSFc7IG9ubHkgTkhXQyBpcyBzdXBwb3J0ZWRcIik7Qyg0PT09bC5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIn0pKSxDKDQ9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IGRlcHRod2lzZSBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksQyg0PT09Yy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiBwb2ludHdpc2UgZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpLEMoMT09PWMuc2hhcGVbMF0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHRoZSBmaXJzdCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciAgbXVzdCBiZSAxLCBidXQgZ290IFwiK2Muc2hhcGVbMF0rXCIuXCJ9KSksQygxPT09Yy5zaGFwZVsxXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIHNlY29uZCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciBtdXN0IGJlIDEsIGJ1dCBnb3QgXCIrYy5zaGFwZVsxXStcIi5cIn0pKTt2YXIgZj11LnNoYXBlWzJdLGQ9dS5zaGFwZVszXTtDKGMuc2hhcGVbMl09PT1mKmQsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHRoZSB0aGlyZCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciBtdXN0IGJlIFwiK2YqZCtcIiwgYnV0IGdvdCBcIitjLnNoYXBlWzJdK1wiLlwifSkpO3ZhciBwPVljKGwsdSxyLG8saSxhKSx2PXFjKHAsYywxLFwidmFsaWRcIixpKTtyZXR1cm4gaD92LmFzM0Qodi5zaGFwZVsxXSx2LnNoYXBlWzJdLHYuc2hhcGVbM10pOnZ9fSksWmM9QW4oe2NvbnYyZFRyYW5zcG9zZV86ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiBWYyhuLG1uKHQsXCJ4XCIsXCJjb252MmRUcmFuc3Bvc2VcIiksbW4oZSxcImZpbHRlclwiLFwiY29udjJkVHJhbnNwb3NlXCIpLHIsbyxcIk5IV0NcIixhKX19KSx0bD1Bbih7Y29udjNkVHJhbnNwb3NlXzpmdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiBHYyhuLG1uKHQsXCJ4XCIsXCJjb252M2RUcmFuc3Bvc2VcIiksbW4oZSxcImZpbHRlclwiLFwiY29udjNkVHJhbnNwb3NlXCIpLHIsbyl9fSk7dmFyIGVsPUFuKHttYXRNdWxfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvO3ZvaWQgMD09PW4mJihuPSExKSx2b2lkIDA9PT1yJiYocj0hMSk7dmFyIGE9bW4odCxcImFcIixcIm1hdE11bFwiKSxpPW1uKGUsXCJiXCIsXCJtYXRNdWxcIik7bz1OdChhLGkpLGE9b1swXSxpPW9bMV07dmFyIHM9bj9hLnNoYXBlW2EucmFuay0yXTphLnNoYXBlW2EucmFuay0xXSx1PXI/aS5zaGFwZVtpLnJhbmstMV06aS5zaGFwZVtpLnJhbmstMl0sYz1uP2Euc2hhcGVbYS5yYW5rLTFdOmEuc2hhcGVbYS5yYW5rLTJdLGw9cj9pLnNoYXBlW2kucmFuay0yXTppLnNoYXBlW2kucmFuay0xXSxoPWEuc2hhcGUuc2xpY2UoMCwtMiksZj1pLnNoYXBlLnNsaWNlKDAsLTIpLGQ9ayhoKSxwPWsoZik7QyhhLnJhbms+PTImJmkucmFuaz49MiYmYS5yYW5rPT09aS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF0TXVsOiBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgb2YgYXQgbGVhc3QgMiwgZ290IHJhbmtzIFwiK2EucmFuaytcIiBhbmQgXCIraS5yYW5rK1wiLlwifSkpLEMoUyhoLGYpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF0TXVsOiBvdXRlciBkaW1lbnNpb25zIChcIitoK1wiKSBhbmQgKFwiK2YrXCIpIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgXCIrYS5zaGFwZStcIiBhbmQgXCIraS5zaGFwZStcIiBtdXN0IG1hdGNoLlwifSkpLEMocz09PXUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXRNdWw6IGlubmVyIHNoYXBlcyAoXCIrcytcIikgYW5kIChcIit1K1wiKSBvZiBUZW5zb3JzIHdpdGggc2hhcGVzIFwiK2Euc2hhcGUrXCIgYW5kIFwiK2kuc2hhcGUrXCIgYW5kIHRyYW5zcG9zZUE9XCIrbitcIiBhbmQgdHJhbnNwb3NlQj1cIityK1wiIG11c3QgbWF0Y2guXCJ9KSk7dmFyIHY9YS5zaGFwZS5zbGljZSgwLC0yKS5jb25jYXQoW2MsbF0pLG09bj9hLmFzM0QoZCxzLGMpOmEuYXMzRChkLGMscyksZz1yP2kuYXMzRChwLGwsdSk6aS5hczNEKHAsdSxsKSx5PXt0cmFuc3Bvc2VBOm4sdHJhbnNwb3NlQjpyfTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbz10LmJhdGNoTWF0TXVsKG0sZyxuLHIpO3JldHVybiBlKFttLGddKSxvfSkse2E6bSxiOmd9LChmdW5jdGlvbih0LGUpe3ZhciBvPWUsYT1vWzBdLGk9b1sxXTtyZXR1cm4gbnx8cj8hbiYmcj97YTpmdW5jdGlvbigpe3JldHVybiB0Lm1hdE11bChpLCExLCExKX0sYjpmdW5jdGlvbigpe3JldHVybiB0Lm1hdE11bChhLCEwLCExKX19Om4mJiFyP3thOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKHQsITEsITApfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIGEubWF0TXVsKHQsITEsITEpfX06e2E6ZnVuY3Rpb24oKXtyZXR1cm4gaS5tYXRNdWwodCwhMCwhMCl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tYXRNdWwoYSwhMCwhMCl9fTp7YTpmdW5jdGlvbigpe3JldHVybiB0Lm1hdE11bChpLCExLCEwKX0sYjpmdW5jdGlvbigpe3JldHVybiBhLm1hdE11bCh0LCEwLCExKX19fSksXCJCYXRjaE1hdE11bFwiLHkpLnJlc2hhcGUodil9fSksbmw9QW4oe2RvdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwidDFcIixcImRvdFwiKSxyPW1uKGUsXCJ0MlwiLFwiZG90XCIpO0MoISgxIT09bi5yYW5rJiYyIT09bi5yYW5rfHwxIT09ci5yYW5rJiYyIT09ci5yYW5rKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRvdDogaW5wdXRzIG11c3QgYWxsIGJlIHJhbmsgMSBvciAyLCBidXQgZ290IHJhbmtzIFwiK24ucmFuaytcIiBhbmQgXCIrci5yYW5rK1wiLlwifSkpO3ZhciBvPTE9PT1uLnJhbms/bi5zaXplOm4uc2hhcGVbMV0sYT0xPT09ci5yYW5rP3Iuc2l6ZTpyLnNoYXBlWzBdO3JldHVybiBDKG89PT1hLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZG90OiBpbm5lciBkaW1lbnNpb25zIG9mIGlucHV0cyBtdXN0IG1hdGNoLCBidXQgZ290IFwiK28rXCIgYW5kIFwiK2ErXCIuXCJ9KSksMT09PW4ucmFuayYmMT09PXIucmFuaz9uLmFzMkQoMSwtMSkubWF0TXVsKHIuYXMyRCgtMSwxKSkuYXNTY2FsYXIoKToxPT09bi5yYW5rJiYyPT09ci5yYW5rP24uYXMyRCgxLC0xKS5tYXRNdWwoci5hczJEKHIuc2hhcGVbMF0sci5zaGFwZVsxXSkpLmFzMUQoKToyPT09bi5yYW5rJiYxPT09ci5yYW5rP24ubWF0TXVsKHIuYXMyRCgtMSwxKSkuYXMxRCgpOm4ubWF0TXVsKHIuYXMyRChyLnNoYXBlWzBdLHIuc2hhcGVbMV0pKX19KSxybD1Bbih7b3V0ZXJQcm9kdWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJ2MVwiLFwib3V0ZXJQcm9kdWN0XCIpLHI9bW4oZSxcInYyXCIsXCJvdXRlclByb2R1Y3RcIik7cmV0dXJuIEMoMT09PW4ucmFuayYmMT09PXIucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG91dGVyUHJvZHVjdDogaW5wdXRzIG11c3QgYmUgcmFuayAxLCBidXQgZ290IHJhbmtzIFwiK24ucmFuaytcIiBhbmQgXCIrci5yYW5rK1wiLlwifSkpLG4uYXMyRCgtMSwxKS5tYXRNdWwoci5hczJEKDEsLTEpKX19KTt2YXIgb2w9QW4oe3JldmVyc2VfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcInhcIixcInJldmVyc2VcIik7aWYoMD09PW4ucmFuaylyZXR1cm4gbi5jbG9uZSgpO3ZhciByPU8oZSxuLnNoYXBlKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQucmV2ZXJzZShuLHIpfSkseyR4Om59LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5yZXZlcnNlKHIpfX19KSkucmVzaGFwZUFzKG4pfX0pLGFsPUFuKHtyZXZlcnNlMWRfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBDKDE9PT1lLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXZlcnNlMUQ6IHggbXVzdCBiZSByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2UucmFuaytcIi5cIn0pKSxvbChlLDApfX0pLGlsPUFuKHtyZXZlcnNlMmRfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIEMoMj09PW4ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJldmVyc2UyRDogeCBtdXN0IGJlIHJhbmsgMiBidXQgZ290IHJhbmsgXCIrbi5yYW5rK1wiLlwifSkpLG9sKG4sZSl9fSksc2w9QW4oe3JldmVyc2UzZF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwieFwiLFwicmV2ZXJzZVwiKTtyZXR1cm4gQygzPT09bi5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmV2ZXJzZTNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIituLnJhbmsrXCIuXCJ9KSksb2wobixlKX19KSx1bD1Bbih7cmV2ZXJzZTRkXzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBDKDQ9PT1uLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXZlcnNlNEQ6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK24ucmFuaytcIi5cIn0pKSxvbChuLGUpfX0pO2Z1bmN0aW9uIGNsKHQsZSxuLHIsbyxhKXt2YXIgaT1tbih0LFwieFwiLFwibWF4UG9vbFwiKSxzPWksdT0hMTszPT09aS5yYW5rJiYodT0hMCxzPWkuYXM0RCgxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdKSksbnVsbD09ciYmKHI9WzEsMV0pLEMoND09PXMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2w6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSksQyhNbyhuLHIpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbitcIiBhbmQgZGlsYXRpb25zICdcIityK1wiJ1wifSkpLG51bGwhPWEmJkMoQShvKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2w6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2ErXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIn0pKTt2YXIgYz1JbyhzLnNoYXBlLGUsbixyLG8sYSk7aWYoMT09PWMuZmlsdGVyV2lkdGgmJjE9PT1jLmZpbHRlckhlaWdodCYmUyhjLmluU2hhcGUsYy5vdXRTaGFwZSkpcmV0dXJuIGkuY2xvbmUoKTt2YXIgbD1bc10saD1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQubWF4UG9vbChzLGMpO3JldHVybiBlKFtzLG5dKSxufSkse3g6c30sKGZ1bmN0aW9uKHQsYSl7dmFyIGk9YVswXSxzPWFbMV07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvLGEsaSxzKXt2YXIgdT1tbih0LFwiZHlcIixcIm1heFBvb2xCYWNrcHJvcFwiKSxjPW1uKGUsXCJpbnB1dFwiLFwibWF4UG9vbEJhY2twcm9wXCIpLGw9bW4obixcIm91dHB1dFwiLFwibWF4UG9vbEJhY2twcm9wXCIpO0MoYy5yYW5rPT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiUmFuayBvZiBpbnB1dCAoXCIrYy5yYW5rK1wiKSBkb2VzIG5vdCBtYXRjaCByYW5rIG9mIGR5IChcIit1LnJhbmsrXCIpXCJ9KSksbnVsbD09YSYmKGE9WzEsMV0pO0MoTW8obyxhKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2xCYWNrUHJvcDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbytcIiBhbmQgZGlsYXRpb25zICdcIithK1wiJ1wifSkpLEMoND09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogZHkgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKDQ9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sQmFja3Byb3A6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSksbnVsbCE9cyYmQyhBKGkpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitzK1wiIGJ1dCBnb3QgcGFkIFwiK2krXCIuXCJ9KSk7dmFyIGg9SW8oYy5zaGFwZSxyLG8sYSxpLHMpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5tYXhQb29sQmFja3Byb3AodSxjLGwsaCl9KSx7JGR5OnUsJGlucHV0OmN9KX0odCxpLHMsZSxuLHIsbyl9fX0pLFwiTWF4UG9vbFwiLGMsbCk7cmV0dXJuIHU/aC5hczNEKGguc2hhcGVbMV0saC5zaGFwZVsyXSxoLnNoYXBlWzNdKTpofWZ1bmN0aW9uIGxsKHQsZSxuLHIsbyxhKXt2YXIgaT1tbih0LFwieFwiLFwiYXZnUG9vbFwiLFwiZmxvYXQzMlwiKTtudWxsPT1yJiYocj1bMSwxXSksQyhNbyhuLHIpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbitcIiBhbmQgZGlsYXRpb25zICdcIityK1wiJ1wifSkpO3ZhciBzPWksdT0hMTszPT09aS5yYW5rJiYodT0hMCxzPWkuYXM0RCgxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdKSksQyg0PT09cy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwifSkpLG51bGwhPWEmJkMoQShvKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2w6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2ErXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIn0pKTt2YXIgYz1JbyhzLnNoYXBlLGUsbixyLG8sYSk7aWYoMT09PWMuZmlsdGVyV2lkdGgmJjE9PT1jLmZpbHRlckhlaWdodCYmUyhjLmluU2hhcGUsYy5vdXRTaGFwZSkpcmV0dXJuIGkuY2xvbmUoKTt2YXIgbD1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5hdmdQb29sKHMsYyl9KSx7eDpzfSwoZnVuY3Rpb24odCl7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPW1uKHQsXCJkeVwiLFwiYXZnUG9vbEJhY2twcm9wXCIpLHM9bW4oZSxcImlucHV0XCIsXCJhdmdQb29sQmFja3Byb3BcIik7QyhzLnJhbms9PT1pLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJSYW5rIG9mIGlucHV0IChcIitzLnJhbmsrXCIpIGRvZXMgbm90IG1hdGNoIHJhbmsgb2YgZHkgKFwiK2kucmFuaytcIilcIn0pKSxudWxsPT1vJiYobz1bMSwxXSk7QyhNbyhyLG8pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbEJhY2twcm9wOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIityK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK28rXCInXCJ9KSk7dmFyIHU9cyxjPWksbD0hMTszPT09cy5yYW5rJiYobD0hMCx1PXMuYXM0RCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdKSxjPWkuYXM0RCgxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdKSk7Qyg0PT09Yy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwifSkpLEMoND09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2xCYWNrcHJvcDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKTt2YXIgaD1Jbyh1LnNoYXBlLG4scixvLGEpLGY9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXZnUG9vbEJhY2twcm9wKGMsdSxoKX0pLHtkeTREOmMsaW5wdXQ0RDp1fSk7aWYobClyZXR1cm4gZi5hczNEKGYuc2hhcGVbMV0sZi5zaGFwZVsyXSxmLnNoYXBlWzNdKTtyZXR1cm4gZn0odCxzLGUsbixyLG8pfX19KSxcIkF2Z1Bvb2xcIixjKTtyZXR1cm4gbD1sLmNhc3QoaS5kdHlwZSksdT9sLmFzM0QobC5zaGFwZVsxXSxsLnNoYXBlWzJdLGwuc2hhcGVbM10pOmx9dmFyIGhsPUFuKHttYXhQb29sXzpmdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiBjbCh0LGUsbiwxLHIsbyl9fSksZmw9QW4oe2F2Z1Bvb2xfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIGxsKHQsZSxuLDEscixvKX19KSxkbD1Bbih7cG9vbF86ZnVuY3Rpb24odCxlLG4scixvLGEpe251bGw9PW8mJihvPVsxLDFdKSxudWxsPT1hJiYoYT0xKSwwPT09ciYmKHI9XCJ2YWxpZFwiKTt2YXIgaT1tbih0LFwieFwiLFwibWF4UG9vbFwiKSxzPWksdT0hMTszPT09aS5yYW5rJiYodT0hMCxzPWkuYXM0RCgxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdKSksQyhNbyhhLG8pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrYStcIiBhbmQgZGlsYXRpb25zICdcIitvK1wiJ1wifSkpO3ZhciBjLGw9SW8ocy5zaGFwZSxlLGEsbyxyKSxoPVtsLmRpbGF0aW9uSGVpZ2h0LGwuZGlsYXRpb25XaWR0aF07Yz1cInNhbWVcIj09PXI/ZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1hcCgoZnVuY3Rpb24odCxuKXtyZXR1cm4gdCsodC0xKSooZVtuXS0xKX0pKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LTF9KSkscj1uLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIE1hdGguZmxvb3IodC8yKX0pKSxvPW4ubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiB0LXJbZV19KSk7cmV0dXJuIG4ubWFwKChmdW5jdGlvbih0LGUpe3JldHVybltyW2VdLG9bZV1dfSkpfShbbC5maWx0ZXJIZWlnaHQsbC5maWx0ZXJXaWR0aF0saCk6W1swLDBdLFswLDBdXTt2YXIgZj0xPT09aFswXSYmMT09PWhbMV0sZD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSkpLG89bi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0WzFdfSkpLGE9dC5jb25jYXQocixvKSxpPWUubWFwKChmdW5jdGlvbih0LGUpe3JldHVybih0LWFbZV0ldCkldH0pKSxzPW8ubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiB0K2lbZV19KSksdT1lLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5bcltlXSxzW2VdXX0pKSxjPWUubWFwKChmdW5jdGlvbih0LGUpe3JldHVyblswLGlbZV1dfSkpO3JldHVyblt1LGNdfShbbC5pbkhlaWdodCxsLmluV2lkdGhdLGgsYykscD1kWzBdLHY9ZFsxXSxtPWY/cjpcInZhbGlkXCIsZz1mP3M6TXIocyxoLHApLHk9KFwiYXZnXCI9PT1uP2Z1bmN0aW9uKCl7cmV0dXJuIGxsKGcsZSxhLDEsbSl9OmZ1bmN0aW9uKCl7cmV0dXJuIGNsKGcsZSxhLDEsbSl9KSgpLHg9Zj95OnZyKHksaCx2KTtyZXR1cm4gdT94LmFzM0QoeC5zaGFwZVsxXSx4LnNoYXBlWzJdLHguc2hhcGVbM10pOnh9fSkscGw9QW4oe21heFBvb2wzZF86ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09YSYmKGE9XCJOREhXQ1wiKTt2YXIgcz1tbih0LFwieFwiLFwibWF4UG9vbDNkXCIpLHU9cyxjPSExOzQ9PT1zLnJhbmsmJihjPSEwLHU9cy5hczVEKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0scy5zaGFwZVszXSkpLG51bGw9PWkmJihpPVsxLDEsMV0pLEMoNT09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZDogeCBtdXN0IGJlIHJhbmsgNSBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpLEMoXCJOREhXQ1wiPT09YSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZDogT25seSBOREhXQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLCBidXQgZ290IGRhdGFGb3JtYXQgb2YgXCIrYX0pKSxDKE1vKG4saSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sM2Q6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK24rXCIgYW5kIGRpbGF0aW9ucyAnXCIraStcIidcIn0pKSxudWxsIT1vJiZDKEEociksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sM2Q6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK28rXCIgYnV0IGdvdCBwYWQgXCIrcitcIi5cIn0pKTt2YXIgbD1rbyh1LnNoYXBlLGUsbixpLHIsbyxhKSxoPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tYXhQb29sM2QodSxsKTtyZXR1cm4gZShbdSxuXSksbn0pLHt4OnV9LChmdW5jdGlvbih0LGEpe3ZhciBzPWFbMF0sdT1hWzFdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyl7dmFyIHU9bW4odCxcImR5XCIsXCJtYXhQb29sM2RCYWNrcHJvcFwiKSxjPW1uKGUsXCJpbnB1dFwiLFwibWF4UG9vbDNkQmFja3Byb3BcIiksbD1tbihuLFwib3V0cHV0XCIsXCJtYXhQb29sM2RCYWNrcHJvcFwiKSxoPXUsZj1jLGQ9bCxwPSExOzQ9PT1jLnJhbmsmJihwPSEwLGg9dS5hczVEKDEsdS5zaGFwZVswXSx1LnNoYXBlWzFdLHUuc2hhcGVbMl0sdS5zaGFwZVszXSksZj1jLmFzNUQoMSxjLnNoYXBlWzBdLGMuc2hhcGVbMV0sYy5zaGFwZVsyXSxjLnNoYXBlWzNdKSxkPWwuYXM1RCgxLGwuc2hhcGVbMF0sbC5zaGFwZVsxXSxsLnNoYXBlWzJdLGwuc2hhcGVbM10pKTtDKDU9PT1oLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sM2RCYWNrcHJvcDogZHkgbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rIFwiK2gucmFuaytcIi5cIn0pKSxDKDU9PT1mLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sM2RCYWNrcHJvcDogaW5wdXQgbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rIFwiK2YucmFuaytcIi5cIn0pKSxDKDU9PT1kLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sM2RCYWNrcHJvcDogb3V0cHV0IG11c3QgYmUgcmFuayA1IGJ1dCBnb3QgcmFuayBcIitkLnJhbmsrXCIuXCJ9KSksbnVsbD09YSYmKGE9WzEsMSwxXSk7QyhNbyhvLGEpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDNkQmFja3Byb3A6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK28rXCIgYW5kIGRpbGF0aW9ucyAnXCIrYStcIidcIn0pKSxudWxsIT1zJiZDKEEoaSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sM2RCYWNrcHJvcDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrcytcIiBidXQgZ290IHBhZCBcIitpK1wiLlwifSkpO3ZhciB2PWtvKGYuc2hhcGUscixvLGEsaSxzKSxtPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1heFBvb2wzZEJhY2twcm9wKGgsZixkLHYpfSkse2R5NUQ6aCxpbnB1dDVEOmZ9KTtpZihwKXJldHVybiBtLmFzNEQobS5zaGFwZVsxXSxtLnNoYXBlWzJdLG0uc2hhcGVbM10sbS5zaGFwZVs0XSk7cmV0dXJuIG19KHQscyx1LGUsbixpLHIsbyl9fX0pKTtyZXR1cm4gYz9oLmFzNEQoaC5zaGFwZVsxXSxoLnNoYXBlWzJdLGguc2hhcGVbM10saC5zaGFwZVs0XSk6aH19KSx2bD1Bbih7YXZnUG9vbDNkXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1hJiYoYT1cIk5ESFdDXCIpO3ZhciBzPW1uKHQsXCJ4XCIsXCJhdmdQb29sM2RcIixcImZsb2F0MzJcIiksdT1zLGM9ITE7ND09PXMucmFuayYmKGM9ITAsdT1zLmFzNUQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSxzLnNoYXBlWzNdKSksbnVsbD09aSYmKGk9WzEsMSwxXSksQyg1PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDNkOiB4IG11c3QgYmUgcmFuayA1IGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksQyhcIk5ESFdDXCI9PT1hLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDNkOiBPbmx5IE5ESFdDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQsIGJ1dCBnb3QgZGF0YUZvcm1hdCBvZiBcIithfSkpLEMoTW8obixpKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2wzZDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbitcIiBhbmQgZGlsYXRpb25zICdcIitpK1wiJ1wifSkpLG51bGwhPW8mJkMoQShyKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2wzZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrbytcIiBidXQgZ290IHBhZCBcIityK1wiLlwifSkpO3ZhciBsPWtvKHUuc2hhcGUsZSxuLGkscixvLGEpLGg9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXZnUG9vbDNkKHUsbCl9KSx7eDp1fSwoZnVuY3Rpb24odCl7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dmFyIHM9bW4odCxcImR5XCIsXCJhdmdQb29sM2RCYWNrcHJvcFwiKSx1PW1uKGUsXCJpbnB1dFwiLFwiYXZnUG9vbDNkQmFja3Byb3BcIiksYz1zLGw9dSxoPSExOzQ9PT11LnJhbmsmJihoPSEwLGM9cy5hczVEKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0scy5zaGFwZVszXSksbD11LmFzNUQoMSx1LnNoYXBlWzBdLHUuc2hhcGVbMV0sdS5zaGFwZVsyXSx1LnNoYXBlWzNdKSk7Qyg1PT09Yy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDNkQmFja3Byb3A6IGR5IG11c3QgYmUgcmFuayA1IGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSksQyg1PT09bC5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDNkQmFja3Byb3A6IGlucHV0IG11c3QgYmUgcmFuayA1IGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSksbnVsbD09byYmKG89WzEsMSwxXSk7QyhNbyhyLG8pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDNkQmFja3Byb3A6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK3IrXCIgYW5kIGRpbGF0aW9ucyAnXCIrbytcIidcIn0pKSxudWxsIT1pJiZDKEEoYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sM2RCYWNrcHJvcDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIraStcIiBidXQgZ290IHBhZCBcIithK1wiLlwifSkpO3ZhciBmPWtvKGwuc2hhcGUsbixyLG8sYSxpKSxkPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmF2Z1Bvb2wzZEJhY2twcm9wKGMsbCxmKX0pLHtkeTVEOmMsaW5wdXQ1RDpsfSk7aWYoaClyZXR1cm4gZC5hczREKGQuc2hhcGVbMV0sZC5zaGFwZVsyXSxkLnNoYXBlWzNdLGQuc2hhcGVbNF0pO3JldHVybiBkfSh0LHUsZSxuLGkscixvKX19fSkpO3JldHVybiBoPWguY2FzdCh1LmR0eXBlKSxjP2guYXM0RChoLnNoYXBlWzFdLGguc2hhcGVbMl0saC5zaGFwZVszXSxoLnNoYXBlWzRdKTpofX0pO3ZhciBtbD1Bbih7c2xpY2VfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvLGE9bW4odCxcInhcIixcInNsaWNlXCIpO2lmKDA9PT1hLnJhbmspdGhyb3cgbmV3IEVycm9yKFwiU2xpY2luZyBzY2FsYXIgaXMgbm90IHBvc3NpYmxlXCIpOyhyPVwibnVtYmVyXCI9PXR5cGVvZiBlP1tlXS5jb25jYXQobmV3IEFycmF5KGEucmFuay0xKS5maWxsKDApKTplLmxlbmd0aDxhLnJhbms/ZS5jb25jYXQobmV3IEFycmF5KGEucmFuay1lLmxlbmd0aCkuZmlsbCgwKSk6ZS5zbGljZSgpKS5mb3JFYWNoKChmdW5jdGlvbih0KXtDKC0xIT09dCwoZnVuY3Rpb24oKXtyZXR1cm5cInNsaWNlKCkgZG9lcyBub3Qgc3VwcG9ydCBuZWdhdGl2ZSBiZWdpbiBpbmRleGluZy5cIn0pKX0pKSxvPShvPW51bGw9PW4/bmV3IEFycmF5KGEucmFuaykuZmlsbCgtMSk6XCJudW1iZXJcIj09dHlwZW9mIG4/W25dLmNvbmNhdChuZXcgQXJyYXkoYS5yYW5rLTEpLmZpbGwoLTEpKTpuLmxlbmd0aDxhLnJhbms/bi5jb25jYXQobmV3IEFycmF5KGEucmFuay1uLmxlbmd0aCkuZmlsbCgtMSkpOm4pLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdD49MD90OihDKC0xPT09dCwoZnVuY3Rpb24oKXtyZXR1cm5cIk5lZ2F0aXZlIHNpemUgdmFsdWVzIHNob3VsZCBiZSBleGFjdGx5IC0xIGJ1dCBnb3QgXCIrdCtcIiBmb3IgdGhlIHNsaWNlKCkgc2l6ZSBhdCBpbmRleCBcIitlK1wiLlwifSkpLGEuc2hhcGVbZV0tcltlXSl9KSksZW8oYSxyLG8pO3ZhciBpPWEuc2hhcGUscz17YmVnaW46cixzaXplOm99O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zbGljZShhLHIsbyl9KSx7eDphfSwoZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQucmFuaztuKyspZS5wdXNoKFtyW25dLGlbbl0tcltuXS1vW25dXSk7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5wYWQoZSl9fX0pLFwiU2xpY2VcIixzKX19KSxnbD1Bbih7c2xpY2UxZF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPW1uKHQsXCJ4XCIsXCJzbGljZTFkXCIpO3JldHVybiBDKDE9PT1yLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJzbGljZTFkIGV4cGVjdHMgYSByYW5rLTEgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIityLnJhbmsrXCIgdGVuc29yXCJ9KSksbWwocixbZV0sW25dKX19KSx5bD1Bbih7c2xpY2UyZF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPW1uKHQsXCJ4XCIsXCJzbGljZTJkXCIpO3JldHVybiBDKDI9PT1yLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJzbGljZTJkIGV4cGVjdHMgYSByYW5rLTIgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIityLnJhbmsrXCIgdGVuc29yXCJ9KSksbWwocixlLG4pfX0pLHhsPUFuKHtzbGljZTNkXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9bW4odCxcInhcIixcInNsaWNlM2RcIik7cmV0dXJuIEMoMz09PXIucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cInNsaWNlM2QgZXhwZWN0cyBhIHJhbmstMyB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiK3IucmFuaytcIiB0ZW5zb3JcIn0pKSxtbChyLGUsbil9fSksYmw9QW4oe3NsaWNlNGRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1tbih0LFwieFwiLFwic2xpY2U0ZFwiKTtyZXR1cm4gQyg0PT09ci5yYW5rLChmdW5jdGlvbigpe3JldHVyblwic2xpY2U0ZCBleHBlY3RzIGEgcmFuay00IHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIrci5yYW5rK1wiIHRlbnNvclwifSkpLG1sKHIsZSxuKX19KTtmdW5jdGlvbiB3bCh0LGUsbixyLG8pe3JldHVybiBlLnJhbms8bi5yYW5rJiYoZT1lLnJlc2hhcGUod24oZS5zaGFwZSxyKSkpLHQucmFuazxuLnJhbmsmJih0PXQucmVzaGFwZSh3bih0LnNoYXBlLHIpKSkse3g6ZnVuY3Rpb24oKXt2YXIgcj10Lm11bChuLmVxdWFsKGUpLmNhc3QodC5kdHlwZSkpO3JldHVybiBudWxsPT1vP3I6ci50cmFuc3Bvc2Uobyl9fX12YXIgQ2w9QW4oe2FsbF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1tbih0LFwieFwiLFwiYWxsXCIsXCJib29sXCIpLG89TyhlLHIuc2hhcGUpLGE9byxpPUVuKGEsci5yYW5rKTtudWxsIT1pJiYocj1yLnRyYW5zcG9zZShpKSxhPUluKGEubGVuZ3RoLHIucmFuaykpO3ZhciBzPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFsbChyLGEpfSkseyR4OnJ9KTtpZihuKXt2YXIgdT13bihzLnNoYXBlLG8pO3JldHVybiBzLnJlc2hhcGUodSl9cmV0dXJuIHN9fSksRWw9QW4oe2FueV86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1tbih0LFwieFwiLFwiYW55XCIsXCJib29sXCIpLG89TyhlLHIuc2hhcGUpLGE9byxpPUVuKGEsci5yYW5rKTtudWxsIT1pJiYocj1yLnRyYW5zcG9zZShpKSxhPUluKGEubGVuZ3RoLHIucmFuaykpO3ZhciBzPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFueShyLGEpfSkseyR4OnJ9KTtpZihuKXt2YXIgdT13bihzLnNoYXBlLG8pO3JldHVybiBzLnJlc2hhcGUodSl9cmV0dXJuIHN9fSksUmw9QW4oe2FyZ01heF86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKTt2YXIgbj1tbih0LFwieFwiLFwiYXJnTWF4XCIpO251bGw9PWUmJihlPTApO3ZhciByPU8oZSxuLnNoYXBlKSxvPUVuKHIsbi5yYW5rKTtudWxsIT1vJiYobj1uLnRyYW5zcG9zZShvKSxyPUluKHIubGVuZ3RoLG4ucmFuaykpO3ZhciBhPXtheGlzOnJbMF19LGk9W25dO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBvPXQuYXJnTWF4KG4sclswXSk7cmV0dXJuIGUoW25dKSxvfSkse3g6bn0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBYbihuKX19fSksXCJBcmdNYXhcIixhLGkpfX0pLElsPUFuKHthcmdNaW5fOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCk7dmFyIG49bW4odCxcInhcIixcImFyZ01pblwiKTtudWxsPT1lJiYoZT0wKTt2YXIgcj1PKGUsbi5zaGFwZSksbz1FbihyLG4ucmFuayk7cmV0dXJuIG51bGwhPW8mJihuPW4udHJhbnNwb3NlKG8pLHI9SW4oci5sZW5ndGgsbi5yYW5rKSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbz10LmFyZ01pbihuLHJbMF0pO3JldHVybiBlKFtuXSksb30pLHskeDpufSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbihuKX19fSkpfX0pLGtsPUFuKHtsb2dTdW1FeHBfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9bW4odCxcInhcIixcImxvZ1N1bUV4cFwiKSxvPU8oZSxyLnNoYXBlKSxhPXIubWF4KG8sITApLGk9ci5zdWIoYSkuZXhwKCkuc3VtKG8pLmxvZygpLHM9YS5yZXNoYXBlKGkuc2hhcGUpLmFkZChpKTtpZihuKXt2YXIgdT13bihzLnNoYXBlLG8pO3JldHVybiBzLnJlc2hhcGUodSl9cmV0dXJuIHN9fSksU2w9QW4oe21heF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1tbih0LFwieFwiLFwibWF4XCIpLG89cixhPU8oZSxyLnNoYXBlKSxpPWEscz1FbihpLHIucmFuayk7bnVsbCE9cyYmKHI9ci50cmFuc3Bvc2UocyksaT1JbihpLmxlbmd0aCxyLnJhbmspKTt2YXIgdT1bcl0sYz1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQubWF4KHIsaSk7cmV0dXJuIGUoW28sbl0pLG59KSx7eDpyfSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gd2wodCxlWzFdLGVbMF0sYSxzKX0pLFwiTWF4XCIse2F4ZXM6aX0sdSxbITBdKTtpZihuKXt2YXIgbD13bihjLnNoYXBlLGEpO2M9Yy5yZXNoYXBlKGwpfXJldHVybiBjfX0pLEFsPUFuKHttZWFuXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPW1uKHQsXCJ4XCIsXCJtZWFuXCIpLG89TyhlLHIuc2hhcGUpLGE9ayhibihyLnNoYXBlLG8pWzFdKTtyZXR1cm4gdm8oKGZ1bmN0aW9uKHQpe3ZhciByPU9uKGEpO3JldHVybnt2YWx1ZTooci5kdHlwZT09PXQuZHR5cGU/dDp0LmNhc3Qoci5kdHlwZSkpLmRpdihyKS5zdW0oZSxuKSxncmFkRnVuYzpmdW5jdGlvbihlKXt2YXIgbj10LnNoYXBlLnNsaWNlKCk7cmV0dXJuIG8uZm9yRWFjaCgoZnVuY3Rpb24odCl7blt0XT0xfSkpLGUucmVzaGFwZShuKS5tdWwoem4odC5zaGFwZSxcImZsb2F0MzJcIikpLmRpdihhKX19fSkpKHIpfX0pLERsPUFuKHttaW5fOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9bW4odCxcInhcIixcIm1pblwiKSxvPXIsYT1PKGUsci5zaGFwZSksaT1hLHM9RW4oaSxyLnJhbmspO251bGwhPXMmJihyPXIudHJhbnNwb3NlKHMpLGk9SW4oaS5sZW5ndGgsci5yYW5rKSk7dmFyIHU9W3JdLGM9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1pbihyLGkpO3JldHVybiBlKFtvLG5dKSxufSkse3g6cn0sKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdsKHQsZVsxXSxlWzBdLGEscyl9KSxcIk1pblwiLHtheGVzOml9LHUsWyEwXSk7aWYobil7dmFyIGw9d24oYy5zaGFwZSxhKTtjPWMucmVzaGFwZShsKX1yZXR1cm4gY319KSxUbD1Bbih7bW9tZW50c186ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1PKGUsKHQ9bW4odCxcInhcIixcIm1vbWVudHNcIikpLnNoYXBlKSxvPXQubWVhbihyLG4pLGE9by5zaGFwZTtufHwoYT13bihvLnNoYXBlLHIpKTt2YXIgaT10LnRvRmxvYXQoKS5zdWIoby5yZXNoYXBlKGEpKS5zcXVhcmUoKTtyZXR1cm57bWVhbjpvLHZhcmlhbmNlOmkubWVhbihyLG4pfX19KSxObD1Bbih7c3VtXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPW1uKHQsXCJ4XCIsXCJzdW1cIik7XCJib29sXCI9PT1yLmR0eXBlJiYocj1yLnRvSW50KCkpO3ZhciBvPU8oZSxyLnNoYXBlKTtyZXR1cm4gdm8oKGZ1bmN0aW9uKHQpe3ZhciBlPUVuKG8sdC5yYW5rKSxyPW8sYT10O251bGwhPWUmJihhPXQudHJhbnNwb3NlKGUpLHI9SW4oci5sZW5ndGgsdC5yYW5rKSk7dmFyIGk9ZnVuY3Rpb24oZSl7dmFyIG49dC5zaGFwZS5zbGljZSgpO3JldHVybiBvLmZvckVhY2goKGZ1bmN0aW9uKHQpe25bdF09MX0pKSxlLnJlc2hhcGUobikubXVsKHpuKHQuc2hhcGUsXCJmbG9hdDMyXCIpKX0scz17YXhlczpyfSx1PUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnN1bShhLHIpfSkse3g6YX0sKGZ1bmN0aW9uKHQpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIGkodCl9fX0pLFwiU3VtXCIscyk7aWYobil7dmFyIGM9d24odS5zaGFwZSxvKTt1PXUucmVzaGFwZShjKX1yZXR1cm57dmFsdWU6dSxncmFkRnVuYzppfX0pKShyKX19KSxGbD1Bbih7cHJvZF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1tbih0LFwieFwiLFwicHJvZFwiKTtcImJvb2xcIj09PXIuZHR5cGUmJihyPXIudG9JbnQoKSk7dmFyIG89TyhlLHIuc2hhcGUpLGE9RW4obyxyLnJhbmspLGk9byxzPXI7bnVsbCE9YSYmKHM9ci50cmFuc3Bvc2UoYSksaT1JbihpLmxlbmd0aCxyLnJhbmspKTt2YXIgdT1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5wcm9kKHMsaSl9KSx7cGVybXV0ZWRYOnN9KTtpZihuKXt2YXIgYz13bih1LnNoYXBlLG8pO3U9dS5yZXNoYXBlKGMpfXJldHVybiB1fX0pO3ZhciBfbD1Bbih7ZWx1XzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiZWx1XCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuZWx1KGUpO3JldHVybiBuKFtyXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbihlKXtyZXR1cm4gZS5lbHVEZXIodCxuKX0pLHtkeTp0LHk6bn0pfX19KSl9fSksT2w9QW4oe2xlYWt5UmVsdV86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0uMik7dmFyIG49bW4odCxcInhcIixcImxlYWt5UmVsdVwiKTtyZXR1cm4gaGMoT24oZSkubXVsKG4pLG4pfX0pLE1sPUFuKHtwcmVsdV86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwieFwiLFwicHJlbHVcIikscj1tbihlLFwiYWxwaGFcIixcInByZWx1XCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBvPXQucHJlbHUobixyKTtyZXR1cm4gZShbbixyXSksb30pLHt4Om4sYWxwaGE6cn0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV0sbz1uLmdyZWF0ZXIoMCk7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gZWMobyx0LHQubXVsKHIpKX0sYWxwaGE6ZnVuY3Rpb24oKXt2YXIgZT1lYyhvLFhuKHQpLHQubXVsKG4pKSxhPUVvKHIuc2hhcGUsdC5zaGFwZSk7cmV0dXJuIGEubGVuZ3RoPjAmJihlPWUuc3VtKGEpKSxlLnJlc2hhcGUoci5zaGFwZSl9fX0pLFwiUHJlbHVcIil9fSksQmw9QW4oe3JlbHVfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJyZWx1XCIpO3JldHVyblwiYm9vbFwiPT09ZS5kdHlwZT9lLnRvSW50KCk6THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnJlbHUoZSk7cmV0dXJuIG4oW2VdKSxyfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0Lm11bFN0cmljdChuLnN0ZXAoKS50b0Zsb2F0KCkpfX19KSxcIlJlbHVcIil9fSksUGw9QW4oe3JlbHU2XzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwicmVsdTZcIik7cmV0dXJuXCJib29sXCI9PT1lLmR0eXBlP2UudG9JbnQoKTpMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQucmVsdTYoZSk7cmV0dXJuIG4oW2VdKSxyfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPW4ubGVzc0VxdWFsKDYpLm11bChuLnN0ZXAoKSk7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWxTdHJpY3Qoci50b0Zsb2F0KCkpfX19KSxcIlJlbHU2XCIpfX0pLExsPUFuKHtzZWx1XzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwic2VsdVwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNlbHUoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7dmFyIGU9bi5ncmVhdGVyKE9uKDApKSxyPU9uKGJzKSxvPU9uKHdzKSxhPXQubXVsKG8pLGk9dC5tdWwocikubXVsKG4udG9GbG9hdCgpLmV4cCgpKTtyZXR1cm4gZWMoZSxhLGkpfX19KSl9fSk7dmFyIFdsPUFuKHt0cmFuc3Bvc2VfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcInhcIixcInRyYW5zcG9zZVwiKTtpZihudWxsPT1lJiYoZT1uLnNoYXBlLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gZX0pKS5yZXZlcnNlKCkpLEMobi5yYW5rPT09ZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiB0cmFuc3Bvc2U6IHJhbmsgb2YgaW5wdXQgXCIrbi5yYW5rK1wiIG11c3QgbWF0Y2ggbGVuZ3RoIG9mIHBlcm0gXCIrZStcIi5cIn0pKSxlLmZvckVhY2goKGZ1bmN0aW9uKHQpe0ModD49MCYmdDxuLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJBbGwgZW50cmllcyBpbiAncGVybScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIFwiKyhuLnJhbmstMSkrXCIgYnV0IGdvdCBcIitlfSkpfSkpLG4ucmFuazw9MSlyZXR1cm4gbi5jbG9uZSgpO3ZhciByPXtwZXJtOmV9O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC50cmFuc3Bvc2UobixlKX0pLHt4Om59LChmdW5jdGlvbih0KXt2YXIgbj1SbihlKTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LnRyYW5zcG9zZShuKX19fSksXCJUcmFuc3Bvc2VcIixyKX19KTt2YXIgVWw9QW4oe2xvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PWUmJihlPTUpLHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PXImJihyPTEpLHZvaWQgMD09PW8mJihvPS41KTt2YXIgYT1tbih0LFwieFwiLFwibG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb25cIik7Qyg0PT09YS5yYW5rfHwzPT09YS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246IHggbXVzdCBiZSByYW5rIDMgb3IgNCBidXQgZ290XFxuICAgICAgICAgICAgICAgcmFuayBcIithLnJhbmsrXCIuXCJ9KSksQyhBKGUpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246IGRlcHRoUmFkaXVzIG11c3QgYmUgYW4gaW50ZWdlciBidXQgZ290IGRlcHRoUmFkaXVzIFwiK2UrXCIuXCJ9KSk7dmFyIGk9YSxzPSExOzM9PT1hLnJhbmsmJihzPSEwLGk9YS5hczREKDEsYS5zaGFwZVswXSxhLnNoYXBlWzFdLGEuc2hhcGVbMl0pKTt2YXIgdT1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGEpe3ZhciBzPXQubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RChpLGUsbixyLG8pO3JldHVybiBhKFtpLHNdKSxzfSkse3g0RDppfSwoZnVuY3Rpb24odCxhKXt2YXIgaT1hWzBdLHM9YVsxXTtyZXR1cm57eDREOmZ1bmN0aW9uKCl7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKGEpe3JldHVybiBhLkxSTkdyYWQodCxpLHMsZSxuLHIsbyl9KSx7fSl9fX0pKTtyZXR1cm4gcz91LmFzM0QodS5zaGFwZVsxXSx1LnNoYXBlWzJdLHUuc2hhcGVbM10pOnV9fSk7dmFyIFZsPUFuKHtub3JtXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1lJiYoZT1cImV1Y2xpZGVhblwiKSx2b2lkIDA9PT1uJiYobj1udWxsKSx2b2lkIDA9PT1yJiYocj0hMSk7dmFyIG89ZnVuY3Rpb24gdChlLG4scil7dm9pZCAwPT09ciYmKHI9bnVsbCk7aWYoMD09PWUucmFuaylyZXR1cm4gZS5hYnMoKTtpZigxIT09ZS5yYW5rJiZudWxsPT09cilyZXR1cm4gdChlLnJlc2hhcGUoWy0xXSksbixyKTtpZigxPT09ZS5yYW5rfHxcIm51bWJlclwiPT10eXBlb2Ygcnx8QXJyYXkuaXNBcnJheShyKSYmMT09PXIubGVuZ3RoKXtpZigxPT09bilyZXR1cm4gZS5hYnMoKS5zdW0ocik7aWYobj09PTEvMClyZXR1cm4gZS5hYnMoKS5tYXgocik7aWYobj09PS0xLzApcmV0dXJuIGUuYWJzKCkubWluKHIpO2lmKFwiZXVjbGlkZWFuXCI9PT1ufHwyPT09bilyZXR1cm4gZS5hYnMoKS5wb3coT24oMixcImludDMyXCIpKS5zdW0ocikuc3FydCgpO3Rocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG5vcm06IGludmFsaWQgb3JkIHZhbHVlOiBcIituKX1pZihBcnJheS5pc0FycmF5KHIpJiYyPT09ci5sZW5ndGgpe2lmKDE9PT1uKXJldHVybiBlLmFicygpLnN1bShyWzBdKS5tYXgoclsxXS0xKTtpZihuPT09MS8wKXJldHVybiBlLmFicygpLnN1bShyWzFdKS5tYXgoclswXSk7aWYobj09PS0xLzApcmV0dXJuIGUuYWJzKCkuc3VtKHJbMV0pLm1pbihyWzBdKTtpZihcImZyb1wiPT09bnx8XCJldWNsaWRlYW5cIj09PW4pcmV0dXJuIGUuc3F1YXJlKCkuc3VtKHIpLnNxcnQoKTt0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBub3JtOiBpbnZhbGlkIG9yZCB2YWx1ZTogXCIrbil9dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBheGlzOiBcIityKX0odD1tbih0LFwieFwiLFwibm9ybVwiKSxlLG4pLGE9by5zaGFwZTtpZihyKXt2YXIgaT1PKG4sdC5zaGFwZSk7YT13bihvLnNoYXBlLGkpfXJldHVybiBvLnJlc2hhcGUoYSl9fSk7dmFyIHpsPUFuKHtiYXNpY0xTVE1DZWxsXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9bW4odCxcImZvcmdldEJpYXNcIixcImJhc2ljTFNUTUNlbGxcIikscz1tbihlLFwibHN0bUtlcm5lbFwiLFwiYmFzaWNMU1RNQ2VsbFwiKSx1PW1uKG4sXCJsc3RtQmlhc1wiLFwiYmFzaWNMU1RNQ2VsbFwiKSxjPW1uKHIsXCJkYXRhXCIsXCJiYXNpY0xTVE1DZWxsXCIpLGw9bW4obyxcImNcIixcImJhc2ljTFNUTUNlbGxcIiksaD1tbihhLFwiaFwiLFwiYmFzaWNMU1RNQ2VsbFwiKSxmPWMuY29uY2F0KGgsMSkubWF0TXVsKHMpLmFkZCh1KSxkPWYuc2hhcGVbMF0scD1mLnNoYXBlWzFdLzQsdj1bZCxwXSxtPWYuc2xpY2UoWzAsMF0sdiksZz1mLnNsaWNlKFswLHBdLHYpLHk9Zi5zbGljZShbMCwyKnBdLHYpLHg9Zi5zbGljZShbMCwzKnBdLHYpLGI9bS5zaWdtb2lkKCkubXVsU3RyaWN0KGcudGFuaCgpKS5hZGRTdHJpY3QobC5tdWxTdHJpY3QoaS5hZGQoeSkuc2lnbW9pZCgpKSksdz1iLnRhbmgoKS5tdWxTdHJpY3QoeC5zaWdtb2lkKCkpO3JldHVybltiLHddfX0pLEdsPUFuKHttdWx0aVJOTkNlbGxfOmZ1bmN0aW9uKHQsZSxuLHIpe2Zvcih2YXIgbz1tbihlLFwiZGF0YVwiLFwibXVsdGlSTk5DZWxsXCIpLGE9Z24obixcImNcIixcIm11bHRpUk5OQ2VsbFwiKSxpPWduKHIsXCJoXCIsXCJtdWx0aVJOTkNlbGxcIikscz1vLHU9W10sYz0wO2M8dC5sZW5ndGg7YysrKXt2YXIgbD10W2NdKHMsYVtjXSxpW2NdKTt1LnB1c2gobFswXSksdS5wdXNoKGxbMV0pLHM9bFsxXX12YXIgaD1bXSxmPVtdO2ZvcihjPTA7Yzx1Lmxlbmd0aDtjKz0yKWgucHVzaCh1W2NdKSxmLnB1c2godVtjKzFdKTtyZXR1cm5baCxmXX19KTt2YXIgSGw9QW4oe21vdmluZ0F2ZXJhZ2VfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09byYmKG89ITApO3ZhciBhPW1uKHQsXCJ2XCIsXCJtb3ZpbmdBdmVyYWdlXCIpLGk9bW4oZSxcInhcIixcIm1vdmluZ0F2ZXJhZ2VcIikscz1tbihuLFwiZGVjYXlcIixcIm1vdmluZ0F2ZXJhZ2VcIik7RnQoYSxpKSxDKFMoYS5zaGFwZSxpLnNoYXBlKSwoZnVuY3Rpb24oKXtyZXR1cm5cIlNoYXBlIG1pc21hdGNoIGluIHYgYW5kIHhcIn0pKTt2YXIgdT1PbigxKSxjPXUuc3ViKHMpLGw9aS5zdWIoYSkubXVsKGMpO2lmKG8pe0MobnVsbCE9ciwoZnVuY3Rpb24oKXtyZXR1cm5cIldoZW4gdXNpbmcgemVyb0RlYmlhczogdHJ1ZSwgc3RlcCBpcyByZXF1aXJlZC5cIn0pKTt2YXIgaD1tbihyLFwic3RlcFwiLFwibW92aW5nQXZlcmFnZVwiKTtsPWwuZGl2KHUuc3ViKHhjKHMsaCkpKX1yZXR1cm4gYS5hZGQobCl9fSk7dmFyIHFsPUFuKHtzdHJpZGVkU2xpY2VfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyx1KXtpZih2b2lkIDA9PT1vJiYobz0wKSx2b2lkIDA9PT1hJiYoYT0wKSx2b2lkIDA9PT1pJiYoaT0wKSx2b2lkIDA9PT1zJiYocz0wKSx2b2lkIDA9PT11JiYodT0wKSxudWxsPT1yJiYocj1uZXcgQXJyYXkoZS5sZW5ndGgpKSwwIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJlbGxpcHNpcyBtYXNrIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO3ZhciBjPW1uKHQsXCJ4XCIsXCJzdHJpZGVkU2xpY2VcIiksbD1ubyhzKSxoPWMuc2hhcGUuc2xpY2UoKTtsLmZvckVhY2goKGZ1bmN0aW9uKHQpe2VbdF09MCxuW3RdPTEsaC5zcGxpY2UodCwwLDEpfSkpLGM9Yy5yZXNoYXBlKGgpO2Zvcih2YXIgZj0wO2Y8Yy5yYW5rO2YrKyllW2ZdPW9vKG8sZSxyLGMuc2hhcGUsZiksbltmXT1hbyhhLG4scixjLnNoYXBlLGYpLHJbZl09cltmXXx8MTt2YXIgZD1ubyh1KTtkLmZvckVhY2goKGZ1bmN0aW9uKHQpe25bdF09ZVt0XSsxLHJbdF09MX0pKTt2YXIgcD1ybyhlLG4sciksdj1wLmZpbHRlcigoZnVuY3Rpb24odCxlKXtyZXR1cm4tMT09PWQuaW5kZXhPZihlKX0pKTtyZXR1cm4gci5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIDE9PT10fSkpP21sKGMsZSxwKS5yZXNoYXBlKHYpOkx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnN0cmlkZWRTbGljZShjLGUsbixyKX0pLHskeDpjfSkucmVzaGFwZSh2KX19KTt2YXIgS2w9QW4oe3RvcGtfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT0xKSx2b2lkIDA9PT1uJiYobj0hMCk7dmFyIHI9bW4odCxcInhcIixcInRvcGtcIik7aWYoMD09PXIucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJ0b3BrKCkgZXhwZWN0cyB0aGUgaW5wdXQgdG8gYmUgb2YgcmFuayAxIG9yIGhpZ2hlclwiKTt2YXIgbz1yLnNoYXBlW3Iuc2hhcGUubGVuZ3RoLTFdO2lmKGU+byl0aHJvdyBuZXcgRXJyb3IoXCInaycgcGFzc2VkIHRvIHRvcGsoKSBtdXN0IGJlIDw9IHRoZSBsYXN0IGRpbWVuc2lvbiAoXCIrbytcIikgYnV0IGdvdCBcIitlKTt2YXIgYT1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC50b3BrKHIsZSxuKX0pLHskeDpyfSk7cmV0dXJue3ZhbHVlczphWzBdLGluZGljZXM6YVsxXX19fSk7dmFyIGpsPUFuKHtzY2F0dGVyTkRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1tbih0LFwiaW5kaWNlc1wiLFwic2NhdHRlck5EXCIsXCJpbnQzMlwiKSxvPW1uKGUsXCJ1cGRhdGVzXCIsXCJzY2F0dGVyTkRcIik7cmV0dXJuIEpyKG8scixuKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zY2F0dGVyTkQocixvLG4pfSkse2luZGljZXM6cix1cGRhdGVzOm99LG51bGwsXCJTY2F0dGVyTmRcIix7c2hhcGU6bn0pfX0pO3ZhciBYbD1Bbih7ZmZ0XzpmdW5jdGlvbih0KXtDKFwiY29tcGxleDY0XCI9PT10LmR0eXBlLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGR0eXBlIGZvciB0Zi5zcGVjdHJhbC5mZnQoKSBtdXN0IGJlIGNvbXBsZXg2NCBidXQgZ290IFwiK3QuZHR5cGUrXCIuXCJ9KSk7dmFyIGU9dC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0xXSxuPXQuc2l6ZS9lLHI9dC5hczJEKG4sZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmZmdChyKX0pLHtpbnB1dDp0fSkucmVzaGFwZSh0LnNoYXBlKX19KSxZbD1Bbih7aWZmdF86ZnVuY3Rpb24odCl7QyhcImNvbXBsZXg2NFwiPT09dC5kdHlwZSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBkdHlwZSBmb3IgdGYuc3BlY3RyYWwuaWZmdCgpIG11c3QgYmUgY29tcGxleDY0IGJ1dCBnb3QgXCIrdC5kdHlwZStcIi5cIn0pKTt2YXIgZT10LnNoYXBlW3Quc2hhcGUubGVuZ3RoLTFdLG49dC5zaXplL2Uscj10LmFzMkQobixlKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuaWZmdChyKX0pLHtpbnB1dDp0fSkucmVzaGFwZSh0LnNoYXBlKX19KSwkbD1Bbih7cmZmdF86ZnVuY3Rpb24odCxlKXtDKFwiZmxvYXQzMlwiPT09dC5kdHlwZSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBkdHlwZSBmb3IgcmZmdCgpIG11c3QgYmUgcmVhbCB2YWx1ZSBidXQgZ290IFwiK3QuZHR5cGV9KSk7dmFyIG4scj10LnNoYXBlW3Quc2hhcGUubGVuZ3RoLTFdLG89dC5zaXplL3I7aWYobnVsbCE9ZSYmZTxyKXt2YXIgYT10LnNoYXBlLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIDB9KSksaT10LnNoYXBlLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSk7aVt0LnNoYXBlLmxlbmd0aC0xXT1lLG49dC5zbGljZShhLGkpLHI9ZX1lbHNlIGlmKG51bGwhPWUmJmU+cil7dmFyIHM9dC5zaGFwZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpO3NbdC5zaGFwZS5sZW5ndGgtMV09ZS1yLG49dC5jb25jYXQoR24ocyksdC5zaGFwZS5sZW5ndGgtMSkscj1lfWVsc2Ugbj10O3ZhciB1PW4uemVyb3NMaWtlKCksYz1EbihuLHUpLmFzMkQobyxyKSxsPVhsKGMpLGg9TWF0aC5mbG9vcihyLzIpKzEsZj1UbihsKSxkPU5uKGwpLHA9Zi5zcGxpdChbaCxyLWhdLGYuc2hhcGUubGVuZ3RoLTEpLHY9ZC5zcGxpdChbaCxyLWhdLGQuc2hhcGUubGVuZ3RoLTEpLG09bi5zaGFwZS5zbGljZSgpO3JldHVybiBtW24uc2hhcGUubGVuZ3RoLTFdPWgsRG4ocFswXSx2WzBdKS5yZXNoYXBlKG0pfX0pLFFsPUFuKHtpcmZmdF86ZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0xXSxuPXQuc2l6ZS9lO2lmKGU8PTIpe3ZhciByPXQuYXMyRChuLGUpLG89WWwocik7cmV0dXJuIFRuKG8pfXZhciBhPVtuLDIqKGUtMSldLGk9VG4odCkuYXMyRChuLGUpLHM9Tm4odCkuYXMyRChuLGUpLHU9aS5zbGljZShbMCwxXSxbbixlLTJdKS5yZXZlcnNlKDEpLGM9cy5zbGljZShbMCwxXSxbbixlLTJdKS5yZXZlcnNlKDEpLm11bChPbigtMSkpLGw9aS5jb25jYXQodSwxKSxoPXMuY29uY2F0KGMsMSk7cmV0dXJuIHI9RG4obCxoKS5hczJEKGFbMF0sYVsxXSksbz1ZbChyKSxUbihvKX19KSxKbD1PYmplY3QuZnJlZXplKHtmZnQ6WGwsaWZmdDpZbCxyZmZ0OiRsLGlyZmZ0OlFsfSk7dmFyIFpsPUFuKHtzcGFyc2VUb0RlbnNlXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj0wKTt2YXIgbz1tbih0LFwic3BhcnNlSW5kaWNlc1wiLFwic3BhcnNlVG9EZW5zZVwiLFwiaW50MzJcIiksYT1tbihlLFwic3BhcnNlVmFsdWVzXCIsXCJzcGFyc2VUb0RlbnNlXCIpLGk9bW4ocixcImRlZmF1bHRWYWx1ZVwiLFwic3BhcnNlVG9EZW5zZVwiLGEuZHR5cGUpO3JldHVybiBmdW5jdGlvbih0LGUsbixyKXtpZihcImludDMyXCIhPT10LmR0eXBlKXRocm93IG5ldyBFcnJvcihcInRmLnNwYXJzZVRvRGVuc2UoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIGludDMyIHR5cGUsIGJ1dCB0aGUgZHR5cGUgd2FzIFwiK3QuZHR5cGUrXCIuXCIpO2lmKHQucmFuaz4yKXRocm93IG5ldyBFcnJvcihcInNwYXJzZUluZGljZXMgc2hvdWxkIGJlIGEgc2NhbGFyLCB2ZWN0b3IsIG9yIG1hdHJpeCwgYnV0IGdvdCBzaGFwZSBcIit0LnNoYXBlK1wiLlwiKTt2YXIgbz10LnJhbms+MD90LnNoYXBlWzBdOjEsYT10LnJhbms+MT90LnNoYXBlWzFdOjE7aWYobi5sZW5ndGghPT1hKXRocm93IG5ldyBFcnJvcihcIm91dHB1dFNoYXBlIGhhcyBpbmNvcnJlY3QgbnVtYmVyIG9mIGVsZW1lbnRzOiwgXCIrbi5sZW5ndGgrXCIsIHNob3VsZCBiZTogXCIrYStcIi5cIik7dmFyIGk9ZS5zaXplO2lmKDAhPT1lLnJhbmsmJigxIT09ZS5yYW5rfHxpIT09bykpdGhyb3cgbmV3IEVycm9yKFwic3BhcnNlVmFsdWVzIGhhcyBpbmNvcnJlY3Qgc2hhcGUgXCIrZS5zaGFwZStcIiwgc2hvdWxkIGJlIFtdIG9yIFtcIitvK1wiXVwiKTtpZihlLmR0eXBlIT09ci5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJzcGFyc2VWYWx1ZXMuZHR5cGUgbXVzdCBtYXRjaCBkZWZhdWx0VmFsdWVzLmR0eXBlXCIpfShvLGEsbixpKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zcGFyc2VUb0RlbnNlKG8sYSxuLGkpfSkseyRzcGFyc2VJbmRpY2VzOm8sJHNwYXJzZVZhbHVlczphLCRkZWZhdWx0VmFsdWU6aX0pfX0pO3ZhciB0aD1Bbih7Z2F0aGVyTkRfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4oZSxcImluZGljZXNcIixcImdhdGhlck5EXCIsXCJpbnQzMlwiKSxyPW1uKHQsXCJ4XCIsXCJnYXRoZXJORFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2F0aGVyTkQocixuKX0pLHt4OnIsaW5kaWNlczpufSxudWxsLFwiR2F0aGVyTmRcIil9fSk7dmFyIGVoPUFuKHtkaWFnXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiZGlhZ1wiKS5mbGF0dGVuKCksbj10LnNoYXBlLmNvbmNhdCh0LnNoYXBlKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGlhZyhlKX0pLHskeDplfSkucmVzaGFwZShuKX19KTt2YXIgbmg9QW4oe2Ryb3BvdXRfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPW1uKHQsXCJ4XCIsXCJkcm9wb3V0XCIpO2lmKEMoXCJmbG9hdDMyXCI9PT1vLmR0eXBlLChmdW5jdGlvbigpe3JldHVyblwieCBoYXMgdG8gYmUgYSBmbG9hdGluZyBwb2ludCB0ZW5zb3Igc2luY2UgaXQncyBnb2luZyB0byBiZSBzY2FsZWQsIGJ1dCBnb3QgYSBcIitvLmR0eXBlK1wiIHRlbnNvciBpbnN0ZWFkLlwifSkpLEMoZT49MCYmZTwxLChmdW5jdGlvbigpe3JldHVyblwicmF0ZSBtdXN0IGJlIGEgZmxvYXQgaW4gdGhlIHJhbmdlIFswLCAxKSwgYnV0IGdvdCBcIitlK1wiLlwifSkpLDA9PT1lKXJldHVybiB0IGluc3RhbmNlb2Ygd3Q/by5jbG9uZSgpOm87dmFyIGE9ZnVuY3Rpb24odCxlKXtpZihudWxsPT1lKXJldHVybiB0LnNoYXBlLnNsaWNlKCk7aWYoUyh0LnNoYXBlLGUpKXJldHVybiBlO2lmKHQuc2hhcGUubGVuZ3RoPT09ZS5sZW5ndGgpe2Zvcih2YXIgbj1bXSxyPTA7cjx0LnNoYXBlLmxlbmd0aDtyKyspbnVsbD09ZVtyXSYmbnVsbCE9dC5zaGFwZVtyXT9uLnB1c2godC5zaGFwZVtyXSk6bi5wdXNoKGVbcl0pO3JldHVybiBufXJldHVybiBlfShvLG4pLGk9MS1lLHM9X3IoYSwwLDEsXCJmbG9hdDMyXCIscikuYWRkKGkpLmZsb29yKCkuZGl2KGkpO3JldHVybiBvLm11bChzKX19KTtmdW5jdGlvbiByaCh0LGUsbil7Zm9yKHZhciByPTEtdCUyLG89bmV3IEZsb2F0MzJBcnJheSh0KSxhPTA7YTx0OysrYSl7dmFyIGk9MipNYXRoLlBJKmEvKHQrci0xKTtvW2FdPWUtbipNYXRoLmNvcyhpKX1yZXR1cm4gTW4obyxcImZsb2F0MzJcIil9dmFyIG9oPUFuKHtoYW5uV2luZG93XzpmdW5jdGlvbih0KXtyZXR1cm4gcmgodCwuNSwuNSl9fSksYWg9QW4oe2hhbW1pbmdXaW5kb3dfOmZ1bmN0aW9uKHQpe3JldHVybiByaCh0LC41NCwuNDYpfX0pLGloPUFuKHtmcmFtZV86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1yJiYocj0hMSksdm9pZCAwPT09byYmKG89MCk7Zm9yKHZhciBhPTAsaT1bXTthK2U8PXQuc2l6ZTspaS5wdXNoKG1sKHQsYSxlKSksYSs9bjtpZihyKWZvcig7YTx0LnNpemU7KXt2YXIgcz1hK2UtdC5zaXplLHU9WW4oW21sKHQsYSxlLXMpLEhuKFtzXSxvKV0pO2kucHVzaCh1KSxhKz1ufXJldHVybiAwPT09aS5sZW5ndGg/Qm4oW10sWzAsZV0pOlluKGkpLmFzMkQoaS5sZW5ndGgsZSl9fSksc2g9QW4oe3N0ZnRfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGE7dm9pZCAwPT09byYmKG89b2gpLG51bGw9PXImJihhPWUscj1NYXRoLmZsb29yKE1hdGgucG93KDIsTWF0aC5jZWlsKE1hdGgubG9nKGEpL01hdGgubG9nKDIpKSkpKTtmb3IodmFyIGk9aWgodCxlLG4pLHM9Z2MoaSxvKGUpKSx1PVtdLGM9MDtjPGkuc2hhcGVbMF07YysrKXUucHVzaCgkbChzLnNsaWNlKFtjLDBdLFsxLGVdKSxyKSk7cmV0dXJuIFluKHUpfX0pLHVoPU9iamVjdC5mcmVlemUoe2hhbm5XaW5kb3c6b2gsaGFtbWluZ1dpbmRvdzphaCxmcmFtZTppaCxzdGZ0OnNofSk7dmFyIGNoLGxoPWZ1bmN0aW9uKHQsZSxvKXtyZXR1cm4gdm9pZCAwPT09byYmKG89MSksbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sYSxpLHMsdSxjLGwsaCxmLGQscCx2LG0sZztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiBuPW1uKHQsXCJwcmVkaWN0aW9uc1wiLFwiaW5Ub3BLXCIpLGE9bW4oZSxcInRhcmdldHNcIixcImluVG9wS1wiKSxDKG4ucmFuaz4xLChmdW5jdGlvbigpe3JldHVyblwiaW5Ub3BLKCkgZXhwZWN0cyB0aGUgcHJlZGljdGlvbnMgdG8gYmUgb2YgcmFuayAyIG9yIGhpZ2hlciwgYnV0IGdvdCBcIituLnJhbmt9KSksQyhuLnJhbmstMT09PWEucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cInByZWRpY3Rpb25zIHJhbmsgc2hvdWxkIGJlIDEgbGFyZ2VyIHRoYW4gdGFyZ2V0cyByYW5rLCBidXQgZ290IHByZWRpY3Rpb25zIHJhbmsgXCIrbi5yYW5rK1wiIGFuZCB0YXJnZXRzIHJhbmsgXCIrYS5yYW5rfSkpLEUobi5zaGFwZS5zbGljZSgwLG4uc2hhcGUubGVuZ3RoLTEpLGEuc2hhcGUsXCJwcmVkaWN0aW9ucydzIHNoYXBlIHNob3VsZCBiZSBhbGlnbiB3aXRoIHRoZSB0YXJnZXRzJyBzaGFwZSwgZXhjZXB0IHRoZSBsYXN0IGRpbWVuc2lvbi5cIiksaT1uLnNoYXBlW24uc2hhcGUubGVuZ3RoLTFdLEMobz4wJiZvPD1pLChmdW5jdGlvbigpe3JldHVyblwiJ2snIHBhc3NlZCB0byBpblRvcEsoKSBtdXN0IGJlID4gMCAmJiA8PSB0aGUgcHJlZGljdGlvbnMgbGFzdCBkaW1lbnNpb24gKFwiK2krXCIpLCBidXQgZ290IFwiK299KSksWzQsbi5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gcz1yLnNlbnQoKSxbNCxhLmRhdGEoKV07Y2FzZSAyOmZvcih1PXIuc2VudCgpLGM9W3MubGVuZ3RoL2ksaV0saD1jWzFdLGY9QihcImJvb2xcIixsPWNbMF0pLGQ9MDtkPGw7ZCsrKXtmb3IocD1kKmgsdj1zLnN1YmFycmF5KHAscCtoKSxtPVtdLGc9MDtnPHYubGVuZ3RoO2crKyltLnB1c2goe3ZhbHVlOnZbZ10saW5kZXg6Z30pO2ZvcihtLnNvcnQoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUudmFsdWUtdC52YWx1ZX0pKSxmW2RdPTAsZz0wO2c8bztnKyspaWYobVtnXS5pbmRleD09PXVbZF0pe2ZbZF09MTticmVha319cmV0dXJuIHQhPT1uJiZuLmRpc3Bvc2UoKSxlIT09YSYmYS5kaXNwb3NlKCksWzIsRm4oZixhLnNoYXBlLFwiYm9vbFwiKV19fSkpfSkpfTshZnVuY3Rpb24odCl7dFt0Lk5PTkU9MF09XCJOT05FXCIsdFt0Lk1FQU49MV09XCJNRUFOXCIsdFt0LlNVTT0yXT1cIlNVTVwiLHRbdC5TVU1fQllfTk9OWkVST19XRUlHSFRTPTNdPVwiU1VNX0JZX05PTlpFUk9fV0VJR0hUU1wifShjaHx8KGNoPXt9KSk7dmFyIGhoPUFuKHthYnNvbHV0ZURpZmZlcmVuY2VfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPWNoLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBvPW1uKHQsXCJsYWJlbHNcIixcImFic29sdXRlRGlmZmVyZW5jZVwiKSxhPW1uKGUsXCJwcmVkaWN0aW9uc1wiLFwiYWJzb2x1dGVEaWZmZXJlbmNlXCIpLGk9bnVsbDtudWxsIT1uJiYoaT1tbihuLFwid2VpZ2h0c1wiLFwiYWJzb2x1dGVEaWZmZXJlbmNlXCIpKSxFKG8uc2hhcGUsYS5zaGFwZSxcIkVycm9yIGluIGFic29sdXRlRGlmZmVyZW5jZTogXCIpO3ZhciBzPW8uc3ViKGEpLmFicygpO3JldHVybiBmaChzLGkscil9fSksZmg9QW4oe2NvbXB1dGVXZWlnaHRlZExvc3NfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1jaC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgcj1tbih0LFwibG9zc2VzXCIsXCJjb21wdXRlV2VpZ2h0ZWRMb3NzXCIpLG89bnVsbDtudWxsIT1lJiYobz1tbihlLFwid2VpZ2h0c1wiLFwiY29tcHV0ZVdlaWdodGVkTG9zc1wiKSk7dmFyIGE9bnVsbD09bz9yOnIubXVsKG8pO2lmKG49PT1jaC5OT05FKXJldHVybiBhO2lmKG49PT1jaC5TVU0pcmV0dXJuIGEuc3VtKCk7aWYobj09PWNoLk1FQU4pe2lmKG51bGw9PW8pcmV0dXJuIGEubWVhbigpO3ZhciBpPXIuc2l6ZS9vLnNpemUscz1hLnN1bSgpLmRpdihvLnN1bSgpKTtyZXR1cm4gaT4xP3MuZGl2KE9uKGkpKTpzfWlmKG49PT1jaC5TVU1fQllfTk9OWkVST19XRUlHSFRTKXtpZihudWxsPT1vKXJldHVybiBhLnN1bSgpLmRpdihPbihyLnNpemUpKTt2YXIgdT1vLm11bCh6bihyLnNoYXBlKSkubm90RXF1YWwoT24oMCkpLnN1bSgpLnRvRmxvYXQoKTtyZXR1cm4gYS5zdW0oKS5kaXYodSl9dGhyb3cgRXJyb3IoXCJVbmtub3duIHJlZHVjdGlvbjogXCIrbil9fSksZGg9QW4oe2Nvc2luZURpc3RhbmNlXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PW8mJihvPWNoLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBhPW1uKHQsXCJsYWJlbHNcIixcImNvc2luZURpc3RhbmNlXCIpLGk9bW4oZSxcInByZWRpY3Rpb25zXCIsXCJjb3NpbmVEaXN0YW5jZVwiKSxzPW51bGw7bnVsbCE9ciYmKHM9bW4ocixcIndlaWdodHNcIixcImNvc2luZURpc3RhbmNlXCIpKSxFKGEuc2hhcGUsaS5zaGFwZSxcIkVycm9yIGluIGNvc2luZURpc3RhbmNlOiBcIik7dmFyIHU9T24oMSkuc3ViKGEubXVsKGkpLnN1bShuLCEwKSk7cmV0dXJuIGZoKHUscyxvKX19KSxwaD1Bbih7aGluZ2VMb3NzXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1jaC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgbz1tbih0LFwibGFiZWxzXCIsXCJoaW5nZUxvc3NcIiksYT1tbihlLFwicHJlZGljdGlvbnNcIixcImhpbmdlTG9zc1wiKSxpPW51bGw7bnVsbCE9biYmKGk9bW4obixcIndlaWdodHNcIixcImhpbmdlTG9zc1wiKSksRShvLnNoYXBlLGEuc2hhcGUsXCJFcnJvciBpbiBoaW5nZUxvc3M6IFwiKTt2YXIgcz1PbigxKTtvPU9uKDIpLm11bChvKS5zdWIocyk7dmFyIHU9cy5zdWIoby5tdWwoYSkpLnJlbHUoKTtyZXR1cm4gZmgodSxpLHIpfX0pLHZoPUFuKHtodWJlckxvc3NfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ciYmKHI9MSksdm9pZCAwPT09byYmKG89Y2guU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGE9bW4odCxcImxhYmVsc1wiLFwiaHViZXJMb3NzXCIpLGk9bW4oZSxcInByZWRpY3Rpb25zXCIsXCJodWJlckxvc3NcIikscz1udWxsO251bGwhPW4mJihzPW1uKG4sXCJ3ZWlnaHRzXCIsXCJodWJlckxvc3NcIikpLEUoYS5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gaHViZXJMb3NzOiBcIik7dmFyIHU9T24ociksYz1pLnN1YihhKS5hYnMoKSxsPWRjKGMsdSksaD1jLnN1YihsKSxmPU9uKC41KS5tdWwobC5zcXVhcmUoKSkuYWRkKHUubXVsKGgpKTtyZXR1cm4gZmgoZixzLG8pfX0pLG1oPUFuKHtsb2dMb3NzXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PXImJihyPTFlLTcpLHZvaWQgMD09PW8mJihvPWNoLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBhPW1uKHQsXCJsYWJlbHNcIixcImxvZ0xvc3NcIiksaT1tbihlLFwicHJlZGljdGlvbnNcIixcImxvZ0xvc3NcIikscz1udWxsO251bGwhPW4mJihzPW1uKG4sXCJ3ZWlnaHRzXCIsXCJsb2dMb3NzXCIpKSxFKGEuc2hhcGUsaS5zaGFwZSxcIkVycm9yIGluIGxvZ0xvc3M6IFwiKTt2YXIgdT1PbigxKSxjPU9uKHIpLGw9YS5tdWwoaS5hZGQoYykubG9nKCkpLm5lZygpLnN1Yih1LnN1YihhKS5tdWwodS5zdWIoaSkuYWRkKGMpLmxvZygpKSk7cmV0dXJuIGZoKGwscyxvKX19KSxnaD1Bbih7bWVhblNxdWFyZWRFcnJvcl86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9Y2guU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIG89bW4odCxcImxhYmVsc1wiLFwibWVhblNxdWFyZWRFcnJvclwiKSxhPW1uKGUsXCJwcmVkaWN0aW9uc1wiLFwibWVhblNxdWFyZWRFcnJvclwiKSxpPW51bGw7bnVsbCE9biYmKGk9bW4obixcIndlaWdodHNcIixcIm1lYW5TcXVhcmVkRXJyb3JcIikpLEUoby5zaGFwZSxhLnNoYXBlLFwiRXJyb3IgaW4gbWVhblNxdWFyZWRFcnJvcjogXCIpO3ZhciBzPW8uc3F1YXJlZERpZmZlcmVuY2UoYSk7cmV0dXJuIGZoKHMsaSxyKX19KSx5aD1Bbih7c2lnbW9pZENyb3NzRW50cm9weV86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1vJiYobz1jaC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgYT1tbih0LFwibXVsdGlDbGFzc0xhYmVsc1wiLFwic2lnbW9pZENyb3NzRW50cm9weVwiKSxpPW1uKGUsXCJsb2dpdHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlcIikscz1udWxsO2lmKG51bGwhPW4mJihzPW1uKG4sXCJ3ZWlnaHRzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5XCIpKSxFKGEuc2hhcGUsaS5zaGFwZSxcIkVycm9yIGluIHNpZ21vaWRDcm9zc0VudHJvcHk6IFwiKSxyPjApe3ZhciB1PU9uKHIpLGM9T24oMSksbD1PbiguNSk7YT1hLm11bChjLnN1Yih1KSkuYWRkKGwubXVsKHUpKX12YXIgaD1mdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJsYWJlbHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzXCIpLHI9bW4oZSxcImxvZ2l0c1wiLFwic2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHNcIik7RShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0czogXCIpO3ZhciBvPXIucmVsdSgpLGE9ci5tdWwobiksaT1yLmFicygpLm5lZygpLmV4cCgpLmxvZzFwKCk7cmV0dXJuIG8uc3ViKGEpLmFkZChpKX0oYSxpKTtyZXR1cm4gZmgoaCxzLG8pfX0pLHhoPUFuKHtzb2Z0bWF4Q3Jvc3NFbnRyb3B5XzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PXImJihyPTApLHZvaWQgMD09PW8mJihvPWNoLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBhPW1uKHQsXCJvbmVob3RMYWJlbHNcIixcInNvZnRtYXhDcm9zc0VudHJvcHlcIiksaT1tbihlLFwibG9naXRzXCIsXCJzb2Z0bWF4Q3Jvc3NFbnRyb3B5XCIpLHM9bnVsbDtpZihudWxsIT1uJiYocz1tbihuLFwid2VpZ2h0c1wiLFwic29mdG1heENyb3NzRW50cm9weVwiKSksRShhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBzb2Z0bWF4Q3Jvc3NFbnRyb3B5OiBcIikscj4wKXt2YXIgdT1PbihyKSxjPU9uKDEpLGw9T24oYS5zaGFwZVsxXSk7YT1hLm11bChjLnN1Yih1KSkuYWRkKHUuZGl2KGwpKX12YXIgaD1mdW5jdGlvbih0LGUsbil7aWYodm9pZCAwPT09biYmKG49LTEpLC0xPT09biYmKG49ZS5yYW5rLTEpLG4hPT1lLnJhbmstMSl0aHJvdyBFcnJvcihcIlNvZnRtYXggY3Jvc3MgZW50cm9weSBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gTGFiZWxzIC8gbG9naXRzIHdhcyByYW5rIFwiK2UucmFuaytcIiBhbmQgZGltIHdhcyBcIituKTtyZXR1cm4gdm8oKGZ1bmN0aW9uKHQsZSxyKXt2YXIgbz1lLmxvZ1N1bUV4cChbbl0sITApLGE9ZS50b0Zsb2F0KCkuc3ViKG8pO3IoW3QsYV0pO3JldHVybnt2YWx1ZTphLm11bCh0KS5uZWcoKS5zdW0oW25dKSxncmFkRnVuYzpmdW5jdGlvbih0LGUpe3ZhciByPWVbMF0sbz1lWzFdLGE9d24odC5zaGFwZSxbbl0pO3JldHVyblt0LnJlc2hhcGUoYSkubXVsKHIudG9GbG9hdCgpLnN1YihvLmV4cCgpKSksdC5yZXNoYXBlKGEpLm11bChvLmV4cCgpLnN1YihyLnRvRmxvYXQoKSkpXX19fSkpKHQsZSl9KGEsaSk7cmV0dXJuIGZoKGgscyxvKX19KSxiaD1PYmplY3QuZnJlZXplKHtnZXQgUmVkdWN0aW9uKCl7cmV0dXJuIGNofSxhYnNvbHV0ZURpZmZlcmVuY2U6aGgsY29tcHV0ZVdlaWdodGVkTG9zczpmaCxjb3NpbmVEaXN0YW5jZTpkaCxoaW5nZUxvc3M6cGgsaHViZXJMb3NzOnZoLGxvZ0xvc3M6bWgsbWVhblNxdWFyZWRFcnJvcjpnaCxzaWdtb2lkQ3Jvc3NFbnRyb3B5OnloLHNvZnRtYXhDcm9zc0VudHJvcHk6eGh9KTtmdW5jdGlvbiB3aCh0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksTHQudGlkeSgoZnVuY3Rpb24oKXtpZigyIT09dC5zaGFwZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwicXIyZCgpIHJlcXVpcmVzIGEgMkQgVGVuc29yLCBidXQgZ290IGEgXCIrdC5zaGFwZS5sZW5ndGgrXCJEIFRlbnNvci5cIik7Zm9yKHZhciBuPXQuc2hhcGVbMF0scj10LnNoYXBlWzFdLG89Q3IobiksYT10LmNsb25lKCksaT1CbihbWzFdXSxbMSwxXSkscz1pLmNsb25lKCksdT1uPj1yP3I6bixjPWZ1bmN0aW9uKHQpe3ZhciBlLHU9YSxjPXMsbD1vO2U9THQudGlkeSgoZnVuY3Rpb24oKXt2YXIgZT1hLnNsaWNlKFt0LHRdLFtuLXQsMV0pLHU9ZS5ub3JtKCksYz1hLnNsaWNlKFt0LHRdLFsxLDFdKSxsPUJuKFtbLTFdXSkud2hlcmUoYy5ncmVhdGVyKDApLEJuKFtbMV1dKSksaD1jLnN1YihsLm11bCh1KSksZj1lLmRpdihoKTtzPTE9PT1mLnNoYXBlWzBdP2kuY2xvbmUoKTppLmNvbmNhdChmLnNsaWNlKFsxLDBdLFtmLnNoYXBlWzBdLTEsZi5zaGFwZVsxXV0pLDApO3ZhciBkPWwubWF0TXVsKGgpLmRpdih1KS5uZWcoKSxwPWEuc2xpY2UoW3QsMF0sW24tdCxyXSksdj1kLm11bChzKTtpZigwPT09dClhPXAuc3ViKHYubWF0TXVsKHMudHJhbnNwb3NlKCkubWF0TXVsKHApKSk7ZWxzZXt2YXIgbT1wLnN1Yih2Lm1hdE11bChzLnRyYW5zcG9zZSgpLm1hdE11bChwKSkpO2E9YS5zbGljZShbMCwwXSxbdCxyXSkuY29uY2F0KG0sMCl9dmFyIGc9by5zbGljZShbMCx0XSxbbixvLnNoYXBlWzFdLXRdKTtpZigwPT09dClvPWcuc3ViKGcubWF0TXVsKHMpLm1hdE11bCh2LnRyYW5zcG9zZSgpKSk7ZWxzZXt2YXIgeT1nLnN1YihnLm1hdE11bChzKS5tYXRNdWwodi50cmFuc3Bvc2UoKSkpO289by5zbGljZShbMCwwXSxbbix0XSkuY29uY2F0KHksMSl9cmV0dXJuW3MsYSxvXX0pKSxzPWVbMF0sYT1lWzFdLG89ZVsyXSx0bihbdSxjLGxdKX0sbD0wO2w8dTsrK2wpYyhsKTtyZXR1cm4hZSYmbj5yJiYobz1vLnNsaWNlKFswLDBdLFtuLHJdKSxhPWEuc2xpY2UoWzAsMF0sW3Iscl0pKSxbbyxhXX0pKX12YXIgQ2g9QW4oe2JhbmRQYXJ0XzpmdW5jdGlvbih0LGUsbil7aWYoZSUxIT0wKXRocm93IG5ldyBFcnJvcihcImJhbmRQYXJ0KCk6IG51bUxvd2VyIG11c3QgYmUgYW4gaW50ZWdlciwgZ290IFwiK2UrXCIuXCIpO2lmKG4lMSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJiYW5kUGFydCgpOiBudW1VcHBlciBtdXN0IGJlIGFuIGludGVnZXIsIGdvdCBcIituK1wiLlwiKTt2YXIgcj1tbih0LFwiYVwiLFwiYmFuZFBhcnRcIik7aWYoci5yYW5rPDIpdGhyb3cgbmV3IEVycm9yKFwiYmFuZFBhcnQoKTogUmFuayBtdXN0IGJlIGF0IGxlYXN0IDIsIGdvdCBcIityLnJhbmsrXCIuXCIpO3ZhciBvPXIuc2hhcGUsYT1yLnNoYXBlLnNsaWNlKC0yKSxpPWFbMF0scz1hWzFdO2lmKCEoZTw9aSkpdGhyb3cgbmV3IEVycm9yKFwiYmFuZFBhcnQoKTogbnVtTG93ZXIgKFwiK2UrXCIpIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHJvd3MgKFwiK2krXCIpLlwiKTtpZighKG48PXMpKXRocm93IG5ldyBFcnJvcihcImJhbmRQYXJ0KCk6IG51bVVwcGVyIChcIituK1wiKSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBjb2x1bW5zIChcIitzK1wiKS5cIik7ZTwwJiYoZT1pKSxuPDAmJihuPXMpO3ZhciB1PUtuKDAsaSwxLFwiaW50MzJcIikucmVzaGFwZShbLTEsMV0pLGM9S24oMCxzLDEsXCJpbnQzMlwiKSxsPUNjKHUsYyksaD1RdShsLmxlc3NFcXVhbChPbigrZSxcImludDMyXCIpKSxsLmdyZWF0ZXJFcXVhbChPbigtbixcImludDMyXCIpKSksZj1HbihbaSxzXSxyLmR0eXBlKTtyZXR1cm4gUHIoVXIoci5yZXNoYXBlKFstMSxpLHNdKSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZWMoaCx0LGYpfSkpKS5yZXNoYXBlKG8pfX0pLEVoPUFuKHtncmFtU2NobWlkdF86ZnVuY3Rpb24odCl7dmFyIGU7aWYoQXJyYXkuaXNBcnJheSh0KSl7ZT0hMSxDKG51bGwhPXQmJnQubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJHcmFtLVNjaG1pZHQgcHJvY2VzczogaW5wdXQgbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBvciBlbXB0eVwifSkpO2Zvcih2YXIgbj10WzBdLnNoYXBlWzBdLHI9ZnVuY3Rpb24oZSl7Qyh0W2VdLnNoYXBlWzBdPT09biwoZnVuY3Rpb24oKXtyZXR1cm5cIkdyYW0tU2NobWlkdDogTm9uLXVuaXF1ZSBsZW5ndGhzIGZvdW5kIGluIHRoZSBpbnB1dCB2ZWN0b3JzOiAoXCIrdFtlXS5zaGFwZVswXStcIiB2cy4gXCIrbitcIilcIn0pKX0sbz0xO288dC5sZW5ndGg7KytvKXIobyl9ZWxzZSBlPSEwLHQ9dHIodCx0LnNoYXBlWzBdLDApLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIEJyKHQsWzBdKX0pKTtDKHQubGVuZ3RoPD10WzBdLnNoYXBlWzBdLChmdW5jdGlvbigpe3JldHVyblwiR3JhbS1TY2htaWR0OiBOdW1iZXIgb2YgdmVjdG9ycyAoXCIrdC5sZW5ndGgrXCIpIGV4Y2VlZHMgbnVtYmVyIG9mIGRpbWVuc2lvbnMgKFwiK3RbMF0uc2hhcGVbMF0rXCIpLlwifSkpO3ZhciBhPVtdLGk9dCxzPWZ1bmN0aW9uKHQpe2EucHVzaChMdC50aWR5KChmdW5jdGlvbigpe3ZhciBlPWlbdF07aWYodD4wKWZvcih2YXIgbj0wO248dDsrK24pe3ZhciByPU5sKGFbbl0ubXVsU3RyaWN0KGUpKS5tdWwoYVtuXSk7ZT1lLnN1YihyKX1yZXR1cm4gZS5kaXYoVmwoZSxcImV1Y2xpZGVhblwiKSl9KSkpfTtmb3Iobz0wO288dC5sZW5ndGg7KytvKXMobyk7cmV0dXJuIGU/UHIoYSwwKTphfX0pLFJoPUFuKHtxcl86ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT1lJiYoZT0hMSksdC5yYW5rPDIpdGhyb3cgbmV3IEVycm9yKFwicXIoKSByZXF1aXJlcyBpbnB1dCB0ZW5zb3IgdG8gaGF2ZSBhIHJhbmsgPj0gMiwgYnV0IGdvdCByYW5rIFwiK3QucmFuayk7aWYoMj09PXQucmFuaylyZXR1cm4gd2godCxlKTt2YXIgbj10LnNoYXBlLnNsaWNlKDAsdC5zaGFwZS5sZW5ndGgtMikucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSkscj1Vcih0LnJlc2hhcGUoW24sdC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0yXSx0LnNoYXBlW3Quc2hhcGUubGVuZ3RoLTFdXSksMCksbz1bXSxhPVtdO3JldHVybiByLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBuPXdoKHQsZSkscj1uWzBdLGk9blsxXTtvLnB1c2gociksYS5wdXNoKGkpfSkpLFtQcihvLDApLnJlc2hhcGUodC5zaGFwZSksUHIoYSwwKS5yZXNoYXBlKHQuc2hhcGUpXX19KSxJaD1PYmplY3QuZnJlZXplKHtiYW5kUGFydDpDaCxncmFtU2NobWlkdDpFaCxxcjpSaH0pO2Z1bmN0aW9uIGtoKHQsZSxuLHIsbyxhKXtudWxsPT1yJiYocj0uNSksbnVsbD09byYmKG89TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSxudWxsPT1hJiYoYT0wKTt2YXIgaT10LnNoYXBlWzBdO3JldHVybiBuPU1hdGgubWluKG4saSksQygwPD1yJiZyPD0xLChmdW5jdGlvbigpe3JldHVyblwiaW91VGhyZXNob2xkIG11c3QgYmUgaW4gWzAsIDFdLCBidXQgd2FzICdcIityK1wiJ1wifSkpLEMoMj09PXQucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cImJveGVzIG11c3QgYmUgYSAyRCB0ZW5zb3IsIGJ1dCB3YXMgb2YgcmFuayAnXCIrdC5yYW5rK1wiJ1wifSkpLEMoND09PXQuc2hhcGVbMV0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJib3hlcyBtdXN0IGhhdmUgNCBjb2x1bW5zLCBidXQgMm5kIGRpbWVuc2lvbiB3YXMgXCIrdC5zaGFwZVsxXX0pKSxDKDE9PT1lLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJzY29yZXMgbXVzdCBiZSBhIDFEIHRlbnNvclwifSkpLEMoZS5zaGFwZVswXT09PWksKGZ1bmN0aW9uKCl7cmV0dXJuXCJzY29yZXMgaGFzIGluY29tcGF0aWJsZSBzaGFwZSB3aXRoIGJveGVzLiBFeHBlY3RlZCBcIitpK1wiLCBidXQgd2FzIFwiK2Uuc2hhcGVbMF19KSksQygwPD1hJiZhPD0xLChmdW5jdGlvbigpe3JldHVyblwic29mdE5tc1NpZ21hIG11c3QgYmUgaW4gWzAsIDFdLCBidXQgd2FzICdcIithK1wiJ1wifSkpLHttYXhPdXRwdXRTaXplOm4saW91VGhyZXNob2xkOnIsc2NvcmVUaHJlc2hvbGQ6byxzb2Z0Tm1zU2lnbWE6YX19dmFyIFNoPUFuKHtyZXNpemVCaWxpbmVhcl86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1tbih0LFwiaW1hZ2VzXCIsXCJyZXNpemVCaWxpbmVhclwiKTtDKDM9PT1yLnJhbmt8fDQ9PT1yLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXNpemVCaWxpbmVhcjogeCBtdXN0IGJlIHJhbmsgMyBvciA0LCBidXQgZ290IHJhbmsgXCIrci5yYW5rK1wiLlwifSkpLEMoMj09PWUubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmVzaXplQmlsaW5lYXI6IG5ldyBzaGFwZSBtdXN0IDJELCBidXQgZ290IHNoYXBlIFwiK2UrXCIuXCJ9KSk7dmFyIG89cixhPSExOzM9PT1yLnJhbmsmJihhPSEwLG89ci5hczREKDEsci5zaGFwZVswXSxyLnNoYXBlWzFdLHIuc2hhcGVbMl0pKTt2YXIgaT1lWzBdLHM9ZVsxXSx1PUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUoW29dKSx0LnJlc2l6ZUJpbGluZWFyKG8saSxzLG4pfSkse3g6b30sKGZ1bmN0aW9uKHQsZSl7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24ocil7cmV0dXJuIHIucmVzaXplQmlsaW5lYXJCYWNrcHJvcCh0LGVbMF0sbil9KSx7fSl9fX0pLFwiUmVzaXplQmlsaW5lYXJcIix7YWxpZ25Db3JuZXJzOm4sbmV3SGVpZ2h0OmksbmV3V2lkdGg6c30pO3JldHVybiBhP3UuYXMzRCh1LnNoYXBlWzFdLHUuc2hhcGVbMl0sdS5zaGFwZVszXSk6dX19KSxBaD1Bbih7cmVzaXplTmVhcmVzdE5laWdoYm9yXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49ITEpO3ZhciByPW1uKHQsXCJpbWFnZXNcIixcInJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiKTtDKDM9PT1yLnJhbmt8fDQ9PT1yLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXNpemVOZWFyZXN0TmVpZ2hib3I6IHggbXVzdCBiZSByYW5rIDMgb3IgNCwgYnV0IGdvdCByYW5rIFwiK3IucmFuaytcIi5cIn0pKSxDKDI9PT1lLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJlc2l6ZU5lYXJlc3ROZWlnaGJvcjogbmV3IHNoYXBlIG11c3QgMkQsIGJ1dCBnb3Qgc2hhcGUgXCIrZStcIi5cIn0pKSxDKFwiZmxvYXQzMlwiPT09ci5kdHlwZXx8XCJpbnQzMlwiPT09ci5kdHlwZSwoZnVuY3Rpb24oKXtyZXR1cm5cImBpbWFnZXNgIG11c3QgaGF2ZSBgaW50MzJgIG9yIGBmbG9hdDMyYCBhcyBkdHlwZVwifSkpO3ZhciBvPXIsYT0hMTszPT09ci5yYW5rJiYoYT0hMCxvPXIuYXM0RCgxLHIuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdKSk7dmFyIGk9ZVswXSxzPWVbMV0sdT1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3JldHVybiBlKFtvXSksdC5yZXNpemVOZWFyZXN0TmVpZ2hib3IobyxpLHMsbil9KSx7YmF0Y2hJbWFnZXM6b30sKGZ1bmN0aW9uKHQsZSl7cmV0dXJue2JhdGNoSW1hZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHIpe3JldHVybiByLnJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wKHQsZVswXSxuKX0pLHt9KX19fSkpO3JldHVybiBhP3UuYXMzRCh1LnNoYXBlWzFdLHUuc2hhcGVbMl0sdS5zaGFwZVszXSk6dX19KSxEaD1Bbih7bm9uTWF4U3VwcHJlc3Npb25fOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ciYmKHI9LjUpLHZvaWQgMD09PW8mJihvPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7dmFyIGE9bW4odCxcImJveGVzXCIsXCJub25NYXhTdXBwcmVzc2lvblwiKSxpPW1uKGUsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLHM9a2goYSxpLG4scixvKTtuPXMubWF4T3V0cHV0U2l6ZSxyPXMuaW91VGhyZXNob2xkLG89cy5zY29yZVRocmVzaG9sZDt2YXIgdT17bWF4T3V0cHV0U2l6ZTpuLGlvdVRocmVzaG9sZDpyLHNjb3JlVGhyZXNob2xkOm99O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5ub25NYXhTdXBwcmVzc2lvbihhLGksbixyLG8pfSkse2JveGVzOmEsc2NvcmVzOml9LG51bGwsXCJOb25NYXhTdXBwcmVzc2lvblYzXCIsdSl9fSksVGg9ZnVuY3Rpb24odCxlLG8sYSxpKXtyZXR1cm4gdm9pZCAwPT09YSYmKGE9LjUpLHZvaWQgMD09PWkmJihpPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSksbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4scyx1LGMsbCxoLGY7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbj1tbih0LFwiYm94ZXNcIixcIm5vbk1heFN1cHByZXNzaW9uQXN5bmNcIikscz1tbihlLFwic2NvcmVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLHU9a2gobixzLG8sYSxpKSxvPXUubWF4T3V0cHV0U2l6ZSxhPXUuaW91VGhyZXNob2xkLGk9dS5zY29yZVRocmVzaG9sZCxbNCxQcm9taXNlLmFsbChbbi5kYXRhKCkscy5kYXRhKCldKV07Y2FzZSAxOnJldHVybiBjPXIuc2VudCgpLGw9Y1swXSxoPWNbMV0sZj1qbyhsLGgsbyxhLGkpLG4hPT10JiZuLmRpc3Bvc2UoKSxzIT09ZSYmcy5kaXNwb3NlKCksWzIsZl19fSkpfSkpfSxOaD1Bbih7bm9uTWF4U3VwcHJlc3Npb25XaXRoU2NvcmVfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2b2lkIDA9PT1yJiYocj0uNSksdm9pZCAwPT09byYmKG89TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSx2b2lkIDA9PT1hJiYoYT0wKTt2YXIgaT1tbih0LFwiYm94ZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLHM9bW4oZSxcInNjb3Jlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25cIiksdT1raChpLHMsbixyLG8sYSksYz17bWF4T3V0cHV0U2l6ZTpuPXUubWF4T3V0cHV0U2l6ZSxpb3VUaHJlc2hvbGQ6cj11LmlvdVRocmVzaG9sZCxzY29yZVRocmVzaG9sZDpvPXUuc2NvcmVUaHJlc2hvbGQsc29mdE5tc1NpZ21hOmE9dS5zb2Z0Tm1zU2lnbWF9LGw9THQucnVuS2VybmVsKFwiTm9uTWF4U3VwcHJlc3Npb25WNVwiLHtib3hlczppLHNjb3JlczpzfSxjKTtyZXR1cm57c2VsZWN0ZWRJbmRpY2VzOmxbMF0sc2VsZWN0ZWRTY29yZXM6bFsxXX19fSksRmg9ZnVuY3Rpb24odCxlLG8sYSxpLHMpe3JldHVybiB2b2lkIDA9PT1hJiYoYT0uNSksdm9pZCAwPT09aSYmKGk9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSx2b2lkIDA9PT1zJiYocz0wKSxuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbix1LGMsbCxoLGYsZDtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiBuPW1uKHQsXCJib3hlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25Bc3luY1wiKSx1PW1uKGUsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uQXN5bmNcIiksYz1raChuLHUsbyxhLGkscyksbz1jLm1heE91dHB1dFNpemUsYT1jLmlvdVRocmVzaG9sZCxpPWMuc2NvcmVUaHJlc2hvbGQscz1jLnNvZnRObXNTaWdtYSxbNCxQcm9taXNlLmFsbChbbi5kYXRhKCksdS5kYXRhKCldKV07Y2FzZSAxOnJldHVybiBsPXIuc2VudCgpLGg9bFswXSxmPWxbMV0sZD1YbyhoLGYsbyxhLGkscyksbiE9PXQmJm4uZGlzcG9zZSgpLHUhPT1lJiZ1LmRpc3Bvc2UoKSxbMixkXX19KSl9KSl9LF9oPUFuKHtjcm9wQW5kUmVzaXplXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9bW4odCxcImltYWdlXCIsXCJjcm9wQW5kUmVzaXplXCIpLHM9bW4oZSxcImJveGVzXCIsXCJjcm9wQW5kUmVzaXplXCIsXCJmbG9hdDMyXCIpLHU9bW4obixcImJveEluZFwiLFwiY3JvcEFuZFJlc2l6ZVwiLFwiaW50MzJcIik7bz1vfHxcImJpbGluZWFyXCIsYT1hfHwwO3ZhciBjPXMuc2hhcGVbMF07cmV0dXJuIEMoND09PWkucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNyb3BBbmRSZXNpemU6IGltYWdlIG11c3QgYmUgcmFuayA0LGJ1dCBnb3QgcmFuayBcIitpLnJhbmsrXCIuXCJ9KSksQygyPT09cy5yYW5rJiY0PT09cy5zaGFwZVsxXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNyb3BBbmRSZXNpemU6IGJveGVzIG11c3QgYmUgaGF2ZSBzaXplIFtcIitjK1wiLDRdIGJ1dCBoYWQgc2hhcGUgXCIrcy5zaGFwZStcIi5cIn0pKSxDKDE9PT11LnJhbmsmJnUuc2hhcGVbMF09PT1jLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogYm94SW5kIG11c3QgYmUgaGF2ZSBzaXplIFtcIitjK1wiXSBidXQgaGFkIHNoYXBlIFwiK3Muc2hhcGUrXCIuXCJ9KSksQygyPT09ci5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBjcm9wU2l6ZSBtdXN0IGJlIG9mIGxlbmd0aCAyLCBidXQgZ290IGxlbmd0aCBcIityLmxlbmd0aCtcIi5cIn0pKSxDKHJbMF0+PTEmJnJbMV0+PTEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJjcm9wU2l6ZSBtdXN0IGJlIGF0bGVhc3QgWzEsMV0sIGJ1dCB3YXMgXCIrcn0pKSxDKFwiYmlsaW5lYXJcIj09PW98fFwibmVhcmVzdFwiPT09bywoZnVuY3Rpb24oKXtyZXR1cm5cIm1ldGhvZCBtdXN0IGJlIGJpbGluZWFyIG9yIG5lYXJlc3QsIGJ1dCB3YXMgXCIrb30pKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3JldHVybiB0LmNyb3BBbmRSZXNpemUoaSxzLHUscixvLGEpfSkse2ltYWdlczppLGJveGVzOnMsYm94SW5kOnV9LG51bGwsXCJDcm9wQW5kUmVzaXplXCIse21ldGhvZDpvLGV4dHJhcG9sYXRpb25WYWx1ZTphLGNyb3BTaXplOnJ9KX19KSxPaD1PYmplY3QuZnJlZXplKHtyZXNpemVCaWxpbmVhcjpTaCxyZXNpemVOZWFyZXN0TmVpZ2hib3I6QWgsbm9uTWF4U3VwcHJlc3Npb246RGgsbm9uTWF4U3VwcHJlc3Npb25Bc3luYzpUaCxub25NYXhTdXBwcmVzc2lvbldpdGhTY29yZTpOaCxub25NYXhTdXBwcmVzc2lvbldpdGhTY29yZUFzeW5jOkZoLGNyb3BBbmRSZXNpemU6X2h9KSxNaD1mdW5jdGlvbih0LGUpe3JldHVybiEodD4wKXx8XCJsaW5lYXJcIj09PWV9LEJoPWZ1bmN0aW9uKHQsZSxuKXtpZihudWxsPT1ufHxcImxpbmVhclwiPT09bilyZXR1cm4gdDtpZihcInJlbHVcIj09PW4pcmV0dXJuIHQubXVsKGUuc3RlcCgpKTt0aHJvdyBuZXcgRXJyb3IoXCJHcmFkaWVudCBmb3IgYWN0aXZhdGlvbiBcIituK1wiIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCB5ZXQuXCIpfSxQaD1mdW5jdGlvbih0LGUpe3ZhciBuPWUscj1Fbyh0LnNoYXBlLGUuc2hhcGUpO3JldHVybiByLmxlbmd0aD4wJiYobj1uLnN1bShyKSksbi5yZXNoYXBlKHQuc2hhcGUpfSxMaD1mdW5jdGlvbih0LGUsbil7aWYoXCJsaW5lYXJcIj09PWUpcmV0dXJuIHQ7aWYoXCJyZWx1XCI9PT1lKXJldHVybiBCbCh0KTtpZihcImVsdVwiPT09ZSlyZXR1cm4gX2wodCk7aWYoXCJyZWx1NlwiPT09ZSlyZXR1cm4gUGwodCk7aWYoXCJwcmVsdVwiPT09ZSlyZXR1cm4gTWwodCxuKTt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZ1c2VkIGFjdGl2YXRpb24gXCIrZStcIi5cIil9O3ZhciBXaD1Bbih7ZnVzZWRNYXRNdWxfOmZ1bmN0aW9uKHQpe3ZhciBlLG49dC5hLHI9dC5iLG89dC50cmFuc3Bvc2VBLGE9dm9pZCAwIT09byYmbyxpPXQudHJhbnNwb3NlQixzPXZvaWQgMCE9PWkmJmksdT10LmJpYXMsYz10LmFjdGl2YXRpb24sbD12b2lkIDA9PT1jP1wibGluZWFyXCI6YyxoPXQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cztpZighMT09PU1oKEx0LnN0YXRlLmdyYWRpZW50RGVwdGgsbCkpe3ZhciBmPWVsKG4scixhLHMpO3JldHVybiBudWxsIT11JiYoZj1yYyhmLHUpKSxMaChmLGwsaCl9dmFyIGQ9bW4obixcImFcIixcImZ1c2VkIG1hdE11bFwiKSxwPW1uKHIsXCJiXCIsXCJmdXNlZCBtYXRNdWxcIik7ZT1OdChkLHApLGQ9ZVswXSxwPWVbMV07dmFyIHY9YT9kLnNoYXBlW2QucmFuay0yXTpkLnNoYXBlW2QucmFuay0xXSxtPXM/cC5zaGFwZVtwLnJhbmstMV06cC5zaGFwZVtwLnJhbmstMl0sZz1hP2Quc2hhcGVbZC5yYW5rLTFdOmQuc2hhcGVbZC5yYW5rLTJdLHk9cz9wLnNoYXBlW3AucmFuay0yXTpwLnNoYXBlW3AucmFuay0xXSx4PWQuc2hhcGUuc2xpY2UoMCwtMiksYj1wLnNoYXBlLnNsaWNlKDAsLTIpLHc9ayh4KSxFPWsoYik7QyhkLnJhbms+PTImJnAucmFuaz49MiYmZC5yYW5rPT09cC5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgbWF0TXVsOiBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgb2YgYXQgbGVhc3QgMiwgZ290IHJhbmtzIFwiK2QucmFuaytcIiBhbmQgXCIrcC5yYW5rK1wiLlwifSkpLEMoUyh4LGIpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgbWF0TXVsOiBvdXRlciBkaW1lbnNpb25zIChcIit4K1wiKSBhbmQgKFwiK2IrXCIpIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgXCIrZC5zaGFwZStcIiBhbmQgXCIrcC5zaGFwZStcIiBtdXN0IG1hdGNoLlwifSkpLEModj09PW0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBtYXRNdWw6IGlubmVyIHNoYXBlcyAoXCIrditcIikgYW5kIChcIittK1wiKSBvZiBUZW5zb3JzIHdpdGggc2hhcGVzIFwiK2Quc2hhcGUrXCIgYW5kIFwiK3Auc2hhcGUrXCIgYW5kIHRyYW5zcG9zZUE9XCIrYStcIiBhbmQgdHJhbnNwb3NlQj1cIitzK1wiIG11c3QgbWF0Y2guXCJ9KSk7dmFyIFIsSSxBPWQuc2hhcGUuc2xpY2UoMCwtMikuY29uY2F0KFtnLHldKSxEPWE/ZC5hczNEKHcsdixnKTpkLmFzM0QodyxnLHYpLFQ9cz9wLmFzM0QoRSx5LG0pOnAuYXMzRChFLG0seSk7bnVsbCE9dSYmUm8oQSwoUj1OdChSPW1uKHUsXCJiaWFzXCIsXCJmdXNlZCBtYXRNdWxcIiksZClbMF0pLnNoYXBlKSxudWxsIT1oJiYoST1tbihoLFwicHJlbHUgd2VpZ2h0c1wiLFwiZnVzZWQgbWF0TXVsXCIpKTt2YXIgTj17YTpELGI6VH07bnVsbCE9dSYmKE4uYmlhcz1SKSxudWxsIT1oJiYoTi5wcmVsdUFjdGl2YXRpb25XZWlnaHRzPUkpO3ZhciBGPVtELFRdO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuZnVzZWRCYXRjaE1hdE11bCh7YTpELGI6VCx0cmFuc3Bvc2VBOmEsdHJhbnNwb3NlQjpzLGJpYXM6UixhY3RpdmF0aW9uOmwscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpJfSk7cmV0dXJuIGUoW0QsVCxuXSksbn0pLE4sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV0sbz1lWzJdLGk9QmgodCxvLGwpLGM9e307cmV0dXJuIG51bGwhPXUmJihjPXtiaWFzOmZ1bmN0aW9uKCl7cmV0dXJuIFBoKFIsaSl9fSksYXx8cz8hYSYmcz9PYmplY3QuYXNzaWduKHthOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKHIsITEsITEpfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKG4sITAsITEpfX0sYyk6YSYmIXM/T2JqZWN0LmFzc2lnbih7YTpmdW5jdGlvbigpe3JldHVybiByLm1hdE11bChpLCExLCEwKX0sYjpmdW5jdGlvbigpe3JldHVybiBuLm1hdE11bChpLCExLCExKX19LGMpOk9iamVjdC5hc3NpZ24oe2E6ZnVuY3Rpb24oKXtyZXR1cm4gci5tYXRNdWwoaSwhMCwhMCl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gaS5tYXRNdWwobiwhMCwhMCl9fSxjKTpPYmplY3QuYXNzaWduKHthOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKHIsITEsITApfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIG4ubWF0TXVsKGksITAsITEpfX0sYyl9KSxcIl9GdXNlZE1hdE11bFwiLHt0cmFuc3Bvc2VBOmEsdHJhbnNwb3NlQjpzLGFjdGl2YXRpb246bH0sRixbITBdKS5yZXNoYXBlKEEpfX0pLFVoPUFuKHtmdXNlZENvbnYyZF86ZnVuY3Rpb24odCl7dmFyIGU9dC54LG49dC5maWx0ZXIscj10LnN0cmlkZXMsbz10LnBhZCxhPXQuZGF0YUZvcm1hdCxpPXZvaWQgMD09PWE/XCJOSFdDXCI6YSxzPXQuZGlsYXRpb25zLHU9dm9pZCAwPT09cz9bMSwxXTpzLGM9dC5kaW1Sb3VuZGluZ01vZGUsbD10LmJpYXMsaD10LmFjdGl2YXRpb24sZj12b2lkIDA9PT1oP1wibGluZWFyXCI6aCxkPXQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cztpZihmPWZ8fFwibGluZWFyXCIsITE9PT1NaChMdC5zdGF0ZS5ncmFkaWVudERlcHRoLGYpKXt2YXIgcD1xYyhlLG4scixvLGksdSxjKTtyZXR1cm4gbnVsbCE9bCYmKHA9cmMocCxsKSksTGgocCxmLGQpfXZhciB2PW1uKGUsXCJ4XCIsXCJjb252MmRcIiksbT1tbihuLFwiZmlsdGVyXCIsXCJjb252MmRcIiksZz12LHk9ITE7Mz09PXYucmFuayYmKHk9ITAsZz12LmFzNEQoMSx2LnNoYXBlWzBdLHYuc2hhcGVbMV0sdi5zaGFwZVsyXSkpLEMoND09PWcucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIGNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitnLnJhbmsrXCIuXCJ9KSksQyg0PT09bS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgY29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIittLnJhbmsrXCIuXCJ9KSksbnVsbCE9YyYmQyhBKG8pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgY29udjJkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitjK1wiIGJ1dCBnb3QgcGFkIFwiK28rXCIuXCJ9KSksQyhnLnNoYXBlWzNdPT09bS5zaGFwZVsyXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZDogZGVwdGggb2YgaW5wdXQgKFwiK2cuc2hhcGVbM10rXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIittLnNoYXBlWzJdK1wiLlwifSkpLEMoTW8ocix1KSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyRDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrcitcIiBhbmQgZGlsYXRpb25zICdcIit1K1wiJ1wifSkpLEMoXCJOSFdDXCI9PT1pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBnb3QgZGF0YUZvcm1hdCBvZiBcIitpK1wiIGJ1dCBvbmx5IE5IV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cIn0pKTt2YXIgeCxiLHc9U28oZy5zaGFwZSxtLnNoYXBlLHIsdSxvLGMpO251bGwhPWwmJih4PU50KHg9bW4obCxcImJpYXNcIixcImZ1c2VkIGNvbnYyZFwiKSx2KVswXSxSbyh3Lm91dFNoYXBlLHguc2hhcGUpKSxudWxsIT1kJiYoYj1tbihkLFwicHJlbHUgd2VpZ2h0c1wiLFwiZnVzZWQgY29udjJkXCIpKTt2YXIgRT17eDpnLGZpbHRlcjptfTtudWxsIT1sJiYoRS5iaWFzPXgpLG51bGwhPWQmJihFLnByZWx1QWN0aXZhdGlvbldlaWdodHM9Yik7dmFyIFI9W20sZ10sST1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuZnVzZWRDb252MmQoe2lucHV0OmcsZmlsdGVyOm0sY29udkluZm86dyxiaWFzOngsYWN0aXZhdGlvbjpmLHByZWx1QWN0aXZhdGlvbldlaWdodHM6Yn0pO3JldHVybiBlKFttLGcsbl0pLG59KSxFLChmdW5jdGlvbih0LGUpe3ZhciBuPWUsYT1uWzBdLGk9blsxXSxzPW5bMl0sYz1CaCh0LHMsZik7QyhPbyh1KSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGdyYWRpZW50IG9mIGZ1c2VkIGNvbnYyRDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGluIGdyYWRpZW50cy4gR290IGRpbGF0aW9ucyAnXCIrdStcIidcIn0pKTt2YXIgaD17fTtyZXR1cm4gbnVsbCE9bCYmKGg9e2JpYXM6ZnVuY3Rpb24oKXtyZXR1cm4gUGgoeCxjKX19KSxPYmplY3QuYXNzaWduKHt4OmZ1bmN0aW9uKCl7cmV0dXJuIFhjKGkuc2hhcGUsYyxhLHIsbyl9LGZpbHRlcjpmdW5jdGlvbigpe3JldHVybiBqYyhpLGMsYS5zaGFwZSxyLG8pfX0saCl9KSxcIkZ1c2VkQ29udjJEXCIse2NvbnZJbmZvOncsYWN0aXZhdGlvbjpmfSxSLFshMF0pO3JldHVybiB5P0kuYXMzRChJLnNoYXBlWzFdLEkuc2hhcGVbMl0sSS5zaGFwZVszXSk6SX19KSxWaD1Bbih7ZnVzZWREZXB0aHdpc2VDb252MmRfOmZ1bmN0aW9uKHQpe3ZhciBlPXQueCxuPXQuZmlsdGVyLHI9dC5zdHJpZGVzLG89dC5wYWQsYT10LmRhdGFGb3JtYXQsaT12b2lkIDA9PT1hP1wiTkhXQ1wiOmEscz10LmRpbGF0aW9ucyx1PXZvaWQgMD09PXM/WzEsMV06cyxjPXQuZGltUm91bmRpbmdNb2RlLGw9dC5iaWFzLGg9dC5hY3RpdmF0aW9uLGY9dm9pZCAwPT09aD9cImxpbmVhclwiOmgsZD10LnByZWx1QWN0aXZhdGlvbldlaWdodHM7aWYoITE9PT1NaChMdC5zdGF0ZS5ncmFkaWVudERlcHRoLGYpKXt2YXIgcD1ZYyhlLG4scixvLGksdSxjKTtyZXR1cm4gbnVsbCE9bCYmKHA9cmMocCxsKSksTGgocCxmLGQpfXZhciB2PW1uKGUsXCJ4XCIsXCJkZXB0aHdpc2VDb252MmRcIiksbT1tbihuLFwiZmlsdGVyXCIsXCJkZXB0aHdpc2VDb252MmRcIiksZz12LHk9ITE7Mz09PXYucmFuayYmKHk9ITAsZz12LmFzNEQoMSx2LnNoYXBlWzBdLHYuc2hhcGVbMV0sdi5zaGFwZVsyXSkpLEMoND09PWcucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitnLnJhbmsrXCIuXCJ9KSksQyg0PT09bS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIittLnJhbmsrXCIuXCJ9KSksQyhnLnNoYXBlWzNdPT09bS5zaGFwZVsyXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogbnVtYmVyIG9mIGlucHV0IGNoYW5uZWxzIChcIitnLnNoYXBlWzNdK1wiKSBtdXN0IG1hdGNoIHRoZSBpbkNoYW5uZWxzIGRpbWVuc2lvbiBpbiBmaWx0ZXIgXCIrbS5zaGFwZVsyXStcIi5cIn0pKSxudWxsPT11JiYodT1bMSwxXSksQyhNbyhyLHUpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIityK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK3UrXCInXCJ9KSksbnVsbCE9YyYmQyhBKG8pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcgZGltUm91bmRpbmdNb2RlIFwiK2MrXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIn0pKTt2YXIgeCxiLHc9U28oZy5zaGFwZSxtLnNoYXBlLHIsdSxvLGMsITApO251bGwhPWwmJih4PU50KHg9bW4obCxcImJpYXNcIixcImZ1c2VkIGNvbnYyZFwiKSx2KVswXSxSbyh3Lm91dFNoYXBlLHguc2hhcGUpKSxudWxsIT1kJiYoYj1tbihkLFwicHJlbHUgd2VpZ2h0c1wiLFwiZnVzZWQgZGVwdGh3aXNlQ29udjJkXCIpKTt2YXIgRT17eDpnLGZpbHRlcjptfTtudWxsIT1sJiYoRS5iaWFzPXgpLG51bGwhPWQmJihFLnByZWx1QWN0aXZhdGlvbldlaWdodHM9Yik7dmFyIFI9W20sZ10sST1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuZnVzZWREZXB0aHdpc2VDb252MkQoe2lucHV0OmcsZmlsdGVyOm0sY29udkluZm86dyxiaWFzOngsYWN0aXZhdGlvbjpmLHByZWx1QWN0aXZhdGlvbldlaWdodHM6Yn0pO3JldHVybiBlKFttLGcsbl0pLG59KSxFLChmdW5jdGlvbih0LGUpe0MoT28odSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBncmFkaWVudCBvZiBmdXNlZCBkZXB0aHdpc2VDb252MmQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZC4gR290IGRpbGF0aW9ucyAnXCIrdStcIidcIn0pKTt2YXIgbj1lWzBdLHI9ZVsxXSxvPWVbMl0sYT1CaCh0LG8sZiksaT17fTtyZXR1cm4gbnVsbCE9bCYmKGk9e2JpYXM6ZnVuY3Rpb24oKXtyZXR1cm4gUGgoeCxhKX19KSxPYmplY3QuYXNzaWduKHt4OmZ1bmN0aW9uKCl7cmV0dXJuICRjKHIuc2hhcGUsYSxuLHcpfSxmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gUWMocixhLG4uc2hhcGUsdyl9fSxpKX0pLFwiRnVzZWREZXB0aHdpc2VDb252MkRcIix7Y29udkluZm86dyxhY3RpdmF0aW9uOmZ9LFIsWyEwXSk7cmV0dXJuIHk/SS5hczNEKEkuc2hhcGVbMV0sSS5zaGFwZVsyXSxJLnNoYXBlWzNdKTpJfX0pLHpoPU9iamVjdC5mcmVlemUoe21hdE11bDpXaCxjb252MmQ6VWgsZGVwdGh3aXNlQ29udjJkOlZofSksR2g9T2JqZWN0LmZyZWV6ZSh7aW1hZ2U6T2gsbGluYWxnOkloLGxvc3NlczpiaCxzcGVjdHJhbDpKbCxmdXNlZDp6aCxzaWduYWw6dWgsc3F1YXJlOnR1LHNxdWFyZWREaWZmZXJlbmNlOm51LGNvbnYxZDpIYyxjb252MmQ6cWMsY29udjNkOktjLGRlcHRod2lzZUNvbnYyZDpZYyxzZXBhcmFibGVDb252MmQ6SmMsY29udjJkVHJhbnNwb3NlOlpjLGNvbnYzZFRyYW5zcG9zZTp0bCxvcDpBbixiYXRjaE5vcm1hbGl6YXRpb24yZDpHdSxiYXRjaE5vcm1hbGl6YXRpb24zZDpIdSxiYXRjaE5vcm1hbGl6YXRpb240ZDpxdSxiYXRjaE5vcm1hbGl6YXRpb246S3UsYmF0Y2hOb3JtOmp1LGJhdGNoTm9ybTJkOlh1LGJhdGNoTm9ybTNkOll1LGJhdGNoTm9ybTRkOiR1LGJvb2xlYW5NYXNrQXN5bmM6VWMsY29tcGxleDpEbixyZWFsOlRuLGltYWc6Tm4sY29uY2F0OlluLGNvbmNhdDFkOiRuLGNvbmNhdDJkOlFuLGNvbmNhdDNkOkpuLGNvbmNhdDRkOlpuLHNwbGl0OnRyLG1hdE11bDplbCxkb3Q6bmwsb3V0ZXJQcm9kdWN0OnJsLHJldmVyc2U6b2wscmV2ZXJzZTFkOmFsLHJldmVyc2UyZDppbCxyZXZlcnNlM2Q6c2wscmV2ZXJzZTRkOnVsLG1heFBvb2w6aGwsYXZnUG9vbDpmbCxwb29sOmRsLG1heFBvb2wzZDpwbCxhdmdQb29sM2Q6dmwsc2xpY2U6bWwsc2xpY2UxZDpnbCxzbGljZTJkOnlsLHNsaWNlM2Q6eGwsc2xpY2U0ZDpibCxhYnM6cnUsYWNvczpvdSxhY29zaDphdSxhc2luOml1LGFzaW5oOnN1LGF0YW46dXUsYXRhbmg6Y3UsY2VpbDpsdSxjbGlwQnlWYWx1ZTpodSxjb3M6ZnUsY29zaDpkdSxlcmY6cHUsZXhwOnZ1LGV4cG0xOm11LGZsb29yOmd1LGxvZzp5dSxsb2cxcDp4dSxsb2dTaWdtb2lkOmJ1LG5lZzp3dSxyZWNpcHJvY2FsOkN1LHJvdW5kOkV1LHJzcXJ0OlJ1LHNpZ21vaWQ6SXUsc2lnbjprdSxpc05hTjpTdSxpc0luZjpBdSxpc0Zpbml0ZTpEdSxzaW46VHUsc2luaDpOdSxzb2Z0cGx1czpGdSxzcXJ0Ol91LHN0ZXA6T3UsdGFuOk11LHRhbmg6QnUsYWxsOkNsLGFueTpFbCxhcmdNYXg6UmwsYXJnTWluOklsLGxvZ1N1bUV4cDprbCxtYXg6U2wsbWVhbjpBbCxtaW46RGwsbW9tZW50czpUbCxzdW06TmwscHJvZDpGbCxlcXVhbDpSYyxlcXVhbFN0cmljdDpJYyxncmVhdGVyOmtjLGdyZWF0ZXJFcXVhbDpTYyxncmVhdGVyRXF1YWxTdHJpY3Q6QWMsZ3JlYXRlclN0cmljdDpEYyxsZXNzOlRjLGxlc3NFcXVhbDpOYyxsZXNzRXF1YWxTdHJpY3Q6RmMsbGVzc1N0cmljdDpfYyxub3RFcXVhbDpPYyxub3RFcXVhbFN0cmljdDpNYyxhZGQ6cmMsYWRkTjpvYyxhZGRTdHJpY3Q6YWMsYXRhbjI6aWMsZGl2OnNjLGRpdk5vTmFuOnVjLGRpdlN0cmljdDpjYyxmbG9vckRpdjpsYyxtYXhpbXVtOmhjLG1heGltdW1TdHJpY3Q6ZmMsbWluaW11bTpkYyxtaW5pbXVtU3RyaWN0OnBjLG1vZDp2Yyxtb2RTdHJpY3Q6bWMsbXVsOmdjLG11bFN0cmljdDp5Yyxwb3c6eGMscG93U3RyaWN0OmJjLHNxdWFyZWREaWZmZXJlbmNlU3RyaWN0OndjLHN1YjpDYyxzdWJTdHJpY3Q6RWMsZWx1Ol9sLGxlYWt5UmVsdTpPbCxwcmVsdTpNbCxyZWx1OkJsLHJlbHU2OlBsLHNlbHU6TGwsbG9naWNhbEFuZDpRdSxsb2dpY2FsTm90Okp1LGxvZ2ljYWxPcjpadSxsb2dpY2FsWG9yOnRjLHdoZXJlOmVjLHdoZXJlQXN5bmM6bmMsYnVmZmVyOmRyLHByaW50OnByLGJhdGNoVG9TcGFjZU5EOnZyLGJyb2FkY2FzdFRvOm1yLGNhc3Q6Z3IsY2xvbmU6eXIsY3Vtc3VtOnhyLGRlcHRoVG9TcGFjZTpicixleHBhbmREaW1zOndyLGV5ZTpDcixtdWx0aW5vbWlhbDpFcixvbmVIb3Q6UnIscGFkOklyLHBhZDFkOmtyLHBhZDJkOlNyLHBhZDNkOkFyLHBhZDRkOkRyLHJhbmQ6VHIscmFuZG9tTm9ybWFsOk5yLHJhbmRvbUdhbW1hOkZyLHJhbmRvbVVuaWZvcm06X3IscmVzaGFwZTpPcixzcGFjZVRvQmF0Y2hORDpNcixzcXVlZXplOkJyLHN0YWNrOlByLHRpbGU6THIsdHJ1bmNhdGVkTm9ybWFsOldyLHVuc3RhY2s6VXIsc2V0ZGlmZjFkQXN5bmM6VnIsZmlsbDpIbixsaW5zcGFjZTpxbixvbmVzOnpuLHJhbmdlOktuLHNjYWxhcjpPbix0ZW5zb3I6Rm4sdGVuc29yMWQ6TW4sdGVuc29yMmQ6Qm4sdGVuc29yM2Q6UG4sdGVuc29yNGQ6TG4sdGVuc29yNWQ6V24sdGVuc29yNmQ6VW4sdmFyaWFibGU6Vm4semVyb3M6R24sb25lc0xpa2U6am4semVyb3NMaWtlOlhuLHRyYW5zcG9zZTpXbCxzb2Z0bWF4OmdvLGxvZ1NvZnRtYXg6eW8sbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246VWwsbm9ybTpWbCxnYXRoZXI6TGMsdW5zb3J0ZWRTZWdtZW50U3VtOldjLGJhc2ljTFNUTUNlbGw6emwsbXVsdGlSTk5DZWxsOkdsLG1vdmluZ0F2ZXJhZ2U6SGwsc3RyaWRlZFNsaWNlOnFsLHRvcGs6S2wsc2NhdHRlck5EOmpsLGZmdDpYbCxpZmZ0OllsLHJmZnQ6JGwsaXJmZnQ6UWwsc3BhcnNlVG9EZW5zZTpabCxnYXRoZXJORDp0aCxkaWFnOmVoLGRyb3BvdXQ6bmgsaGFubldpbmRvdzpvaCxoYW1taW5nV2luZG93OmFoLGZyYW1lOmloLHN0ZnQ6c2gsaW5Ub3BLQXN5bmM6bGh9KTtmdW5jdGlvbiBIaCh0LGUpe0FycmF5LmlzQXJyYXkodCl8fCh0PVt0XSksdC5mb3JFYWNoKChmdW5jdGlvbih0KXtudWxsIT10JiZDKFwiY29tcGxleDY0XCIhPT10LmR0eXBlLChmdW5jdGlvbigpe3JldHVybiBlK1wiIGRvZXMgbm90IHN1cHBvcnQgY29tcGxleDY0IHRlbnNvcnMuXCJ9KSl9KSl9ZnVuY3Rpb24gcWgodCxlLG4scil7aWYoXCJsaW5lYXJcIj09PW4pcmV0dXJuIHQubGluZWFyKGUpO2lmKFwicmVsdVwiPT09bilyZXR1cm4gdC5yZWx1KGUpO2lmKFwiZWx1XCI9PT1uKXJldHVybiB0LmVsdShlKTtpZihcInJlbHU2XCI9PT1uKXJldHVybiB0LnJlbHU2KGUpO2lmKFwicHJlbHVcIj09PW4pcmV0dXJuIHQucHJlbHUoZSxyKTt0aHJvdyBuZXcgRXJyb3IoXCJBY3RpdmF0aW9uIFwiK24rXCIgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciB0aGUgQ1BVIGJhY2tlbmQuXCIpfXZhciBLaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKCl7dmFyIGU9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBlLmJsb2NrU2l6ZT00OCxlLmZpcnN0VXNlPSEwLGUuZGF0YT1uZXcgeG8oZSxMdCksZX1yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmZpcnN0VXNlJiYodGhpcy5maXJzdFVzZT0hMSxpKCkuZ2V0KFwiSVNfTk9ERVwiKSYmZG4oXCJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuSGkgdGhlcmUg8J+Riy4gTG9va3MgbGlrZSB5b3UgYXJlIHJ1bm5pbmcgVGVuc29yRmxvdy5qcyBpbiBOb2RlLmpzLiBUbyBzcGVlZCB0aGluZ3MgdXAgZHJhbWF0aWNhbGx5LCBpbnN0YWxsIG91ciBub2RlIGJhY2tlbmQsIHdoaWNoIGJpbmRzIHRvIFRlbnNvckZsb3cgQysrLCBieSBydW5uaW5nIG5wbSBpIEB0ZW5zb3JmbG93L3RmanMtbm9kZSwgb3IgbnBtIGkgQHRlbnNvcmZsb3cvdGZqcy1ub2RlLWdwdSBpZiB5b3UgaGF2ZSBDVURBLiBUaGVuIGNhbGwgcmVxdWlyZSgnQHRlbnNvcmZsb3cvdGZqcy1ub2RlJyk7ICgtZ3B1IHN1ZmZpeCBmb3IgQ1VEQSkgYXQgdGhlIHN0YXJ0IG9mIHlvdXIgcHJvZ3JhbS4gVmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy1ub2RlIGZvciBtb3JlIGRldGFpbHMuXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKSk7dmFyIHI9e307cmV0dXJuIHRoaXMuZGF0YS5zZXQocix7dmFsdWVzOnQsZHR5cGU6bn0pLHJ9LG8ucHJvdG90eXBlLm1vdmU9ZnVuY3Rpb24odCxlLG4scil7dGhpcy5kYXRhLnNldCh0LHt2YWx1ZXM6ZSxkdHlwZTpyfSl9LG8ucHJvdG90eXBlLm51bURhdGFJZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhLm51bURhdGFJZHMoKX0sby5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24oZSl7cmV0dXJuWzIsdGhpcy5yZWFkU3luYyh0KV19KSl9KSl9LG8ucHJvdG90eXBlLnJlYWRTeW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZGF0YS5nZXQodCksbj1lLmR0eXBlLHI9ZS5jb21wbGV4VGVuc29ycztyZXR1cm5cImNvbXBsZXg2NFwiPT09bj9Wbyh0aGlzLnJlYWRTeW5jKHIucmVhbC5kYXRhSWQpLHRoaXMucmVhZFN5bmMoci5pbWFnLmRhdGFJZCkpOnRoaXMuZGF0YS5nZXQodCkudmFsdWVzfSxvLnByb3RvdHlwZS5idWZmZXJTeW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49ZTtpZihcInN0cmluZ1wiPT09dC5kdHlwZSl0cnl7bj1lLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG90KHQpfSkpfWNhdGNoKHQpe3Rocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNvZGUgZW5jb2RlZCBzdHJpbmcgYnl0ZXMgaW50byB1dGYtOFwiKX1yZXR1cm4gZHIodC5zaGFwZSx0LmR0eXBlLG4pfSxvLnByb3RvdHlwZS5tYWtlT3V0cHV0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLndyaXRlKHQsZSxuKTtyZXR1cm4gTHQubWFrZVRlbnNvckZyb21EYXRhSWQocixlLG4sdGhpcyl9LG8ucHJvdG90eXBlLmRpc3Bvc2VEYXRhPWZ1bmN0aW9uKHQpe2lmKHRoaXMuZGF0YS5oYXModCkpe3ZhciBlPXRoaXMuZGF0YS5nZXQodCkuY29tcGxleFRlbnNvcnM7bnVsbCE9ZSYmKGUucmVhbC5kaXNwb3NlKCksZS5pbWFnLmRpc3Bvc2UoKSksdGhpcy5kYXRhLmRlbGV0ZSh0KX19LG8ucHJvdG90eXBlLnRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3JldHVybiBlPWV0KCksdCgpLFsyLHtrZXJuZWxNczpldCgpLWV9XX0pKX0pKX0sby5wcm90b3R5cGUubWVtb3J5PWZ1bmN0aW9uKCl7cmV0dXJue3VucmVsaWFibGU6ITAscmVhc29uczpbXCJUaGUgcmVwb3J0ZWQgbWVtb3J5IGlzIGFuIHVwcGVyIGJvdW5kLiBEdWUgdG8gYXV0b21hdGljIGdhcmJhZ2UgY29sbGVjdGlvbiwgdGhlIHRydWUgYWxsb2NhdGVkIG1lbW9yeSBtYXkgYmUgbGVzcy5cIl19fSxvLnByb3RvdHlwZS5jb21wbGV4PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5tYWtlT3V0cHV0KG51bGwsdC5zaGFwZSxcImNvbXBsZXg2NFwiKTtyZXR1cm4gdGhpcy5kYXRhLmdldChuLmRhdGFJZCkuY29tcGxleFRlbnNvcnM9e3JlYWw6THQua2VlcCh0LmNsb25lKCkpLGltYWc6THQua2VlcChlLmNsb25lKCkpfSxufSxvLnByb3RvdHlwZS5yZWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5yZWFsLmNsb25lKCl9LG8ucHJvdG90eXBlLmltYWc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YS5nZXQodC5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLmltYWcuY2xvbmUoKX0sby5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24odCxlLG4pe2lmKEhoKHQsXCJzbGljZVwiKSxpbyh0LnNoYXBlLGUsbikpe3ZhciByPXNvKGUsdC5zdHJpZGVzKSxvPWsobik7cmV0dXJuIEZuKHRoaXMucmVhZFN5bmModC5kYXRhSWQpLnN1YmFycmF5KHIscitvKSxuLHQuZHR5cGUpfWZvcih2YXIgYT1kcihuLHQuZHR5cGUpLGk9dGhpcy5idWZmZXJTeW5jKHQpLHM9MDtzPGEuc2l6ZTsrK3Mpe3ZhciB1PWEuaW5kZXhUb0xvYyhzKS5tYXAoKGZ1bmN0aW9uKHQsbil7cmV0dXJuIHQrZVtuXX0pKTthLnZhbHVlc1tzXT1pLmdldC5hcHBseShpLHUpfXJldHVybiBhLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLnN0cmlkZWRTbGljZT1mdW5jdGlvbih0LGUsbixyKXtIaCh0LFwic3RyaWRlZFNsaWNlXCIpO3ZhciBvPXJvKGUsbixyKTtpZihvLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiAwPT09dH0pKSlyZXR1cm4gRm4oW10sbyk7Zm9yKHZhciBhPWRyKG8sdC5kdHlwZSksaT10aGlzLmJ1ZmZlclN5bmModCkscz0wO3M8YS5zaXplO3MrKyl7Zm9yKHZhciB1PWEuaW5kZXhUb0xvYyhzKSxjPW5ldyBBcnJheSh1Lmxlbmd0aCksbD0wO2w8Yy5sZW5ndGg7bCsrKWNbbF09dVtsXSpyW2xdK2VbbF07YS5zZXQuYXBwbHkoYSxbaS5nZXQuYXBwbHkoaSxjKV0uY29uY2F0KHUpKX1yZXR1cm4gYS50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5kaWFnPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPWRyKFt0LnNpemUsdC5zaXplXSx0LmR0eXBlKSxyPW4udmFsdWVzLG89MDtvPGUubGVuZ3RoO28rKylyW28qdC5zaXplK29dPWVbb107cmV0dXJuIG4udG9UZW5zb3IoKX0sby5wcm90b3R5cGUudW5zdGFjaz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LnNoYXBlW2VdLHI9bmV3IEFycmF5KHQucmFuay0xKSxvPTAsYT0wO2E8dC5yYW5rO2ErKylhIT09ZSYmKHJbbysrXT10LnNoYXBlW2FdKTt2YXIgaT1uZXcgQXJyYXkodC5yYW5rKS5maWxsKDApLHM9dC5zaGFwZS5zbGljZSgpO3NbZV09MTt2YXIgdT1uZXcgQXJyYXkobik7Zm9yKGE9MDthPHUubGVuZ3RoO2ErKylpW2VdPWEsdVthXT10aGlzLnNsaWNlKHQsaSxzKS5yZXNoYXBlKHIpO3JldHVybiB1fSxvLnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKHQsZSl7SGgodCxcInJldmVyc2VcIik7Zm9yKHZhciBuPWRyKHQuc2hhcGUsdC5kdHlwZSkscj10aGlzLmJ1ZmZlclN5bmModCksbz1mdW5jdGlvbihvKXt2YXIgYT1uLmluZGV4VG9Mb2MobyksaT1hLnNsaWNlKCk7ZS5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gaVtlXT10LnNoYXBlW2VdLTEtaVtlXX0pKSxuLnNldC5hcHBseShuLFtyLmdldC5hcHBseShyLGkpXS5jb25jYXQoYSkpfSxhPTA7YTxuLnNpemU7YSsrKW8oYSk7cmV0dXJuIG4udG9UZW5zb3IoKX0sby5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztpZihcImNvbXBsZXg2NFwiPT09dFswXS5kdHlwZSl7dmFyIHI9dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBUbih0KX0pKSxvPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gTm4odCl9KSk7cmV0dXJuIERuKHRoaXMuY29uY2F0KHIsZSksdGhpcy5jb25jYXQobyxlKSl9dmFyIGE9dC5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBuPWsodC5zaGFwZS5zbGljZShlKSk7cmV0dXJuIHQuYXMyRCgtMSxuKX0pKSxpPVNuKGEubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pKSwxKSxzPWRyKGksdFswXS5kdHlwZSkudmFsdWVzO2lmKDE9PT1hWzBdLnNoYXBlWzBdKXt2YXIgdT0wO2EuZm9yRWFjaCgoZnVuY3Rpb24odCl7cy5zZXQobi5yZWFkU3luYyh0LmRhdGFJZCksdSksdSs9dC5zaXplfSkpfWVsc2V7dmFyIGM9MDthLmZvckVhY2goKGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTAsbz0wO288dC5zaGFwZVswXTsrK28pZm9yKHZhciBhPW8qaVsxXStjLHU9MDt1PHQuc2hhcGVbMV07Kyt1KXNbYSt1XT1lW3IrK107Yys9dC5zaGFwZVsxXX0pKX12YXIgbD1Tbih0Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSksZSk7cmV0dXJuIEZuKHMsbCx0WzBdLmR0eXBlKX0sby5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKHQpe3JldHVybiBIaCh0LFwibmVnXCIpLHRoaXMubXVsdGlwbHkoT24oLTEpLHQpfSxvLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCxlKXtyZXR1cm5cImNvbXBsZXg2NFwiPT09dC5kdHlwZXx8XCJjb21wbGV4NjRcIj09PWUuZHR5cGU/dGhpcy5icm9hZGNhc3RlZEJpbmFyeUNvbXBsZXhPcCh0LmNhc3QoXCJjb21wbGV4NjRcIiksZS5jYXN0KFwiY29tcGxleDY0XCIpLChmdW5jdGlvbih0LGUsbixyKXtyZXR1cm57cmVhbDp0K24saW1hZzplK3J9fSkpOnRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsRHQodC5kdHlwZSxlLmR0eXBlKSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlfSkpfSxvLnByb3RvdHlwZS5hZGROPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7SGgodCxcImFkZE5cIik7Zm9yKHZhciBuPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZS5yZWFkU3luYyh0LmRhdGFJZCl9KSkscj1kcih0WzBdLnNoYXBlLHRbMF0uZHR5cGUpLG89ci52YWx1ZXMsYT0wO2E8dC5sZW5ndGg7YSsrKWZvcih2YXIgaT1uW2FdLHM9MDtzPG8ubGVuZ3RoO3MrKylvW3NdKz1pW3NdO3JldHVybiByLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLnNvZnRtYXg9ZnVuY3Rpb24odCxlKXt2YXIgbj1PKFtlXSx0LnNoYXBlKSxyPXRoaXMubWF4KHQsbiksbz13bihyLnNoYXBlLG4pLGE9dGhpcy5zdWJ0cmFjdCh0LHIucmVzaGFwZShvKSksaT10aGlzLmV4cChhKSxzPXRoaXMuc3VtKGksbikucmVzaGFwZShvKTtyZXR1cm4gdGhpcy5yZWFsRGl2aWRlKGkscyl9LG8ucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJjb21wbGV4NjRcIj09PXQuZHR5cGV8fFwiY29tcGxleDY0XCI9PT1lLmR0eXBlP3RoaXMuYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3AodC5jYXN0KFwiY29tcGxleDY0XCIpLGUuY2FzdChcImNvbXBsZXg2NFwiKSwoZnVuY3Rpb24odCxlLG4scil7cmV0dXJue3JlYWw6dC1uLGltYWc6ZS1yfX0pKTp0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLER0KHQuZHR5cGUsZS5kdHlwZSksKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQtZX0pKX0sby5wcm90b3R5cGUucG93PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwicG93XCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5wb3codCxlKX0pKX0sby5wcm90b3R5cGUuYmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCxlLG4scil7SGgoW3QsZV0sXCJtYXRNdWxcIik7Zm9yKHZhciBvPW4/dC5zaGFwZVsxXTp0LnNoYXBlWzJdLGE9bj90LnNoYXBlWzJdOnQuc2hhcGVbMV0saT1yP2Uuc2hhcGVbMV06ZS5zaGFwZVsyXSxzPXQuc2hhcGVbMF0sdT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxjPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLGw9bj9bdC5zdHJpZGVzWzBdLDEsdC5zdHJpZGVzWzFdXTpbdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXSwxXSxoPWxbMF0sZj1sWzFdLGQ9bFsyXSxwPXI/WzEsZS5zdHJpZGVzWzFdLGUuc3RyaWRlc1swXV06W2Uuc3RyaWRlc1sxXSwxLGUuc3RyaWRlc1swXV0sdj1wWzBdLG09cFsxXSxnPXBbMl0seT1hKmkseD1kcihbcyxhLGldLHQuZHR5cGUpLGI9eC52YWx1ZXMsdz10aGlzLmJsb2NrU2l6ZSxDPTA7QzxzO0MrKylmb3IodmFyIEU9MDtFPGE7RSs9dylmb3IodmFyIFI9MDtSPGk7Uis9dylmb3IodmFyIEk9MDtJPG87SSs9dylmb3IodmFyIGs9TWF0aC5taW4oRSt3LGEpLFM9TWF0aC5taW4oUit3LGkpLEE9TWF0aC5taW4oSSt3LG8pLEQ9RTtEPGs7RCsrKWZvcih2YXIgVD1SO1Q8UztUKyspe2Zvcih2YXIgTj0wLEY9STtGPEE7RisrKU4rPXVbQypoK0QqZitGKmRdKmNbRip2K1QqbStDKmddO2JbQyp5KyhEKmkrVCldKz1OfXJldHVybiB4LnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmZ1c2VkQmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCl7dmFyIGU9dC5hLG49dC5iLHI9dC50cmFuc3Bvc2VBLG89dC50cmFuc3Bvc2VCLGE9dC5iaWFzLGk9dC5hY3RpdmF0aW9uLHM9dC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzLHU9dGhpcy5iYXRjaE1hdE11bChlLG4scixvKTtyZXR1cm4gYSYmKHU9dGhpcy5hZGQodSxhKSksaSYmKHU9cWgodGhpcyx1LGkscykpLHV9LG8ucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJjb21wbGV4NjRcIj09PXQuZHR5cGV8fFwiY29tcGxleDY0XCI9PT1lLmR0eXBlP3RoaXMuYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3AodC5jYXN0KFwiY29tcGxleDY0XCIpLGUuY2FzdChcImNvbXBsZXg2NFwiKSwoZnVuY3Rpb24odCxlLG4scil7cmV0dXJue3JlYWw6dCpuLWUqcixpbWFnOnQqcitlKm59fSkpOnRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsRHQodC5kdHlwZSxlLmR0eXBlKSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkpfSxvLnByb3RvdHlwZS5yZWFsRGl2aWRlPWZ1bmN0aW9uKHQsZSl7SGgoW3QsZV0sXCJyZWFsRGl2aWRlXCIpO3JldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiZmxvYXQzMlwiLChmdW5jdGlvbih0LGUpe3JldHVybiB0L2V9KSl9LG8ucHJvdG90eXBlLmZsb29yRGl2PWZ1bmN0aW9uKHQsZSl7SGgoW3QsZV0sXCJmbG9vckRpdlwiKTtyZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImludDMyXCIsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1hdGguZmxvb3IodC9lKX0pKX0sby5wcm90b3R5cGUuc3VtPWZ1bmN0aW9uKHQsZSl7SGgodCxcInN1bVwiKSxDbihcInN1bVwiLGUsdC5yYW5rKTtmb3IodmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1uWzFdLGE9R24ocixEdCh0LmR0eXBlLFwiaW50MzJcIikpLGk9ayhvKSxzPXRoaXMucmVhZFN5bmMoYS5kYXRhSWQpLHU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYz0wO2M8cy5sZW5ndGg7KytjKXtmb3IodmFyIGw9YyppLGg9MCxmPTA7ZjxpOysrZiloKz11W2wrZl07c1tjXT1ofXJldHVybiBhfSxvLnByb3RvdHlwZS5wcm9kPWZ1bmN0aW9uKHQsZSl7SGgodCxcInN1bVwiKTtmb3IodmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1uWzFdLGE9R24ocixEdCh0LmR0eXBlLFwiaW50MzJcIikpLGk9ayhvKSxzPXRoaXMucmVhZFN5bmMoYS5kYXRhSWQpLHU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYz0wO2M8cy5sZW5ndGg7KytjKXtmb3IodmFyIGw9YyppLGg9MSxmPTA7ZjxpOysrZiloKj11W2wrZl07c1tjXT1ofXJldHVybiBhfSxvLnByb3RvdHlwZS51bnNvcnRlZFNlZ21lbnRTdW09ZnVuY3Rpb24odCxlLG4pe0hoKHQsXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIik7Zm9yKHZhciByPVtdLG89dC5yYW5rLWUucmFuayxhPTA7YTxvOysrYSllPWUuZXhwYW5kRGltcyhhKzEpO2ZvcihhPTA7YTxuOysrYSl7dmFyIGk9T24oYSxcImludDMyXCIpLHM9UmMoaSxlKS5hc1R5cGUoXCJmbG9hdDMyXCIpLm11bCh0KS5zdW0oMCk7ci5wdXNoKHMpfXJldHVybiBQcihyKX0sby5wcm90b3R5cGUuYXJnTWluPWZ1bmN0aW9uKHQsZSl7SGgodCxcImFyZ01pblwiKTt2YXIgbj1bZV07Q24oXCJhcmdNaW5cIixuLHQucmFuayk7Zm9yKHZhciByPWJuKHQuc2hhcGUsbiksbz1yWzBdLGE9clsxXSxpPUduKG8sXCJpbnQzMlwiKSxzPWsoYSksdT10aGlzLnJlYWRTeW5jKGkuZGF0YUlkKSxjPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGw9MDtsPHUubGVuZ3RoOysrbCl7Zm9yKHZhciBoPWwqcyxmPWNbaF0sZD0wLHA9MDtwPHM7KytwKXt2YXIgdj1jW2grcF07djxmJiYoZj12LGQ9cCl9dVtsXT1kfXJldHVybiBpfSxvLnByb3RvdHlwZS5hcmdNYXg9ZnVuY3Rpb24odCxlKXtIaCh0LFwiYXJnTWF4XCIpO3ZhciBuPVtlXTtDbihcImFyZ01heFwiLG4sdC5yYW5rKTtmb3IodmFyIHI9Ym4odC5zaGFwZSxuKSxvPXJbMF0sYT1yWzFdLGk9R24obyxcImludDMyXCIpLHM9ayhhKSx1PXRoaXMucmVhZFN5bmMoaS5kYXRhSWQpLGM9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbD0wO2w8dS5sZW5ndGg7KytsKXtmb3IodmFyIGg9bCpzLGY9Y1toXSxkPTAscD0wO3A8czsrK3Ape3ZhciB2PWNbaCtwXTt2PmYmJihmPXYsZD1wKX11W2xdPWR9cmV0dXJuIGl9LG8ucHJvdG90eXBlLmN1bXN1bT1mdW5jdGlvbih0LGUsbixyKXtpZihIaCh0LFwiY3Vtc3VtXCIpLGUhPT10LnJhbmstMSl0aHJvdyBuZXcgRXJyb3IoXCJiYWNrZW5kLmN1bXN1bSBpbiBDUFUgZXhwZWN0cyBhbiBpbm5lci1tb3N0IGF4aXM9XCIrKHQucmFuay0xKStcIiBidXQgZ290IGF4aXM9XCIrZSk7Zm9yKHZhciBvPUR0KHQuZHR5cGUsXCJpbnQzMlwiKSxhPUduKHQuc2hhcGUsbyksaT10aGlzLnJlYWRTeW5jKGEuZGF0YUlkKSxzPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHU9dC5zaGFwZVt0LnJhbmstMV0sYz1yP2Z1bmN0aW9uKHQsZSl7cmV0dXJuIHQrdS1lLTF9OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZX0sbD0wO2w8cy5sZW5ndGg7bCs9dSlmb3IodmFyIGg9MDtoPHU7aCsrKXt2YXIgZj1jKGwsaCk7aWYoMD09PWgpaVtmXT1uPzA6c1tmXTtlbHNle3ZhciBkPWMobCxoLTEpO2lbZl09bj9zW2RdK2lbZF06c1tmXStpW2RdfX1yZXR1cm4gYX0sby5wcm90b3R5cGUuZXF1YWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJlcXVhbFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLChmdW5jdGlvbih0LGUpe3JldHVybiB0PT09ZT8xOjB9KSl9LG8ucHJvdG90eXBlLm5vdEVxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwibm90RXF1YWxcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCE9PWU/MTowfSkpfSxvLnByb3RvdHlwZS5sZXNzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwibGVzc1wiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLChmdW5jdGlvbih0LGUpe3JldHVybiB0PGU/MTowfSkpfSxvLnByb3RvdHlwZS5sZXNzRXF1YWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJsZXNzRXF1YWxcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdDw9ZT8xOjB9KSl9LG8ucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJncmVhdGVyXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+ZT8xOjB9KSl9LG8ucHJvdG90eXBlLmdyZWF0ZXJFcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcImdyZWF0ZXJFcXVhbFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLChmdW5jdGlvbih0LGUpe3JldHVybiB0Pj1lPzE6MH0pKX0sby5wcm90b3R5cGUubG9naWNhbE5vdD1mdW5jdGlvbih0KXtIaCh0LFwibG9naWNhbE5vdFwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgVWludDhBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKW5bcl09ZVtyXT8wOjE7cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJib29sXCIpfSxvLnByb3RvdHlwZS5sb2dpY2FsQW5kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwibG9naWNhbEFuZFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLChmdW5jdGlvbih0LGUpe3JldHVybiB0JiZlfSkpfSxvLnByb3RvdHlwZS5sb2dpY2FsT3I9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJsb2dpY2FsT3JcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdHx8ZX0pKX0sby5wcm90b3R5cGUuc2VsZWN0PWZ1bmN0aW9uKHQsZSxuKXtIaChbdCxlLG5dLFwic2VsZWN0XCIpO2Zvcih2YXIgcj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxvPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLGE9dGhpcy5yZWFkU3luYyhuLmRhdGFJZCksaT1HbihlLnNoYXBlLER0KGUuZHR5cGUsbi5kdHlwZSkpLHM9dGhpcy5yZWFkU3luYyhpLmRhdGFJZCksdT0wLGM9MD09PXQucmFua3x8dC5yYW5rPjF8fDE9PT1lLnJhbms/MTprKGUuc2hhcGUuc2xpY2UoMSkpLGw9MDtsPHIubGVuZ3RoO2wrKylmb3IodmFyIGg9MDtoPGM7aCsrKTE9PT1yW2xdP3NbdSsrXT1vW2xdOnNbdSsrXT1hW2xdO3JldHVybiBpfSxvLnByb3RvdHlwZS53aGVyZT1mdW5jdGlvbih0KXtIaChbdF0sXCJ3aGVyZVwiKTt2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKTtyZXR1cm4gbmEodC5zaGFwZSxlKX0sby5wcm90b3R5cGUudG9waz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIEhoKHQsXCJ0b3BrXCIpLGVhKHRoaXMucmVhZFN5bmModC5kYXRhSWQpLHQuc2hhcGUsdC5kdHlwZSxlKX0sby5wcm90b3R5cGUubWluPWZ1bmN0aW9uKHQsZSl7SGgodCxcIm1pblwiKSxDbihcIm1pblwiLGUsdC5yYW5rKTtmb3IodmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1uWzFdLGE9R24ocix0LmR0eXBlKSxpPWsobykscz10aGlzLnJlYWRTeW5jKGEuZGF0YUlkKSx1PXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGM9MDtjPHMubGVuZ3RoOysrYyl7Zm9yKHZhciBsPWMqaSxoPXVbbF0sZj0wO2Y8aTsrK2Ype3ZhciBkPXVbbCtmXTtkPGgmJihoPWQpfXNbY109aH1yZXR1cm4gYX0sby5wcm90b3R5cGUubWluaW11bT1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcIm1pbmltdW1cIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLChmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLm1pbih0LGUpfSkpfSxvLnByb3RvdHlwZS5tb2Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJtb2RcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLChmdW5jdGlvbih0LGUpe3ZhciBuPXQlZTtyZXR1cm4gdDwwJiZlPDB8fHQ+PTAmJmU+PTA/bjoobitlKSVlfSkpfSxvLnByb3RvdHlwZS5tYXg9ZnVuY3Rpb24odCxlKXtIaCh0LFwibWF4XCIpLENuKFwibWF4XCIsZSx0LnJhbmspO2Zvcih2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPW5bMV0sYT1HbihyLHQuZHR5cGUpLGk9ayhvKSxzPXRoaXMucmVhZFN5bmMoYS5kYXRhSWQpLHU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYz0wO2M8cy5sZW5ndGg7KytjKXtmb3IodmFyIGw9YyppLGg9dVtsXSxmPTA7ZjxpOysrZil7dmFyIGQ9dVtsK2ZdO2Q+aCYmKGg9ZCl9c1tjXT1ofXJldHVybiBhfSxvLnByb3RvdHlwZS5tYXhpbXVtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwibWF4aW11bVwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1hdGgubWF4KHQsZSl9KSl9LG8ucHJvdG90eXBlLmFsbD1mdW5jdGlvbih0LGUpe0hoKHQsXCJhbGxcIiksQ24oXCJhbGxcIixlLHQucmFuayk7Zm9yKHZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPUduKHIsdC5kdHlwZSksaT1rKG8pLHM9dGhpcy5yZWFkU3luYyhhLmRhdGFJZCksdT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxjPTA7YzxzLmxlbmd0aDsrK2Mpe2Zvcih2YXIgbD1jKmksaD11W2xdLGY9MDtmPGk7KytmKXt2YXIgZD11W2wrZl07aD1oJiZkfXNbY109aH1yZXR1cm4gYX0sby5wcm90b3R5cGUuYW55PWZ1bmN0aW9uKHQsZSl7SGgodCxcImFueVwiKSxDbihcImFueVwiLGUsdC5yYW5rKTtmb3IodmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1uWzFdLGE9R24ocix0LmR0eXBlKSxpPWsobykscz10aGlzLnJlYWRTeW5jKGEuZGF0YUlkKSx1PXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGM9MDtjPHMubGVuZ3RoOysrYyl7Zm9yKHZhciBsPWMqaSxoPXVbbF0sZj0wO2Y8aTsrK2Ype3ZhciBkPXVbbCtmXTtoPWh8fGR9c1tjXT1ofXJldHVybiBhfSxvLnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcInNxdWFyZWREaWZmZXJlbmNlXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSwoZnVuY3Rpb24odCxlKXt2YXIgbj10LWU7cmV0dXJuIG4qbn0pKX0sby5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbih0KXtIaCh0LFwiY2VpbFwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpbltyXT1NYXRoLmNlaWwoZVtyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbih0KXtIaCh0LFwiZmxvb3JcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKW5bcl09TWF0aC5mbG9vcihlW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24odCl7SGgodCxcInhcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKWVbcl08MD9uW3JdPS0xOmVbcl0+MD9uW3JdPTE6bltyXT0wO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuaXNOYU49ZnVuY3Rpb24odCl7SGgodCxcInhcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcilOdW1iZXIuaXNOYU4oZVtyXSkmJihuW3JdPTEpO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiYm9vbFwiKX0sby5wcm90b3R5cGUuaXNJbmY9ZnVuY3Rpb24odCl7SGgodCxcInhcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcilNYXRoLmFicyhlW3JdKT09PTEvMCYmKG5bcl09MSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJib29sXCIpfSxvLnByb3RvdHlwZS5pc0Zpbml0ZT1mdW5jdGlvbih0KXtIaCh0LFwieFwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgVWludDhBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKU51bWJlci5pc0Zpbml0ZShlW3JdKSYmKG5bcl09MSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJib29sXCIpfSxvLnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbih0KXtIaCh0LFwicm91bmRcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbz1NYXRoLmZsb29yKGVbcl0pO2Vbcl0tbzwuNT9uW3JdPU1hdGguZmxvb3IoZVtyXSk6ZVtyXS1vPi41P25bcl09TWF0aC5jZWlsKGVbcl0pOm5bcl09byUyPT0wP286bysxfXJldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKHQpe0hoKHQsXCJleHBcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKW5bcl09TWF0aC5leHAoZVtyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5leHBtMT1mdW5jdGlvbih0KXtIaCh0LFwiZXhwbTFcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKW5bcl09TWF0aC5leHBtMShlW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmxvZz1mdW5jdGlvbih0KXtIaCh0LFwibG9nXCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcil7dmFyIG89ZVtyXTtuW3JdPU1hdGgubG9nKG8pfXJldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24odCl7SGgodCxcImxvZzFwXCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcil7dmFyIG89ZVtyXTtuW3JdPU1hdGgubG9nMXAobyl9cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKHQpe0hoKHQsXCJzcXJ0XCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcil7dmFyIG89ZVtyXTtuW3JdPU1hdGguc3FydChvKX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLnJzcXJ0PWZ1bmN0aW9uKHQpe0hoKHQsXCJyc3FydFwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBvPWVbcl07bltyXT0xL01hdGguc3FydChvKX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLnJlY2lwcm9jYWw9ZnVuY3Rpb24odCl7SGgodCxcInJlY2lwcm9jYWxcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKW5bcl09MS9lW3JdO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUubGluZWFyPWZ1bmN0aW9uKHQpe3JldHVybiB0fSxvLnByb3RvdHlwZS5yZWx1PWZ1bmN0aW9uKHQpe0hoKHQsXCJyZWx1XCIpO2Zvcih2YXIgZT1Hbih0LnNoYXBlLHQuZHR5cGUpLG49dGhpcy5yZWFkU3luYyhlLmRhdGFJZCkscj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxvPTA7bzxyLmxlbmd0aDsrK28pbltvXT1NYXRoLm1heCgwLHJbb10pO3JldHVybiBlfSxvLnByb3RvdHlwZS5yZWx1Nj1mdW5jdGlvbih0KXtIaCh0LFwicmVsdVwiKTtmb3IodmFyIGU9R24odC5zaGFwZSx0LmR0eXBlKSxuPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLHI9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbz0wO288ci5sZW5ndGg7KytvKW5bb109TWF0aC5taW4oTWF0aC5tYXgoMCxyW29dKSw2KTtyZXR1cm4gZX0sby5wcm90b3R5cGUucHJlbHU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJwcmVsdVwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ8MD9lKnQ6dH0pKX0sby5wcm90b3R5cGUuZWx1PWZ1bmN0aW9uKHQpe0hoKHQsXCJlbHVcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcil7dmFyIG89bltyXTtlW3JdPW8+PTA/bzpNYXRoLmV4cChvKS0xfXJldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuZWx1RGVyPWZ1bmN0aW9uKHQsZSl7SGgoW3QsZV0sXCJlbHVEZXJcIik7Zm9yKHZhciBuPW5ldyBGbG9hdDMyQXJyYXkoZS5zaXplKSxyPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLG89dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYT0wO2E8ci5sZW5ndGg7KythKXt2YXIgaT1yW2FdO25bYV09aT49MT9vW2FdOm9bYV0qKGkrMSl9cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLGUuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5zZWx1PWZ1bmN0aW9uKHQpe0hoKHQsXCJzZWx1XCIpO2Zvcih2YXIgZT1icyxuPXdzLHI9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG89dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYT0wO2E8by5sZW5ndGg7KythKXt2YXIgaT1vW2FdO3JbYV09aT49MD9uKmk6ZSooTWF0aC5leHAoaSktMSl9cmV0dXJuIHRoaXMubWFrZU91dHB1dChyLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5jbGlwPWZ1bmN0aW9uKHQsZSxuKXtIaCh0LFwiY2xpcFwiKTtmb3IodmFyIHI9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG89dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYT0wO2E8by5sZW5ndGg7KythKXt2YXIgaT1vW2FdO3JbYV09aT5uP246aTxlP2U6aX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KHIsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmFicz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5hYnMobltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5jb21wbGV4QWJzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjx0LnNpemU7KytyKXt2YXIgbz1uWzIqcl0sYT1uWzIqcisxXTtlW3JdPU1hdGguaHlwb3QobyxhKX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmludD1mdW5jdGlvbih0KXtIaCh0LFwiaW50XCIpO2Zvcih2YXIgZT1uZXcgSW50MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09bltyXTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImludDMyXCIpfSxvLnByb3RvdHlwZS5zaWdtb2lkPWZ1bmN0aW9uKHQpe0hoKHQsXCJzaWdtb2lkXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT0xLygxK01hdGguZXhwKC1uW3JdKSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5zb2Z0cGx1cz1mdW5jdGlvbih0KXtIaCh0LFwic29mdHBsdXNcIik7Zm9yKHZhciBlPU1hdGgubG9nKDEuMTkyMDkyODk1NTA3ODEyNWUtNykrMixuPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxyPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG89MDtvPHIubGVuZ3RoOysrbyl7dmFyIGE9cltvXT4tZSxpPXJbb108ZSxzPU1hdGguZXhwKHJbb10pLHU9dm9pZCAwO3U9aT9zOmE/cltvXTpNYXRoLmxvZygxK3MpLG5bb109dX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLnNpbj1mdW5jdGlvbih0KXtIaCh0LFwic2luXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLnNpbihuW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmNvcz1mdW5jdGlvbih0KXtIaCh0LFwiY29zXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmNvcyhuW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLnRhbj1mdW5jdGlvbih0KXtIaCh0LFwidGFuXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLnRhbihuW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24odCl7SGgodCxcImFzaW5cIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYXNpbihuW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmFjb3M9ZnVuY3Rpb24odCl7SGgodCxcImFjb3NcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYWNvcyhuW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmF0YW49ZnVuY3Rpb24odCl7SGgodCxcImF0YW5cIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYXRhbihuW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmF0YW4yPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwiYXRhbjJcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLChmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLmF0YW4yKHQsZSl9KSl9LG8ucHJvdG90eXBlLnNpbmg9ZnVuY3Rpb24odCl7SGgodCxcInNpbmhcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguc2luaChuW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24odCl7SGgodCxcImNvc2hcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguY29zaChuW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24odCl7SGgodCxcInRhbmhcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPUQobltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hc2luaD1mdW5jdGlvbih0KXtIaCh0LFwiYXNpbmhcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYXNpbmgobltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hY29zaD1mdW5jdGlvbih0KXtIaCh0LFwiYWNvc2hcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYWNvc2gobltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbih0KXtIaCh0LFwiYXRhbmhcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYXRhbmgobltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5lcmY9ZnVuY3Rpb24odCl7SGgodCxcImVyZlwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKXt2YXIgbz1NYXRoLnNpZ24obltyXSksYT1NYXRoLmFicyhuW3JdKSxpPTEvKDErLjMyNzU5MTEqYSk7ZVtyXT1vKigxLSgoKCgxLjA2MTQwNTQyOSppLTEuNDUzMTUyMDI3KSppKzEuNDIxNDEzNzQxKSppLS4yODQ0OTY3MzYpKmkrLjI1NDgyOTU5MikqaSpNYXRoLmV4cCgtYSphKSl9cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5zdGVwPWZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCksSGgodCxcInN0ZXBcIik7Zm9yKHZhciBuPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxyPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG89MDtvPHIubGVuZ3RoOysrbyl7dmFyIGE9cltvXTtpc05hTihhKT9uW29dPU5hTjpuW29dPWE+MD8xOmV9cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5mdXNlZENvbnYyZD1mdW5jdGlvbih0KXt2YXIgZT10LmlucHV0LG49dC5maWx0ZXIscj10LmNvbnZJbmZvLG89dC5iaWFzLGE9dC5hY3RpdmF0aW9uLGk9dC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzLHM9dGhpcy5jb252MmQoZSxuLHIpO3JldHVybiBvJiYocz10aGlzLmFkZChzLG8pKSxhJiYocz1xaCh0aGlzLHMsYSxpKSksc30sby5wcm90b3R5cGUuY29udjJkPWZ1bmN0aW9uKHQsZSxuKXtIaChbdCxlXSxcImNvbnYyZFwiKTtmb3IodmFyIHI9bi5maWx0ZXJIZWlnaHQsbz1uLmZpbHRlcldpZHRoLGE9bi5kaWxhdGlvbkhlaWdodCxpPW4uZGlsYXRpb25XaWR0aCxzPW4ucGFkSW5mby5sZWZ0LHU9bi5wYWRJbmZvLnRvcCxjPVwiY2hhbm5lbHNMYXN0XCI9PT1uLmRhdGFGb3JtYXQsbD1kcihuLm91dFNoYXBlLHQuZHR5cGUpLGg9dC5zdHJpZGVzWzBdLGY9Yz90LnN0cmlkZXNbMV06dC5zdHJpZGVzWzJdLGQ9Yz90LnN0cmlkZXNbMl06MSxwPWM/MTp0LnN0cmlkZXNbMV0sdj1sLnN0cmlkZXNbMF0sbT1jP2wuc3RyaWRlc1sxXTpsLnN0cmlkZXNbMl0sZz1jP2wuc3RyaWRlc1syXToxLHk9Yz8xOmwuc3RyaWRlc1sxXSx4PXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGI9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksdz1sLnZhbHVlcyxDPTA7QzxuLmJhdGNoU2l6ZTsrK0MpZm9yKHZhciBFPUMqaCxSPUMqdixJPTA7STxuLm91dEhlaWdodDsrK0kpZm9yKHZhciBrPVIrSSptLFM9SSpuLnN0cmlkZUhlaWdodC11LEE9MDtBPHI7QSsrKXt2YXIgRD1TK0EqYTtpZighKEQ8MHx8RD49bi5pbkhlaWdodCkpZm9yKHZhciBUPUEqZS5zdHJpZGVzWzBdLE49RStEKmYsRj0wO0Y8bi5vdXRXaWR0aDsrK0YpZm9yKHZhciBfPWsrRipnLE89RipuLnN0cmlkZVdpZHRoLXMsTT0wO008bztNKyspe3ZhciBCPU8rTSppO2lmKCEoQjwwfHxCPj1uLmluV2lkdGgpKWZvcih2YXIgUD1OK0IqZCxMPVQrTSplLnN0cmlkZXNbMV0sVz0wO1c8bi5pbkNoYW5uZWxzOysrVyl7Zm9yKHZhciBVPXhbUCtXKnBdLFY9MDtWPG4ub3V0Q2hhbm5lbHM7KytWKXdbXytWKnldKz1VKmJbTCtWXTtMKz1uLm91dENoYW5uZWxzfX19cmV0dXJuIGwudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuY29udjNkPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9bi5maWx0ZXJEZXB0aCxvPW4uZmlsdGVySGVpZ2h0LGE9bi5maWx0ZXJXaWR0aCxpPW4uZGlsYXRpb25EZXB0aCxzPW4uZGlsYXRpb25IZWlnaHQsdT1uLmRpbGF0aW9uV2lkdGgsYz1uLnBhZEluZm8uZnJvbnQsbD1uLnBhZEluZm8ubGVmdCxoPW4ucGFkSW5mby50b3AsZj1kcihuLm91dFNoYXBlLHQuZHR5cGUpLGQ9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscD10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSx2PWYudmFsdWVzLG09MDttPG4uYmF0Y2hTaXplOysrbSlmb3IodmFyIGc9bSp0LnN0cmlkZXNbMF0seT1tKmYuc3RyaWRlc1swXSx4PTA7eDxuLm91dERlcHRoOysreClmb3IodmFyIGI9eSt4KmYuc3RyaWRlc1sxXSx3PXgqbi5zdHJpZGVEZXB0aC1jLEM9MDtDPHI7QysrKXt2YXIgRT13K0MqaTtpZighKEU8MHx8RT49bi5pbkRlcHRoKSlmb3IodmFyIFI9QyplLnN0cmlkZXNbMF0sST1nK0UqdC5zdHJpZGVzWzFdLGs9MDtrPG4ub3V0SGVpZ2h0Oysraylmb3IodmFyIFM9YitrKmYuc3RyaWRlc1syXSxBPWsqbi5zdHJpZGVIZWlnaHQtaCxEPTA7RDxvO0QrKyl7dmFyIFQ9QStEKnM7aWYoIShUPDB8fFQ+PW4uaW5IZWlnaHQpKWZvcih2YXIgTj1SK0QqZS5zdHJpZGVzWzFdLEY9SStUKnQuc3RyaWRlc1syXSxfPTA7XzxuLm91dFdpZHRoOysrXylmb3IodmFyIE89UytfKm4ub3V0Q2hhbm5lbHMsTT1fKm4uc3RyaWRlV2lkdGgtbCxCPTA7QjxhO0IrKyl7dmFyIFA9TStCKnU7aWYoIShQPDB8fFA+PW4uaW5XaWR0aCkpZm9yKHZhciBMPU4rQiplLnN0cmlkZXNbMl0sVz1GK1Aqbi5pbkNoYW5uZWxzLFU9TCxWPTA7VjxuLmluQ2hhbm5lbHM7KytWKXtmb3IodmFyIHo9ZFtXK1ZdLEc9MDtHPG4ub3V0Q2hhbm5lbHM7KytHKXZbTytHXSs9eipwW1UrR107VSs9bi5vdXRDaGFubmVsc319fX1yZXR1cm4gZi50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5jb252MmREZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7SGgoW3QsZV0sXCJjb252MmREZXJJbnB1dFwiKTtmb3IodmFyIHI9ZHIobi5pblNoYXBlLFwiZmxvYXQzMlwiKSxvPXIudmFsdWVzLGE9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksaT10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxzPWUuc3RyaWRlcyx1PXNbMF0sYz1zWzFdLGw9c1syXSxoPW4uYmF0Y2hTaXplLGY9bi5maWx0ZXJIZWlnaHQsZD1uLmZpbHRlcldpZHRoLHA9bi5pbkNoYW5uZWxzLHY9bi5pbkhlaWdodCxtPW4uaW5XaWR0aCxnPW4ub3V0Q2hhbm5lbHMseT1uLm91dEhlaWdodCx4PW4ub3V0V2lkdGgsYj1uLnN0cmlkZUhlaWdodCx3PW4uc3RyaWRlV2lkdGgsQz1uLmRhdGFGb3JtYXQsRT1mLTEtbi5wYWRJbmZvLnRvcCxSPWQtMS1uLnBhZEluZm8ubGVmdCxJPVwiY2hhbm5lbHNMYXN0XCI9PT1DLGs9ci5zdHJpZGVzWzBdLFM9ST9yLnN0cmlkZXNbMV06ci5zdHJpZGVzWzJdLEE9ST9yLnN0cmlkZXNbMl06MSxEPUk/MTpyLnN0cmlkZXNbMV0sVD10LnN0cmlkZXNbMF0sTj1JP3Quc3RyaWRlc1sxXTp0LnN0cmlkZXNbMl0sRj1JP3Quc3RyaWRlc1syXToxLF89ST8xOnQuc3RyaWRlc1sxXSxPPTA7TzxoOysrTylmb3IodmFyIE09MDtNPHA7KytNKWZvcih2YXIgQj0wO0I8djsrK0IpZm9yKHZhciBQPUItRSxMPU1hdGgubWF4KDAsTWF0aC5jZWlsKFAvYikpLFc9TWF0aC5taW4oeSwoZitQKS9iKSxVPTA7VTxtOysrVSl7Zm9yKHZhciBWPVUtUix6PU1hdGgubWF4KDAsTWF0aC5jZWlsKFYvdykpLEc9TWF0aC5taW4oeCwoZCtWKS93KSxIPTAscT1MO3E8VzsrK3EpZm9yKHZhciBLPXEqYi1QLGo9ejtqPEc7KytqKWZvcih2YXIgWD1UKk8rTipxK0YqaixZPXUqKGYtMS1LKStjKihkLTEtKGoqdy1WKSkrbCpNLCQ9MDskPGc7KyskKXtIKz1hW1grXyokXSppW1krJF19b1trKk8rUypCK0EqVStEKk1dPUh9cmV0dXJuIHIudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuY29udjNkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1kcihuLmluU2hhcGUsXCJmbG9hdDMyXCIpLG89ci52YWx1ZXMsYT1yLnN0cmlkZXMsaT1hWzBdLHM9YVsxXSx1PWFbMl0sYz1hWzNdLGw9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksaD10LnN0cmlkZXMsZj1oWzBdLGQ9aFsxXSxwPWhbMl0sdj1oWzNdLG09dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksZz1lLnN0cmlkZXMseT1nWzBdLHg9Z1sxXSxiPWdbMl0sdz1nWzNdLEM9bi5iYXRjaFNpemUsRT1uLmZpbHRlckRlcHRoLFI9bi5maWx0ZXJIZWlnaHQsST1uLmZpbHRlcldpZHRoLGs9bi5pbkNoYW5uZWxzLFM9bi5pbkRlcHRoLEE9bi5pbkhlaWdodCxEPW4uaW5XaWR0aCxUPW4ub3V0Q2hhbm5lbHMsTj1uLm91dERlcHRoLEY9bi5vdXRIZWlnaHQsXz1uLm91dFdpZHRoLE89bi5zdHJpZGVEZXB0aCxNPW4uc3RyaWRlSGVpZ2h0LEI9bi5zdHJpZGVXaWR0aCxQPUUtMS1uLnBhZEluZm8uZnJvbnQsTD1SLTEtbi5wYWRJbmZvLnRvcCxXPUktMS1uLnBhZEluZm8ubGVmdCxVPTA7VTxDOysrVSlmb3IodmFyIFY9MDtWPGs7KytWKWZvcih2YXIgej0wO3o8UzsrK3opZm9yKHZhciBHPXotUCxIPU1hdGgubWF4KDAsTWF0aC5jZWlsKEcvTykpLHE9TWF0aC5taW4oTiwoRStHKS9PKSxLPTA7SzxBOysrSylmb3IodmFyIGo9Sy1MLFg9TWF0aC5tYXgoMCxNYXRoLmNlaWwoai9NKSksWT1NYXRoLm1pbihGLChSK2opL00pLCQ9MDskPEQ7KyskKXtmb3IodmFyIFE9JC1XLEo9TWF0aC5tYXgoMCxNYXRoLmNlaWwoUS9CKSksWj1NYXRoLm1pbihfLChJK1EpL0IpLHR0PTAsZXQ9SDtldDxxOysrZXQpZm9yKHZhciBudD1ldCpPLUcscnQ9WDtydDxZOysrcnQpZm9yKHZhciBvdD1ydCpNLWosYXQ9SjthdDxaOysrYXQpZm9yKHZhciBpdD1mKlUrZCpldCtwKnJ0K3YqYXQsc3Q9eSooRS0xLW50KSt4KihSLTEtb3QpK2IqKEktMS0oYXQqQi1RKSkrdypWLHV0PTA7dXQ8VDsrK3V0KXt0dCs9bFtpdCt1dF0qbVtzdCt1dF19b1tpKlUrcyp6K3UqSytjKiQrVl09dHR9cmV0dXJuIHIudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXtIaChbdCxlXSxcImNvbnYyZERlckZpbHRlclwiKTtmb3IodmFyIHI9bi5zdHJpZGVIZWlnaHQsbz1uLnN0cmlkZVdpZHRoLGE9bi5maWx0ZXJIZWlnaHQsaT1uLmZpbHRlcldpZHRoLHM9XCJjaGFubmVsc0xhc3RcIj09PW4uZGF0YUZvcm1hdCx1PWRyKG4uZmlsdGVyU2hhcGUsXCJmbG9hdDMyXCIpLGM9bi5wYWRJbmZvLmxlZnQsbD1uLnBhZEluZm8udG9wLGg9dGhpcy5idWZmZXJTeW5jKHQpLGY9dGhpcy5idWZmZXJTeW5jKGUpLGQ9MDtkPGE7KytkKWZvcih2YXIgcD1NYXRoLm1heCgwLE1hdGguY2VpbCgobC1kKS9yKSksdj1NYXRoLm1pbihuLm91dEhlaWdodCwobi5pbkhlaWdodCtsLWQpL3IpLG09MDttPGk7KyttKWZvcih2YXIgZz1NYXRoLm1heCgwLE1hdGguY2VpbCgoYy1tKS9vKSkseT1NYXRoLm1pbihuLm91dFdpZHRoLChuLmluV2lkdGgrYy1tKS9vKSx4PTA7eDxuLmluQ2hhbm5lbHM7Kyt4KWZvcih2YXIgYj0wO2I8bi5vdXRDaGFubmVsczsrK2Ipe2Zvcih2YXIgdz0wLEM9MDtDPG4uYmF0Y2hTaXplOysrQylmb3IodmFyIEU9cDtFPHY7KytFKWZvcih2YXIgUj1kK0Uqci1sLEk9ZztJPHk7KytJKXt2YXIgaz1tK0kqby1jO3crPXM/aC5nZXQoQyxSLGsseCkqZi5nZXQoQyxFLEksYik6aC5nZXQoQyx4LFIsaykqZi5nZXQoQyxiLEUsSSl9dS5zZXQodyxkLG0seCxiKX1yZXR1cm4gdS50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5jb252M2REZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1uLnN0cmlkZURlcHRoLG89bi5zdHJpZGVIZWlnaHQsYT1uLnN0cmlkZVdpZHRoLGk9bi5maWx0ZXJEZXB0aCxzPW4uZmlsdGVySGVpZ2h0LHU9bi5maWx0ZXJXaWR0aCxjPWRyKG4uZmlsdGVyU2hhcGUsXCJmbG9hdDMyXCIpLGw9Yy52YWx1ZXMsaD1jLnN0cmlkZXMsZj1oWzBdLGQ9aFsxXSxwPWhbMl0sdj1oWzNdLG09dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksZz1lLnN0cmlkZXMseT1nWzBdLHg9Z1sxXSxiPWdbMl0sdz1nWzNdLEM9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksRT10LnN0cmlkZXMsUj1FWzBdLEk9RVsxXSxrPUVbMl0sUz1FWzNdLEE9bi5wYWRJbmZvLmZyb250LEQ9bi5wYWRJbmZvLmxlZnQsVD1uLnBhZEluZm8udG9wLE49MDtOPGk7KytOKWZvcih2YXIgRj1NYXRoLm1heCgwLE1hdGguY2VpbCgoQS1OKS9yKSksXz1NYXRoLm1pbihuLm91dERlcHRoLChuLmluRGVwdGgrQS1OKS9yKSxPPU4qZixNPTA7TTxzOysrTSlmb3IodmFyIEI9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKFQtTSkvbykpLFA9TWF0aC5taW4obi5vdXRIZWlnaHQsKG4uaW5IZWlnaHQrVC1NKS9vKSxMPU0qZCtPLFc9MDtXPHU7KytXKWZvcih2YXIgVT1NYXRoLm1heCgwLE1hdGguY2VpbCgoRC1XKS9hKSksVj1NYXRoLm1pbihuLm91dFdpZHRoLChuLmluV2lkdGgrRC1XKS9hKSx6PVcqcCtMLEc9MDtHPG4uaW5DaGFubmVsczsrK0cpZm9yKHZhciBIPUcqdit6LHE9MDtxPG4ub3V0Q2hhbm5lbHM7KytxKXtmb3IodmFyIEs9MCxqPTA7ajxuLmJhdGNoU2l6ZTsrK2opZm9yKHZhciBYPWoqUixZPWoqeSwkPUY7JDxfOysrJClmb3IodmFyIFE9KE4rJCpyLUEpKkkrWCxKPSQqeCtZLFo9QjtaPFA7KytaKWZvcih2YXIgdHQ9KE0rWipvLVQpKmsrUSxldD1aKmIrSixudD1VO250PFY7KytudCl7dmFyIHJ0PW50KncrZXQ7Sys9Q1soVytudCphLUQpKlMrdHQrR10qbVtydCtxXX1sW0grcV09S31yZXR1cm4gYy50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5mdXNlZERlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0KXt2YXIgZT10LmlucHV0LG49dC5maWx0ZXIscj10LmNvbnZJbmZvLG89dC5iaWFzLGE9dC5hY3RpdmF0aW9uLGk9dC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzLHM9dGhpcy5kZXB0aHdpc2VDb252MkQoZSxuLHIpO3JldHVybiBvJiYocz10aGlzLmFkZChzLG8pKSxhJiYocz1xaCh0aGlzLHMsYSxpKSksc30sby5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKHQsZSxuKXtIaChbdCxlXSxcImRlcHRod2lzZUNvbnYyRFwiKTtmb3IodmFyIHI9bi5maWx0ZXJIZWlnaHQsbz1uLmZpbHRlcldpZHRoLGE9bi5kaWxhdGlvbkhlaWdodCxpPW4uZGlsYXRpb25XaWR0aCxzPW4ucGFkSW5mby5sZWZ0LHU9bi5wYWRJbmZvLnRvcCxjPW4ub3V0Q2hhbm5lbHMvbi5pbkNoYW5uZWxzLGw9ZHIobi5vdXRTaGFwZSx0LmR0eXBlKSxoPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGY9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksZD1sLnZhbHVlcyxwPTA7cDxuLmJhdGNoU2l6ZTsrK3ApZm9yKHZhciB2PXAqdC5zdHJpZGVzWzBdLG09cCpsLnN0cmlkZXNbMF0sZz0wO2c8bi5vdXRIZWlnaHQ7KytnKWZvcih2YXIgeT1tK2cqbC5zdHJpZGVzWzFdLHg9ZypuLnN0cmlkZUhlaWdodC1zLGI9MDtiPHI7KytiKXt2YXIgdz14K2IqYTtpZighKHc8MHx8dz49bi5pbkhlaWdodCkpZm9yKHZhciBDPWIqZS5zdHJpZGVzWzBdLEU9dit3KnQuc3RyaWRlc1sxXSxSPTA7UjxuLm91dFdpZHRoOysrUilmb3IodmFyIEk9eStSKmwuc3RyaWRlc1syXSxrPVIqbi5zdHJpZGVXaWR0aC11LFM9MDtTPG87KytTKXt2YXIgQT1rK1MqaTtpZighKEE8MHx8QT49bi5pbldpZHRoKSlmb3IodmFyIEQ9QytTKmUuc3RyaWRlc1sxXSxUPUUrQSpuLmluQ2hhbm5lbHMsTj1JLEY9RCxfPTA7XzxuLmluQ2hhbm5lbHM7KytfKXtmb3IodmFyIE89aFtUK19dLE09MDtNPGM7KytNKWRbTitNXSs9TypmW0YrTV07Tis9YyxGKz1jfX19cmV0dXJuIGwudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe0hoKFt0LGVdLFwiZGVwdGh3aXNlQ29udjJERGVySW5wdXRcIik7Zm9yKHZhciByPWRyKG4uaW5TaGFwZSxcImZsb2F0MzJcIiksbz1yLnZhbHVlcyxhPXIuc3RyaWRlcyxpPWFbMF0scz1hWzFdLHU9YVsyXSxjPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGw9dC5zdHJpZGVzLGg9bFswXSxmPWxbMV0sZD1sWzJdLHA9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksdj1lLnN0cmlkZXMsbT12WzBdLGc9dlsxXSx5PXZbMl0seD1uLmJhdGNoU2l6ZSxiPW4uZmlsdGVySGVpZ2h0LHc9bi5maWx0ZXJXaWR0aCxDPW4uaW5DaGFubmVscyxFPW4uaW5IZWlnaHQsUj1uLmluV2lkdGgsST1uLm91dENoYW5uZWxzLGs9bi5vdXRIZWlnaHQsUz1uLm91dFdpZHRoLEE9bi5zdHJpZGVIZWlnaHQsRD1uLnN0cmlkZVdpZHRoLFQ9Yi0xLW4ucGFkSW5mby50b3AsTj13LTEtbi5wYWRJbmZvLmxlZnQsRj1JL0MsXz0wO188eDsrK18pZm9yKHZhciBPPTA7TzxDOysrTylmb3IodmFyIE09MDtNPEU7KytNKWZvcih2YXIgQj1NLVQsUD1NYXRoLm1heCgwLE1hdGguY2VpbChCL0EpKSxMPU1hdGgubWluKGssKGIrQikvQSksVz0wO1c8UjsrK1cpe2Zvcih2YXIgVT1XLU4sVj1NYXRoLm1heCgwLE1hdGguY2VpbChVL0QpKSx6PU1hdGgubWluKFMsKHcrVSkvRCksRz0wLEg9UDtIPEw7KytIKWZvcih2YXIgcT1IKkEtQixLPVY7Szx6OysrSylmb3IodmFyIGo9aCpfK2YqSCtkKkssWD1tKihiLTEtcSkrZyoody0xLShLKkQtVSkpK3kqTyxZPTA7WTxGOysrWSl7Rys9Y1tqKyhPKkYrWSldKnBbWCtZXX1vW2kqXytzKk0rdSpXK09dPUd9cmV0dXJuIHIudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXtIaChbdCxlXSxcImRlcHRod2lzZUNvbnYyRERlckZpbHRlclwiKTtmb3IodmFyIHI9bi5zdHJpZGVIZWlnaHQsbz1uLnN0cmlkZVdpZHRoLGE9bi5maWx0ZXJIZWlnaHQsaT1uLmZpbHRlcldpZHRoLHM9ZHIobi5maWx0ZXJTaGFwZSxcImZsb2F0MzJcIiksdT1uLnBhZEluZm8ubGVmdCxjPW4ucGFkSW5mby50b3AsbD1uLm91dENoYW5uZWxzL24uaW5DaGFubmVscyxoPXRoaXMuYnVmZmVyU3luYyh0KSxmPXRoaXMuYnVmZmVyU3luYyhlKSxkPTA7ZDxhOysrZClmb3IodmFyIHA9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKGMtZCkvcikpLHY9TWF0aC5taW4obi5vdXRIZWlnaHQsKG4uaW5IZWlnaHQrYy1kKS9yKSxtPTA7bTxpOysrbSlmb3IodmFyIGc9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKHUtbSkvbykpLHk9TWF0aC5taW4obi5vdXRXaWR0aCwobi5pbldpZHRoK3UtbSkvbykseD0wO3g8bi5vdXRDaGFubmVsczsrK3gpe2Zvcih2YXIgYj1NYXRoLnRydW5jKHgvbCksdz14JWwsQz0wLEU9MDtFPG4uYmF0Y2hTaXplOysrRSlmb3IodmFyIFI9cDtSPHY7KytSKWZvcih2YXIgST1kK1Iqci1jLGs9ZztrPHk7KytrKXt2YXIgUz1tK2sqby11O0MrPWguZ2V0KEUsSSxTLGIpKmYuZ2V0KEUsUixrLHgpfXMuc2V0KEMsZCxtLGIsdyl9cmV0dXJuIHMudG9UZW5zb3IoKX0sby5wcm90b3R5cGUudGlsZT1mdW5jdGlvbih0LGUpe3JldHVybiBIaCh0LFwidGlsZVwiKSx0YSh0aGlzLmJ1ZmZlclN5bmModCksZSl9LG8ucHJvdG90eXBlLnBhZD1mdW5jdGlvbih0LGUsbil7SGgodCxcInBhZFwiKTt2YXIgcj1lLm1hcCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVswXSt0LnNoYXBlW25dK2VbMV19KSksbz1lLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KSksYT10aGlzLmJ1ZmZlclN5bmModCksaT1kcihyLHQuZHR5cGUpOzAhPT1uJiZpLnZhbHVlcy5maWxsKG4pO2Zvcih2YXIgcz0wO3M8dC5zaXplO3MrKyl7dmFyIHU9YS5pbmRleFRvTG9jKHMpLGM9dS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrb1tlXX0pKTtpLnNldC5hcHBseShpLFthLmdldC5hcHBseShhLHUpXS5jb25jYXQoYykpfXJldHVybiBpLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLnRyYW5zcG9zZT1mdW5jdGlvbih0LGUpe0hoKHQsXCJ0cmFuc3Bvc2VcIik7Zm9yKHZhciBuPW5ldyBBcnJheSh0LnJhbmspLHI9MDtyPG4ubGVuZ3RoO3IrKyluW3JdPXQuc2hhcGVbZVtyXV07dmFyIG89dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYT1kcihuLHQuZHR5cGUpLGk9dGhpcy5idWZmZXJTeW5jKHQpO2ZvcihyPTA7cjx0LnNpemU7KytyKXtmb3IodmFyIHM9aS5pbmRleFRvTG9jKHIpLHU9bmV3IEFycmF5KHMubGVuZ3RoKSxjPTA7Yzx1Lmxlbmd0aDtjKyspdVtjXT1zW2VbY11dO3ZhciBsPWEubG9jVG9JbmRleCh1KTthLnZhbHVlc1tsXT1vW3JdfXJldHVybiBhLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbih0LGUsbil7SGgoW3QsZV0sXCJnYXRoZXJcIik7dmFyIHI9dC5zaGFwZS5zbGljZSgpLG89dGhpcy5yZWFkU3luYyhlLmRhdGFJZCk7cltuXT1vLmxlbmd0aDtmb3IodmFyIGE9ZHIocix0LmR0eXBlKSxpPXRoaXMuYnVmZmVyU3luYyh0KSxzPTA7czxhLnNpemU7KytzKXt2YXIgdT1hLmluZGV4VG9Mb2MocyksYz11LnNsaWNlKCk7Y1tuXT1vW3Vbbl1dO3ZhciBsPWkubG9jVG9JbmRleChjKTthLnZhbHVlc1tzXT1pLnZhbHVlc1tsXX1yZXR1cm4gYS50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5iYXRjaFRvU3BhY2VORD1mdW5jdGlvbih0LGUsbil7SGgoW3RdLFwiYmF0Y2hUb1NwYWNlTkRcIik7dmFyIHI9ZS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pKSxvPXpyKHQuc2hhcGUsZSxyKSxhPUdyKG8ubGVuZ3RoLGUubGVuZ3RoKSxpPUhyKHQuc2hhcGUsZSxyKSxzPXFyKG4sZS5sZW5ndGgpLHU9S3IoaSxuLGUubGVuZ3RoKTtyZXR1cm4gdC5yZXNoYXBlKG8pLnRyYW5zcG9zZShhKS5yZXNoYXBlKGkpLnNsaWNlKHMsdSl9LG8ucHJvdG90eXBlLnNwYWNlVG9CYXRjaE5EPWZ1bmN0aW9uKHQsZSxuKXtIaChbdF0sXCJzcGFjZVRvQmF0Y2hORFwiKTt2YXIgcj1lLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkpLG89W1swLDBdXTtvLnB1c2guYXBwbHkobyxuKTtmb3IodmFyIGE9MStlLmxlbmd0aDthPHQuc2hhcGUubGVuZ3RoOysrYSlvLnB1c2goWzAsMF0pO3ZhciBpPXQucGFkKG8pLHM9enIoaS5zaGFwZSxlLHIsITEpLHU9R3Iocy5sZW5ndGgsZS5sZW5ndGgsITEpLGM9SHIoaS5zaGFwZSxlLHIsITEpO3JldHVybiBpLnJlc2hhcGUocykudHJhbnNwb3NlKHUpLnJlc2hhcGUoYyl9LG8ucHJvdG90eXBlLnBvb2w9ZnVuY3Rpb24odCxlLG4pe0hoKHQsXCJwb29sXCIpO2Zvcih2YXIgcj1lLnN0cmlkZUhlaWdodCxvPWUuc3RyaWRlV2lkdGgsYT1lLmRpbGF0aW9uSGVpZ2h0LGk9ZS5kaWxhdGlvbldpZHRoLHM9ZS5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsdT1lLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGM9ZS5wYWRJbmZvLnRvcCxsPWUucGFkSW5mby5sZWZ0LGg9XCJtYXhcIj09PW4/TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSxmPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGQ9ZHIoZS5vdXRTaGFwZSx0LmR0eXBlKSxwPWQudmFsdWVzLHY9ZS5vdXRTaGFwZVsxXSplLm91dFNoYXBlWzJdKmUub3V0U2hhcGVbM10sbT1lLm91dFNoYXBlWzJdKmUub3V0U2hhcGVbM10sZz1lLm91dFNoYXBlWzNdLHk9MDt5PGUuYmF0Y2hTaXplOysreSlmb3IodmFyIHg9eSp2LGI9eSp0LnN0cmlkZXNbMF0sdz0wO3c8ZS5pbkNoYW5uZWxzOysrdylmb3IodmFyIEM9MDtDPGUub3V0SGVpZ2h0OysrQylmb3IodmFyIEU9QypyLWMsUj1NYXRoLm1heCgwLEUpLEk9TWF0aC5taW4oZS5pbkhlaWdodCxzK0UpLGs9eCtDKm0sUz0wO1M8ZS5vdXRXaWR0aDsrK1Mpe2Zvcih2YXIgQT1TKm8tbCxEPU1hdGgubWF4KDAsQSksVD1NYXRoLm1pbihlLmluV2lkdGgsdStBKSxOPWgsRj0wLF89MCxPPVI7TzxJO08rPWEpe2Zvcih2YXIgTT1iK08qdC5zdHJpZGVzWzFdLEI9RDtCPFQ7Qis9aSl7dmFyIFA9ZltNK0IqdC5zdHJpZGVzWzJdK3ddO1wibWF4XCI9PT1uJiZQPk4/Tj1QOlwiYXZnXCI9PT1uJiYoRis9UCxfKyspfWlmKGlzTmFOKE4pKWJyZWFrfXBbaytTKmcrd109XCJhdmdcIj09PW4/Ri9fOk59cmV0dXJuIGQudG9UZW5zb3IoKX0sby5wcm90b3R5cGUubWF4UG9vbD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnBvb2wodCxlLFwibWF4XCIpfSxvLnByb3RvdHlwZS5tYXhQb29sUG9zaXRpb25zPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWRyKGUub3V0U2hhcGUsXCJpbnQzMlwiKSxyPWUuc3RyaWRlSGVpZ2h0LG89ZS5zdHJpZGVXaWR0aCxhPWUuZGlsYXRpb25IZWlnaHQsaT1lLmRpbGF0aW9uV2lkdGgscz1lLmVmZmVjdGl2ZUZpbHRlckhlaWdodCx1PWUuZWZmZWN0aXZlRmlsdGVyV2lkdGgsYz1lLnBhZEluZm8udG9wLGw9ZS5wYWRJbmZvLmxlZnQsaD10aGlzLmJ1ZmZlclN5bmModCksZj0wO2Y8ZS5iYXRjaFNpemU7KytmKWZvcih2YXIgZD0wO2Q8ZS5pbkNoYW5uZWxzOysrZClmb3IodmFyIHA9MDtwPGUub3V0SGVpZ2h0OysrcCl7Zm9yKHZhciB2PXAqci1jLG09djttPDA7KW0rPWE7Zm9yKHZhciBnPU1hdGgubWluKGUuaW5IZWlnaHQscyt2KSx5PTA7eTxlLm91dFdpZHRoOysreSl7Zm9yKHZhciB4PXkqby1sLGI9eDtiPDA7KWIrPWk7Zm9yKHZhciB3PU1hdGgubWluKGUuaW5XaWR0aCx1K3gpLEM9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLEU9LTEsUj1tO1I8ZztSKz1hKWZvcih2YXIgST1SLXYsaz1iO2s8dztrKz1pKXt2YXIgUz1rLXgsQT1oLmdldChmLFIsayxkKTtBPkMmJihDPUEsRT1JKnUrUyl9bi5zZXQoRSxmLHAseSxkKX19cmV0dXJuIG4udG9UZW5zb3IoKX0sby5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuLHIpe0hoKFtlLG5dLFwibWF4UG9vbEJhY2twcm9wXCIpO2Zvcih2YXIgbz10aGlzLm1heFBvb2xQb3NpdGlvbnMoZSxyKSxhPXIuc3RyaWRlSGVpZ2h0LGk9ci5zdHJpZGVXaWR0aCxzPXIuZGlsYXRpb25IZWlnaHQsdT1yLmRpbGF0aW9uV2lkdGgsYz1yLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxsPXIuZWZmZWN0aXZlRmlsdGVyV2lkdGgsaD1sLTEtci5wYWRJbmZvLmxlZnQsZj1jLTEtci5wYWRJbmZvLnRvcCxkPWRyKGUuc2hhcGUsXCJmbG9hdDMyXCIpLHA9dGhpcy5idWZmZXJTeW5jKG8pLHY9dGhpcy5idWZmZXJTeW5jKHQpLG09MDttPHIuYmF0Y2hTaXplOysrbSlmb3IodmFyIGc9MDtnPHIuaW5DaGFubmVsczsrK2cpZm9yKHZhciB5PTA7eTxyLmluSGVpZ2h0OysreSlmb3IodmFyIHg9MDt4PHIuaW5XaWR0aDsrK3gpe2Zvcih2YXIgYj15LWYsdz14LWgsQz0wLEU9MDtFPGM7RSs9cyl7dmFyIFI9KGIrRSkvYTtpZighKFI8MHx8Uj49ci5vdXRIZWlnaHR8fE1hdGguZmxvb3IoUikhPT1SKSlmb3IodmFyIEk9MDtJPGw7SSs9dSl7dmFyIGs9KHcrSSkvaTtpZighKGs8MHx8az49ci5vdXRXaWR0aHx8TWF0aC5mbG9vcihrKSE9PWspKXt2YXIgUz1jKmwtMS1wLmdldChtLFIsayxnKT09PUUqbCtJPzE6MDtpZigwIT09UylDKz12LmdldChtLFIsayxnKSpTfX19ZC5zZXQoQyxtLHkseCxnKX1yZXR1cm4gZC50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5hdmdQb29sQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe0hoKFt0LGVdLFwiYXZnUG9vbEJhY2twcm9wXCIpO2Zvcih2YXIgcj1uLnN0cmlkZUhlaWdodCxvPW4uc3RyaWRlV2lkdGgsYT1uLmZpbHRlckhlaWdodCxpPW4uZmlsdGVyV2lkdGgscz1uLmRpbGF0aW9uSGVpZ2h0LHU9bi5kaWxhdGlvbldpZHRoLGM9bi5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsbD1uLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGg9bC0xLW4ucGFkSW5mby5sZWZ0LGY9Yy0xLW4ucGFkSW5mby50b3AsZD1kcihlLnNoYXBlLFwiZmxvYXQzMlwiKSxwPTEvKGEqaSksdj10aGlzLmJ1ZmZlclN5bmModCksbT0wO208bi5iYXRjaFNpemU7KyttKWZvcih2YXIgZz0wO2c8bi5pbkNoYW5uZWxzOysrZylmb3IodmFyIHk9MDt5PG4uaW5IZWlnaHQ7Kyt5KWZvcih2YXIgeD0wO3g8bi5pbldpZHRoOysreCl7Zm9yKHZhciBiPXktZix3PXgtaCxDPTAsRT0wO0U8YztFKz1zKXt2YXIgUj0oYitFKS9yO2lmKCEoUjwwfHxSPj1uLm91dEhlaWdodHx8TWF0aC5mbG9vcihSKSE9PVIpKWZvcih2YXIgST0wO0k8bDtJKz11KXt2YXIgaz0odytJKS9vO2lmKCEoazwwfHxrPj1uLm91dFdpZHRofHxNYXRoLmZsb29yKGspIT09aykpQys9di5nZXQobSxSLGssZyl9fWQuc2V0KEMqcCxtLHkseCxnKX1yZXR1cm4gZC50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5wb29sM2Q9ZnVuY3Rpb24odCxlLG4pe0hoKHQsXCJwb29sM2RcIik7Zm9yKHZhciByPWUuc3RyaWRlRGVwdGgsbz1lLnN0cmlkZUhlaWdodCxhPWUuc3RyaWRlV2lkdGgsaT1lLmRpbGF0aW9uRGVwdGgscz1lLmRpbGF0aW9uSGVpZ2h0LHU9ZS5kaWxhdGlvbldpZHRoLGM9ZS5lZmZlY3RpdmVGaWx0ZXJEZXB0aCxsPWUuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGg9ZS5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxmPWUucGFkSW5mby5mcm9udCxkPWUucGFkSW5mby50b3AscD1lLnBhZEluZm8ubGVmdCx2PVwibWF4XCI9PT1uP051bWJlci5ORUdBVElWRV9JTkZJTklUWTpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksbT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxnPWRyKGUub3V0U2hhcGUsdC5kdHlwZSkseT1nLnZhbHVlcyx4PWUub3V0U2hhcGVbMV0qZS5vdXRTaGFwZVsyXSplLm91dFNoYXBlWzNdKmUub3V0U2hhcGVbNF0sYj1lLm91dFNoYXBlWzJdKmUub3V0U2hhcGVbM10qZS5vdXRTaGFwZVs0XSx3PWUub3V0U2hhcGVbM10qZS5vdXRTaGFwZVs0XSxDPWUub3V0U2hhcGVbNF0sRT0wO0U8ZS5iYXRjaFNpemU7KytFKWZvcih2YXIgUj1FKngsST1FKnQuc3RyaWRlc1swXSxrPTA7azxlLmluQ2hhbm5lbHM7KytrKWZvcih2YXIgUz0wO1M8ZS5vdXREZXB0aDsrK1Mpe2Zvcih2YXIgQT1TKnItZixEPUE7RDwwOylEKz1pO2Zvcih2YXIgVD1NYXRoLm1pbihlLmluRGVwdGgsYytBKSxOPVIrUypiLEY9MDtGPGUub3V0SGVpZ2h0OysrRil7Zm9yKHZhciBfPUYqby1kLE89XztPPDA7KU8rPXM7Zm9yKHZhciBNPU1hdGgubWluKGUuaW5IZWlnaHQsbCtfKSxCPU4rRip3LFA9MDtQPGUub3V0V2lkdGg7KytQKXtmb3IodmFyIEw9UCphLXAsVz1MO1c8MDspVys9dTtmb3IodmFyIFU9TWF0aC5taW4oZS5pbldpZHRoLGgrTCksVj1CK1AqQyx6PXYsRz0wLEg9MCxxPUQ7cTxUO3ErPWkpe2Zvcih2YXIgSz1JK3EqdC5zdHJpZGVzWzFdLGo9TztqPE07ais9cyl7Zm9yKHZhciBYPUsraip0LnN0cmlkZXNbMl0sWT1XO1k8VTtZKz11KXt2YXIgJD1tW1grWSp0LnN0cmlkZXNbM10ra107aWYoXCJtYXhcIj09PW4mJiQ+ej96PSQ6XCJhdmdcIj09PW4mJihHKz0kLEgrKyksaXNOYU4oeikpYnJlYWt9aWYoaXNOYU4oeikpYnJlYWt9aWYoaXNOYU4oeikpYnJlYWt9eVtWK2tdPVwiYXZnXCI9PT1uP0cvSDp6fX19cmV0dXJuIGcudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuYXZnUG9vbDNkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKHQsXCJhdmdQb29sM2RcIiksdGhpcy5wb29sM2QodCxlLFwiYXZnXCIpLnRvRmxvYXQoKX0sby5wcm90b3R5cGUuYXZnUG9vbDNkQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe0hoKFt0LGVdLFwiYXZnUG9vbDNkQmFja3Byb3BcIik7Zm9yKHZhciByPW4uc3RyaWRlRGVwdGgsbz1uLnN0cmlkZUhlaWdodCxhPW4uc3RyaWRlV2lkdGgsaT1uLmZpbHRlckRlcHRoLHM9bi5maWx0ZXJIZWlnaHQsdT1uLmZpbHRlcldpZHRoLGM9bi5kaWxhdGlvbkRlcHRoLGw9bi5kaWxhdGlvbkhlaWdodCxoPW4uZGlsYXRpb25XaWR0aCxmPW4uZWZmZWN0aXZlRmlsdGVyRGVwdGgsZD1uLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxwPW4uZWZmZWN0aXZlRmlsdGVyV2lkdGgsdj1mLTEtbi5wYWRJbmZvLmZyb250LG09cC0xLW4ucGFkSW5mby5sZWZ0LGc9ZC0xLW4ucGFkSW5mby50b3AseT1kcihlLnNoYXBlLFwiZmxvYXQzMlwiKSx4PTEvKGkqcyp1KSxiPXRoaXMuYnVmZmVyU3luYyh0KSx3PTA7dzxuLmJhdGNoU2l6ZTsrK3cpZm9yKHZhciBDPTA7QzxuLmluQ2hhbm5lbHM7KytDKWZvcih2YXIgRT0wO0U8bi5pbkRlcHRoOysrRSlmb3IodmFyIFI9MDtSPG4uaW5IZWlnaHQ7KytSKWZvcih2YXIgST0wO0k8bi5pbldpZHRoOysrSSl7Zm9yKHZhciBrPUUtdixTPVItZyxBPUktbSxEPTAsVD0wO1Q8ZjtUKz1jKXt2YXIgTj0oaytUKS9yO2lmKCEoTjwwfHxOPj1uLm91dERlcHRofHxNYXRoLmZsb29yKE4pIT09TikpZm9yKHZhciBGPTA7RjxkO0YrPWwpe3ZhciBfPShTK0YpL287aWYoIShfPDB8fF8+PW4ub3V0SGVpZ2h0fHxNYXRoLmZsb29yKF8pIT09XykpZm9yKHZhciBPPTA7TzxwO08rPWgpe3ZhciBNPShBK08pL2E7aWYoIShNPDB8fE0+PW4ub3V0V2lkdGh8fE1hdGguZmxvb3IoTSkhPT1NKSlEKz1iLmdldCh3LE4sXyxNLEMpfX19eS5zZXQoRCp4LHcsRSxSLEksQyl9cmV0dXJuIHkudG9UZW5zb3IoKX0sby5wcm90b3R5cGUubWF4UG9vbDNkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKHQsXCJtYXhQb29sM2RcIiksdGhpcy5wb29sM2QodCxlLFwibWF4XCIpLnRvRmxvYXQoKX0sby5wcm90b3R5cGUubWF4UG9vbDNkUG9zaXRpb25zPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWRyKGUub3V0U2hhcGUsXCJpbnQzMlwiKSxyPWUuc3RyaWRlRGVwdGgsbz1lLnN0cmlkZUhlaWdodCxhPWUuc3RyaWRlV2lkdGgsaT1lLmRpbGF0aW9uRGVwdGgscz1lLmRpbGF0aW9uSGVpZ2h0LHU9ZS5kaWxhdGlvbldpZHRoLGM9ZS5lZmZlY3RpdmVGaWx0ZXJEZXB0aCxsPWUuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGg9ZS5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxmPWUucGFkSW5mby5mcm9udCxkPWUucGFkSW5mby50b3AscD1lLnBhZEluZm8ubGVmdCx2PXRoaXMuYnVmZmVyU3luYyh0KSxtPTA7bTxlLmJhdGNoU2l6ZTsrK20pZm9yKHZhciBnPTA7ZzxlLmluQ2hhbm5lbHM7KytnKWZvcih2YXIgeT0wO3k8ZS5vdXREZXB0aDsrK3kpe2Zvcih2YXIgeD15KnItZixiPXg7YjwwOyliKz1pO2Zvcih2YXIgdz1NYXRoLm1pbihlLmluRGVwdGgsYyt4KSxDPTA7QzxlLm91dEhlaWdodDsrK0Mpe2Zvcih2YXIgRT1DKm8tZCxSPUU7UjwwOylSKz1zO2Zvcih2YXIgST1NYXRoLm1pbihlLmluSGVpZ2h0LGwrRSksaz0wO2s8ZS5vdXRXaWR0aDsrK2spe2Zvcih2YXIgUz1rKmEtcCxBPVM7QTwwOylBKz11O2Zvcih2YXIgRD1NYXRoLm1pbihlLmluV2lkdGgsaCtTKSxUPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSxOPS0xLEY9YjtGPHc7Ris9aSlmb3IodmFyIF89Ri14LE89UjtPPEk7Tys9cylmb3IodmFyIE09Ty1FLEI9QTtCPEQ7Qis9dSl7dmFyIFA9Qi1TLEw9di5nZXQobSxGLE8sQixnKTtMPj1UJiYoVD1MLE49XypsKmgrTSpsK1ApfW4uc2V0KE4sbSx5LEMsayxnKX19fXJldHVybiBuLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLm1heFBvb2wzZEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuLHIpe0hoKFtlLG5dLFwibWF4UG9vbDNkQmFja3Byb3BcIik7Zm9yKHZhciBvPXRoaXMubWF4UG9vbDNkUG9zaXRpb25zKGUsciksYT1yLnN0cmlkZURlcHRoLGk9ci5zdHJpZGVIZWlnaHQscz1yLnN0cmlkZVdpZHRoLHU9ci5kaWxhdGlvbkRlcHRoLGM9ci5kaWxhdGlvbkhlaWdodCxsPXIuZGlsYXRpb25XaWR0aCxoPXIuZWZmZWN0aXZlRmlsdGVyRGVwdGgsZj1yLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxkPXIuZWZmZWN0aXZlRmlsdGVyV2lkdGgscD1oLTEtci5wYWRJbmZvLmZyb250LHY9ZC0xLXIucGFkSW5mby5sZWZ0LG09Zi0xLXIucGFkSW5mby50b3AsZz1kcihlLnNoYXBlLFwiZmxvYXQzMlwiKSx5PXRoaXMuYnVmZmVyU3luYyhvKSx4PXRoaXMuYnVmZmVyU3luYyh0KSxiPTA7YjxyLmJhdGNoU2l6ZTsrK2IpZm9yKHZhciB3PTA7dzxyLmluQ2hhbm5lbHM7Kyt3KWZvcih2YXIgQz0wO0M8ci5pbkRlcHRoOysrQylmb3IodmFyIEU9MDtFPHIuaW5IZWlnaHQ7KytFKWZvcih2YXIgUj0wO1I8ci5pbldpZHRoOysrUil7Zm9yKHZhciBJPUMtcCxrPUUtbSxTPVItdixBPTAsRD0wO0Q8aDtEKz11KXt2YXIgVD0oSStEKS9hO2lmKCEoVDwwfHxUPj1yLm91dERlcHRofHxNYXRoLmZsb29yKFQpIT09VCkpZm9yKHZhciBOPTA7TjxmO04rPWMpe3ZhciBGPShrK04pL2k7aWYoIShGPDB8fEY+PXIub3V0SGVpZ2h0fHxNYXRoLmZsb29yKEYpIT09RikpZm9yKHZhciBfPTA7XzxkO18rPWwpe3ZhciBPPShTK18pL3M7aWYoIShPPDB8fE8+PXIub3V0V2lkdGh8fE1hdGguZmxvb3IoTykhPT1PKSl7dmFyIE09aCpmKmQtMS15LmdldChiLFQsRixPLHcpPT09RCpmKmQrTipkK18/MTowO2lmKDAhPT1NKUErPXguZ2V0KGIsVCxGLE8sdykqTX19fX1nLnNldChBLGIsQyxFLFIsdyl9cmV0dXJuIGcudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuY2FzdD1mdW5jdGlvbih0LGUpe3JldHVybiBQbyh0LGUsdGhpcyl9LG8ucHJvdG90eXBlLnJlc2hhcGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gTG8odCxlKX0sby5wcm90b3R5cGUuYXZnUG9vbD1mdW5jdGlvbih0LGUpe3JldHVybiBIaCh0LFwiYXZnUG9vbFwiKSx0aGlzLnBvb2wodCxlLFwiYXZnXCIpLnRvRmxvYXQoKX0sby5wcm90b3R5cGUucmVzaXplQmlsaW5lYXI9ZnVuY3Rpb24odCxlLG4scil7SGgodCxcInJlc2l6ZUJpbGluZWFyXCIpO2Zvcih2YXIgbz10LnNoYXBlLGE9b1swXSxpPW9bMV0scz1vWzJdLHU9b1szXSxjPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGw9bmV3IEZsb2F0MzJBcnJheShrKFthLGUsbix1XSkpLGg9W3ImJmU+MT9pLTE6aSxyJiZuPjE/cy0xOnNdLGY9W3ImJmU+MT9lLTE6ZSxyJiZuPjE/bi0xOm5dLGQ9MCxwPWhbMF0vZlswXSx2PWhbMV0vZlsxXSxtPTA7bTxhO20rKylmb3IodmFyIGc9MDtnPGU7ZysrKWZvcih2YXIgeT1wKmcseD1NYXRoLmZsb29yKHkpLGI9eS14LHc9TWF0aC5taW4oaS0xLE1hdGguY2VpbCh5KSksQz1tKnQuc3RyaWRlc1swXSt4KnQuc3RyaWRlc1sxXSxFPW0qdC5zdHJpZGVzWzBdK3cqdC5zdHJpZGVzWzFdLFI9MDtSPG47UisrKWZvcih2YXIgST12KlIsUz1NYXRoLmZsb29yKEkpLEE9SS1TLEQ9TWF0aC5taW4ocy0xLE1hdGguY2VpbChJKSksVD1DK1MqdC5zdHJpZGVzWzJdLE49RStTKnQuc3RyaWRlc1syXSxGPUMrRCp0LnN0cmlkZXNbMl0sXz1FK0QqdC5zdHJpZGVzWzJdLE89MDtPPHU7TysrKXt2YXIgTT1jW1QrT10sQj1jW04rT10sUD1NKyhjW0YrT10tTSkqQSxMPVArKEIrKGNbXytPXS1CKSpBLVApKmI7bFtkKytdPUx9cmV0dXJuIEZuKGwsW2EsZSxuLHVdKX0sby5wcm90b3R5cGUucmVzaXplQmlsaW5lYXJCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7SGgoW3QsZV0sXCJyZXNpemVCaWxpbmVhckJhY2twcm9wXCIpO2Zvcih2YXIgcj1lLnNoYXBlLG89clswXSxhPXJbMV0saT1yWzJdLHM9clszXSx1PXQuc2hhcGUsYz11WzFdLGw9dVsyXSxoPW5ldyBGbG9hdDMyQXJyYXkobyphKmkqcyksZj1bbiYmYz4xP2EtMTphLG4mJmw+MT9pLTE6aV0sZD1bbiYmYz4xP2MtMTpjLG4mJmw+MT9sLTE6bF0scD1mWzBdL2RbMF0sdj1mWzFdL2RbMV0sbT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxnPTAseT0wO3k8bzt5KyspZm9yKHZhciB4PXkqZS5zdHJpZGVzWzBdLGI9MDtiPGM7YisrKWZvcih2YXIgdz1iKnAsQz1NYXRoLmZsb29yKHcpLEU9TWF0aC5taW4oTWF0aC5jZWlsKHcpLGEtMSksUj14K0MqZS5zdHJpZGVzWzFdLEk9eCtFKmUuc3RyaWRlc1sxXSxrPXctQyxTPTEtayxBPTA7QTxsO0ErKylmb3IodmFyIEQ9QSp2LFQ9TWF0aC5mbG9vcihEKSxOPU1hdGgubWluKE1hdGguY2VpbChEKSxpLTEpLEY9RC1ULF89MS1GLE89UitUKmUuc3RyaWRlc1syXSxNPVIrTiplLnN0cmlkZXNbMl0sQj1JK1QqZS5zdHJpZGVzWzJdLFA9SStOKmUuc3RyaWRlc1syXSxMPVMqXyxXPVMqRixVPWsqXyxWPWsqRix6PTA7ejxzO3orKyl7dmFyIEc9bVtnKytdO2hbTyt6XSs9RypMLGhbTSt6XSs9RypXLGhbQit6XSs9RypVLGhbUCt6XSs9RypWfXJldHVybiBMbihoLFtvLGksYSxzXSxlLmR0eXBlKX0sby5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKHQsZSxuLHIpe0hoKHQsXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JcIik7Zm9yKHZhciBvPXQuc2hhcGUsYT1vWzBdLGk9b1sxXSxzPW9bMl0sdT1vWzNdLGM9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbD1uZXcgRmxvYXQzMkFycmF5KGEqZSpuKnUpLGg9W3ImJmU+MT9pLTE6aSxyJiZuPjE/cy0xOnNdLGY9W3ImJmU+MT9lLTE6ZSxyJiZuPjE/bi0xOm5dLGQ9aFswXS9mWzBdLHA9aFsxXS9mWzFdLHY9MCxtPTA7bTxhO20rKylmb3IodmFyIGc9bSp0LnN0cmlkZXNbMF0seT0wO3k8ZTt5KyspZm9yKHZhciB4PWQqeSxiPWcrTWF0aC5taW4oaS0xLHI/TWF0aC5yb3VuZCh4KTpNYXRoLmZsb29yKHgpKSp0LnN0cmlkZXNbMV0sdz0wO3c8bjt3KyspZm9yKHZhciBDPXAqdyxFPWIrTWF0aC5taW4ocy0xLHI/TWF0aC5yb3VuZChDKTpNYXRoLmZsb29yKEMpKSp0LnN0cmlkZXNbMl0sUj0wO1I8dTtSKyspe3ZhciBJPWNbRStSXTtsW3YrK109SX1yZXR1cm4gRm4obCxbYSxlLG4sdV0sdC5kdHlwZSl9LG8ucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXtIaChbdCxlXSxcInJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wXCIpO2Zvcih2YXIgcj1lLnNoYXBlLG89clswXSxhPXJbMV0saT1yWzJdLHM9clszXSx1PXQuc2hhcGUsYz11WzFdLGw9dVsyXSxoPW5ldyBGbG9hdDMyQXJyYXkobyphKmkqcyksZj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxkPVtuJiZjPjE/YS0xOmEsbiYmbD4xP2ktMTppXSxwPVtuJiZjPjE/Yy0xOmMsbiYmbD4xP2wtMTpsXSx2PWRbMF0vcFswXSxtPWRbMV0vcFsxXSxnPTEvdix5PTEvbSx4PTIqTWF0aC5jZWlsKGcpKzIsYj0yKk1hdGguY2VpbCh5KSsyLHc9MDt3PG87dysrKWZvcih2YXIgQz13KmUuc3RyaWRlc1swXSxFPTA7RTxhO0UrKylmb3IodmFyIFI9QytFKmUuc3RyaWRlc1sxXSxJPU1hdGguZmxvb3IoRSpnKSxrPU1hdGguZmxvb3IoSS14LzIpLFM9MDtTPGk7UysrKWZvcih2YXIgQT1SK1MqZS5zdHJpZGVzWzJdLEQ9TWF0aC5mbG9vcihTKnkpLFQ9TWF0aC5mbG9vcihELWIvMiksTj0wO048cztOKyspe2Zvcih2YXIgRj0wLF89MDtfPHg7XysrKXt2YXIgTz1fK2s7aWYoIShPPDB8fE8+PWMpKXt2YXIgTT1DK08qdC5zdHJpZGVzWzFdLEI9Typ2O2lmKEU9PT1NYXRoLm1pbihhLTEsbj9NYXRoLnJvdW5kKEIpOk1hdGguZmxvb3IoQikpKWZvcih2YXIgUD0wO1A8YjtQKyspe3ZhciBMPVArVDtpZighKEw8MHx8TD49bCkpe3ZhciBXPU0rTCp0LnN0cmlkZXNbMl0sVT1MKm07Uz09PU1hdGgubWluKGktMSxuP01hdGgucm91bmQoVSk6TWF0aC5mbG9vcihVKSkmJihGKz1mW1crTl0pfX19fWhbQStOXT1GfXJldHVybiBMbihoLGUuc2hhcGUsZS5kdHlwZSl9LG8ucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbj1mdW5jdGlvbih0LGUsbixyLG8sYSl7SGgoW3QsZSxuLG8sYV0sXCJiYXRjaE5vcm1cIik7Zm9yKHZhciBpPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHM9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksdT10aGlzLnJlYWRTeW5jKG4uZGF0YUlkKSxjPW8/dGhpcy5yZWFkU3luYyhvLmRhdGFJZCk6bmV3IEZsb2F0MzJBcnJheShbMV0pLGw9YT90aGlzLnJlYWRTeW5jKGEuZGF0YUlkKTpuZXcgRmxvYXQzMkFycmF5KFswXSksaD1uZXcgRmxvYXQzMkFycmF5KGkubGVuZ3RoKSxmPWwubGVuZ3RoLGQ9Yy5sZW5ndGgscD11Lmxlbmd0aCx2PXMubGVuZ3RoLG09MCxnPTAseT0wLHg9MCxiPTA7YjxpLmxlbmd0aDsrK2IpaFtiXT1sW20rK10rKGlbYl0tc1tnKytdKSpjW3krK10vTWF0aC5zcXJ0KHVbeCsrXStyKSxtPj1mJiYobT0wKSxnPj12JiYoZz0wKSx5Pj1kJiYoeT0wKSx4Pj1wJiYoeD0wKTtyZXR1cm4gTG4oaCx0LnNoYXBlKX0sby5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RD1mdW5jdGlvbih0LGUsbixyLG8pe0hoKHQsXCJsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREXCIpO3ZhciBhPXQuc2hhcGVbM10saT1hLTEscz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSx1PXQuc2l6ZSxjPW5ldyBGbG9hdDMyQXJyYXkodSk7ZnVuY3Rpb24gbCh0KXtmb3IodmFyIG49dCVhLHI9dC1uK01hdGgubWF4KDAsbi1lKSxvPXQtbitNYXRoLm1pbihuK2UsaSksdT0wO3I8PW87cisrKXt2YXIgYz1zW3JdO3UrPWMqY31yZXR1cm4gdX1mb3IodmFyIGg9MDtoPHU7aCsrKXt2YXIgZj1sKGgpLGQ9c1toXSpNYXRoLnBvdyhuK3IqZiwtbyk7Y1toXT1kfXJldHVybiBMbihjLHQuc2hhcGUpfSxvLnByb3RvdHlwZS5MUk5HcmFkPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe0hoKHQsXCJMUk5HcmFkXCIpO2Zvcih2YXIgcz10LnNoYXBlWzNdLHU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYz10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxsPXRoaXMucmVhZFN5bmMobi5kYXRhSWQpLGg9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLGY9dC5zaXplLGQ9MDtkPGY7ZCsrKXtmb3IodmFyIHA9ZCVzLHY9ZC1wK01hdGgubWF4KDAscC1yKSxtPWQtcCtNYXRoLm1pbihzLHArcisxKSxnPTAseT12O3k8bTt5KyspZys9TWF0aC5wb3coY1t5XSwyKTtnPWEqZytvO2Zvcih5PXY7eTxtO3krKyl7dmFyIHg9LTIqYSppKmNbeV0qbFtkXS9nO2Q9PT15JiYoeCs9TWF0aC5wb3coZywtaSkpLHgqPXVbZF0saFt5XSs9eH19cmV0dXJuIExuKGgsdC5zaGFwZSl9LG8ucHJvdG90eXBlLm11bHRpbm9taWFsPWZ1bmN0aW9uKHQsZSxuLHIpe0hoKHQsXCJtdWx0aW5vbWlhbFwiKTtmb3IodmFyIG89ZT90OmdvKHQpLGE9by5zaGFwZVswXSxpPW8uc2hhcGVbMV0scz1HbihbYSxuXSxcImludDMyXCIpLHU9dGhpcy5yZWFkU3luYyhzLmRhdGFJZCksYz10aGlzLnJlYWRTeW5jKG8uZGF0YUlkKSxsPTA7bDxhOysrbCl7dmFyIGg9bCppLGY9bmV3IEZsb2F0MzJBcnJheShpLTEpO2ZbMF09Y1toXTtmb3IodmFyIGQ9MTtkPGYubGVuZ3RoOysrZClmW2RdPWZbZC0xXStjW2grZF07Zm9yKHZhciBwPWNyKHIudG9TdHJpbmcoKSksdj1sKm4sbT0wO208bjsrK20pe3ZhciBnPXAoKTt1W3YrbV09Zi5sZW5ndGg7Zm9yKHZhciB5PTA7eTxmLmxlbmd0aDt5KyspaWYoZzxmW3ldKXt1W3YrbV09eTticmVha319fXJldHVybiBzfSxvLnByb3RvdHlwZS5vbmVIb3Q9ZnVuY3Rpb24odCxlLG4scil7SGgodCxcIm9uZUhvdFwiKTt2YXIgbz1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSplKTtvLmZpbGwocik7Zm9yKHZhciBhPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGk9MDtpPHQuc2l6ZTsrK2kpYVtpXT49MCYmYVtpXTxlJiYob1tpKmUrYVtpXV09bik7cmV0dXJuIEJuKG8sW3Quc2l6ZSxlXSxcImludDMyXCIpfSxvLnByb3RvdHlwZS5ub25NYXhTdXBwcmVzc2lvbj1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiBIaCh0LFwibm9uTWF4U3VwcHJlc3Npb25cIiksam8odGhpcy5yZWFkU3luYyh0LmRhdGFJZCksdGhpcy5yZWFkU3luYyhlLmRhdGFJZCksbixyLG8pfSxvLnByb3RvdHlwZS5mZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmZ0QmF0Y2godCwhMSl9LG8ucHJvdG90eXBlLmlmZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmZ0QmF0Y2godCwhMCl9LG8ucHJvdG90eXBlLmZmdEJhdGNoPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuc2hhcGVbMF0scj10LnNoYXBlWzFdLG89ZHIodC5zaGFwZSxcImZsb2F0MzJcIiksYT1kcih0LnNoYXBlLFwiZmxvYXQzMlwiKSxpPVRuKHQpLmFzMkQobixyKSxzPU5uKHQpLmFzMkQobixyKSx1PTA7dTxuO3UrKylmb3IodmFyIGM9aS5zbGljZShbdSwwXSxbMSxyXSksbD1zLnNsaWNlKFt1LDBdLFsxLHJdKSxoPURuKGMsbCksZj10aGlzLnJlYWRTeW5jKHRoaXMuZmZ0SW1wbChoLGUpLmRhdGFJZCksZD0wO2Q8cjtkKyspe3ZhciBwPXpvKGYsZCk7by52YWx1ZXNbdSpyK2RdPXAucmVhbCxhLnZhbHVlc1t1KnIrZF09cC5pbWFnfXJldHVybiBEbihvLnRvVGVuc29yKCksYS50b1RlbnNvcigpKS5hczJEKG4scil9LG8ucHJvdG90eXBlLmZmdEltcGw9ZnVuY3Rpb24odCxlKXt2YXIgbj10LmFzMUQoKSxyPW4uc2l6ZTtpZih0aGlzLmlzRXhwb25lbnRPZjIocikpe3ZhciBvPXRoaXMuZmZ0UmFkaXgyKG4scixlKS5hczJEKHQuc2hhcGVbMF0sdC5zaGFwZVsxXSk7cmV0dXJuIGUmJihvPURuKFRuKG8pLmRpdihPbihyKSksTm4obykuZGl2KE9uKHIpKSkpLG99dmFyIGE9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksaT1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aC8yKSxuPW5ldyBGbG9hdDMyQXJyYXkodC5sZW5ndGgvMikscj0wO3I8dC5sZW5ndGg7cis9MillW3IvMl09dFtyXSxuW3IvMl09dFtyKzFdO3JldHVybntyZWFsOmUsaW1hZzpufX0odGhpcy5mb3VyaWVyVHJhbnNmb3JtQnlNYXRtdWwoYSxyLGUpKTtyZXR1cm4gRG4oaS5yZWFsLGkuaW1hZykuYXMyRCh0LnNoYXBlWzBdLHQuc2hhcGVbMV0pfSxvLnByb3RvdHlwZS5pc0V4cG9uZW50T2YyPWZ1bmN0aW9uKHQpe3JldHVybiAwPT0odCZ0LTEpfSxvLnByb3RvdHlwZS5mZnRSYWRpeDI9ZnVuY3Rpb24odCxlLG4pe2lmKDE9PT1lKXJldHVybiB0O3ZhciByPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG89ZS8yLGE9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPU1hdGguY2VpbCh0Lmxlbmd0aC80KSxuPW5ldyBGbG9hdDMyQXJyYXkoZSkscj1uZXcgRmxvYXQzMkFycmF5KGUpLG89MDtvPHQubGVuZ3RoO28rPTQpbltNYXRoLmZsb29yKG8vNCldPXRbb10scltNYXRoLmZsb29yKG8vNCldPXRbbysxXTtyZXR1cm57cmVhbDpuLGltYWc6cn19KHIpLGk9RG4oYS5yZWFsLGEuaW1hZykuYXMxRCgpLHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPU1hdGguZmxvb3IodC5sZW5ndGgvNCksbj1uZXcgRmxvYXQzMkFycmF5KGUpLHI9bmV3IEZsb2F0MzJBcnJheShlKSxvPTI7bzx0Lmxlbmd0aDtvKz00KW5bTWF0aC5mbG9vcihvLzQpXT10W29dLHJbTWF0aC5mbG9vcihvLzQpXT10W28rMV07cmV0dXJue3JlYWw6bixpbWFnOnJ9fShyKSx1PURuKHMucmVhbCxzLmltYWcpLmFzMUQoKTtpPXRoaXMuZmZ0UmFkaXgyKGksbyxuKSx1PXRoaXMuZmZ0UmFkaXgyKHUsbyxuKTt2YXIgYz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgRmxvYXQzMkFycmF5KHQvMikscj1uZXcgRmxvYXQzMkFycmF5KHQvMiksbz0wO288TWF0aC5jZWlsKHQvMik7bysrKXt2YXIgYT0oZT8yOi0yKSpNYXRoLlBJKihvL3QpO25bb109TWF0aC5jb3MoYSkscltvXT1NYXRoLnNpbihhKX1yZXR1cm57cmVhbDpuLGltYWc6cn19KGUsbiksbD1EbihjLnJlYWwsYy5pbWFnKS5tdWwodSksaD1pLmFkZChsKSxmPWkuc3ViKGwpLGQ9VG4oaCkuY29uY2F0KFRuKGYpKSxwPU5uKGgpLmNvbmNhdChObihmKSk7cmV0dXJuIERuKGQscCkuYXMxRCgpfSxvLnByb3RvdHlwZS5mb3VyaWVyVHJhbnNmb3JtQnlNYXRtdWw9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1uZXcgRmxvYXQzMkFycmF5KDIqZSksbz0wO288ZTtvKyspe2Zvcih2YXIgYT0wLGk9MCxzPTA7czxlO3MrKyl7dmFyIHU9SG8obypzLGUsbiksYz16byh0LHMpO2ErPWMucmVhbCp1LnJlYWwtYy5pbWFnKnUuaW1hZyxpKz1jLnJlYWwqdS5pbWFnK2MuaW1hZyp1LnJlYWx9biYmKGEvPWUsaS89ZSksR28ocixhLGksbyl9cmV0dXJuIHJ9LG8ucHJvdG90eXBlLmRlcHRoVG9TcGFjZT1mdW5jdGlvbih0LGUsbil7QyhcIk5IV0NcIj09PW4sKGZ1bmN0aW9uKCl7cmV0dXJuXCJPbmx5IE5IV0MgZGF0YUZvcm1hdCBzdXBwb3J0ZWQgb24gQ1BVIGZvciBkZXB0aFRvU3BhY2UuIEdvdCBcIitufSkpLEMoZT4xLChmdW5jdGlvbigpe3JldHVyblwiYmxvY2tTaXplIHNob3VsZCBiZSA+IDEgZm9yIGRlcHRoVG9TcGFjZSwgYnV0IHdhczogXCIrZX0pKTtmb3IodmFyIHI9dC5zaGFwZVswXSxvPXQuc2hhcGVbMV0sYT10LnNoYXBlWzJdLGk9dC5zaGFwZVszXSxzPW8qZSx1PWEqZSxjPWkvKGUqZSksbD10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxoPW5ldyBGbG9hdDMyQXJyYXkocipzKnUqYyksZj0wLGQ9MDtkPHI7KytkKWZvcih2YXIgcD0wO3A8czsrK3ApZm9yKHZhciB2PU1hdGguZmxvb3IocC9lKSxtPXAlZSxnPTA7Zzx1OysrZylmb3IodmFyIHk9TWF0aC5mbG9vcihnL2UpLHg9KG0qZStnJWUpKmMsYj0wO2I8YzsrK2Ipe3ZhciB3PWIreCtpKih5K2EqKHYrbypkKSk7aFtmKytdPWxbd119cmV0dXJuIExuKGgsW3Iscyx1LGNdKX0sby5wcm90b3R5cGUuYnJvYWRjYXN0ZWRCaW5hcnlPcD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1Sbyh0LnNoYXBlLGUuc2hhcGUpLGE9ZHIobyxuKSxpPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHM9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksdT1Dbyh0LnNoYXBlLG8pLGM9Q28oZS5zaGFwZSxvKSxsPWEudmFsdWVzO2lmKHUubGVuZ3RoK2MubGVuZ3RoPT09MClmb3IodmFyIGg9MDtoPGwubGVuZ3RoOysraClsW2hdPXIoaVtoJWkubGVuZ3RoXSxzW2glcy5sZW5ndGhdKTtlbHNle3ZhciBmPXRoaXMuYnVmZmVyU3luYyh0KSxkPXRoaXMuYnVmZmVyU3luYyhlKSxwPWZ1bmN0aW9uKG4pe3ZhciBvPWEuaW5kZXhUb0xvYyhuKSxoPW8uc2xpY2UoLXQucmFuayk7dS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gaFt0XT0wfSkpO3ZhciBwPWYubG9jVG9JbmRleChoKSx2PW8uc2xpY2UoLWUucmFuayk7Yy5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdlt0XT0wfSkpO3ZhciBtPWQubG9jVG9JbmRleCh2KTtsW25dPXIoaVtwXSxzW21dKX07Zm9yKGg9MDtoPGwubGVuZ3RoOysraClwKGgpfXJldHVybiBhLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmJyb2FkY2FzdGVkQmluYXJ5Q29tcGxleE9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1Sbyh0LnNoYXBlLGUuc2hhcGUpLG89ZHIocixcImZsb2F0MzJcIiksYT1kcihyLFwiZmxvYXQzMlwiKSxpPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHM9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksdT1Dbyh0LnNoYXBlLHIpLGM9Q28oZS5zaGFwZSxyKSxsPW8udmFsdWVzLGg9YS52YWx1ZXM7aWYodS5sZW5ndGgrYy5sZW5ndGg9PT0wKWZvcih2YXIgZj0wO2Y8bC5sZW5ndGg7ZisrKXt2YXIgZD1mJWkubGVuZ3RoLHA9ZiVzLmxlbmd0aCx2PW4oaVsyKmRdLGlbMipkKzFdLHNbMipwXSxzWzIqcCsxXSk7bFtmXT12LnJlYWwsaFtmXT12LmltYWd9ZWxzZXt2YXIgbT10aGlzLmJ1ZmZlclN5bmModGhpcy5kYXRhLmdldCh0LmRhdGFJZCkuY29tcGxleFRlbnNvcnMucmVhbCksZz10aGlzLmJ1ZmZlclN5bmModGhpcy5kYXRhLmdldChlLmRhdGFJZCkuY29tcGxleFRlbnNvcnMucmVhbCkseT1mdW5jdGlvbihyKXt2YXIgYT1vLmluZGV4VG9Mb2MociksZj1hLnNsaWNlKC10LnJhbmspO3UuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGZbdF09MH0pKTt2YXIgZD1tLmxvY1RvSW5kZXgoZikscD1hLnNsaWNlKC1lLnJhbmspO2MuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHBbdF09MH0pKTt2YXIgdj1nLmxvY1RvSW5kZXgocCkseT1uKGlbMipkXSxpWzIqZCsxXSxzWzIqdl0sc1syKnYrMV0pO2xbcl09eS5yZWFsLGhbcl09eS5pbWFnfTtmb3IoZj0wO2Y8bC5sZW5ndGg7ZisrKXkoZil9cmV0dXJuIHRoaXMuY29tcGxleChvLnRvVGVuc29yKCksYS50b1RlbnNvcigpKX0sby5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBabyh0LGUsbil9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt9LG8ucHJvdG90eXBlLmZsb2F0UHJlY2lzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuIDMyfSxvLnByb3RvdHlwZS5lcHNpbG9uPWZ1bmN0aW9uKCl7cmV0dXJuIDFlLTd9LG8ucHJvdG90eXBlLmNyb3BBbmRSZXNpemU9ZnVuY3Rpb24odCxlLG4scixvLGEpe2Zvcih2YXIgaT10LnNoYXBlLHM9aVswXSx1PWlbMV0sYz1pWzJdLGw9aVszXSxoPWUuc2hhcGVbMF0sZj1yWzBdLGQ9clsxXSxwPWRyKFtoLGYsZCxsXSxcImZsb2F0MzJcIiksdj10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxtPXRoaXMucmVhZFN5bmMobi5kYXRhSWQpLGc9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkseT10LnN0cmlkZXMseD1wLnN0cmlkZXMsYj0wO2I8aDtiKyspe3ZhciB3PTQqYixDPXZbd10sRT12W3crMV0sUj12W3crMl0sST12W3crM10saz1tW2JdO2lmKCEoaz49cykpZm9yKHZhciBTPWY+MT8oUi1DKSoodS0xKS8oZi0xKTowLEE9ZD4xPyhJLUUpKihjLTEpLyhkLTEpOjAsRD0wO0Q8ZjtEKyspe3ZhciBUPWY+MT9DKih1LTEpK0QqUzouNSooQytSKSoodS0xKTtpZihUPDB8fFQ+dS0xKWZvcih2YXIgTj0wO048ZDtOKyspZm9yKHZhciBGPTA7RjxsO0YrKyl7dmFyIF89RitOKnhbMl0rRCp4WzFdK2IqeFswXTtwLnZhbHVlc1tfXT1hfWVsc2UgaWYoXCJiaWxpbmVhclwiPT09byl7dmFyIE89TWF0aC5mbG9vcihUKSxNPU1hdGguY2VpbChUKSxCPVQtTztmb3IoTj0wO048ZDtOKyspe2lmKChxPWQ+MT9FKihjLTEpK04qQTouNSooRStJKSooYy0xKSk8MHx8cT5jLTEpZm9yKEY9MDtGPGw7RisrKXtfPUYrTip4WzJdK0QqeFsxXStiKnhbMF07cC52YWx1ZXNbX109YX1lbHNle3ZhciBQPU1hdGguZmxvb3IocSksTD1NYXRoLmNlaWwocSksVz1xLVA7Zm9yKEY9MDtGPGw7RisrKXt2YXIgVT1nW189RitQKnlbMl0rTyp5WzFdK2sqeVswXV0sVj1nW189RitMKnlbMl0rTyp5WzFdK2sqeVswXV0sej1nW189RitQKnlbMl0rTSp5WzFdK2sqeVswXV0sRz1VKyhWLVUpKlcsSD16KyhnW189RitMKnlbMl0rTSp5WzFdK2sqeVswXV0teikqVztfPUYrTip4WzJdK0QqeFsxXStiKnhbMF0scC52YWx1ZXNbX109RysoSC1HKSpCfX19fWVsc2UgZm9yKE49MDtOPGQ7KytOKXt2YXIgcTtpZigocT1kPjE/RSooYy0xKStOKkE6LjUqKEUrSSkqKGMtMSkpPDB8fHE+Yy0xKWZvcihGPTA7RjxsO0YrKyl7Xz1GK04qeFsyXStEKnhbMV0rYip4WzBdO3AudmFsdWVzW19dPWF9ZWxzZXt2YXIgSz1NYXRoLnJvdW5kKHEpLGo9TWF0aC5yb3VuZChUKTtmb3IoRj0wO0Y8bDtGKyspe3ZhciBYPUYrSyp5WzJdK2oqeVsxXStrKnlbMF0sWT1GK04qeFsyXStEKnhbMV0rYip4WzBdO3AudmFsdWVzW1ldPWdbWF19fX19fXJldHVybiBwLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLnNwYXJzZVRvRGVuc2U9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89WnIoMCx0LG4pLGE9by5zbGljZVJhbmssaT1vLm51bVVwZGF0ZXMscz1vLnNsaWNlU2l6ZSx1PW8uc3RyaWRlcyxjPW8ub3V0cHV0U2l6ZTtyZXR1cm4gdGhpcy5zY2F0dGVyKHQsZSxuLGMscyxpLGEsdSxyLCExKX0sby5wcm90b3R5cGUuZ2F0aGVyTkQ9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLnNoYXBlLHI9bltuLmxlbmd0aC0xXSxvPWpyKHQsZSksYT1vWzBdLGk9b1sxXSxzPW9bMl0sdT1vWzNdO2lmKDA9PT1pKXJldHVybiBGbihbXSxhLHQuZHR5cGUpO2Zvcih2YXIgYz1uZXcgZ3QoW2ksc10sdC5kdHlwZSksbD10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxoPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGY9MDtmPGk7ZisrKXtmb3IodmFyIGQ9W10scD0wLHY9MDt2PHI7disrKXt2YXIgbT1sW2Yqcit2XTtwKz1tKnVbdl0sZC5wdXNoKG0pfWlmKHA8MHx8cD49dC5zaXplL3MpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRpY2VzOiBcIitkK1wiIGRvZXMgbm90IGluZGV4IGludG8gXCIrdC5zaGFwZSk7Zm9yKHZhciBnPTA7ZzxzO2crKyljLnZhbHVlc1tmKnMrZ109aFtwKnMrZ119cmV0dXJuIGMudG9UZW5zb3IoKS5yZXNoYXBlKGEpfSxvLnByb3RvdHlwZS5zY2F0dGVyTkQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPVpyKDAsdCxuKSxvPXIuc2xpY2VSYW5rLGE9ci5udW1VcGRhdGVzLGk9ci5zbGljZVNpemUscz1yLnN0cmlkZXMsdT1yLm91dHB1dFNpemUsYz1PbigwKTtyZXR1cm4gdGhpcy5zY2F0dGVyKHQsZSxuLHUsaSxhLG8scyxjLCEwKX0sby5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbih0LGUsbil7dmFyIHI9UChuPW58fGooZSksayh0KSk7cmV0dXJuIHIuZmlsbChlKSxMdC5tYWtlVGVuc29yKHIsdCxuLHRoaXMpfSxvLnByb3RvdHlwZS5vbmVzTGlrZT1mdW5jdGlvbih0KXtpZihcInN0cmluZ1wiPT09dC5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJvbmVzTGlrZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBzdHJpbmcgdGVuc29yc1wiKTtyZXR1cm4gdGhpcy5maWxsKHQuc2hhcGUsMSx0LmR0eXBlKX0sby5wcm90b3R5cGUuemVyb3NMaWtlPWZ1bmN0aW9uKHQpe3ZhciBlPVAodC5kdHlwZSxrKHQuc2hhcGUpKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSx0LmR0eXBlKX0sby5wcm90b3R5cGUubGluc3BhY2U9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBXbyh0LGUsbil9LG8ucHJvdG90eXBlLnNjYXR0ZXI9ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzLHUsYyl7dmFyIGw9W3IvbyxvXSxoPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGY9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCk7aWYoMD09PXIpcmV0dXJuIEZuKFtdLG4sZS5kdHlwZSk7dmFyIGQ9bmV3IGd0KGwsZS5kdHlwZSk7ZC52YWx1ZXMuZmlsbCh0aGlzLnJlYWRTeW5jKHUuZGF0YUlkKVswXSk7Zm9yKHZhciBwPTA7cDxhO3ArKyl7Zm9yKHZhciB2PVtdLG09MCxnPTA7ZzxpO2crKyl7dmFyIHk9aFtwKmkrZ107di5wdXNoKHkpLG0rPXkqc1tnXX1pZihtPDB8fG0+PXIvbyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGljZXM6IFwiK3YrXCIgZG9lcyBub3QgaW5kZXggaW50byBcIituKTtmb3IodmFyIHg9MDt4PG87eCsrKWM/ZC52YWx1ZXNbbSpvK3hdKz1mW3Aqbyt4XTpkLnZhbHVlc1ttKm8reF09MD09PWUucmFuaz9mWzBdOmZbcCpvK3hdfXJldHVybiBkLnRvVGVuc29yKCkucmVzaGFwZShuKX0sb30oYm8pO0x0LnJlZ2lzdGVyQmFja2VuZChcImNwdVwiLChmdW5jdGlvbigpe3JldHVybiBuZXcgS2h9KSwxKTtmb3IodmFyIGpoPTAsWGg9W3trZXJuZWxOYW1lOlwiTm9uTWF4U3VwcHJlc3Npb25WNVwiLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpmdW5jdGlvbih0KXt2YXIgZT10LmlucHV0cyxuPXQuYmFja2VuZCxyPXQuYXR0cnMsbz1lLGE9by5ib3hlcyxpPW8uc2NvcmVzLHM9cix1PXMubWF4T3V0cHV0U2l6ZSxjPXMuaW91VGhyZXNob2xkLGw9cy5zY29yZVRocmVzaG9sZCxoPXMuc29mdE5tc1NpZ21hLGY9bjtIaChhLFwiTm9uTWF4U3VwcHJlc3Npb25XaXRoU2NvcmVcIik7dmFyIGQ9WG8oZi5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLGYuZGF0YS5nZXQoaS5kYXRhSWQpLnZhbHVlcyx1LGMsbCxoKTtyZXR1cm5bZC5zZWxlY3RlZEluZGljZXMsZC5zZWxlY3RlZFNjb3Jlc119fSx7a2VybmVsTmFtZTpcIlNxdWFyZVwiLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpmdW5jdGlvbih0KXt2YXIgZT10LmlucHV0cyxuPXQuYmFja2VuZCxyPWUueCxvPW47SGgocixcInNxdWFyZVwiKTtmb3IodmFyIGE9by5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLGk9bmV3IEZsb2F0MzJBcnJheShhLmxlbmd0aCkscz0wO3M8YS5sZW5ndGg7KytzKXt2YXIgdT1hW3NdO2lbc109dSp1fXJldHVybntkYXRhSWQ6by53cml0ZShpLHIuc2hhcGUsci5kdHlwZSksc2hhcGU6ci5zaGFwZSxkdHlwZTpyLmR0eXBlfX19LHtrZXJuZWxOYW1lOmV1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpmdW5jdGlvbih0KXt2YXIgZT10LmlucHV0cyxuPXQuYmFja2VuZCxyPWUsbz1yLmEsYT1yLmIsaT1uO0hoKFtvLGFdLGV1KTt2YXIgcz1pLmRhdGEuZ2V0KG8uZGF0YUlkKS52YWx1ZXMsdT1pLmRhdGEuZ2V0KGEuZGF0YUlkKS52YWx1ZXMsYz1mdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9Um8odCxlKSxzPWkubGVuZ3RoLHU9JChpKSxjPUIobyxrKGkpKSxsPXQubGVuZ3RoLGg9ZS5sZW5ndGgsZj0kKHQpLGQ9JChlKSxwPUNvKHQsaSksdj1DbyhlLGkpO2lmKHAubGVuZ3RoK3YubGVuZ3RoPT09MClmb3IodmFyIG09MDttPGMubGVuZ3RoOysrbSljW21dPWEoblttJW4ubGVuZ3RoXSxyW20lci5sZW5ndGhdKTtlbHNle3ZhciBnPWZ1bmN0aW9uKHQpe3ZhciBlPWl0KHQscyx1KSxvPWUuc2xpY2UoLWwpO3AuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIG9bdF09MH0pKTt2YXIgaT1hdChvLGwsZiksbT1lLnNsaWNlKC1oKTt2LmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBtW3RdPTB9KSk7dmFyIGc9YXQobSxoLGQpO2NbdF09YShuW2ldLHJbZ10pfTtmb3IobT0wO208Yy5sZW5ndGg7KyttKWcobSl9cmV0dXJuW2MsaV19KG8uc2hhcGUsYS5zaGFwZSxzLHUsby5kdHlwZSwoZnVuY3Rpb24odCxlKXt2YXIgbj10LWU7cmV0dXJuIG4qbn0pKSxsPWNbMF0saD1jWzFdO3JldHVybntkYXRhSWQ6aS53cml0ZShsLGgsby5kdHlwZSksc2hhcGU6aCxkdHlwZTpvLmR0eXBlfX19XTtqaDxYaC5sZW5ndGg7amgrKyl7ZChYaFtqaF0pfXZhciBZaCwkaD1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTt2YXIgZT11YSgpLG49dFswXSxyPXRbMV07dGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB0ZXhSID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHRleEMgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgZGVwdGggPSBjb29yZHNbMl07XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMihcIityK1wiLjAsIFwiK24rXCIuMCk7XFxuXFxuICAgICAgICB2ZWM0IHZhbHVlcyA9IFwiK2UudGV4dHVyZTJEK1wiKEEsIHV2KTtcXG4gICAgICAgIGZsb2F0IHZhbHVlO1xcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMucjtcXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMSkge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5nO1xcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAyKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmI7XFxuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDMpIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuYTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNldE91dHB1dChmbG9vcih2YWx1ZSAqIDI1NS4wICsgMC41KSk7XFxuICAgICAgfVxcbiAgICBcIn0sUWg9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITEsdGhpcy5wYWNrZWRPdXRwdXQ9ITA7dmFyIGU9dWEoKSxuPXRbMF0scj10WzFdO3RoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgdGV4UiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCB0ZXhDID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGRlcHRoID0gY29vcmRzWzJdO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG5cXG4gICAgICAgIGZvcihpbnQgcm93PTA7IHJvdzw9MTsgcm93KyspIHtcXG4gICAgICAgICAgZm9yKGludCBjb2w9MDsgY29sPD0xOyBjb2wrKykge1xcbiAgICAgICAgICAgIHRleEMgPSBjb29yZHNbMV0gKyByb3c7XFxuICAgICAgICAgICAgZGVwdGggPSBjb29yZHNbMl0gKyBjb2w7XFxuXFxuICAgICAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK3IrXCIuMCwgXCIrbitcIi4wKTtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IFwiK2UudGV4dHVyZTJEK1wiKEEsIHV2KTtcXG4gICAgICAgICAgICBmbG9hdCB2YWx1ZTtcXG4gICAgICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXMucjtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDEpIHtcXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmc7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAyKSB7XFxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5iO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMykge1xcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuYTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmVzdWx0W3JvdyAqIDIgKyBjb2xdID0gZmxvb3IodmFsdWUgKiAyNTUuMCArIDAuNSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFwiK2Uub3V0cHV0K1wiID0gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgXCJ9O2Zvcih2YXIgSmg9MCxaaD1be2tlcm5lbE5hbWU6XCJGcm9tUGl4ZWxzXCIsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnB1dHMsbj10LmJhY2tlbmQscj10LmF0dHJzLG89ZS5waXhlbHMsYT1yLm51bUNoYW5uZWxzLHM9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEhUTUxWaWRlb0VsZW1lbnQmJm8gaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50LHU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQmJm8gaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50LGM9cz9bby52aWRlb1dpZHRoLG8udmlkZW9IZWlnaHRdOltvLndpZHRoLG8uaGVpZ2h0XSxsPWNbMF0saD1jWzFdLGY9W2gsbF0sZD1baCxsLGFdOyh1fHxzKSYmKG51bGw9PVloJiYoWWg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIikpLFloLmNhbnZhcy53aWR0aD1sLFloLmNhbnZhcy5oZWlnaHQ9aCxZaC5kcmF3SW1hZ2UobywwLDAsbCxoKSxvPVloLmNhbnZhcyk7dmFyIHA9bi5tYWtlVGVuc29ySW5mbyhmLFwiaW50MzJcIik7bi50ZXhEYXRhLmdldChwLmRhdGFJZCkudXNhZ2U9enQuUElYRUxTLG4uZ3BncHUudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKG4uZ2V0VGV4dHVyZShwLmRhdGFJZCksbyk7dmFyIHY9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpP25ldyBRaChkKTpuZXcgJGgoZCksbT1uLnJ1bldlYkdMUHJvZ3JhbSh2LFtwXSxcImludDMyXCIpO3JldHVybiBuLmRpc3Bvc2VEYXRhKHAuZGF0YUlkKSxtfX0se2tlcm5lbE5hbWU6XCJOb25NYXhTdXBwcmVzc2lvblY1XCIsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnB1dHMsbj10LmJhY2tlbmQscj10LmF0dHJzO2RuKFwidGYubm9uTWF4U3VwcHJlc3Npb24oKSBpbiB3ZWJnbCBsb2NrcyB0aGUgVUkgdGhyZWFkLiBDYWxsIHRmLm5vbk1heFN1cHByZXNzaW9uQXN5bmMoKSBpbnN0ZWFkXCIpO3ZhciBvPWUsYT1vLmJveGVzLGk9by5zY29yZXMscz1yLHU9cy5tYXhPdXRwdXRTaXplLGM9cy5pb3VUaHJlc2hvbGQsbD1zLnNjb3JlVGhyZXNob2xkLGg9cy5zb2Z0Tm1zU2lnbWEsZj1uLGQ9WG8oZi5yZWFkU3luYyhhLmRhdGFJZCksZi5yZWFkU3luYyhpLmRhdGFJZCksdSxjLGwsaCk7cmV0dXJuW2Quc2VsZWN0ZWRJbmRpY2VzLGQuc2VsZWN0ZWRTY29yZXNdfX0se2tlcm5lbE5hbWU6XCJTcXVhcmVcIixiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmdW5jdGlvbih0KXt2YXIgZT10LmlucHV0cyxuPXQuYmFja2VuZCxyPWUueCxvPW4sYT1uZXcgQ3Moci5zaGFwZSxcInJldHVybiB4ICogeDtcIik7cmV0dXJuIG8ucnVuV2ViR0xQcm9ncmFtKGEsW3JdLHIuZHR5cGUpfX0se2tlcm5lbE5hbWU6ZXUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnB1dHMsbj10LmJhY2tlbmQscj1lLG89ci5hLGE9ci5iLHM9bix1PWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgTGEoXCJyZXR1cm4gKGEgLSBiKSAqIChhIC0gYik7XCIsby5zaGFwZSxhLnNoYXBlKTpuZXcgQmEoXCJyZXR1cm4gKGEgLSBiKSAqIChhIC0gYik7XCIsby5zaGFwZSxhLnNoYXBlKTtyZXR1cm4gcy5jb21waWxlQW5kUnVuKHUsW28sYV0pfX1dO0poPFpoLmxlbmd0aDtKaCsrKXtkKFpoW0poXSl9Zm9yKHZhciB0Zj0wLGVmPVt7a2VybmVsTmFtZTpcIlNxdWFyZVwiLGdyYWRGdW5jOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLnRvRmxvYXQoKS5tdWwoMikpfX19fSx7a2VybmVsTmFtZTpldSxncmFkRnVuYzpmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdLG89T24oMik7cmV0dXJue2E6ZnVuY3Rpb24oKXtyZXR1cm4gZ2ModCxnYyhvLENjKG4scikpKX0sYjpmdW5jdGlvbigpe3JldHVybiBnYyh0LGdjKG8sQ2MocixuKSkpfX19fV07dGY8ZWYubGVuZ3RoO3RmKyspe3AoZWZbdGZdKX12YXIgbmY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5mZXRjaD1mdW5jdGlvbih0LGUpe3JldHVybiBmZXRjaCh0LGUpfSx0LnByb3RvdHlwZS5ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9LHQucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKFwidXRmLThcIiE9PWUmJlwidXRmOFwiIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyJ3MgZW5jb2RlciBvbmx5IHN1cHBvcnRzIHV0Zi04LCBidXQgZ290IFwiK2UpO3JldHVybiBudWxsPT10aGlzLnRleHRFbmNvZGVyJiYodGhpcy50ZXh0RW5jb2Rlcj1uZXcgVGV4dEVuY29kZXIpLHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKHQpfSx0LnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IFRleHREZWNvZGVyKGUpLmRlY29kZSh0KX0sdH0oKTtpKCkuZ2V0KFwiSVNfQlJPV1NFUlwiKSYmaSgpLnNldFBsYXRmb3JtKFwiYnJvd3NlclwiLG5ldyBuZik7dmFyIHJmLG9mPWZ1bmN0aW9uKCl7cmV0dXJuIHJlcXVpcmUoXCJub2RlLWZldGNoXCIpfSxhZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLnV0aWw9cmVxdWlyZShcInV0aWxcIiksdGhpcy50ZXh0RW5jb2Rlcj1uZXcgdGhpcy51dGlsLlRleHRFbmNvZGVyfXJldHVybiB0LnByb3RvdHlwZS5mZXRjaD1mdW5jdGlvbih0LGUpe3JldHVybiBudWxsIT1pKCkuZ2xvYmFsLmZldGNoP2koKS5nbG9iYWwuZmV0Y2godCxlKToobnVsbD09cmYmJihyZj1vZigpKSxyZih0LGUpKX0sdC5wcm90b3R5cGUubm93PWZ1bmN0aW9uKCl7dmFyIHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKnRbMF0rdFsxXS8xZTZ9LHQucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKFwidXRmLThcIiE9PWUmJlwidXRmOFwiIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGJ1aWx0LWluIGVuY29kZXIgb25seSBzdXBwb3J0cyB1dGYtOCwgYnV0IGdvdCBcIitlKTtyZXR1cm4gdGhpcy50ZXh0RW5jb2Rlci5lbmNvZGUodCl9LHQucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiAwPT09dC5sZW5ndGg/XCJcIjpuZXcgdGhpcy51dGlsLlRleHREZWNvZGVyKGUpLmRlY29kZSh0KX0sdH0oKTtpKCkuZ2V0KFwiSVNfTk9ERVwiKSYmaSgpLnNldFBsYXRmb3JtKFwibm9kZVwiLG5ldyBhZik7dmFyIHNmPXtmbG9hdDMyOjQsaW50MzI6NCx1aW50MTY6Mix1aW50ODoxLGJvb2w6MX0sdWY9NDtmdW5jdGlvbiBjZih0LGUpe2Zvcih2YXIgbj17fSxyPTAsbz1mdW5jdGlvbihlKXt2YXIgbz1lLm5hbWUsYT1lLmR0eXBlLGk9ZS5zaGFwZSxzPWsoaSksdT12b2lkIDA7aWYoXCJxdWFudGl6YXRpb25cImluIGUpe3ZhciBjPWUucXVhbnRpemF0aW9uO2lmKFwidWludDhcIiE9PWMuZHR5cGUmJlwidWludDE2XCIhPT1jLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIldlaWdodCBcIitlLm5hbWUrXCIgaGFzIHVua25vd24gcXVhbnRpemF0aW9uIGR0eXBlIFwiK2MuZHR5cGUrXCIuIFN1cHBvcnRlZCBxdWFudGl6YXRpb24gZHR5cGVzIGFyZTogJ3VpbnQ4JyBhbmQgJ3VpbnQxNicuXCIpO3ZhciBsPXNmW2MuZHR5cGVdLGg9dC5zbGljZShyLHIrcypsKSxmPVwidWludDhcIj09PWMuZHR5cGU/bmV3IFVpbnQ4QXJyYXkoaCk6bmV3IFVpbnQxNkFycmF5KGgpO2lmKFwiZmxvYXQzMlwiPT09YSl1PUZsb2F0MzJBcnJheS5mcm9tKGYsKGZ1bmN0aW9uKHQpe3JldHVybiB0KmMuc2NhbGUrYy5taW59KSk7ZWxzZXtpZihcImludDMyXCIhPT1hKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnXCIrbytcIic6IFwiK2EpO3U9SW50MzJBcnJheS5mcm9tKGYsKGZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnJvdW5kKHQqYy5zY2FsZStjLm1pbil9KSl9cis9cypsfWVsc2UgaWYoXCJzdHJpbmdcIj09PWEpe3ZhciBkPWsoZS5zaGFwZSk7dT1bXTtmb3IodmFyIHA9MDtwPGQ7cCsrKXt2YXIgdj1uZXcgVWludDMyQXJyYXkodC5zbGljZShyLHIrdWYpKVswXTtyKz11Zjt2YXIgbT1uZXcgVWludDhBcnJheSh0LnNsaWNlKHIscit2KSk7dS5wdXNoKG0pLHIrPXZ9fWVsc2V7dmFyIGc9c2ZbYV07aD10LnNsaWNlKHIscitzKmcpO2lmKFwiZmxvYXQzMlwiPT09YSl1PW5ldyBGbG9hdDMyQXJyYXkoaCk7ZWxzZSBpZihcImludDMyXCI9PT1hKXU9bmV3IEludDMyQXJyYXkoaCk7ZWxzZXtpZihcImJvb2xcIiE9PWEpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZHR5cGUgaW4gd2VpZ2h0ICdcIitvK1wiJzogXCIrYSk7dT1uZXcgVWludDhBcnJheShoKX1yKz1zKmd9bltvXT1Gbih1LGksYSl9LGE9MCxpPWU7YTxpLmxlbmd0aDthKyspe28oaVthXSl9cmV0dXJuIG59ZnVuY3Rpb24gbGYodCl7aWYobnVsbD09PXQpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB2YWx1ZTogXCIrSlNPTi5zdHJpbmdpZnkodCkpO3ZhciBlPTAsbj1bXTt0LmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKGUrPXQuYnl0ZUxlbmd0aCxuLnB1c2godC5ieXRlTGVuZ3RoPT09dC5idWZmZXIuYnl0ZUxlbmd0aD90Om5ldyB0LmNvbnN0cnVjdG9yKHQpKSwhKHQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBJbnQzMkFycmF5fHx0IGluc3RhbmNlb2YgVWludDhBcnJheSkpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgVHlwZWRBcnJheSBzdWJ0eXBlOiBcIit0LmNvbnN0cnVjdG9yLm5hbWUpfSkpO3ZhciByPW5ldyBVaW50OEFycmF5KGUpLG89MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbih0KXtyLnNldChuZXcgVWludDhBcnJheSh0LmJ1ZmZlciksbyksbys9dC5ieXRlTGVuZ3RofSkpLHIuYnVmZmVyfXZhciBoZj1cInVuZGVmaW5lZFwiIT10eXBlb2YgQnVmZmVyJiYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEJsb2J8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBhdG9ifHxcInVuZGVmaW5lZFwiPT10eXBlb2YgYnRvYSk7ZnVuY3Rpb24gZmYodCl7cmV0dXJuIGhmP0J1ZmZlci5ieXRlTGVuZ3RoKHQpOm5ldyBCbG9iKFt0XSkuc2l6ZX1mdW5jdGlvbiBkZih0KXt2YXIgZT0wO3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZSs9dC5ieXRlTGVuZ3RofSkpO3ZhciBuPW5ldyBVaW50OEFycmF5KGUpLHI9MDtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXtuLnNldChuZXcgVWludDhBcnJheSh0KSxyKSxyKz10LmJ5dGVMZW5ndGh9KSksbi5idWZmZXJ9ZnVuY3Rpb24gcGYodCl7Zm9yKHQ9dC50cmltKCk7dC5lbmRzV2l0aChcIi9cIik7KXQ9dC5zbGljZSgwLHQubGVuZ3RoLTEpO3ZhciBlPXQuc3BsaXQoXCIvXCIpO3JldHVybiBlW2UubGVuZ3RoLTFdfWZ1bmN0aW9uIHZmKHQpe2lmKHQubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIEpTT04gbW9kZWwgdG9wb2xvZ3ksIHJlY2VpdmVkIEFycmF5QnVmZmVyLlwiKTtyZXR1cm57ZGF0ZVNhdmVkOm5ldyBEYXRlLG1vZGVsVG9wb2xvZ3lUeXBlOlwiSlNPTlwiLG1vZGVsVG9wb2xvZ3lCeXRlczpudWxsPT10Lm1vZGVsVG9wb2xvZ3k/MDpmZihKU09OLnN0cmluZ2lmeSh0Lm1vZGVsVG9wb2xvZ3kpKSx3ZWlnaHRTcGVjc0J5dGVzOm51bGw9PXQud2VpZ2h0U3BlY3M/MDpmZihKU09OLnN0cmluZ2lmeSh0LndlaWdodFNwZWNzKSksd2VpZ2h0RGF0YUJ5dGVzOm51bGw9PXQud2VpZ2h0RGF0YT8wOnQud2VpZ2h0RGF0YS5ieXRlTGVuZ3RofX12YXIgbWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5zYXZlUm91dGVycz1bXSx0aGlzLmxvYWRSb3V0ZXJzPVtdfXJldHVybiB0LmdldEluc3RhbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PXQuaW5zdGFuY2UmJih0Lmluc3RhbmNlPW5ldyB0KSx0Lmluc3RhbmNlfSx0LnJlZ2lzdGVyU2F2ZVJvdXRlcj1mdW5jdGlvbihlKXt0LmdldEluc3RhbmNlKCkuc2F2ZVJvdXRlcnMucHVzaChlKX0sdC5yZWdpc3RlckxvYWRSb3V0ZXI9ZnVuY3Rpb24oZSl7dC5nZXRJbnN0YW5jZSgpLmxvYWRSb3V0ZXJzLnB1c2goZSl9LHQuZ2V0U2F2ZUhhbmRsZXJzPWZ1bmN0aW9uKGUpe3JldHVybiB0LmdldEhhbmRsZXJzKGUsXCJzYXZlXCIpfSx0LmdldExvYWRIYW5kbGVycz1mdW5jdGlvbihlLG4pe3JldHVybiB0LmdldEhhbmRsZXJzKGUsXCJsb2FkXCIsbil9LHQuZ2V0SGFuZGxlcnM9ZnVuY3Rpb24oZSxuLHIpe3ZhciBvPVtdO3JldHVybihcImxvYWRcIj09PW4/dC5nZXRJbnN0YW5jZSgpLmxvYWRSb3V0ZXJzOnQuZ2V0SW5zdGFuY2UoKS5zYXZlUm91dGVycykuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIG49dChlLHIpO251bGwhPT1uJiZvLnB1c2gobil9KSksb30sdH0oKSxnZj1cIjovL1wiLHlmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMubWFuYWdlcnM9e319cmV0dXJuIHQuZ2V0SW5zdGFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dC5pbnN0YW5jZSYmKHQuaW5zdGFuY2U9bmV3IHQpLHQuaW5zdGFuY2V9LHQucmVnaXN0ZXJNYW5hZ2VyPWZ1bmN0aW9uKGUsbil7QyhudWxsIT1lLChmdW5jdGlvbigpe3JldHVyblwic2NoZW1lIG11c3Qgbm90IGJlIHVuZGVmaW5lZCBvciBudWxsLlwifSkpLGUuZW5kc1dpdGgoZ2YpJiYoZT1lLnNsaWNlKDAsZS5pbmRleE9mKGdmKSkpLEMoZS5sZW5ndGg+MCwoZnVuY3Rpb24oKXtyZXR1cm5cInNjaGVtZSBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcuXCJ9KSk7dmFyIHI9dC5nZXRJbnN0YW5jZSgpO0MobnVsbD09ci5tYW5hZ2Vyc1tlXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkEgbW9kZWwgc3RvcmUgbWFuYWdlciBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIHNjaGVtZSAnXCIrZStcIicuXCJ9KSksci5tYW5hZ2Vyc1tlXT1ufSx0LmdldE1hbmFnZXI9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRJbnN0YW5jZSgpLm1hbmFnZXJzW3RdO2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kZWwgbWFuYWdlciBmb3Igc2NoZW1lICdcIit0K1wiJ1wiKTtyZXR1cm4gZX0sdC5nZXRTY2hlbWVzPWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0SW5zdGFuY2UoKS5tYW5hZ2Vycyl9LHR9KCk7ZnVuY3Rpb24geGYodCl7aWYoLTE9PT10LmluZGV4T2YoZ2YpKXRocm93IG5ldyBFcnJvcihcIlRoZSB1cmwgc3RyaW5nIHByb3ZpZGVkIGRvZXMgbm90IGNvbnRhaW4gYSBzY2hlbWUuIFN1cHBvcnRlZCBzY2hlbWVzIGFyZTogXCIreWYuZ2V0U2NoZW1lcygpLmpvaW4oXCIsXCIpKTtyZXR1cm57c2NoZW1lOnQuc3BsaXQoZ2YpWzBdLHBhdGg6dC5zcGxpdChnZilbMV19fWZ1bmN0aW9uIGJmKHQsZSxvKXtyZXR1cm4gdm9pZCAwPT09byYmKG89ITEpLG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLGEsaSxzLHUsYyxsLGgsZjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiBDKHQhPT1lLChmdW5jdGlvbigpe3JldHVyblwiT2xkIHBhdGggYW5kIG5ldyBwYXRoIGFyZSB0aGUgc2FtZTogJ1wiK3QrXCInXCJ9KSksQygobj1tZi5nZXRMb2FkSGFuZGxlcnModCkpLmxlbmd0aD4wLChmdW5jdGlvbigpe3JldHVyblwiQ29weWluZyBmYWlsZWQgYmVjYXVzZSBubyBsb2FkIGhhbmRsZXIgaXMgZm91bmQgZm9yIHNvdXJjZSBVUkwgXCIrdCtcIi5cIn0pKSxDKG4ubGVuZ3RoPDIsKGZ1bmN0aW9uKCl7cmV0dXJuXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG1vcmUgdGhhbiBvbmUgKFwiK24ubGVuZ3RoK1wiKSBsb2FkIGhhbmRsZXJzIGZvciBzb3VyY2UgVVJMIFwiK3QrXCIuXCJ9KSksYT1uWzBdLEMoKGk9bWYuZ2V0U2F2ZUhhbmRsZXJzKGUpKS5sZW5ndGg+MCwoZnVuY3Rpb24oKXtyZXR1cm5cIkNvcHlpbmcgZmFpbGVkIGJlY2F1c2Ugbm8gc2F2ZSBoYW5kbGVyIGlzIGZvdW5kIGZvciBkZXN0aW5hdGlvbiBVUkwgXCIrZStcIi5cIn0pKSxDKGkubGVuZ3RoPDIsKGZ1bmN0aW9uKCl7cmV0dXJuXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG1vcmUgdGhhbiBvbmUgKFwiK24ubGVuZ3RoK1wiKSBzYXZlIGhhbmRsZXJzIGZvciBkZXN0aW5hdGlvbiBVUkwgXCIrZStcIi5cIn0pKSxzPWlbMF0sdT14Zih0KS5zY2hlbWUsYz14Zih0KS5wYXRoLGw9dT09PXhmKHQpLnNjaGVtZSxbNCxhLmxvYWQoKV07Y2FzZSAxOnJldHVybiBoPXIuc2VudCgpLG8mJmw/WzQseWYuZ2V0TWFuYWdlcih1KS5yZW1vdmVNb2RlbChjKV06WzMsM107Y2FzZSAyOnIuc2VudCgpLHIubGFiZWw9MztjYXNlIDM6cmV0dXJuWzQscy5zYXZlKGgpXTtjYXNlIDQ6cmV0dXJuIGY9ci5zZW50KCksIW98fGw/WzMsNl06WzQseWYuZ2V0TWFuYWdlcih1KS5yZW1vdmVNb2RlbChjKV07Y2FzZSA1OnIuc2VudCgpLHIubGFiZWw9NjtjYXNlIDY6cmV0dXJuWzIsZi5tb2RlbEFydGlmYWN0c0luZm9dfX0pKX0pKX12YXIgd2Y9XCJtb2RlbHNfc3RvcmVcIixDZj1cIm1vZGVsX2luZm9fc3RvcmVcIjtmdW5jdGlvbiBFZigpe2lmKCFpKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIG9idGFpbiBJbmRleGVkREIgZmFjdG9yeSBiZWNhdXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50aXMgbm90IGEgd2ViIGJyb3dzZXIuXCIpO3ZhciB0PXdpbmRvd3x8c2VsZixlPXQuaW5kZXhlZERCfHx0Lm1vekluZGV4ZWREQnx8dC53ZWJraXRJbmRleGVkREJ8fHQubXNJbmRleGVkREJ8fHQuc2hpbUluZGV4ZWREQjtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IGJyb3dzZXIgZG9lcyBub3QgYXBwZWFyIHRvIHN1cHBvcnQgSW5kZXhlZERCLlwiKTtyZXR1cm4gZX1mdW5jdGlvbiBSZih0KXt2YXIgZT10LnJlc3VsdDtlLmNyZWF0ZU9iamVjdFN0b3JlKHdmLHtrZXlQYXRoOlwibW9kZWxQYXRoXCJ9KSxlLmNyZWF0ZU9iamVjdFN0b3JlKENmLHtrZXlQYXRoOlwibW9kZWxQYXRoXCJ9KX12YXIgSWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHRoaXMuaW5kZXhlZERCPUVmKCksbnVsbD09dHx8IXQpdGhyb3cgbmV3IEVycm9yKFwiRm9yIEluZGV4ZWREQiwgbW9kZWxQYXRoIG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciBlbXB0eS5cIik7dGhpcy5tb2RlbFBhdGg9dH1yZXR1cm4gdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24oZSl7aWYodC5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckxvY2FsU3RvcmFnZS5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTtyZXR1cm5bMix0aGlzLmRhdGFiYXNlQWN0aW9uKHRoaXMubW9kZWxQYXRoLHQpXX0pKX0pKX0sdC5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbih0KXtyZXR1cm5bMix0aGlzLmRhdGFiYXNlQWN0aW9uKHRoaXMubW9kZWxQYXRoKV19KSl9KSl9LHQucHJvdG90eXBlLmRhdGFiYXNlQWN0aW9uPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQscil7dmFyIG89bi5pbmRleGVkREIub3BlbihcInRlbnNvcmZsb3dqc1wiLDEpO28ub251cGdyYWRlbmVlZGVkPWZ1bmN0aW9uKCl7cmV0dXJuIFJmKG8pfSxvLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3ZhciBhPW8ucmVzdWx0O2lmKG51bGw9PWUpe3ZhciBpPWEudHJhbnNhY3Rpb24od2YsXCJyZWFkb25seVwiKSxzPWkub2JqZWN0U3RvcmUod2YpLmdldChuLm1vZGVsUGF0aCk7cy5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtpZihudWxsPT1zLnJlc3VsdClyZXR1cm4gYS5jbG9zZSgpLHIobmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kZWwgd2l0aCBwYXRoICdcIituLm1vZGVsUGF0aCtcIicgaW4gSW5kZXhlZERCLlwiKSk7dChzLnJlc3VsdC5tb2RlbEFydGlmYWN0cyl9LHMub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gYS5jbG9zZSgpLHIocy5lcnJvcil9LGkub25jb21wbGV0ZT1mdW5jdGlvbigpe3JldHVybiBhLmNsb3NlKCl9fWVsc2V7dmFyIHUsYz12ZihlKSxsPWEudHJhbnNhY3Rpb24oQ2YsXCJyZWFkd3JpdGVcIiksaD1sLm9iamVjdFN0b3JlKENmKSxmPWgucHV0KHttb2RlbFBhdGg6bi5tb2RlbFBhdGgsbW9kZWxBcnRpZmFjdHNJbmZvOmN9KTtmLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3ZhciBvPSh1PWEudHJhbnNhY3Rpb24od2YsXCJyZWFkd3JpdGVcIikpLm9iamVjdFN0b3JlKHdmKS5wdXQoe21vZGVsUGF0aDpuLm1vZGVsUGF0aCxtb2RlbEFydGlmYWN0czplLG1vZGVsQXJ0aWZhY3RzSW5mbzpjfSk7by5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gdCh7bW9kZWxBcnRpZmFjdHNJbmZvOmN9KX0sby5vbmVycm9yPWZ1bmN0aW9uKHQpe3ZhciBlPShoPWwub2JqZWN0U3RvcmUoQ2YpKS5kZWxldGUobi5tb2RlbFBhdGgpO2Uub25zdWNjZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIGEuY2xvc2UoKSxyKG8uZXJyb3IpfSxlLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIGEuY2xvc2UoKSxyKG8uZXJyb3IpfX19LGYub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gYS5jbG9zZSgpLHIoZi5lcnJvcil9LGwub25jb21wbGV0ZT1mdW5jdGlvbigpe251bGw9PXU/YS5jbG9zZSgpOnUub25jb21wbGV0ZT1mdW5jdGlvbigpe3JldHVybiBhLmNsb3NlKCl9fX19LG8ub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gcihvLmVycm9yKX19KSl9LHQuVVJMX1NDSEVNRT1cImluZGV4ZWRkYjovL1wiLHR9KCksa2Y9ZnVuY3Rpb24odCl7cmV0dXJuIGkoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSYmIUFycmF5LmlzQXJyYXkodCkmJnQuc3RhcnRzV2l0aChJZi5VUkxfU0NIRU1FKT8oZT10LnNsaWNlKElmLlVSTF9TQ0hFTUUubGVuZ3RoKSxuZXcgSWYoZSkpOm51bGw7dmFyIGV9O21mLnJlZ2lzdGVyU2F2ZVJvdXRlcihrZiksbWYucmVnaXN0ZXJMb2FkUm91dGVyKGtmKTt2YXIgU2Y9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5pbmRleGVkREI9RWYoKX1yZXR1cm4gdC5wcm90b3R5cGUubGlzdE1vZGVscz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3JldHVyblsyLG5ldyBQcm9taXNlKChmdW5jdGlvbihlLG4pe3ZhciByPXQuaW5kZXhlZERCLm9wZW4oXCJ0ZW5zb3JmbG93anNcIiwxKTtyLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbigpe3JldHVybiBSZihyKX0sci5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgdD1yLnJlc3VsdCxvPXQudHJhbnNhY3Rpb24oQ2YsXCJyZWFkb25seVwiKSxhPW8ub2JqZWN0U3RvcmUoQ2YpLmdldEFsbCgpO2Eub25zdWNjZXNzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXt9LG49MCxyPWEucmVzdWx0O248ci5sZW5ndGg7bisrKXt2YXIgbz1yW25dO3Rbby5tb2RlbFBhdGhdPW8ubW9kZWxBcnRpZmFjdHNJbmZvfWUodCl9LGEub25lcnJvcj1mdW5jdGlvbihlKXtyZXR1cm4gdC5jbG9zZSgpLG4oYS5lcnJvcil9LG8ub25jb21wbGV0ZT1mdW5jdGlvbigpe3JldHVybiB0LmNsb3NlKCl9fSxyLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIG4oci5lcnJvcil9fSkpXX0pKX0pKX0sdC5wcm90b3R5cGUucmVtb3ZlTW9kZWw9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIHQ9KHI9dCkuc3RhcnRzV2l0aChJZi5VUkxfU0NIRU1FKT9yLnNsaWNlKElmLlVSTF9TQ0hFTUUubGVuZ3RoKTpyLFsyLG5ldyBQcm9taXNlKChmdW5jdGlvbihuLHIpe3ZhciBvPWUuaW5kZXhlZERCLm9wZW4oXCJ0ZW5zb3JmbG93anNcIiwxKTtvLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbigpe3JldHVybiBSZihvKX0sby5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgZSxhPW8ucmVzdWx0LGk9YS50cmFuc2FjdGlvbihDZixcInJlYWR3cml0ZVwiKSxzPWkub2JqZWN0U3RvcmUoQ2YpLHU9cy5nZXQodCk7dS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtpZihudWxsPT11LnJlc3VsdClyZXR1cm4gYS5jbG9zZSgpLHIobmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kZWwgd2l0aCBwYXRoICdcIit0K1wiJyBpbiBJbmRleGVkREIuXCIpKTt2YXIgbz1zLmRlbGV0ZSh0KSxpPWZ1bmN0aW9uKCl7dmFyIG89KGU9YS50cmFuc2FjdGlvbih3ZixcInJlYWR3cml0ZVwiKSkub2JqZWN0U3RvcmUod2YpLmRlbGV0ZSh0KTtvLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3JldHVybiBuKHUucmVzdWx0Lm1vZGVsQXJ0aWZhY3RzSW5mbyl9LG8ub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gcih1LmVycm9yKX19O28ub25zdWNjZXNzPWksby5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBpKCksYS5jbG9zZSgpLHIodS5lcnJvcil9fSx1Lm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIGEuY2xvc2UoKSxyKHUuZXJyb3IpfSxpLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtudWxsPT1lP2EuY2xvc2UoKTplLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gYS5jbG9zZSgpfX19LG8ub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gcihvLmVycm9yKX19KSldfSkpfSkpfSx0fSgpO2lmKGkoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSl0cnl7eWYucmVnaXN0ZXJNYW5hZ2VyKElmLlVSTF9TQ0hFTUUsbmV3IFNmKX1jYXRjaCh0KXt9dmFyIEFmPVwiL1wiLERmPVwidGVuc29yZmxvd2pzX21vZGVsc1wiLFRmPVwiaW5mb1wiLE5mPVwibW9kZWxfdG9wb2xvZ3lcIixGZj1cIndlaWdodF9zcGVjc1wiLF9mPVwid2VpZ2h0X2RhdGFcIixPZj1cIm1vZGVsX21ldGFkYXRhXCI7ZnVuY3Rpb24gTWYodCl7cmV0dXJue2luZm86W0RmLHQsVGZdLmpvaW4oQWYpLHRvcG9sb2d5OltEZix0LE5mXS5qb2luKEFmKSx3ZWlnaHRTcGVjczpbRGYsdCxGZl0uam9pbihBZiksd2VpZ2h0RGF0YTpbRGYsdCxfZl0uam9pbihBZiksbW9kZWxNZXRhZGF0YTpbRGYsdCxPZl0uam9pbihBZil9fWZ1bmN0aW9uIEJmKHQpe3ZhciBlPXQuc3BsaXQoQWYpO2lmKGUubGVuZ3RoPDMpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXkgZm9ybWF0OiBcIit0KTtyZXR1cm4gZS5zbGljZSgxLGUubGVuZ3RoLTEpLmpvaW4oQWYpfXZhciBQZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYoIWkoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKXx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvd3x8dm9pZCAwPT09d2luZG93LmxvY2FsU3RvcmFnZSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IGxvY2FsIHN0b3JhZ2UuXCIpO2lmKHRoaXMuTFM9d2luZG93LmxvY2FsU3RvcmFnZSxudWxsPT10fHwhdCl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgbG9jYWwgc3RvcmFnZSwgbW9kZWxQYXRoIG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciBlbXB0eS5cIik7dGhpcy5tb2RlbFBhdGg9dCx0aGlzLmtleXM9TWYodGhpcy5tb2RlbFBhdGgpfXJldHVybiB0LnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuLG87cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7aWYodC5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckxvY2FsU3RvcmFnZS5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTtlPUpTT04uc3RyaW5naWZ5KHQubW9kZWxUb3BvbG9neSksbj1KU09OLnN0cmluZ2lmeSh0LndlaWdodFNwZWNzKSxvPXZmKHQpO3RyeXtyZXR1cm4gdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy5pbmZvLEpTT04uc3RyaW5naWZ5KG8pKSx0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLnRvcG9sb2d5LGUpLHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0U3BlY3MsbiksdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy53ZWlnaHREYXRhLGZ1bmN0aW9uKHQpe2lmKGhmKXJldHVybiBCdWZmZXIuZnJvbSh0KS50b1N0cmluZyhcImJhc2U2NFwiKTtmb3IodmFyIGU9bmV3IFVpbnQ4QXJyYXkodCksbj1cIlwiLHI9MCxvPWUubGVuZ3RoO3I8bztyKyspbis9U3RyaW5nLmZyb21DaGFyQ29kZShlW3JdKTtyZXR1cm4gYnRvYShuKX0odC53ZWlnaHREYXRhKSksdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy5tb2RlbE1ldGFkYXRhLEpTT04uc3RyaW5naWZ5KHtmb3JtYXQ6dC5mb3JtYXQsZ2VuZXJhdGVkQnk6dC5nZW5lcmF0ZWRCeSxjb252ZXJ0ZWRCeTp0LmNvbnZlcnRlZEJ5LHVzZXJEZWZpbmVkTWV0YWRhdGE6dC51c2VyRGVmaW5lZE1ldGFkYXRhfSkpLFsyLHttb2RlbEFydGlmYWN0c0luZm86b31dfWNhdGNoKHQpe3Rocm93IHRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXMuaW5mbyksdGhpcy5MUy5yZW1vdmVJdGVtKHRoaXMua2V5cy50b3BvbG9neSksdGhpcy5MUy5yZW1vdmVJdGVtKHRoaXMua2V5cy53ZWlnaHRTcGVjcyksdGhpcy5MUy5yZW1vdmVJdGVtKHRoaXMua2V5cy53ZWlnaHREYXRhKSx0aGlzLkxTLnJlbW92ZUl0ZW0odGhpcy5rZXlzLm1vZGVsTWV0YWRhdGEpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBzYXZlIG1vZGVsICdcIit0aGlzLm1vZGVsUGF0aCtcIicgdG8gbG9jYWwgc3RvcmFnZTogc2l6ZSBxdW90YSBiZWluZyBleGNlZWRlZCBpcyBhIHBvc3NpYmxlIGNhdXNlIG9mIHRoaXMgZmFpbHVyZTogbW9kZWxUb3BvbG9neUJ5dGVzPVwiK28ubW9kZWxUb3BvbG9neUJ5dGVzK1wiLCB3ZWlnaHRTcGVjc0J5dGVzPVwiK28ud2VpZ2h0U3BlY3NCeXRlcytcIiwgd2VpZ2h0RGF0YUJ5dGVzPVwiK28ud2VpZ2h0RGF0YUJ5dGVzK1wiLlwiKX1yZXR1cm5bMl19KSl9KSl9LHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQsZSxuLG8sYSxpLHM7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7aWYobnVsbD09KHQ9SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLmluZm8pKSkpdGhyb3cgbmV3IEVycm9yKFwiSW4gbG9jYWwgc3RvcmFnZSwgdGhlcmUgaXMgbm8gbW9kZWwgd2l0aCBuYW1lICdcIit0aGlzLm1vZGVsUGF0aCtcIidcIik7aWYoXCJKU09OXCIhPT10Lm1vZGVsVG9wb2xvZ3lUeXBlKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJMb2NhbFN0b3JhZ2UgZG9lcyBub3Qgc3VwcG9ydCBsb2FkaW5nIG5vbi1KU09OIG1vZGVsIHRvcG9sb2d5IHlldC5cIik7aWYoZT17fSxudWxsPT0obj1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMudG9wb2xvZ3kpKSkpdGhyb3cgbmV3IEVycm9yKFwiSW4gbG9jYWwgc3RvcmFnZSwgdGhlIHRvcG9sb2d5IG9mIG1vZGVsICdcIit0aGlzLm1vZGVsUGF0aCtcIicgaXMgbWlzc2luZy5cIik7aWYoZS5tb2RlbFRvcG9sb2d5PW4sbnVsbD09KG89SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLndlaWdodFNwZWNzKSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZSB3ZWlnaHQgc3BlY3Mgb2YgbW9kZWwgJ1wiK3RoaXMubW9kZWxQYXRoK1wiJyBhcmUgbWlzc2luZy5cIik7aWYoZS53ZWlnaHRTcGVjcz1vLG51bGwhPShhPXRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMubW9kZWxNZXRhZGF0YSkpJiYoaT1KU09OLnBhcnNlKGEpLGUuZm9ybWF0PWkuZm9ybWF0LGUuZ2VuZXJhdGVkQnk9aS5nZW5lcmF0ZWRCeSxlLmNvbnZlcnRlZEJ5PWkuY29udmVydGVkQnksZS51c2VyRGVmaW5lZE1ldGFkYXRhPWkudXNlckRlZmluZWRNZXRhZGF0YSksbnVsbD09KHM9dGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy53ZWlnaHREYXRhKSkpdGhyb3cgbmV3IEVycm9yKFwiSW4gbG9jYWwgc3RvcmFnZSwgdGhlIGJpbmFyeSB3ZWlnaHQgdmFsdWVzIG9mIG1vZGVsICdcIit0aGlzLm1vZGVsUGF0aCtcIicgYXJlIG1pc3NpbmcuXCIpO3JldHVybiBlLndlaWdodERhdGE9ZnVuY3Rpb24odCl7aWYoaGYpe3ZhciBlPUJ1ZmZlci5mcm9tKHQsXCJiYXNlNjRcIik7cmV0dXJuIGUuYnVmZmVyLnNsaWNlKGUuYnl0ZU9mZnNldCxlLmJ5dGVPZmZzZXQrZS5ieXRlTGVuZ3RoKX1mb3IodmFyIG49YXRvYih0KSxyPW5ldyBVaW50OEFycmF5KG4ubGVuZ3RoKSxvPTA7bzxuLmxlbmd0aDsrK28pci5zZXQoW24uY2hhckNvZGVBdChvKV0sbyk7cmV0dXJuIHIuYnVmZmVyfShzKSxbMixlXX0pKX0pKX0sdC5VUkxfU0NIRU1FPVwibG9jYWxzdG9yYWdlOi8vXCIsdH0oKSxMZj1mdW5jdGlvbih0KXtyZXR1cm4gaSgpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpJiYhQXJyYXkuaXNBcnJheSh0KSYmdC5zdGFydHNXaXRoKFBmLlVSTF9TQ0hFTUUpPyhlPXQuc2xpY2UoUGYuVVJMX1NDSEVNRS5sZW5ndGgpLG5ldyBQZihlKSk6bnVsbDt2YXIgZX07bWYucmVnaXN0ZXJTYXZlUm91dGVyKExmKSxtZi5yZWdpc3RlckxvYWRSb3V0ZXIoTGYpO3ZhciBXZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtDKGkoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkN1cnJlbnQgZW52aXJvbm1lbnQgaXMgbm90IGEgd2ViIGJyb3dzZXJcIn0pKSxDKFwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3d8fHZvaWQgMCE9PXdpbmRvdy5sb2NhbFN0b3JhZ2UsKGZ1bmN0aW9uKCl7cmV0dXJuXCJDdXJyZW50IGJyb3dzZXIgZG9lcyBub3QgYXBwZWFyIHRvIHN1cHBvcnQgbG9jYWxTdG9yYWdlXCJ9KSksdGhpcy5MUz13aW5kb3cubG9jYWxTdG9yYWdlfXJldHVybiB0LnByb3RvdHlwZS5saXN0TW9kZWxzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0LGUsbixvLGEsaTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtmb3IodD17fSxlPURmK0FmLG49QWYrVGYsbz0wO288dGhpcy5MUy5sZW5ndGg7KytvKShhPXRoaXMuTFMua2V5KG8pKS5zdGFydHNXaXRoKGUpJiZhLmVuZHNXaXRoKG4pJiYoaT1CZihhKSx0W2ldPUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKGEpKSk7cmV0dXJuWzIsdF19KSl9KSl9LHQucHJvdG90eXBlLnJlbW92ZU1vZGVsPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3ZhciBvO2lmKHQ9KG89dCkuc3RhcnRzV2l0aChQZi5VUkxfU0NIRU1FKT9vLnNsaWNlKFBmLlVSTF9TQ0hFTUUubGVuZ3RoKTpvLGU9TWYodCksbnVsbD09dGhpcy5MUy5nZXRJdGVtKGUuaW5mbykpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kZWwgYXQgcGF0aCAnXCIrdCtcIidcIik7cmV0dXJuIG49SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0oZS5pbmZvKSksdGhpcy5MUy5yZW1vdmVJdGVtKGUuaW5mbyksdGhpcy5MUy5yZW1vdmVJdGVtKGUudG9wb2xvZ3kpLHRoaXMuTFMucmVtb3ZlSXRlbShlLndlaWdodFNwZWNzKSx0aGlzLkxTLnJlbW92ZUl0ZW0oZS53ZWlnaHREYXRhKSxbMixuXX0pKX0pKX0sdH0oKTtpZihpKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikpdHJ5e3lmLnJlZ2lzdGVyTWFuYWdlcihQZi5VUkxfU0NIRU1FLG5ldyBXZil9Y2F0Y2godCl7fXZhciBVZj1cIm1vZGVsXCIsVmY9XCIuanNvblwiLHpmPVwiLndlaWdodHMuYmluXCI7ZnVuY3Rpb24gR2YodCl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0KXtyZXR1cm4gc2V0VGltZW91dCh0KX0pKS50aGVuKHQpfXZhciBIZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7aWYoIWkoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJicm93c2VyRG93bmxvYWRzKCkgY2Fubm90IHByb2NlZWQgYmVjYXVzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyBub3QgYSBicm93c2VyLlwiKTtlLnN0YXJ0c1dpdGgodC5VUkxfU0NIRU1FKSYmKGU9ZS5zbGljZSh0LlVSTF9TQ0hFTUUubGVuZ3RoKSksbnVsbCE9ZSYmMCE9PWUubGVuZ3RofHwoZT1VZiksdGhpcy5tb2RlbFRvcG9sb2d5RmlsZU5hbWU9ZStWZix0aGlzLndlaWdodERhdGFGaWxlTmFtZT1lK3pmfXJldHVybiB0LnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuLG8sYSxpLHM7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDppZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZG9jdW1lbnQpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlciBkb3dubG9hZHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCBzaW5jZSBgZG9jdW1lbnRgIGlzIG5vdCBwcmVzZW50XCIpO2lmKGU9d2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3Qud2VpZ2h0RGF0YV0se3R5cGU6XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIn0pKSwhKHQubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSlyZXR1cm5bMywxXTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyRG93bmxvYWRzLnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSBpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuXCIpO2Nhc2UgMTpyZXR1cm4gbj1be3BhdGhzOltcIi4vXCIrdGhpcy53ZWlnaHREYXRhRmlsZU5hbWVdLHdlaWdodHM6dC53ZWlnaHRTcGVjc31dLG89e21vZGVsVG9wb2xvZ3k6dC5tb2RlbFRvcG9sb2d5LGZvcm1hdDp0LmZvcm1hdCxnZW5lcmF0ZWRCeTp0LmdlbmVyYXRlZEJ5LGNvbnZlcnRlZEJ5OnQuY29udmVydGVkQnksd2VpZ2h0c01hbmlmZXN0Om59LGE9d2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KG8pXSx7dHlwZTpcImFwcGxpY2F0aW9uL2pzb25cIn0pKSwoaT1udWxsPT10aGlzLmpzb25BbmNob3I/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik6dGhpcy5qc29uQW5jaG9yKS5kb3dubG9hZD10aGlzLm1vZGVsVG9wb2xvZ3lGaWxlTmFtZSxpLmhyZWY9YSxbNCxHZigoZnVuY3Rpb24oKXtyZXR1cm4gaS5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIikpfSkpXTtjYXNlIDI6cmV0dXJuIHIuc2VudCgpLG51bGw9PXQud2VpZ2h0RGF0YT9bMyw0XTooKHM9bnVsbD09dGhpcy53ZWlnaHREYXRhQW5jaG9yP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpOnRoaXMud2VpZ2h0RGF0YUFuY2hvcikuZG93bmxvYWQ9dGhpcy53ZWlnaHREYXRhRmlsZU5hbWUscy5ocmVmPWUsWzQsR2YoKGZ1bmN0aW9uKCl7cmV0dXJuIHMuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudChcImNsaWNrXCIpKX0pKV0pO2Nhc2UgMzpyLnNlbnQoKSxyLmxhYmVsPTQ7Y2FzZSA0OnJldHVyblsyLHttb2RlbEFydGlmYWN0c0luZm86dmYodCl9XX19KSl9KSl9LHQuVVJMX1NDSEVNRT1cImRvd25sb2FkczovL1wiLHR9KCkscWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKG51bGw9PXR8fHQubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBjYWxsaW5nIGJyb3dzZXJGaWxlcywgYXQgbGVhc3QgMSBmaWxlIGlzIHJlcXVpcmVkLCBidXQgcmVjZWl2ZWQgXCIrdCk7dGhpcy5maWxlcz10fXJldHVybiB0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0LGUsbj10aGlzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3JldHVybiB0PXRoaXMuZmlsZXNbMF0sZT10aGlzLmZpbGVzLnNsaWNlKDEpLFsyLG5ldyBQcm9taXNlKChmdW5jdGlvbihyLG8pe3ZhciBhPW5ldyBGaWxlUmVhZGVyO2Eub25sb2FkPWZ1bmN0aW9uKGEpe3ZhciBpPUpTT04ucGFyc2UoYS50YXJnZXQucmVzdWx0KSxzPWkubW9kZWxUb3BvbG9neTtpZihudWxsIT1zKXswPT09ZS5sZW5ndGgmJnIoe21vZGVsVG9wb2xvZ3k6c30pO3ZhciB1PWkud2VpZ2h0c01hbmlmZXN0O2lmKG51bGwhPXUpe3ZhciBjO3RyeXtjPW4uY2hlY2tNYW5pZmVzdEFuZFdlaWdodEZpbGVzKHUsZSl9Y2F0Y2godCl7cmV0dXJuIHZvaWQgbyh0KX12YXIgbD1bXSxoPVtdLGY9W107dS5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnBhdGhzLmZvckVhY2goKGZ1bmN0aW9uKHQpe2gucHVzaCh0KSxmLnB1c2gobnVsbCl9KSksbC5wdXNoLmFwcGx5KGwsdC53ZWlnaHRzKX0pKSx1LmZvckVhY2goKGZ1bmN0aW9uKHQpe3QucGF0aHMuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9bmV3IEZpbGVSZWFkZXI7ZS5vbmxvYWQ9ZnVuY3Rpb24oZSl7dmFyIG49ZS50YXJnZXQucmVzdWx0LG89aC5pbmRleE9mKHQpO2Zbb109biwtMT09PWYuaW5kZXhPZihudWxsKSYmcih7bW9kZWxUb3BvbG9neTpzLHdlaWdodFNwZWNzOmwsd2VpZ2h0RGF0YTpkZihmKSxmb3JtYXQ6aS5mb3JtYXQsZ2VuZXJhdGVkQnk6aS5nZW5lcmF0ZWRCeSxjb252ZXJ0ZWRCeTppLmNvbnZlcnRlZEJ5LHVzZXJEZWZpbmVkTWV0YWRhdGE6aS51c2VyRGVmaW5lZE1ldGFkYXRhfSl9LGUub25lcnJvcj1mdW5jdGlvbihlKXtyZXR1cm4gbyhcIkZhaWxlZCB0byB3ZWlnaHRzIGRhdGEgZnJvbSBmaWxlIG9mIHBhdGggJ1wiK3QrXCInLlwiKX0sZS5yZWFkQXNBcnJheUJ1ZmZlcihjW3RdKX0pKX0pKX1lbHNlIG8obmV3IEVycm9yKFwid2VpZ2h0TWFuaWZlc3QgZmllbGQgaXMgbWlzc2luZyBmcm9tIGZpbGUgXCIrdC5uYW1lKSl9ZWxzZSBvKG5ldyBFcnJvcihcIm1vZGVsVG9wb2xvZ3kgZmllbGQgaXMgbWlzc2luZyBmcm9tIGZpbGUgXCIrdC5uYW1lKSl9LGEub25lcnJvcj1mdW5jdGlvbihlKXtyZXR1cm4gbyhcIkZhaWxlZCB0byByZWFkIG1vZGVsIHRvcG9sb2d5IGFuZCB3ZWlnaHRzIG1hbmlmZXN0IEpTT04gZnJvbSBmaWxlICdcIit0Lm5hbWUrXCInLiBCcm93c2VyRmlsZXMgc3VwcG9ydHMgbG9hZGluZyBLZXJhcy1zdHlsZSB0Zi5Nb2RlbCBhcnRpZmFjdHMgb25seS5cIil9LGEucmVhZEFzVGV4dCh0KX0pKV19KSl9KSl9LHQucHJvdG90eXBlLmNoZWNrTWFuaWZlc3RBbmRXZWlnaHRGaWxlcz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1bXSxyPWUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gcGYodC5uYW1lKX0pKSxvPXt9LGE9MCxpPXQ7YTxpLmxlbmd0aDthKyspe2lbYV0ucGF0aHMuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGE9cGYodCk7aWYoLTEhPT1uLmluZGV4T2YoYSkpdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGZpbGUgYmFzZW5hbWUgZm91bmQgaW4gd2VpZ2h0cyBtYW5pZmVzdDogJ1wiK2ErXCInXCIpO2lmKG4ucHVzaChhKSwtMT09PXIuaW5kZXhPZihhKSl0aHJvdyBuZXcgRXJyb3IoXCJXZWlnaHQgZmlsZSB3aXRoIGJhc2VuYW1lICdcIithK1wiJyBpcyBub3QgcHJvdmlkZWQuXCIpO29bdF09ZVtyLmluZGV4T2YoYSldfSkpfWlmKG4ubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2ggaW4gdGhlIG51bWJlciBvZiBmaWxlcyBpbiB3ZWlnaHRzIG1hbmlmZXN0IChcIituLmxlbmd0aCtcIikgYW5kIHRoZSBudW1iZXIgb2Ygd2VpZ2h0IGZpbGVzIHByb3ZpZGVkIChcIitlLmxlbmd0aCtcIikuXCIpO3JldHVybiBvfSx0fSgpO2Z1bmN0aW9uIEtmKHQsZSxuLHIpeyFmdW5jdGlvbih0KXtDKG51bGwhPXQmJkFycmF5LmlzQXJyYXkodCkmJnQubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJwcm9taXNlcyBtdXN0IGJlIGEgbm9uZSBlbXB0eSBhcnJheVwifSkpfSh0KSxmdW5jdGlvbih0LGUpe0ModD49MCYmdDw9MSwoZnVuY3Rpb24oKXtyZXR1cm5cIlByb2dyZXNzIGZyYWN0aW9uIG11c3QgYmUgaW4gcmFuZ2UgWzAsIDFdLCBidXQgZ290IHN0YXJ0RnJhY3Rpb24gXCIrdH0pKSxDKGU+PTAmJmU8PTEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJQcm9ncmVzcyBmcmFjdGlvbiBtdXN0IGJlIGluIHJhbmdlIFswLCAxXSwgYnV0IGdvdCBlbmRGcmFjdGlvbiBcIitlfSkpLEMoZT49dCwoZnVuY3Rpb24oKXtyZXR1cm5cInN0YXJ0RnJhY3Rpb24gbXVzdCBiZSBubyBtb3JlIHRoYW4gZW5kRnJhY3Rpb24sIGJ1dCBnb3Qgc3RhcnRGcmFjdGlvbiBcIit0K1wiIGFuZCBlbmRGcmFjdGlvbiBcIitlfSkpfShuPW51bGw9PW4/MDpuLHI9bnVsbD09cj8xOnIpO3ZhciBvPTA7cmV0dXJuIFByb21pc2UuYWxsKHQubWFwKChmdW5jdGlvbihhKXtyZXR1cm4gYS50aGVuKChmdW5jdGlvbihhKXt2YXIgaT1uKyArK28vdC5sZW5ndGgqKHItbik7cmV0dXJuIGUoaSksYX0pKSxhfSkpKX1mdW5jdGlvbiBqZih0LGUpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixvLGEscyx1LGMsbCxoLGY7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbnVsbD09ZSYmKGU9e30pLG49bnVsbD09ZS5mZXRjaEZ1bmM/aSgpLnBsYXRmb3JtLmZldGNoOmUuZmV0Y2hGdW5jLG89dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBuKHQsZS5yZXF1ZXN0SW5pdCx7aXNCaW5hcnk6ITB9KX0pKSxhPTAscz0uNSxudWxsIT1lLm9uUHJvZ3Jlc3M/WzMsMl06WzQsUHJvbWlzZS5hbGwobyldO2Nhc2UgMTpyZXR1cm4gdT1yLnNlbnQoKSxbMyw0XTtjYXNlIDI6cmV0dXJuWzQsS2YobyxlLm9uUHJvZ3Jlc3MsYSxzKV07Y2FzZSAzOnU9ci5zZW50KCksci5sYWJlbD00O2Nhc2UgNDpyZXR1cm4gYz11Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXJyYXlCdWZmZXIoKX0pKSxsPS41LGg9MSxudWxsIT1lLm9uUHJvZ3Jlc3M/WzMsNl06WzQsUHJvbWlzZS5hbGwoYyldO2Nhc2UgNTpyZXR1cm4gZj1yLnNlbnQoKSxbMyw4XTtjYXNlIDY6cmV0dXJuWzQsS2YoYyxlLm9uUHJvZ3Jlc3MsbCxoKV07Y2FzZSA3OmY9ci5zZW50KCksci5sYWJlbD04O2Nhc2UgODpyZXR1cm5bMixmXX19KSl9KSl9ZnVuY3Rpb24gWGYodCl7dmFyIGU9dGhpcztyZXR1cm4gZnVuY3Rpb24obyxhLGkpe3JldHVybiB2b2lkIDA9PT1hJiYoYT1cIlwiKSxuKGUsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuLHMsdSxjLGwsaCxmLGQscDtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKGU9by5tYXAoKGZ1bmN0aW9uKCl7cmV0dXJuITF9KSksbj17fSxzPW51bGwhPWk/aS5tYXAoKGZ1bmN0aW9uKCl7cmV0dXJuITF9KSk6W10sdT1bXSxvLmZvckVhY2goKGZ1bmN0aW9uKHQscil7dmFyIG89MDt0LndlaWdodHMuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGE9XCJxdWFudGl6YXRpb25cImluIHQ/dC5xdWFudGl6YXRpb24uZHR5cGU6dC5kdHlwZSxjPXNmW2FdKmsodC5zaGFwZSksbD1mdW5jdGlvbigpe2Vbcl09ITAsbnVsbD09bltyXSYmKG5bcl09W10pLG5bcl0ucHVzaCh7bWFuaWZlc3RFbnRyeTp0LGdyb3VwT2Zmc2V0Om8sc2l6ZUJ5dGVzOmN9KX07bnVsbCE9aT9pLmZvckVhY2goKGZ1bmN0aW9uKGUsbil7ZT09PXQubmFtZSYmKGwoKSxzW25dPSEwKX0pKTpsKCksdS5wdXNoKHQubmFtZSksbys9Y30pKX0pKSwhcy5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSkpdGhyb3cgYz1pLmZpbHRlcigoZnVuY3Rpb24odCxlKXtyZXR1cm4hc1tlXX0pKSxuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCB3ZWlnaHRzIGluIG1hbmlmZXN0IHdpdGggbmFtZXM6IFwiK2Muam9pbihcIiwgXCIpK1wiLiBcXG5NYW5pZmVzdCBKU09OIGhhcyB3ZWlnaHRzIHdpdGggbmFtZXM6IFwiK3Uuam9pbihcIiwgXCIpK1wiLlwiKTtyZXR1cm4gbD1lLnJlZHVjZSgoZnVuY3Rpb24odCxlLG4pe3JldHVybiBlJiZ0LnB1c2gobiksdH0pLFtdKSxoPVtdLGwuZm9yRWFjaCgoZnVuY3Rpb24odCl7b1t0XS5wYXRocy5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT1hKyhhLmVuZHNXaXRoKFwiL1wiKT9cIlwiOlwiL1wiKSt0O2gucHVzaChlKX0pKX0pKSxbNCx0KGgpXTtjYXNlIDE6cmV0dXJuIGY9ci5zZW50KCksZD17fSxwPTAsbC5mb3JFYWNoKChmdW5jdGlvbih0KXtmb3IodmFyIGU9b1t0XS5wYXRocy5sZW5ndGgscj0wLGE9MDthPGU7YSsrKXIrPWZbcCthXS5ieXRlTGVuZ3RoO2Zvcih2YXIgaT1uZXcgQXJyYXlCdWZmZXIocikscz1uZXcgVWludDhBcnJheShpKSx1PTAsYz0wO2M8ZTtjKyspe3ZhciBsPW5ldyBVaW50OEFycmF5KGZbcCtjXSk7cy5zZXQobCx1KSx1Kz1sLmJ5dGVMZW5ndGh9blt0XS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT1jZihpLnNsaWNlKHQuZ3JvdXBPZmZzZXQsdC5ncm91cE9mZnNldCt0LnNpemVCeXRlcyksW3QubWFuaWZlc3RFbnRyeV0pO2Zvcih2YXIgbiBpbiBlKWRbbl09ZVtuXX0pKSxwKz1lfSkpLFsyLGRdfX0pKX0pKX19bWYucmVnaXN0ZXJTYXZlUm91dGVyKChmdW5jdGlvbih0KXtyZXR1cm4gaSgpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpJiYhQXJyYXkuaXNBcnJheSh0KSYmdC5zdGFydHNXaXRoKEhmLlVSTF9TQ0hFTUUpP2Z1bmN0aW9uKHQpe3ZvaWQgMD09PXQmJih0PVwibW9kZWxcIik7cmV0dXJuIG5ldyBIZih0KX0odC5zbGljZShIZi5VUkxfU0NIRU1FLmxlbmd0aCkpOm51bGx9KSk7dmFyIFlmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2lmKHRoaXMuREVGQVVMVF9NRVRIT0Q9XCJQT1NUXCIsbnVsbD09ZSYmKGU9e30pLHRoaXMud2VpZ2h0UGF0aFByZWZpeD1lLndlaWdodFBhdGhQcmVmaXgsdGhpcy5vblByb2dyZXNzPWUub25Qcm9ncmVzcyxudWxsIT1lLmZldGNoRnVuYz8oQyhcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmZldGNoRnVuYywoZnVuY3Rpb24oKXtyZXR1cm5cIk11c3QgcGFzcyBhIGZ1bmN0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgc2lnbmF0dXJlIG9mIGBmZXRjaGAgKHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJKVwifSkpLHRoaXMuZmV0Y2g9ZS5mZXRjaEZ1bmMpOnRoaXMuZmV0Y2g9aSgpLnBsYXRmb3JtLmZldGNoLEMobnVsbCE9dCYmdC5sZW5ndGg+MCwoZnVuY3Rpb24oKXtyZXR1cm5cIlVSTCBwYXRoIGZvciBodHRwIG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciBlbXB0eS5cIn0pKSxBcnJheS5pc0FycmF5KHQpJiZDKDI9PT10Lmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIlVSTCBwYXRocyBmb3IgaHR0cCBtdXN0IGhhdmUgYSBsZW5ndGggb2YgMiwgKGFjdHVhbCBsZW5ndGggaXMgXCIrdC5sZW5ndGgrXCIpLlwifSkpLHRoaXMucGF0aD10LG51bGwhPWUucmVxdWVzdEluaXQmJm51bGwhPWUucmVxdWVzdEluaXQuYm9keSl0aHJvdyBuZXcgRXJyb3IoXCJyZXF1ZXN0SW5pdCBpcyBleHBlY3RlZCB0byBoYXZlIG5vIHByZS1leGlzdGluZyBib2R5LCBidXQgaGFzIG9uZS5cIik7dGhpcy5yZXF1ZXN0SW5pdD1lLnJlcXVlc3RJbml0fHx7fX1yZXR1cm4gdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixvLGE7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDppZih0Lm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VySFRUUFJlcXVlc3Quc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5IGluIGJpbmFyeSBmb3JtYXRzIHlldC5cIik7cmV0dXJuKGU9T2JqZWN0LmFzc2lnbih7bWV0aG9kOnRoaXMuREVGQVVMVF9NRVRIT0R9LHRoaXMucmVxdWVzdEluaXQpKS5ib2R5PW5ldyBGb3JtRGF0YSxuPVt7cGF0aHM6W1wiLi9tb2RlbC53ZWlnaHRzLmJpblwiXSx3ZWlnaHRzOnQud2VpZ2h0U3BlY3N9XSxvPXttb2RlbFRvcG9sb2d5OnQubW9kZWxUb3BvbG9neSxmb3JtYXQ6dC5mb3JtYXQsZ2VuZXJhdGVkQnk6dC5nZW5lcmF0ZWRCeSxjb252ZXJ0ZWRCeTp0LmNvbnZlcnRlZEJ5LHVzZXJEZWZpbmVkTWV0YWRhdGE6dC51c2VyRGVmaW5lZE1ldGFkYXRhLHdlaWdodHNNYW5pZmVzdDpufSxlLmJvZHkuYXBwZW5kKFwibW9kZWwuanNvblwiLG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShvKV0se3R5cGU6XCJhcHBsaWNhdGlvbi9qc29uXCJ9KSxcIm1vZGVsLmpzb25cIiksbnVsbCE9dC53ZWlnaHREYXRhJiZlLmJvZHkuYXBwZW5kKFwibW9kZWwud2VpZ2h0cy5iaW5cIixuZXcgQmxvYihbdC53ZWlnaHREYXRhXSx7dHlwZTpcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifSksXCJtb2RlbC53ZWlnaHRzLmJpblwiKSxbNCx0aGlzLmZldGNoKHRoaXMucGF0aCxlKV07Y2FzZSAxOmlmKChhPXIuc2VudCgpKS5vaylyZXR1cm5bMix7bW9kZWxBcnRpZmFjdHNJbmZvOnZmKHQpLHJlc3BvbnNlczpbYV19XTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VySFRUUFJlcXVlc3Quc2F2ZSgpIGZhaWxlZCBkdWUgdG8gSFRUUCByZXNwb25zZSBzdGF0dXMgXCIrYS5zdGF0dXMrXCIuXCIpfX0pKX0pKX0sdC5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxlLG4sbyxhLGkscyx1LGMsbCxoLGY7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmZldGNoKHRoaXMucGF0aCx0aGlzLnJlcXVlc3RJbml0KV07Y2FzZSAxOmlmKCEodD1yLnNlbnQoKSkub2spdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdCB0byBcIit0aGlzLnBhdGgrXCIgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgXCIrdC5zdGF0dXMrXCIuIFBsZWFzZSB2ZXJpZnkgdGhpcyBVUkwgcG9pbnRzIHRvIHRoZSBtb2RlbCBKU09OIG9mIHRoZSBtb2RlbCB0byBsb2FkLlwiKTtyLmxhYmVsPTI7Y2FzZSAyOnJldHVybiByLnRyeXMucHVzaChbMiw0LCw1XSksWzQsdC5qc29uKCldO2Nhc2UgMzpyZXR1cm4gZT1yLnNlbnQoKSxbMyw1XTtjYXNlIDQ6dGhyb3cgci5zZW50KCksbj1cIkZhaWxlZCB0byBwYXJzZSBtb2RlbCBKU09OIG9mIHJlc3BvbnNlIGZyb20gXCIrdGhpcy5wYXRoK1wiLlwiLHRoaXMucGF0aC5lbmRzV2l0aChcIi5wYlwiKT9uKz1cIiBZb3VyIHBhdGggY29udGFpbnMgYSAucGIgZmlsZSBleHRlbnNpb24uIFN1cHBvcnQgZm9yIC5wYiBtb2RlbHMgaGF2ZSBiZWVuIHJlbW92ZWQgaW4gVGVuc29yRmxvdy5qcyAxLjAgaW4gZmF2b3Igb2YgLmpzb24gbW9kZWxzLiBZb3UgY2FuIHJlLWNvbnZlcnQgeW91ciBQeXRob24gVGVuc29yRmxvdyBtb2RlbCB1c2luZyB0aGUgVGVuc29yRmxvdy5qcyAxLjAgY29udmVyc2lvbiBzY3JpcHRzIG9yIHlvdSBjYW4gY29udmVydCB5b3VyLnBiIG1vZGVscyB3aXRoIHRoZSAncGIyanNvbidOUE0gc2NyaXB0IGluIHRoZSB0ZW5zb3JmbG93L3RmanMtY29udmVydGVyIHJlcG9zaXRvcnkuXCI6bis9XCIgUGxlYXNlIG1ha2Ugc3VyZSB0aGUgc2VydmVyIGlzIHNlcnZpbmcgdmFsaWQgSlNPTiBmb3IgdGhpcyByZXF1ZXN0LlwiLG5ldyBFcnJvcihuKTtjYXNlIDU6aWYobz1lLm1vZGVsVG9wb2xvZ3ksYT1lLndlaWdodHNNYW5pZmVzdCxpPWUuZ2VuZXJhdGVkQnkscz1lLmNvbnZlcnRlZEJ5LHU9ZS5mb3JtYXQsYz1lLnVzZXJEZWZpbmVkTWV0YWRhdGEsbnVsbD09byYmbnVsbD09YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgSlNPTiBmcm9tIEhUVFAgcGF0aCBcIit0aGlzLnBhdGgrXCIgY29udGFpbnMgbmVpdGhlciBtb2RlbCB0b3BvbG9neSBvciBtYW5pZmVzdCBmb3Igd2VpZ2h0cy5cIik7cmV0dXJuIG51bGw9PWE/WzMsN106WzQsdGhpcy5sb2FkV2VpZ2h0cyhhKV07Y2FzZSA2OmY9ci5zZW50KCksbD1mWzBdLGg9ZlsxXSxyLmxhYmVsPTc7Y2FzZSA3OnJldHVyblsyLHttb2RlbFRvcG9sb2d5Om8sd2VpZ2h0U3BlY3M6bCx3ZWlnaHREYXRhOmgsdXNlckRlZmluZWRNZXRhZGF0YTpjLGdlbmVyYXRlZEJ5OmksY29udmVydGVkQnk6cyxmb3JtYXQ6dX1dfX0pKX0pKX0sdC5wcm90b3R5cGUubG9hZFdlaWdodHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG4sbyxhLGkscyx1LGMsbCxoLGY7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpmb3IoZT1BcnJheS5pc0FycmF5KHRoaXMucGF0aCk/dGhpcy5wYXRoWzFdOnRoaXMucGF0aCxuPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGFzdEluZGV4T2YoXCIvXCIpLG49dC5sYXN0SW5kZXhPZihcIj9cIikscj10LnN1YnN0cmluZygwLGUpLG89bj5lP3Quc3Vic3RyaW5nKG4pOlwiXCI7cmV0dXJuW3IrXCIvXCIsb119KGUpLG89blswXSxhPW5bMV0saT10aGlzLndlaWdodFBhdGhQcmVmaXh8fG8scz1bXSx1PTAsYz10O3U8Yy5sZW5ndGg7dSsrKWw9Y1t1XSxzLnB1c2guYXBwbHkocyxsLndlaWdodHMpO3JldHVybiBoPVtdLHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5wYXRocy5mb3JFYWNoKChmdW5jdGlvbih0KXtoLnB1c2goaSt0K2EpfSkpfSkpLFs0LGpmKGgse3JlcXVlc3RJbml0OnRoaXMucmVxdWVzdEluaXQsZmV0Y2hGdW5jOnRoaXMuZmV0Y2gsb25Qcm9ncmVzczp0aGlzLm9uUHJvZ3Jlc3N9KV07Y2FzZSAxOnJldHVybiBmPXIuc2VudCgpLFsyLFtzLGRmKGYpXV19fSkpfSkpfSx0LlVSTF9TQ0hFTUVfUkVHRVg9L15odHRwcz86XFwvXFwvLyx0fSgpO2Z1bmN0aW9uICRmKHQpe3JldHVybiBudWxsIT10Lm1hdGNoKFlmLlVSTF9TQ0hFTUVfUkVHRVgpfXZhciBRZj1mdW5jdGlvbih0LGUpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaClyZXR1cm4gbnVsbDtyZXR1cm4oQXJyYXkuaXNBcnJheSh0KT90LmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gJGYodCl9KSk6JGYodCkpP0pmKHQse29uUHJvZ3Jlc3M6ZX0pOm51bGx9O2Z1bmN0aW9uIEpmKHQsZSl7cmV0dXJuIG5ldyBZZih0LGUpfW1mLnJlZ2lzdGVyU2F2ZVJvdXRlcihRZiksbWYucmVnaXN0ZXJMb2FkUm91dGVyKFFmKTt2YXIgWmY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMubW9kZWxBcnRpZmFjdHM9dH1yZXR1cm4gdC5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbih0KXtyZXR1cm5bMix0aGlzLm1vZGVsQXJ0aWZhY3RzXX0pKX0pKX0sdH0oKSx0ZD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5zYXZlSGFuZGxlcj10fXJldHVybiB0LnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtyZXR1cm5bMix0aGlzLnNhdmVIYW5kbGVyKHQpXX0pKX0pKX0sdH0oKTt2YXIgZWQ9T2JqZWN0LmZyZWV6ZSh7YnJvd3NlckZpbGVzOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgcWYodCl9LGJyb3dzZXJIVFRQUmVxdWVzdDpmdW5jdGlvbih0LGUpe3JldHVybiBKZih0LGUpfSxjb25jYXRlbmF0ZUFycmF5QnVmZmVyczpkZixkZWNvZGVXZWlnaHRzOmNmLGVuY29kZVdlaWdodHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG8sYSxpLHMsdSxjPXRoaXM7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obCl7c3dpdGNoKGwubGFiZWwpe2Nhc2UgMDpmb3Iobz1bXSxhPVtdLGk9QXJyYXkuaXNBcnJheSh0KT90Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pKTpPYmplY3Qua2V5cyh0KSxzPWZ1bmN0aW9uKHMpe3ZhciB1PWlbc10sbD1BcnJheS5pc0FycmF5KHQpP3Rbc10udGVuc29yOnRbdV07aWYoXCJmbG9hdDMyXCIhPT1sLmR0eXBlJiZcImludDMyXCIhPT1sLmR0eXBlJiZcImJvb2xcIiE9PWwuZHR5cGUmJlwic3RyaW5nXCIhPT1sLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnXCIrdStcIic6IFwiK2wuZHR5cGUpO3ZhciBoPXtuYW1lOnUsc2hhcGU6bC5zaGFwZSxkdHlwZTpsLmR0eXBlfTtpZihcInN0cmluZ1wiPT09bC5kdHlwZSl7dmFyIGY9bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQpe3JldHVybiBuKGMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuLG8sYSxpLHMsdTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGwuYnl0ZXMoKV07Y2FzZSAxOmZvcihlPXIuc2VudCgpLG49ZS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZS5sZW5ndGh9KSwwKSt1ZiplLmxlbmd0aCxvPW5ldyBVaW50OEFycmF5KG4pLGE9MCxpPTA7aTxlLmxlbmd0aDtpKyspcz1lW2ldLHU9bmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFtzLmxlbmd0aF0pLmJ1ZmZlciksby5zZXQodSxhKSxhKz11ZixvLnNldChzLGEpLGErPXMubGVuZ3RoO3JldHVybiB0KG8pLFsyXX19KSl9KSl9KSk7YS5wdXNoKGYpfWVsc2UgYS5wdXNoKGwuZGF0YSgpKTtudWxsIT1lJiYoaC5ncm91cD1lKSxvLnB1c2goaCl9LHU9MDt1PGkubGVuZ3RoOysrdSlzKHUpO3JldHVybls0LFByb21pc2UuYWxsKGEpXTtjYXNlIDE6cmV0dXJuWzIse2RhdGE6bGYobC5zZW50KCkpLHNwZWNzOm99XX19KSl9KSl9LGZyb21NZW1vcnk6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP251bGwhPXQubW9kZWxUb3BvbG9neXx8bnVsbCE9dC53ZWlnaHRTcGVjcz9uZXcgWmYodCk6KGNvbnNvbGUud2FybihcIlBsZWFzZSBjYWxsIHRmLmlvLmZyb21NZW1vcnkoKSB3aXRoIG9ubHkgb25lIGFyZ3VtZW50LiBUaGUgYXJndW1lbnQgc2hvdWxkIGJlIG9mIHR5cGUgTW9kZWxBcnRpZmFjdHMuIFRoZSBtdWx0aS1hcmd1bWVudCBzaWduYXR1cmUgb2YgdGYuaW8uZnJvbU1lbW9yeSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiKSxuZXcgWmYoe21vZGVsVG9wb2xvZ3k6dH0pKTooY29uc29sZS53YXJuKFwiUGxlYXNlIGNhbGwgdGYuaW8uZnJvbU1lbW9yeSgpIHdpdGggb25seSBvbmUgYXJndW1lbnQuIFRoZSBhcmd1bWVudCBzaG91bGQgYmUgb2YgdHlwZSBNb2RlbEFydGlmYWN0cy4gVGhlIG11bHRpLWFyZ3VtZW50IHNpZ25hdHVyZSBvZiB0Zi5pby5mcm9tTWVtb3J5KCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXCIpLG5ldyBaZih7bW9kZWxUb3BvbG9neTp0LHdlaWdodFNwZWNzOmUsd2VpZ2h0RGF0YTpuLHRyYWluaW5nQ29uZmlnOnJ9KSl9LGdldExvYWRIYW5kbGVyczpmdW5jdGlvbih0LGUpe3JldHVybiBtZi5nZXRMb2FkSGFuZGxlcnModCxlKX0sZ2V0TW9kZWxBcnRpZmFjdHNJbmZvRm9ySlNPTjp2ZixnZXRTYXZlSGFuZGxlcnM6ZnVuY3Rpb24odCl7cmV0dXJuIG1mLmdldFNhdmVIYW5kbGVycyh0KX0saHR0cDpKZixpc0hUVFBTY2hlbWU6JGYsbG9hZFdlaWdodHM6ZnVuY3Rpb24odCxlLG8sYSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwiXCIpLG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3JldHVyblsyLFhmKChmdW5jdGlvbih0KXtyZXR1cm4gamYodCx7cmVxdWVzdEluaXQ6YX0pfSkpKHQsZSxvKV19KSl9KSl9LHJlZ2lzdGVyTG9hZFJvdXRlcjpmdW5jdGlvbih0KXtyZXR1cm4gbWYucmVnaXN0ZXJMb2FkUm91dGVyKHQpfSxyZWdpc3RlclNhdmVSb3V0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIG1mLnJlZ2lzdGVyU2F2ZVJvdXRlcih0KX0sd2VpZ2h0c0xvYWRlckZhY3Rvcnk6WGYsd2l0aFNhdmVIYW5kbGVyOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgdGQodCl9LGNvcHlNb2RlbDpmdW5jdGlvbih0LGUpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtyZXR1cm4hMSxbMixiZih0LGUsITEpXX0pKX0pKX0sbGlzdE1vZGVsczpmdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxlLG4sbyxhLGkscztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnQ9eWYuZ2V0U2NoZW1lcygpLGU9e30sbj0wLG89dCxyLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBuPG8ubGVuZ3RoPyhhPW9bbl0sWzQseWYuZ2V0TWFuYWdlcihhKS5saXN0TW9kZWxzKCldKTpbMyw0XTtjYXNlIDI6Zm9yKHMgaW4gaT1yLnNlbnQoKSllW2ErZ2Yrc109aVtzXTtyLmxhYmVsPTM7Y2FzZSAzOnJldHVybiBuKyssWzMsMV07Y2FzZSA0OnJldHVyblsyLGVdfX0pKX0pKX0sbW92ZU1vZGVsOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3JldHVybiEwLFsyLGJmKHQsZSwhMCldfSkpfSkpfSxyZW1vdmVNb2RlbDpmdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7cmV0dXJuIGU9eGYodCksWzIseWYuZ2V0TWFuYWdlcihlLnNjaGVtZSkucmVtb3ZlTW9kZWwoZS5wYXRoKV19KSl9KSl9fSk7dmFyIG5kLHJkPUFuKHtjb25mdXNpb25NYXRyaXhfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1tbih0LFwibGFiZWxzXCIsXCJjb25mdXNpb25NYXRyaXhcIiksbz1tbihlLFwicHJlZGljdGlvbnNcIixcImNvbmZ1c2lvbk1hdHJpeFwiKTtDKG51bGw9PW58fG4+MCYmTnVtYmVyLmlzSW50ZWdlcihuKSwoZnVuY3Rpb24oKXtyZXR1cm5cIklmIHByb3ZpZGVkLCBudW1DbGFzc2VzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290IFwiK259KSksQygxPT09ci5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXhwZWN0ZWQgdGhlIHJhbmsgb2YgbGFiZWxzIHRvIGJlIDEsIGJ1dCBnb3QgXCIrci5yYW5rfSkpLEMoMT09PW8ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkV4cGVjdGVkIHRoZSByYW5rIG9mIHByZWRpY3Rpb25zIHRvIGJlIDEsIGJ1dCBnb3QgXCIrby5yYW5rfSkpLEMoci5zaGFwZVswXT09PW8uc2hhcGVbMF0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJNaXNtYXRjaCBpbiB0aGUgbnVtYmVyIG9mIGV4YW1wbGVzOiBcIityLnNoYXBlWzBdK1wiIHZzLiBcIitvLnNoYXBlWzBdK1wiLiBMYWJlbHMgYW5kIHByZWRpY3Rpb25zIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy5cIn0pKSxDKG4+MCYmTnVtYmVyLmlzSW50ZWdlcihuKSwoZnVuY3Rpb24oKXtyZXR1cm5cIm51bUNsYXNzZXMgaXMgcmVxdWlyZWQgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290IFwiK259KSk7dmFyIGE9UnIoci5hc1R5cGUoXCJpbnQzMlwiKSxuKSxpPVJyKG8uYXNUeXBlKFwiaW50MzJcIiksbik7cmV0dXJuIGEudHJhbnNwb3NlKCkubWF0TXVsKGkpLmFzVHlwZShcImludDMyXCIpfX0pLG9kPU9iamVjdC5mcmVlemUoe2NvbmZ1c2lvbk1hdHJpeDpyZH0pO3ZhciBhZD1Bbih7ZnJvbVBpeGVsc186ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT1lJiYoZT0zKSxlPjQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnN0cnVjdCBUZW5zb3Igd2l0aCBtb3JlIHRoYW4gNCBjaGFubmVscyBmcm9tIHBpeGVscy5cIik7aWYobnVsbD09dCl0aHJvdyBuZXcgRXJyb3IoXCJwaXhlbHMgcGFzc2VkIHRvIHRmLmJyb3dzZXIuZnJvbVBpeGVscygpIGNhbiBub3QgYmUgbnVsbFwiKTt2YXIgbj0hMSxyPSExLG89ITEsYT0hMSxpPSExO2lmKHQuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpbj0hMDtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBJbWFnZURhdGEmJnQgaW5zdGFuY2VvZiBJbWFnZURhdGEpcj0hMDtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBIVE1MVmlkZW9FbGVtZW50JiZ0IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudClvPSEwO2Vsc2UgaWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQmJnQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KWE9ITA7ZWxzZXtpZihudWxsPT10LmdldENvbnRleHQpdGhyb3cgbmV3IEVycm9yKFwicGl4ZWxzIHBhc3NlZCB0byB0Zi5icm93c2VyLmZyb21QaXhlbHMoKSBtdXN0IGJlIGVpdGhlciBhbiBIVE1MVmlkZW9FbGVtZW50LCBIVE1MSW1hZ2VFbGVtZW50LCBIVE1MQ2FudmFzRWxlbWVudCwgSW1hZ2VEYXRhIGluIGJyb3dzZXIsIG9yIE9mZnNjcmVlbkNhbnZhcywgSW1hZ2VEYXRhIGluIHdlYndvcmtlciBvciB7ZGF0YTogVWludDMyQXJyYXksIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgYnV0IHdhcyBcIit0LmNvbnN0cnVjdG9yLm5hbWUpO2k9ITB9aWYobyl7aWYobyYmdC5yZWFkeVN0YXRlPDIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHZpZGVvIGVsZW1lbnQgaGFzIG5vdCBsb2FkZWQgZGF0YSB5ZXQuIFBsZWFzZSB3YWl0IGZvciBgbG9hZGVkZGF0YWAgZXZlbnQgb24gdGhlIDx2aWRlbz4gZWxlbWVudC5cIil9aWYobnVsbCE9bChcIkZyb21QaXhlbHNcIixMdC5iYWNrZW5kTmFtZSkpcmV0dXJuIEx0LnJ1bktlcm5lbChcIkZyb21QaXhlbHNcIix7cGl4ZWxzOnR9LHtudW1DaGFubmVsczplfSk7dmFyIHMsdSxjPW8/W3QudmlkZW9XaWR0aCx0LnZpZGVvSGVpZ2h0XTpbdC53aWR0aCx0LmhlaWdodF0saD1jWzBdLGY9Y1sxXTtpZihpP3M9dC5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKDAsMCxoLGYpLmRhdGE6cnx8bj9zPXQuZGF0YTooYXx8bykmJihudWxsPT1uZCYmKG5kPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpKSxuZC5jYW52YXMud2lkdGg9aCxuZC5jYW52YXMuaGVpZ2h0PWYsbmQuZHJhd0ltYWdlKHQsMCwwLGgsZikscz1uZC5nZXRJbWFnZURhdGEoMCwwLGgsZikuZGF0YSksND09PWUpdT1uZXcgSW50MzJBcnJheShzKTtlbHNle3ZhciBkPWgqZjt1PW5ldyBJbnQzMkFycmF5KGQqZSk7Zm9yKHZhciBwPTA7cDxkO3ArKylmb3IodmFyIHY9MDt2PGU7Kyt2KXVbcCplK3ZdPXNbNCpwK3ZdfXJldHVybiBQbih1LFtmLGgsZV0sXCJpbnQzMlwiKX19KSxpZD1PYmplY3QuZnJlZXplKHt0b1BpeGVsczpmdW5jdGlvbih0LGUpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixvLGEsaSxzLHUsYyxsLGgsZixkLHAsdixtLGcseSx4LGIsdyxDLEUsUixJO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYobj1tbih0LFwiaW1nXCIsXCJ0b1BpeGVsc1wiKSx0IGluc3RhbmNlb2Ygd3R8fChuPW4udG9JbnQoKSksMiE9PW4ucmFuayYmMyE9PW4ucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJ0b1BpeGVscyBvbmx5IHN1cHBvcnRzIHJhbmsgMiBvciAzIHRlbnNvcnMsIGdvdCByYW5rIFwiK24ucmFuaytcIi5cIik7aWYobz1uLnNoYXBlLnNsaWNlKDAsMiksYT1vWzBdLGk9b1sxXSwocz0yPT09bi5yYW5rPzE6bi5zaGFwZVsyXSk+NHx8Mj09PXMpdGhyb3cgbmV3IEVycm9yKFwidG9QaXhlbHMgb25seSBzdXBwb3J0cyBkZXB0aCBvZiBzaXplIDEsIDMgb3IgNCBidXQgZ290IFwiK3MpO3JldHVybls0LG4uZGF0YSgpXTtjYXNlIDE6cmV0dXJuIHU9ci5zZW50KCksYz1uLm1pbigpLGw9bi5tYXgoKSxbNCxQcm9taXNlLmFsbChbYy5kYXRhKCksbC5kYXRhKCldKV07Y2FzZSAyOmlmKGg9ci5zZW50KCksZj1oWzBdLGQ9aFsxXSxwPWZbMF0sdj1kWzBdLGMuZGlzcG9zZSgpLGwuZGlzcG9zZSgpLFwiZmxvYXQzMlwiPT09bi5kdHlwZSl7aWYocDwwfHx2PjEpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIHZhbHVlcyBmb3IgYSBmbG9hdDMyIFRlbnNvciBtdXN0IGJlIGluIHRoZSByYW5nZSBbMCAtIDFdIGJ1dCBnb3QgcmFuZ2UgW1wiK3ArXCIgLSBcIit2K1wiXS5cIil9ZWxzZXtpZihcImludDMyXCIhPT1uLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHR5cGUgZm9yIHRvUGl4ZWxzOiBcIituLmR0eXBlK1wiLiBQbGVhc2UgdXNlIGZsb2F0MzIgb3IgaW50MzIgdGVuc29ycy5cIik7aWYocDwwfHx2PjI1NSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgdmFsdWVzIGZvciBhIGludDMyIFRlbnNvciBtdXN0IGJlIGluIHRoZSByYW5nZSBbMCAtIDI1NV0gYnV0IGdvdCByYW5nZSBbXCIrcCtcIiAtIFwiK3YrXCJdLlwiKX1mb3IobT1cImZsb2F0MzJcIj09PW4uZHR5cGU/MjU1OjEsZz1uZXcgVWludDhDbGFtcGVkQXJyYXkoaSphKjQpLHk9MDt5PGEqaTsrK3kpeD12b2lkIDAsYj12b2lkIDAsdz12b2lkIDAsQz12b2lkIDAsMT09PXM/KHg9dVt5XSptLGI9dVt5XSptLHc9dVt5XSptLEM9MjU1KTozPT09cz8oeD11WzMqeV0qbSxiPXVbMyp5KzFdKm0sdz11WzMqeSsyXSptLEM9MjU1KTo0PT09cyYmKHg9dVs0KnldKm0sYj11WzQqeSsxXSptLHc9dVs0KnkrMl0qbSxDPXVbNCp5KzNdKm0pLGdbKEU9NCp5KSswXT1NYXRoLnJvdW5kKHgpLGdbRSsxXT1NYXRoLnJvdW5kKGIpLGdbRSsyXT1NYXRoLnJvdW5kKHcpLGdbRSszXT1NYXRoLnJvdW5kKEMpO3JldHVybiBudWxsIT1lJiYoZS53aWR0aD1pLGUuaGVpZ2h0PWEsUj1lLmdldENvbnRleHQoXCIyZFwiKSxJPW5ldyBJbWFnZURhdGEoZyxpLGEpLFIucHV0SW1hZ2VEYXRhKEksMCwwKSksbiE9PXQmJm4uZGlzcG9zZSgpLFsyLGddfX0pKX0pKX0sZnJvbVBpeGVsczphZH0pLHNkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY2xhc3NOYW1lfSx0LmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZSl9LHR9KCksdWQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5jbGFzc05hbWVNYXA9e319cmV0dXJuIHQuZ2V0TWFwPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PXQuaW5zdGFuY2UmJih0Lmluc3RhbmNlPW5ldyB0KSx0Lmluc3RhbmNlfSx0LnJlZ2lzdGVyPWZ1bmN0aW9uKGUpe3QuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwW2UuY2xhc3NOYW1lXT1bZSxlLmZyb21Db25maWddfSx0fSgpO2Z1bmN0aW9uIGNkKHQpe0MobnVsbCE9dC5jbGFzc05hbWUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJDbGFzcyBiZWluZyByZWdpc3RlcmVkIGRvZXMgbm90IGhhdmUgdGhlIHN0YXRpYyBjbGFzc05hbWUgcHJvcGVydHkgZGVmaW5lZC5cIn0pKSxDKFwic3RyaW5nXCI9PXR5cGVvZiB0LmNsYXNzTmFtZSwoZnVuY3Rpb24oKXtyZXR1cm5cImNsYXNzTmFtZSBpcyByZXF1aXJlZCB0byBiZSBhIHN0cmluZywgYnV0IGdvdCB0eXBlIFwiK3R5cGVvZiB0LmNsYXNzTmFtZX0pKSxDKHQuY2xhc3NOYW1lLmxlbmd0aD4wLChmdW5jdGlvbigpe3JldHVyblwiQ2xhc3MgYmVpbmcgcmVnaXN0ZXJlZCBoYXMgYW4gZW1wdHktc3RyaW5nIGFzIGl0cyBjbGFzc05hbWUsIHdoaWNoIGlzIGRpc2FsbG93ZWQuXCJ9KSksdWQucmVnaXN0ZXIodCl9dmFyIGxkPU9iamVjdC5mcmVlemUoe1NlcmlhbGl6YWJsZTpzZCxTZXJpYWxpemF0aW9uTWFwOnVkLHJlZ2lzdGVyQ2xhc3M6Y2R9KSxoZD0uMDAxLGZkPS4xO2Z1bmN0aW9uIGRkKCl7cmV0dXJuIDMyPT09THQuYmFja2VuZC5mbG9hdFByZWNpc2lvbigpP2hkOmZkfWZ1bmN0aW9uIHBkKHQsZSxuKXt2YXIgcj0hMDtpZigoVih0KXx8VihlKSkmJihyPSExKSxWKHQpJiZWKGUpJiYocj0hMCkscil7dmFyIG89dC5jb25zdHJ1Y3Rvci5uYW1lLGE9ZS5jb25zdHJ1Y3Rvci5uYW1lO2lmKG8hPT1hKXRocm93IG5ldyBFcnJvcihcIkFycmF5cyBhcmUgb2YgZGlmZmVyZW50IHR5cGUuIEFjdHVhbDogXCIrbytcIi4gRXhwZWN0ZWQ6IFwiK2EpfWlmKEFycmF5LmlzQXJyYXkodCkmJkFycmF5LmlzQXJyYXkoZSkpe3ZhciBpPXBuKHQpLHM9cG4oZSk7aWYoIVMoaSxzKSl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgaGF2ZSBkaWZmZXJlbnQgc2hhcGVzLiBBY3R1YWw6IFtcIitpK1wiXS4gRXhwZWN0ZWQ6IFtcIitzK1wiXVwiKX12YXIgdT1WKHQpP3Q6SSh0KSxjPVYoZSk/ZTpJKGUpO2lmKHUubGVuZ3RoIT09Yy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGhhdmUgZGlmZmVyZW50IGxlbmd0aHMgYWN0dWFsOiBcIit1Lmxlbmd0aCtcIiB2cyBleHBlY3RlZDogXCIrYy5sZW5ndGgrXCIuXFxuQWN0dWFsOiAgIFwiK3UrXCIuXFxuRXhwZWN0ZWQ6IFwiK2MrXCIuXCIpO2Zvcih2YXIgbD0wO2w8Yy5sZW5ndGg7KytsKXt2YXIgaD11W2xdLGY9Y1tsXTtpZighbihoLGYpKXRocm93IG5ldyBFcnJvcihcIkFycmF5cyBkaWZmZXI6IGFjdHVhbFtcIitsK1wiXSA9IFwiK2grXCIsIGV4cGVjdGVkW1wiK2wrXCJdID0gXCIrZitcIi5cXG5BY3R1YWw6ICAgXCIrdStcIi5cXG5FeHBlY3RlZDogXCIrYytcIi5cIil9fWZ1bmN0aW9uIHZkKHQsZSxuKXtyZXR1cm4haXNGaW5pdGUodCkmJiFpc0Zpbml0ZShlKXx8IShpc05hTih0KXx8aXNOYU4oZSl8fE1hdGguYWJzKHQtZSk+bil9dmFyIG1kPU9iamVjdC5mcmVlemUoe1RFU1RfRVBTSUxPTl9GTE9BVDE2OmZkLGV4cGVjdEFycmF5c0Nsb3NlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gbnVsbD09biYmKG49ZGQoKSkscGQodCxlLChmdW5jdGlvbih0LGUpe3JldHVybiB2ZCh0LGUsbil9KSl9LHRlc3RFcHNpbG9uOmRkLGV4cGVjdFByb21pc2VUb0ZhaWw6ZnVuY3Rpb24odCxlKXt0KCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gZS5mYWlsKCl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gZSgpfSkpfSxleHBlY3RBcnJheXNFcXVhbDpmdW5jdGlvbih0LGUpe3ZhciBuPVwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlP1tlXTplO3JldHVybiBIKHQpfHxIKHRbMF0pfHxIKGUpfHxIKGVbMF0pP3BkKHQsbiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09ZX0pKTpwZCh0LGUsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZkKHQsZSwwKX0pKX0sZXhwZWN0TnVtYmVyc0Nsb3NlOmZ1bmN0aW9uKHQsZSxuKXtpZihudWxsPT1uJiYobj1kZCgpKSwhdmQodCxlLG4pKXRocm93IG5ldyBFcnJvcihcIk51bWJlcnMgZGlmZmVyOiBhY3R1YWwgPT09IFwiK3QrXCIsIGV4cGVjdGVkID09PSBcIitlKX0sZXhwZWN0VmFsdWVzSW5SYW5nZTpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspaWYodFtyXTxlfHx0W3JdPm4pdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgb3V0IG9mIHJhbmdlOlwiK3Rbcl0rXCIgbG93OiBcIitlK1wiLCBoaWdoOiBcIituKX0sZXhwZWN0QXJyYXlCdWZmZXJzRXF1YWw6ZnVuY3Rpb24odCxlKXtleHBlY3QobmV3IEZsb2F0MzJBcnJheSh0KSkudG9FcXVhbChuZXcgRmxvYXQzMkFycmF5KGUpKX19KSxnZD1cIjEuNy4wXCI7dmFyIHlkPU9iamVjdC5mcmVlemUoe2dwZ3B1X3V0aWw6TWksd2ViZ2xfdXRpbDpHZSxmb3JjZUhhbGZGbG9hdDpmdW5jdGlvbigpe2koKS5zZXQoXCJXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVNcIiwhMCl9LE1hdGhCYWNrZW5kV2ViR0w6WnMsc2V0V2ViR0xDb250ZXh0Okt0LEdQR1BVQ29udGV4dDpCaX0pLHhkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oKXtyZXR1cm4gbnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBlKG8sdCksby5wcm90b3R5cGUubWluaW1pemU9ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPSExKTt2YXIgcj10aGlzLmNvbXB1dGVHcmFkaWVudHModCxuKSxvPXIudmFsdWUsYT1yLmdyYWRzO2lmKG51bGwhPW4pe3ZhciBpPW4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm57bmFtZTp0Lm5hbWUsdGVuc29yOmFbdC5uYW1lXX19KSk7dGhpcy5hcHBseUdyYWRpZW50cyhpKX1lbHNlIHRoaXMuYXBwbHlHcmFkaWVudHMoYSk7cmV0dXJuIHRuKGEpLGU/bzooby5kaXNwb3NlKCksbnVsbCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLnByb3RvdHlwZSxcIml0ZXJhdGlvbnNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PXRoaXMuaXRlcmF0aW9uc18mJih0aGlzLml0ZXJhdGlvbnNfPTApLHRoaXMuaXRlcmF0aW9uc199LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksby5wcm90b3R5cGUuaW5jcmVtZW50SXRlcmF0aW9ucz1mdW5jdGlvbigpe3RoaXMuaXRlcmF0aW9uc189dGhpcy5pdGVyYXRpb25zKzF9LG8ucHJvdG90eXBlLmNvbXB1dGVHcmFkaWVudHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gcG8odCxlKX0sby5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe251bGwhPXRoaXMuaXRlcmF0aW9uc18mJnRuKHRoaXMuaXRlcmF0aW9uc18pfSxvLnByb3RvdHlwZS5zYXZlSXRlcmF0aW9ucz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dGhpcy5pdGVyYXRpb25zXyYmKHRoaXMuaXRlcmF0aW9uc189MCksWzIse25hbWU6XCJpdGVyXCIsdGVuc29yOk9uKHRoaXMuaXRlcmF0aW9uc18sXCJpbnQzMlwiKX1dfSkpfSkpfSxvLnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcImdldFdlaWdodHMoKSBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIHRoaXMgb3B0aW1pemVyIHlldC5cIil9KSl9KSl9LG8ucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcInNldFdlaWdodHMoKSBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIHRoaXMgb3B0aW1pemVyIGNsYXNzIFwiK3RoaXMuZ2V0Q2xhc3NOYW1lKCkpfSkpfSkpfSxvLnByb3RvdHlwZS5leHRyYWN0SXRlcmF0aW9ucz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gZT10aGlzLFs0LHRbMF0udGVuc29yLmRhdGEoKV07Y2FzZSAxOnJldHVybiBlLml0ZXJhdGlvbnNfPW4uc2VudCgpWzBdLFsyLHQuc2xpY2UoMSldfX0pKX0pKX0sb30oc2QpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh4ZCxTeW1ib2wuaGFzSW5zdGFuY2Use3ZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10Lm1pbmltaXplJiZudWxsIT10LmNvbXB1dGVHcmFkaWVudHMmJm51bGwhPXQuYXBwbHlHcmFkaWVudHN9fSk7dmFyIGJkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSxuLHIpe3ZvaWQgMD09PXImJihyPW51bGwpO3ZhciBvPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gby5sZWFybmluZ1JhdGU9ZSxvLnJobz1uLG8uZXBzaWxvbj1yLG8uYWNjdW11bGF0ZWRHcmFkcz1bXSxvLmFjY3VtdWxhdGVkVXBkYXRlcz1bXSxudWxsPT1yJiYoby5lcHNpbG9uPUx0LmJhY2tlbmQuZXBzaWxvbigpKSxvfXJldHVybiBlKG8sdCksby5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpczsoQXJyYXkuaXNBcnJheSh0KT90Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pKTpPYmplY3Qua2V5cyh0KSkuZm9yRWFjaCgoZnVuY3Rpb24obixyKXt2YXIgbz1MdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dO251bGw9PWUuYWNjdW11bGF0ZWRHcmFkc1tyXSYmKGUuYWNjdW11bGF0ZWRHcmFkc1tyXT17b3JpZ2luYWxOYW1lOm4rXCIvYWNjdW1fZ3JhZFwiLHZhcmlhYmxlOlplKChmdW5jdGlvbigpe3JldHVybiBYbihvKS52YXJpYWJsZSghMSl9KSl9KSxudWxsPT1lLmFjY3VtdWxhdGVkVXBkYXRlc1tyXSYmKGUuYWNjdW11bGF0ZWRVcGRhdGVzW3JdPXtvcmlnaW5hbE5hbWU6bitcIi9hY2N1bV92YXJcIix2YXJpYWJsZTpaZSgoZnVuY3Rpb24oKXtyZXR1cm4gWG4obykudmFyaWFibGUoITEpfSkpfSk7dmFyIGE9QXJyYXkuaXNBcnJheSh0KT90W3JdLnRlbnNvcjp0W25dO2lmKG51bGwhPWEpe3ZhciBpPWUuYWNjdW11bGF0ZWRHcmFkc1tyXS52YXJpYWJsZSxzPWUuYWNjdW11bGF0ZWRVcGRhdGVzW3JdLnZhcmlhYmxlO1plKChmdW5jdGlvbigpe3ZhciB0PWkubXVsKGUucmhvKS5hZGQoYS5zcXVhcmUoKS5tdWwoMS1lLnJobykpLG49cy5hZGQoZS5lcHNpbG9uKS5zcXJ0KCkuZGl2KGkuYWRkKGUuZXBzaWxvbikuc3FydCgpKS5tdWwoYSkscj1zLm11bChlLnJobykuYWRkKG4uc3F1YXJlKCkubXVsKDEtZS5yaG8pKTtpLmFzc2lnbih0KSxzLmFzc2lnbihyKTt2YXIgdT1uLm11bCgtZS5sZWFybmluZ1JhdGUpLmFkZChvKTtvLmFzc2lnbih1KX0pKX19KSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmFjY3VtdWxhdGVkVXBkYXRlcyYmKHRuKHRoaXMuYWNjdW11bGF0ZWRHcmFkcy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnZhcmlhYmxlfSkpKSx0bih0aGlzLmFjY3VtdWxhdGVkVXBkYXRlcy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnZhcmlhYmxlfSkpKSl9LG8ucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdD10aGlzLmFjY3VtdWxhdGVkR3JhZHMuY29uY2F0KHRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzKSxbNCx0aGlzLnNhdmVJdGVyYXRpb25zKCldO2Nhc2UgMTpyZXR1cm5bMixbZS5zZW50KCldLmNvbmNhdCh0Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue25hbWU6dC5vcmlnaW5hbE5hbWUsdGVuc29yOnQudmFyaWFibGV9fSkpKV19fSkpfSkpfSxvLnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZXh0cmFjdEl0ZXJhdGlvbnModCldO2Nhc2UgMTpyZXR1cm4gdD1uLnNlbnQoKSxlPXQubGVuZ3RoLzIsITEsdGhpcy5hY2N1bXVsYXRlZEdyYWRzPXQuc2xpY2UoMCxlKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntvcmlnaW5hbE5hbWU6dC5uYW1lLHZhcmlhYmxlOnQudGVuc29yLnZhcmlhYmxlKCExKX19KSksdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXM9dC5zbGljZShlLDIqZSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm57b3JpZ2luYWxOYW1lOnQubmFtZSx2YXJpYWJsZTp0LnRlbnNvci52YXJpYWJsZSghMSl9fSkpLFsyXX19KSl9KSl9LG8ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUscmhvOnRoaXMucmhvLGVwc2lsb246dGhpcy5lcHNpbG9ufX0sby5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlLGUucmhvLGUuZXBzaWxvbil9LG8uY2xhc3NOYW1lPVwiQWRhZGVsdGFcIixvfSh4ZCk7Y2QoYmQpO3ZhciB3ZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKGUsbil7dm9pZCAwPT09biYmKG49LjEpO3ZhciByPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gci5sZWFybmluZ1JhdGU9ZSxyLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlPW4sci5hY2N1bXVsYXRlZEdyYWRzPVtdLHJ9cmV0dXJuIGUobyx0KSxvLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzOyhBcnJheS5pc0FycmF5KHQpP3QubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSkpOk9iamVjdC5rZXlzKHQpKS5mb3JFYWNoKChmdW5jdGlvbihuLHIpe3ZhciBvPUx0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07aWYobnVsbD09ZS5hY2N1bXVsYXRlZEdyYWRzW3JdKXtlLmFjY3VtdWxhdGVkR3JhZHNbcl09e29yaWdpbmFsTmFtZTpuK1wiL2FjY3VtdWxhdG9yXCIsdmFyaWFibGU6WmUoKGZ1bmN0aW9uKCl7cmV0dXJuIEhuKG8uc2hhcGUsZS5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZSkudmFyaWFibGUoITEpfSkpfX12YXIgYT1BcnJheS5pc0FycmF5KHQpP3Rbcl0udGVuc29yOnRbbl07aWYobnVsbCE9YSl7dmFyIGk9ZS5hY2N1bXVsYXRlZEdyYWRzW3JdLnZhcmlhYmxlO1plKChmdW5jdGlvbigpe3ZhciB0PWkuYWRkKGEuc3F1YXJlKCkpO2kuYXNzaWduKHQpO3ZhciBuPWEuZGl2KHQuYWRkKEx0LmJhY2tlbmQuZXBzaWxvbigpKS5zcXJ0KCkpLm11bCgtZS5sZWFybmluZ1JhdGUpLmFkZChvKTtvLmFzc2lnbihuKX0pKX19KSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmFjY3VtdWxhdGVkR3JhZHMmJnRuKHRoaXMuYWNjdW11bGF0ZWRHcmFkcy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnZhcmlhYmxlfSkpKX0sby5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuc2F2ZUl0ZXJhdGlvbnMoKV07Y2FzZSAxOnJldHVyblsyLFt0LnNlbnQoKV0uY29uY2F0KHRoaXMuYWNjdW11bGF0ZWRHcmFkcy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntuYW1lOnQub3JpZ2luYWxOYW1lLHRlbnNvcjp0LnZhcmlhYmxlfX0pKSldfX0pKX0pKX0sby5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmV4dHJhY3RJdGVyYXRpb25zKHQpXTtjYXNlIDE6cmV0dXJuIHQ9ZS5zZW50KCksITEsdGhpcy5hY2N1bXVsYXRlZEdyYWRzPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm57b3JpZ2luYWxOYW1lOnQubmFtZSx2YXJpYWJsZTp0LnRlbnNvci52YXJpYWJsZSghMSl9fSkpLFsyXX19KSl9KSl9LG8ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWU6dGhpcy5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZX19LG8uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSxlLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlKX0sby5jbGFzc05hbWU9XCJBZGFncmFkXCIsb30oeGQpO2NkKHdkKTt2YXIgQ2Q9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbyhlLG4scixvKXt2b2lkIDA9PT1vJiYobz1udWxsKTt2YXIgYT10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGEubGVhcm5pbmdSYXRlPWUsYS5iZXRhMT1uLGEuYmV0YTI9cixhLmVwc2lsb249byxhLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQ9W10sYS5hY2N1bXVsYXRlZFNlY29uZE1vbWVudD1bXSxaZSgoZnVuY3Rpb24oKXthLmFjY0JldGExPU9uKG4pLnZhcmlhYmxlKCksYS5hY2NCZXRhMj1PbihyKS52YXJpYWJsZSgpfSkpLG51bGw9PW8mJihhLmVwc2lsb249THQuYmFja2VuZC5lcHNpbG9uKCkpLGF9cmV0dXJuIGUobyx0KSxvLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49QXJyYXkuaXNBcnJheSh0KT90Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pKTpPYmplY3Qua2V5cyh0KTtaZSgoZnVuY3Rpb24oKXt2YXIgcj1DYygxLGUuYWNjQmV0YTEpLG89Q2MoMSxlLmFjY0JldGEyKTtuLmZvckVhY2goKGZ1bmN0aW9uKG4sYSl7dmFyIGk9THQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXTtudWxsPT1lLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbYV0mJihlLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbYV09e29yaWdpbmFsTmFtZTpuK1wiL21cIix2YXJpYWJsZTpaZSgoZnVuY3Rpb24oKXtyZXR1cm4gWG4oaSkudmFyaWFibGUoITEpfSkpfSksbnVsbD09ZS5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFthXSYmKGUuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbYV09e29yaWdpbmFsTmFtZTpuK1wiL3ZcIix2YXJpYWJsZTpaZSgoZnVuY3Rpb24oKXtyZXR1cm4gWG4oaSkudmFyaWFibGUoITEpfSkpfSk7dmFyIHM9QXJyYXkuaXNBcnJheSh0KT90W2FdLnRlbnNvcjp0W25dO2lmKG51bGwhPXMpe3ZhciB1PWUuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFthXS52YXJpYWJsZSxjPWUuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbYV0udmFyaWFibGUsbD11Lm11bChlLmJldGExKS5hZGQocy5tdWwoMS1lLmJldGExKSksaD1jLm11bChlLmJldGEyKS5hZGQocy5zcXVhcmUoKS5tdWwoMS1lLmJldGEyKSksZj1sLmRpdihyKSxkPWguZGl2KG8pO3UuYXNzaWduKGwpLGMuYXNzaWduKGgpO3ZhciBwPWYuZGl2KGQuc3FydCgpLmFkZChlLmVwc2lsb24pKS5tdWwoLWUubGVhcm5pbmdSYXRlKS5hZGQoaSk7aS5hc3NpZ24ocCl9fSkpLGUuYWNjQmV0YTEuYXNzaWduKGUuYWNjQmV0YTEubXVsKGUuYmV0YTEpKSxlLmFjY0JldGEyLmFzc2lnbihlLmFjY0JldGEyLm11bChlLmJldGEyKSl9KSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmFjY0JldGExLmRpc3Bvc2UoKSx0aGlzLmFjY0JldGEyLmRpc3Bvc2UoKSxudWxsIT10aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQmJnRuKHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnZhcmlhYmxlfSkpKSxudWxsIT10aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50JiZ0bih0aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpfSxvLnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0O3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHQ9dGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50LmNvbmNhdCh0aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50KSxbNCx0aGlzLnNhdmVJdGVyYXRpb25zKCldO2Nhc2UgMTpyZXR1cm5bMixbZS5zZW50KCldLmNvbmNhdCh0Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue25hbWU6dC5vcmlnaW5hbE5hbWUsdGVuc29yOnQudmFyaWFibGV9fSkpKV19fSkpfSkpfSxvLnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuPXRoaXM7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmV4dHJhY3RJdGVyYXRpb25zKHQpXTtjYXNlIDE6cmV0dXJuIHQ9ci5zZW50KCksWmUoKGZ1bmN0aW9uKCl7bi5hY2NCZXRhMS5hc3NpZ24oeGMobi5iZXRhMSxuLml0ZXJhdGlvbnNfKzEpKSxuLmFjY0JldGEyLmFzc2lnbih4YyhuLmJldGEyLG4uaXRlcmF0aW9uc18rMSkpfSkpLGU9dC5sZW5ndGgvMiwhMSx0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQ9dC5zbGljZSgwLGUpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue29yaWdpbmFsTmFtZTp0Lm5hbWUsdmFyaWFibGU6dC50ZW5zb3IudmFyaWFibGUoITEpfX0pKSx0aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50PXQuc2xpY2UoZSwyKmUpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue29yaWdpbmFsTmFtZTp0Lm5hbWUsdmFyaWFibGU6dC50ZW5zb3IudmFyaWFibGUoITEpfX0pKSxbMl19fSkpfSkpfSxvLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGJldGExOnRoaXMuYmV0YTEsYmV0YTI6dGhpcy5iZXRhMixlcHNpbG9uOnRoaXMuZXBzaWxvbn19LG8uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSxlLmJldGExLGUuYmV0YTIsZS5lcHNpbG9uKX0sby5jbGFzc05hbWU9XCJBZGFtXCIsb30oeGQpO2NkKENkKTt2YXIgRWQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbyhlLG4scixvLGEpe3ZvaWQgMD09PW8mJihvPW51bGwpLHZvaWQgMD09PWEmJihhPTApO3ZhciBpPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gaS5sZWFybmluZ1JhdGU9ZSxpLmJldGExPW4saS5iZXRhMj1yLGkuZXBzaWxvbj1vLGkuZGVjYXk9YSxpLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQ9W10saS5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybT1bXSxaZSgoZnVuY3Rpb24oKXtpLml0ZXJhdGlvbj1PbigwKS52YXJpYWJsZSgpLGkuYWNjQmV0YTE9T24obikudmFyaWFibGUoKX0pKSxudWxsPT1vJiYoaS5lcHNpbG9uPUx0LmJhY2tlbmQuZXBzaWxvbigpKSxpfXJldHVybiBlKG8sdCksby5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPUFycmF5LmlzQXJyYXkodCk/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSk6T2JqZWN0LmtleXModCk7WmUoKGZ1bmN0aW9uKCl7dmFyIHI9Q2MoMSxlLmFjY0JldGExKSxvPXNjKC1lLmxlYXJuaW5nUmF0ZSxlLml0ZXJhdGlvbi5tdWwoZS5kZWNheSkuYWRkKDEpKTtuLmZvckVhY2goKGZ1bmN0aW9uKG4sYSl7dmFyIGk9THQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXTtudWxsPT1lLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbYV0mJihlLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbYV09e29yaWdpbmFsTmFtZTpuK1wiL21cIix2YXJpYWJsZTpYbihpKS52YXJpYWJsZSghMSl9KSxudWxsPT1lLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW2FdJiYoZS5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVthXT17b3JpZ2luYWxOYW1lOm4rXCIvdlwiLHZhcmlhYmxlOlhuKGkpLnZhcmlhYmxlKCExKX0pO3ZhciBzPUFycmF5LmlzQXJyYXkodCk/dFthXS50ZW5zb3I6dFtuXTtpZihudWxsIT1zKXt2YXIgdT1lLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbYV0udmFyaWFibGUsYz1lLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW2FdLnZhcmlhYmxlLGw9dS5tdWwoZS5iZXRhMSkuYWRkKHMubXVsKDEtZS5iZXRhMSkpLGg9Yy5tdWwoZS5iZXRhMiksZj1zLmFicygpLGQ9aC5tYXhpbXVtKGYpO3UuYXNzaWduKGwpLGMuYXNzaWduKGQpO3ZhciBwPW8uZGl2KHIpLm11bChsLmRpdihkLmFkZChlLmVwc2lsb24pKSkuYWRkKGkpO2kuYXNzaWduKHApfX0pKSxlLml0ZXJhdGlvbi5hc3NpZ24oZS5pdGVyYXRpb24uYWRkKDEpKSxlLmFjY0JldGExLmFzc2lnbihlLmFjY0JldGExLm11bChlLmJldGExKSl9KSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmFjY0JldGExLmRpc3Bvc2UoKSx0aGlzLml0ZXJhdGlvbi5kaXNwb3NlKCksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50JiZ0bih0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybSYmdG4odGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnZhcmlhYmxlfSkpKX0sby5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJnZXRXZWlnaHRzKCkgaXMgbm90IGltcGxlbWVudGVkIGZvciBBZGFtYXggeWV0LlwiKX0pKX0pKX0sby5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwic2V0V2VpZ2h0cygpIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgQWRhbWF4IHlldC5cIil9KSl9KSl9LG8ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsYmV0YTE6dGhpcy5iZXRhMSxiZXRhMjp0aGlzLmJldGEyLGVwc2lsb246dGhpcy5lcHNpbG9uLGRlY2F5OnRoaXMuZGVjYXl9fSxvLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5iZXRhMSxlLmJldGEyLGUuZXBzaWxvbixlLmRlY2F5KX0sby5jbGFzc05hbWU9XCJBZGFtYXhcIixvfSh4ZCk7Y2QoRWQpO3ZhciBSZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKGUpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5sZWFybmluZ1JhdGU9ZSxuLnNldExlYXJuaW5nUmF0ZShlKSxufXJldHVybiBlKG8sdCksby5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpczsoQXJyYXkuaXNBcnJheSh0KT90Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pKTpPYmplY3Qua2V5cyh0KSkuZm9yRWFjaCgoZnVuY3Rpb24obixyKXt2YXIgbz1BcnJheS5pc0FycmF5KHQpP3Rbcl0udGVuc29yOnRbbl07aWYobnVsbCE9byl7dmFyIGE9THQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXTtaZSgoZnVuY3Rpb24oKXt2YXIgdD1lLmMubXVsKG8pLmFkZChhKTthLmFzc2lnbih0KX0pKX19KSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9LG8ucHJvdG90eXBlLnNldExlYXJuaW5nUmF0ZT1mdW5jdGlvbih0KXt0aGlzLmxlYXJuaW5nUmF0ZT10LG51bGwhPXRoaXMuYyYmdGhpcy5jLmRpc3Bvc2UoKSx0aGlzLmM9ZW4oT24oLXQpKX0sby5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuYy5kaXNwb3NlKCl9LG8ucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLnNhdmVJdGVyYXRpb25zKCldO2Nhc2UgMTpyZXR1cm5bMixbdC5zZW50KCldXX19KSl9KSl9LG8ucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5leHRyYWN0SXRlcmF0aW9ucyh0KV07Y2FzZSAxOmlmKDAhPT0odD1lLnNlbnQoKSkubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNHRCBvcHRpbWl6ZXIgZG9lcyBub3QgaGF2ZSBzZXR0YWJsZSB3ZWlnaHRzLlwiKTtyZXR1cm5bMl19fSkpfSkpfSxvLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlfX0sby5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlKX0sby5jbGFzc05hbWU9XCJTR0RcIixvfSh4ZCk7Y2QoUmQpO3ZhciBJZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKGUsbixyKXt2b2lkIDA9PT1yJiYocj0hMSk7dmFyIG89dC5jYWxsKHRoaXMsZSl8fHRoaXM7cmV0dXJuIG8ubGVhcm5pbmdSYXRlPWUsby5tb21lbnR1bT1uLG8udXNlTmVzdGVyb3Y9cixvLmFjY3VtdWxhdGlvbnM9W10sby5tPU9uKG8ubW9tZW50dW0pLG99cmV0dXJuIGUobyx0KSxvLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzOyhBcnJheS5pc0FycmF5KHQpP3QubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSkpOk9iamVjdC5rZXlzKHQpKS5mb3JFYWNoKChmdW5jdGlvbihuLHIpe3ZhciBvPUx0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07aWYobnVsbD09ZS5hY2N1bXVsYXRpb25zW3JdKXtlLmFjY3VtdWxhdGlvbnNbcl09e29yaWdpbmFsTmFtZTpuK1wiL21vbWVudHVtXCIsdmFyaWFibGU6WmUoKGZ1bmN0aW9uKCl7cmV0dXJuIFhuKG8pLnZhcmlhYmxlKCExKX0pKX19dmFyIGE9ZS5hY2N1bXVsYXRpb25zW3JdLnZhcmlhYmxlLGk9QXJyYXkuaXNBcnJheSh0KT90W3JdLnRlbnNvcjp0W25dO251bGwhPWkmJlplKChmdW5jdGlvbigpe3ZhciB0LG49ZS5tLm11bChhKS5hZGQoaSk7dD1lLnVzZU5lc3Rlcm92P2UuYy5tdWwoaS5hZGQobi5tdWwoZS5tKSkpLmFkZChvKTplLmMubXVsKG4pLmFkZChvKSxhLmFzc2lnbihuKSxvLmFzc2lnbih0KX0pKX0pKSx0aGlzLmluY3JlbWVudEl0ZXJhdGlvbnMoKX0sby5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMubS5kaXNwb3NlKCksbnVsbCE9dGhpcy5hY2N1bXVsYXRpb25zJiZ0bih0aGlzLmFjY3VtdWxhdGlvbnMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSl9LG8ucHJvdG90eXBlLnNldE1vbWVudHVtPWZ1bmN0aW9uKHQpe3RoaXMubW9tZW50dW09dH0sby5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuc2F2ZUl0ZXJhdGlvbnMoKV07Y2FzZSAxOnJldHVyblsyLFt0LnNlbnQoKV0uY29uY2F0KHRoaXMuYWNjdW11bGF0aW9ucy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntuYW1lOnQub3JpZ2luYWxOYW1lLHRlbnNvcjp0LnZhcmlhYmxlfX0pKSldfX0pKX0pKX0sby5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmV4dHJhY3RJdGVyYXRpb25zKHQpXTtjYXNlIDE6cmV0dXJuIHQ9ZS5zZW50KCksITEsdGhpcy5hY2N1bXVsYXRpb25zPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm57b3JpZ2luYWxOYW1lOnQubmFtZSx2YXJpYWJsZTp0LnRlbnNvci52YXJpYWJsZSghMSl9fSkpLFsyXX19KSl9KSl9LG8ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsbW9tZW50dW06dGhpcy5tb21lbnR1bSx1c2VOZXN0ZXJvdjp0aGlzLnVzZU5lc3Rlcm92fX0sby5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlLGUubW9tZW50dW0sZS51c2VOZXN0ZXJvdil9LG8uY2xhc3NOYW1lPVwiTW9tZW50dW1cIixvfShSZCk7Y2QoSWQpO3ZhciBrZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKGUsbixyLG8sYSl7dm9pZCAwPT09biYmKG49LjkpLHZvaWQgMD09PXImJihyPTApLHZvaWQgMD09PW8mJihvPW51bGwpLHZvaWQgMD09PWEmJihhPSExKTt2YXIgaT10LmNhbGwodGhpcyl8fHRoaXM7aWYoaS5sZWFybmluZ1JhdGU9ZSxpLmRlY2F5PW4saS5tb21lbnR1bT1yLGkuZXBzaWxvbj1vLGkuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcz1bXSxpLmFjY3VtdWxhdGVkTW9tZW50cz1bXSxpLmFjY3VtdWxhdGVkTWVhbkdyYWRzPVtdLGkuY2VudGVyZWQ9YSxudWxsPT1vJiYoaS5lcHNpbG9uPUx0LmJhY2tlbmQuZXBzaWxvbigpKSxudWxsPT1lKXRocm93IG5ldyBFcnJvcihcImxlYXJuaW5nUmF0ZSBmb3IgUk1TUHJvcE9wdGltaXplciBtdXN0IGJlIGRlZmluZWQuXCIpO3JldHVybiBpfXJldHVybiBlKG8sdCksby5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpczsoQXJyYXkuaXNBcnJheSh0KT90Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pKTpPYmplY3Qua2V5cyh0KSkuZm9yRWFjaCgoZnVuY3Rpb24obixyKXt2YXIgbz1MdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dO251bGw9PWUuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1tyXSYmKGUuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1tyXT17b3JpZ2luYWxOYW1lOm4rXCIvcm1zXCIsdmFyaWFibGU6WmUoKGZ1bmN0aW9uKCl7cmV0dXJuIFhuKG8pLnZhcmlhYmxlKCExKX0pKX0pLG51bGw9PWUuYWNjdW11bGF0ZWRNb21lbnRzW3JdJiYoZS5hY2N1bXVsYXRlZE1vbWVudHNbcl09e29yaWdpbmFsTmFtZTpuK1wiL21vbWVudHVtXCIsdmFyaWFibGU6WmUoKGZ1bmN0aW9uKCl7cmV0dXJuIFhuKG8pLnZhcmlhYmxlKCExKX0pKX0pLG51bGw9PWUuYWNjdW11bGF0ZWRNZWFuR3JhZHNbcl0mJmUuY2VudGVyZWQmJihlLmFjY3VtdWxhdGVkTWVhbkdyYWRzW3JdPXtvcmlnaW5hbE5hbWU6bitcIi9tZ1wiLHZhcmlhYmxlOlplKChmdW5jdGlvbigpe3JldHVybiBYbihvKS52YXJpYWJsZSghMSl9KSl9KTt2YXIgYT1BcnJheS5pc0FycmF5KHQpP3Rbcl0udGVuc29yOnRbbl07aWYobnVsbCE9YSl7dmFyIGk9ZS5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW3JdLnZhcmlhYmxlLHM9ZS5hY2N1bXVsYXRlZE1vbWVudHNbcl0udmFyaWFibGU7WmUoKGZ1bmN0aW9uKCl7dmFyIHQ9aS5tdWwoZS5kZWNheSkuYWRkKGEuc3F1YXJlKCkubXVsKDEtZS5kZWNheSkpO2lmKGUuY2VudGVyZWQpe3ZhciBuPWUuYWNjdW11bGF0ZWRNZWFuR3JhZHNbcl0udmFyaWFibGUsdT1uLm11bChlLmRlY2F5KS5hZGQoYS5tdWwoMS1lLmRlY2F5KSksYz1zLm11bChlLm1vbWVudHVtKS5hZGQoYS5tdWwoZS5sZWFybmluZ1JhdGUpLmRpdih0LnN1Yih1LnNxdWFyZSgpLmFkZChlLmVwc2lsb24pKS5zcXJ0KCkpKTtpLmFzc2lnbih0KSxuLmFzc2lnbih1KSxzLmFzc2lnbihjKTt2YXIgbD1vLnN1YihjKTtvLmFzc2lnbihsKX1lbHNle3ZhciBoPWkubXVsKGUuZGVjYXkpLmFkZChhLnNxdWFyZSgpLm11bCgxLWUuZGVjYXkpKTtjPXMubXVsKGUubW9tZW50dW0pLmFkZChhLm11bChlLmxlYXJuaW5nUmF0ZSkuZGl2KGguYWRkKGUuZXBzaWxvbikuc3FydCgpKSk7aS5hc3NpZ24oaCkscy5hc3NpZ24oYyk7bD1vLnN1YihjKTtvLmFzc2lnbihsKX19KSl9fSkpLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfSxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzJiZ0bih0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcyYmdGhpcy5jZW50ZXJlZCYmdG4odGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnZhcmlhYmxlfSkpKSxudWxsIT10aGlzLmFjY3VtdWxhdGVkTW9tZW50cyYmdG4odGhpcy5hY2N1bXVsYXRlZE1vbWVudHMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSl9LG8ucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdD10aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMuY29uY2F0KHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzKSx0aGlzLmNlbnRlcmVkJiZ0LnB1c2guYXBwbHkodCx0aGlzLmFjY3VtdWxhdGVkTWVhbkdyYWRzKSxbNCx0aGlzLnNhdmVJdGVyYXRpb25zKCldO2Nhc2UgMTpyZXR1cm5bMixbZS5zZW50KCldLmNvbmNhdCh0Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue25hbWU6dC5vcmlnaW5hbE5hbWUsdGVuc29yOnQudmFyaWFibGV9fSkpKV19fSkpfSkpfSxvLnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZXh0cmFjdEl0ZXJhdGlvbnModCldO2Nhc2UgMTpyZXR1cm4gdD1uLnNlbnQoKSxlPXRoaXMuY2VudGVyZWQ/dC5sZW5ndGgvMzp0Lmxlbmd0aC8yLCExLHRoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcz10LnNsaWNlKDAsZSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm57b3JpZ2luYWxOYW1lOnQubmFtZSx2YXJpYWJsZTp0LnRlbnNvci52YXJpYWJsZSghMSl9fSkpLHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzPXQuc2xpY2UoZSwyKmUpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue29yaWdpbmFsTmFtZTp0Lm5hbWUsdmFyaWFibGU6dC50ZW5zb3IudmFyaWFibGUoITEpfX0pKSx0aGlzLmNlbnRlcmVkJiYodGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcz10LnNsaWNlKDIqZSwzKmUpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue29yaWdpbmFsTmFtZTp0Lm5hbWUsdmFyaWFibGU6dC50ZW5zb3IudmFyaWFibGUoITEpfX0pKSksWzJdfX0pKX0pKX0sby5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxkZWNheTp0aGlzLmRlY2F5LG1vbWVudHVtOnRoaXMubW9tZW50dW0sZXBzaWxvbjp0aGlzLmVwc2lsb24sY2VudGVyZWQ6dGhpcy5jZW50ZXJlZH19LG8uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSxlLmRlY2F5LGUubW9tZW50dW0sZS5lcHNpbG9uLGUuY2VudGVyZWQpfSxvLmNsYXNzTmFtZT1cIlJNU1Byb3BcIixvfSh4ZCk7Y2Qoa2QpO3ZhciBTZD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQuc2dkPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgUmQodCl9LHQubW9tZW50dW09ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0hMSksbmV3IElkKHQsZSxuKX0sdC5ybXNwcm9wPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHZvaWQgMD09PWUmJihlPS45KSx2b2lkIDA9PT1uJiYobj0wKSx2b2lkIDA9PT1yJiYocj1udWxsKSx2b2lkIDA9PT1vJiYobz0hMSksbmV3IGtkKHQsZSxuLHIsbyl9LHQuYWRhbT1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LjAwMSksdm9pZCAwPT09ZSYmKGU9LjkpLHZvaWQgMD09PW4mJihuPS45OTkpLHZvaWQgMD09PXImJihyPW51bGwpLG5ldyBDZCh0LGUsbixyKX0sdC5hZGFkZWx0YT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PXQmJih0PS4wMDEpLHZvaWQgMD09PWUmJihlPS45NSksdm9pZCAwPT09biYmKG49bnVsbCksbmV3IGJkKHQsZSxuKX0sdC5hZGFtYXg9ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LjAwMiksdm9pZCAwPT09ZSYmKGU9LjkpLHZvaWQgMD09PW4mJihuPS45OTkpLHZvaWQgMD09PXImJihyPW51bGwpLHZvaWQgMD09PW8mJihvPTApLG5ldyBFZCh0LGUsbixyLG8pfSx0LmFkYWdyYWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9LjEpLG5ldyB3ZCh0LGUpfSx0fSgpLEFkPXtzZ2Q6U2Quc2dkLG1vbWVudHVtOlNkLm1vbWVudHVtLGFkYWRlbHRhOlNkLmFkYWRlbHRhLGFkYWdyYWQ6U2QuYWRhZ3JhZCxybXNwcm9wOlNkLnJtc3Byb3AsYWRhbWF4OlNkLmFkYW1heCxhZGFtOlNkLmFkYW19LERkPVwidW5kZWZpbmVkXCIhPXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU/cmVxdWVzdEFuaW1hdGlvbkZyYW1lOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZXRJbW1lZGlhdGU/c2V0SW1tZWRpYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0KCl9O2Z1bmN0aW9uIFRkKCl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0KXtyZXR1cm4gRGQoKGZ1bmN0aW9uKCl7cmV0dXJuIHQoKX0pKX0pKX13dC5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2U9ZnVuY3Rpb24odCl7cmV0dXJuIG51KHRoaXMsdCl9LHh0PUdoO2V4cG9ydHtiZCBhcyBBZGFkZWx0YU9wdGltaXplcix3ZCBhcyBBZGFncmFkT3B0aW1pemVyLENkIGFzIEFkYW1PcHRpbWl6ZXIsRWQgYXMgQWRhbWF4T3B0aW1pemVyLHhvIGFzIERhdGFTdG9yYWdlLHMgYXMgRU5WLG8gYXMgRW52aXJvbm1lbnQsYm8gYXMgS2VybmVsQmFja2VuZCxJZCBhcyBNb21lbnR1bU9wdGltaXplcix4ZCBhcyBPcHRpbWl6ZXIsa2QgYXMgUk1TUHJvcE9wdGltaXplcixDdCBhcyBSYW5rLGNoIGFzIFJlZHVjdGlvbixSZCBhcyBTR0RPcHRpbWl6ZXIsd3QgYXMgVGVuc29yLGd0IGFzIFRlbnNvckJ1ZmZlcixTdCBhcyBWYXJpYWJsZSxydSBhcyBhYnMsb3UgYXMgYWNvcyxhdSBhcyBhY29zaCxyYyBhcyBhZGQsb2MgYXMgYWRkTixhYyBhcyBhZGRTdHJpY3QsQ2wgYXMgYWxsLEVsIGFzIGFueSxSbCBhcyBhcmdNYXgsSWwgYXMgYXJnTWluLGl1IGFzIGFzaW4sc3UgYXMgYXNpbmgsdXUgYXMgYXRhbixpYyBhcyBhdGFuMixjdSBhcyBhdGFuaCxmbCBhcyBhdmdQb29sLHZsIGFzIGF2Z1Bvb2wzZCxobiBhcyBiYWNrZW5kLFVvIGFzIGJhY2tlbmRfdXRpbCx6bCBhcyBiYXNpY0xTVE1DZWxsLGp1IGFzIGJhdGNoTm9ybSxYdSBhcyBiYXRjaE5vcm0yZCxZdSBhcyBiYXRjaE5vcm0zZCwkdSBhcyBiYXRjaE5vcm00ZCxLdSBhcyBiYXRjaE5vcm1hbGl6YXRpb24sR3UgYXMgYmF0Y2hOb3JtYWxpemF0aW9uMmQsSHUgYXMgYmF0Y2hOb3JtYWxpemF0aW9uM2QscXUgYXMgYmF0Y2hOb3JtYWxpemF0aW9uNGQsdnIgYXMgYmF0Y2hUb1NwYWNlTkQsVWMgYXMgYm9vbGVhbk1hc2tBc3luYyxtciBhcyBicm9hZGNhc3RUbyxpZCBhcyBicm93c2VyLGRyIGFzIGJ1ZmZlcixnciBhcyBjYXN0LGx1IGFzIGNlaWwsaHUgYXMgY2xpcEJ5VmFsdWUseXIgYXMgY2xvbmUsRG4gYXMgY29tcGxleCxZbiBhcyBjb25jYXQsJG4gYXMgY29uY2F0MWQsUW4gYXMgY29uY2F0MmQsSm4gYXMgY29uY2F0M2QsWm4gYXMgY29uY2F0NGQsSGMgYXMgY29udjFkLHFjIGFzIGNvbnYyZCxaYyBhcyBjb252MmRUcmFuc3Bvc2UsS2MgYXMgY29udjNkLHRsIGFzIGNvbnYzZFRyYW5zcG9zZSxmdSBhcyBjb3MsZHUgYXMgY29zaCx4ciBhcyBjdW1zdW0sdm8gYXMgY3VzdG9tR3JhZCxYZSBhcyBkZXByZWNhdGlvbldhcm4sYnIgYXMgZGVwdGhUb1NwYWNlLFljIGFzIGRlcHRod2lzZUNvbnYyZCxlaCBhcyBkaWFnLGplIGFzIGRpc2FibGVEZXByZWNhdGlvbldhcm5pbmdzLHRuIGFzIGRpc3Bvc2UsWWUgYXMgZGlzcG9zZVZhcmlhYmxlcyxzYyBhcyBkaXYsdWMgYXMgZGl2Tm9OYW4sY2MgYXMgZGl2U3RyaWN0LG5sIGFzIGRvdCxuaCBhcyBkcm9wb3V0LF9sIGFzIGVsdSxLZSBhcyBlbmFibGVEZWJ1Z01vZGUscWUgYXMgZW5hYmxlUHJvZE1vZGUsJGUgYXMgZW5naW5lLGkgYXMgZW52LFJjIGFzIGVxdWFsLEljIGFzIGVxdWFsU3RyaWN0LHB1IGFzIGVyZix2dSBhcyBleHAsd3IgYXMgZXhwYW5kRGltcyxtdSBhcyBleHBtMSxDciBhcyBleWUsWGwgYXMgZmZ0LEhuIGFzIGZpbGwsdW4gYXMgZmluZEJhY2tlbmQsY24gYXMgZmluZEJhY2tlbmRGYWN0b3J5LGd1IGFzIGZsb29yLGxjIGFzIGZsb29yRGl2LGloIGFzIGZyYW1lLHpoIGFzIGZ1c2VkLExjIGFzIGdhdGhlcix0aCBhcyBnYXRoZXJORCxYciBhcyBnYXRoZXJfdXRpbCxhbiBhcyBnZXRCYWNrZW5kLGggYXMgZ2V0R3JhZGllbnQsbCBhcyBnZXRLZXJuZWwsZiBhcyBnZXRLZXJuZWxzRm9yQmFja2VuZCxjbyBhcyBncmFkLGxvIGFzIGdyYWRzLGtjIGFzIGdyZWF0ZXIsU2MgYXMgZ3JlYXRlckVxdWFsLEFjIGFzIGdyZWF0ZXJFcXVhbFN0cmljdCxEYyBhcyBncmVhdGVyU3RyaWN0LGFoIGFzIGhhbW1pbmdXaW5kb3csb2ggYXMgaGFubldpbmRvdyxZbCBhcyBpZmZ0LE5uIGFzIGltYWcsT2ggYXMgaW1hZ2UsbGggYXMgaW5Ub3BLQXN5bmMsZWQgYXMgaW8sUWwgYXMgaXJmZnQsRHUgYXMgaXNGaW5pdGUsQXUgYXMgaXNJbmYsU3UgYXMgaXNOYU4sZW4gYXMga2VlcCxPbCBhcyBsZWFreVJlbHUsVGMgYXMgbGVzcyxOYyBhcyBsZXNzRXF1YWwsRmMgYXMgbGVzc0VxdWFsU3RyaWN0LF9jIGFzIGxlc3NTdHJpY3QsSWggYXMgbGluYWxnLHFuIGFzIGxpbnNwYWNlLFVsIGFzIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uLHl1IGFzIGxvZyx4dSBhcyBsb2cxcCxidSBhcyBsb2dTaWdtb2lkLHlvIGFzIGxvZ1NvZnRtYXgsa2wgYXMgbG9nU3VtRXhwLFF1IGFzIGxvZ2ljYWxBbmQsSnUgYXMgbG9naWNhbE5vdCxadSBhcyBsb2dpY2FsT3IsdGMgYXMgbG9naWNhbFhvcixiaCBhcyBsb3NzZXMsZWwgYXMgbWF0TXVsLG9kIGFzIG1hdGgsU2wgYXMgbWF4LGhsIGFzIG1heFBvb2wscGwgYXMgbWF4UG9vbDNkLGhjIGFzIG1heGltdW0sZmMgYXMgbWF4aW11bVN0cmljdCxBbCBhcyBtZWFuLFFlIGFzIG1lbW9yeSxEbCBhcyBtaW4sZGMgYXMgbWluaW11bSxwYyBhcyBtaW5pbXVtU3RyaWN0LHZjIGFzIG1vZCxtYyBhcyBtb2RTdHJpY3QsVGwgYXMgbW9tZW50cyxIbCBhcyBtb3ZpbmdBdmVyYWdlLGdjIGFzIG11bCx5YyBhcyBtdWxTdHJpY3QsR2wgYXMgbXVsdGlSTk5DZWxsLEVyIGFzIG11bHRpbm9taWFsLHd1IGFzIG5lZyxUZCBhcyBuZXh0RnJhbWUsVmwgYXMgbm9ybSxPYyBhcyBub3RFcXVhbCxNYyBhcyBub3RFcXVhbFN0cmljdCxSciBhcyBvbmVIb3Qsem4gYXMgb25lcyxqbiBhcyBvbmVzTGlrZSxBbiBhcyBvcCxybCBhcyBvdXRlclByb2R1Y3QsSXIgYXMgcGFkLGtyIGFzIHBhZDFkLFNyIGFzIHBhZDJkLEFyIGFzIHBhZDNkLERyIGFzIHBhZDRkLGRsIGFzIHBvb2wseGMgYXMgcG93LGJjIGFzIHBvd1N0cmljdCxNbCBhcyBwcmVsdSxwciBhcyBwcmludCxGbCBhcyBwcm9kLEplIGFzIHByb2ZpbGUsVHIgYXMgcmFuZCxGciBhcyByYW5kb21HYW1tYSxOciBhcyByYW5kb21Ob3JtYWwsX3IgYXMgcmFuZG9tVW5pZm9ybSxLbiBhcyByYW5nZSxvbiBhcyByZWFkeSxUbiBhcyByZWFsLEN1IGFzIHJlY2lwcm9jYWwsbG4gYXMgcmVnaXN0ZXJCYWNrZW5kLHAgYXMgcmVnaXN0ZXJHcmFkaWVudCxkIGFzIHJlZ2lzdGVyS2VybmVsLEJsIGFzIHJlbHUsUGwgYXMgcmVsdTYsc24gYXMgcmVtb3ZlQmFja2VuZCxPciBhcyByZXNoYXBlLG9sIGFzIHJldmVyc2UsYWwgYXMgcmV2ZXJzZTFkLGlsIGFzIHJldmVyc2UyZCxzbCBhcyByZXZlcnNlM2QsdWwgYXMgcmV2ZXJzZTRkLCRsIGFzIHJmZnQsRXUgYXMgcm91bmQsUnUgYXMgcnNxcnQsT24gYXMgc2NhbGFyLGpsIGFzIHNjYXR0ZXJORCx0byBhcyBzY2F0dGVyX3V0aWwsTGwgYXMgc2VsdSxKYyBhcyBzZXBhcmFibGVDb252MmQsbGQgYXMgc2VyaWFsaXphdGlvbixybiBhcyBzZXRCYWNrZW5kLGZuIGFzIHNldFBsYXRmb3JtLFZyIGFzIHNldGRpZmYxZEFzeW5jLEl1IGFzIHNpZ21vaWQsa3UgYXMgc2lnbix1aCBhcyBzaWduYWwsVHUgYXMgc2luLE51IGFzIHNpbmgsbWwgYXMgc2xpY2UsZ2wgYXMgc2xpY2UxZCx5bCBhcyBzbGljZTJkLHhsIGFzIHNsaWNlM2QsYmwgYXMgc2xpY2U0ZCx1byBhcyBzbGljZV91dGlsLGdvIGFzIHNvZnRtYXgsRnUgYXMgc29mdHBsdXMsTXIgYXMgc3BhY2VUb0JhdGNoTkQsWmwgYXMgc3BhcnNlVG9EZW5zZSxKbCBhcyBzcGVjdHJhbCx0ciBhcyBzcGxpdCxfdSBhcyBzcXJ0LHR1IGFzIHNxdWFyZSxudSBhcyBzcXVhcmVkRGlmZmVyZW5jZSx3YyBhcyBzcXVhcmVkRGlmZmVyZW5jZVN0cmljdCxCciBhcyBzcXVlZXplLFByIGFzIHN0YWNrLE91IGFzIHN0ZXAsc2ggYXMgc3RmdCxxbCBhcyBzdHJpZGVkU2xpY2UsQ2MgYXMgc3ViLEVjIGFzIHN1YlN0cmljdCxObCBhcyBzdW0sVHQgYXMgc3VtT3V0VHlwZSxNdSBhcyB0YW4sQnUgYXMgdGFuaCxGbiBhcyB0ZW5zb3IsTW4gYXMgdGVuc29yMWQsQm4gYXMgdGVuc29yMmQsUG4gYXMgdGVuc29yM2QsTG4gYXMgdGVuc29yNGQsV24gYXMgdGVuc29yNWQsVW4gYXMgdGVuc29yNmQsTXQgYXMgdGVuc29yX3V0aWwsbWQgYXMgdGVzdF91dGlsLFplIGFzIHRpZHksTHIgYXMgdGlsZSxubiBhcyB0aW1lLEtsIGFzIHRvcGssQWQgYXMgdHJhaW4sV2wgYXMgdHJhbnNwb3NlLFdyIGFzIHRydW5jYXRlZE5vcm1hbCxtIGFzIHVucmVnaXN0ZXJHcmFkaWVudCx2IGFzIHVucmVnaXN0ZXJLZXJuZWwsV2MgYXMgdW5zb3J0ZWRTZWdtZW50U3VtLFVyIGFzIHVuc3RhY2ssc3QgYXMgdXRpbCxobyBhcyB2YWx1ZUFuZEdyYWQsZm8gYXMgdmFsdWVBbmRHcmFkcyxWbiBhcyB2YXJpYWJsZSxwbyBhcyB2YXJpYWJsZUdyYWRzLGdkIGFzIHZlcnNpb25fY29yZSx5ZCBhcyB3ZWJnbCxlYyBhcyB3aGVyZSxuYyBhcyB3aGVyZUFzeW5jLEduIGFzIHplcm9zLFhuIGFzIHplcm9zTGlrZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10Zi1jb3JlLmVzbS5qcy5tYXBcbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO3ZhciBhc3NpZ249T2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCk7bW9kdWxlLmV4cG9ydHM9YXNzaWduO21vZHVsZS5leHBvcnRzLmRlZmF1bHQ9bW9kdWxlLmV4cG9ydHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3QtYXNzaWduLmpzLm1hcCIsIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwiQzpcXFxcUGVyc29uYWxcXFxcUHJvamVjdHNcXFxcc21pbGVcXFxccGFnZXNcXFxcaW5kZXguanNcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICIsIlwidXNlIHN0cmljdFwiO2NvbnN0IGlzT2xkSUU9ZnVuY3Rpb24gaXNPbGRJRSgpe2xldCBtZW1vO3JldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpe2lmKHR5cGVvZiBtZW1vPT09J3VuZGVmaW5lZCcpey8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4vLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4vLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4vLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xubWVtbz1Cb29sZWFuKHdpbmRvdyYmZG9jdW1lbnQmJmRvY3VtZW50LmFsbCYmIXdpbmRvdy5hdG9iKTt9cmV0dXJuIG1lbW87fTt9KCk7Y29uc3QgZ2V0VGFyZ2V0PWZ1bmN0aW9uIGdldFRhcmdldCgpe2NvbnN0IG1lbW89e307cmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCl7aWYodHlwZW9mIG1lbW9bdGFyZ2V0XT09PSd1bmRlZmluZWQnKXtsZXQgc3R5bGVUYXJnZXQ9ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOy8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5pZih3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQmJnN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KXt0cnl7Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbi8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5zdHlsZVRhcmdldD1zdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDt9Y2F0Y2goZSl7Ly8gaXN0YW5idWwgaWdub3JlIG5leHRcbnN0eWxlVGFyZ2V0PW51bGw7fX1tZW1vW3RhcmdldF09c3R5bGVUYXJnZXQ7fXJldHVybiBtZW1vW3RhcmdldF07fTt9KCk7Y29uc3Qgc3R5bGVzSW5Eb209W107ZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcil7bGV0IHJlc3VsdD0tMTtmb3IobGV0IGk9MDtpPHN0eWxlc0luRG9tLmxlbmd0aDtpKyspe2lmKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXI9PT1pZGVudGlmaWVyKXtyZXN1bHQ9aTticmVhazt9fXJldHVybiByZXN1bHQ7fWZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LG9wdGlvbnMpe2NvbnN0IGlkQ291bnRNYXA9e307Y29uc3QgaWRlbnRpZmllcnM9W107Zm9yKGxldCBpPTA7aTxsaXN0Lmxlbmd0aDtpKyspe2NvbnN0IGl0ZW09bGlzdFtpXTtjb25zdCBpZD1vcHRpb25zLmJhc2U/aXRlbVswXStvcHRpb25zLmJhc2U6aXRlbVswXTtjb25zdCBjb3VudD1pZENvdW50TWFwW2lkXXx8MDtjb25zdCBpZGVudGlmaWVyPWAke2lkfSAke2NvdW50fWA7aWRDb3VudE1hcFtpZF09Y291bnQrMTtjb25zdCBpbmRleD1nZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtjb25zdCBvYmo9e2NzczppdGVtWzFdLG1lZGlhOml0ZW1bMl0sc291cmNlTWFwOml0ZW1bM119O2lmKGluZGV4IT09LTEpe3N0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7c3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTt9ZWxzZXtzdHlsZXNJbkRvbS5wdXNoKHtpZGVudGlmaWVyLHVwZGF0ZXI6YWRkU3R5bGUob2JqLG9wdGlvbnMpLHJlZmVyZW5jZXM6MX0pO31pZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO31yZXR1cm4gaWRlbnRpZmllcnM7fWZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKXtjb25zdCBzdHlsZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO2NvbnN0IGF0dHJpYnV0ZXM9b3B0aW9ucy5hdHRyaWJ1dGVzfHx7fTtpZih0eXBlb2YgYXR0cmlidXRlcy5ub25jZT09PSd1bmRlZmluZWQnKXtjb25zdCBub25jZT0vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbnR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyE9PSd1bmRlZmluZWQnP19fd2VicGFja19ub25jZV9fOm51bGw7aWYobm9uY2Upe2F0dHJpYnV0ZXMubm9uY2U9bm9uY2U7fX1PYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGtleT0+e3N0eWxlLnNldEF0dHJpYnV0ZShrZXksYXR0cmlidXRlc1trZXldKTt9KTtpZih0eXBlb2Ygb3B0aW9ucy5pbnNlcnQ9PT0nZnVuY3Rpb24nKXtvcHRpb25zLmluc2VydChzdHlsZSk7fWVsc2V7Y29uc3QgdGFyZ2V0PWdldFRhcmdldChvcHRpb25zLmluc2VydHx8J2hlYWQnKTtpZighdGFyZ2V0KXt0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO310YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO31yZXR1cm4gc3R5bGU7fWZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSl7Ly8gaXN0YW5idWwgaWdub3JlIGlmXG5pZihzdHlsZS5wYXJlbnROb2RlPT09bnVsbCl7cmV0dXJuIGZhbHNlO31zdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTt9LyogaXN0YW5idWwgaWdub3JlIG5leHQgICovY29uc3QgcmVwbGFjZVRleHQ9ZnVuY3Rpb24gcmVwbGFjZVRleHQoKXtjb25zdCB0ZXh0U3RvcmU9W107cmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgscmVwbGFjZW1lbnQpe3RleHRTdG9yZVtpbmRleF09cmVwbGFjZW1lbnQ7cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7fTt9KCk7ZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSxpbmRleCxyZW1vdmUsb2JqKXtjb25zdCBjc3M9cmVtb3ZlPycnOm9iai5tZWRpYT9gQG1lZGlhICR7b2JqLm1lZGlhfSB7JHtvYmouY3NzfX1gOm9iai5jc3M7Ly8gRm9yIG9sZCBJRVxuLyogaXN0YW5idWwgaWdub3JlIGlmICAqL2lmKHN0eWxlLnN0eWxlU2hlZXQpe3N0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dD1yZXBsYWNlVGV4dChpbmRleCxjc3MpO31lbHNle2NvbnN0IGNzc05vZGU9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtjb25zdCBjaGlsZE5vZGVzPXN0eWxlLmNoaWxkTm9kZXM7aWYoY2hpbGROb2Rlc1tpbmRleF0pe3N0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTt9aWYoY2hpbGROb2Rlcy5sZW5ndGgpe3N0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLGNoaWxkTm9kZXNbaW5kZXhdKTt9ZWxzZXtzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTt9fX1mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLG9wdGlvbnMsb2JqKXtsZXQgY3NzPW9iai5jc3M7Y29uc3QgbWVkaWE9b2JqLm1lZGlhO2NvbnN0IHNvdXJjZU1hcD1vYmouc291cmNlTWFwO2lmKG1lZGlhKXtzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJyxtZWRpYSk7fWVsc2V7c3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO31pZihzb3VyY2VNYXAmJnR5cGVvZiBidG9hIT09J3VuZGVmaW5lZCcpe2Nzcys9YFxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJHtidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpfSAqL2A7fS8vIEZvciBvbGQgSUVcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9pZihzdHlsZS5zdHlsZVNoZWV0KXtzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQ9Y3NzO31lbHNle3doaWxlKHN0eWxlLmZpcnN0Q2hpbGQpe3N0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO31zdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTt9fWxldCBzaW5nbGV0b249bnVsbDtsZXQgc2luZ2xldG9uQ291bnRlcj0wO2Z1bmN0aW9uIGFkZFN0eWxlKG9iaixvcHRpb25zKXtsZXQgc3R5bGU7bGV0IHVwZGF0ZTtsZXQgcmVtb3ZlO2lmKG9wdGlvbnMuc2luZ2xldG9uKXtjb25zdCBzdHlsZUluZGV4PXNpbmdsZXRvbkNvdW50ZXIrKztzdHlsZT1zaW5nbGV0b258fChzaW5nbGV0b249aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTt1cGRhdGU9YXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsc3R5bGUsc3R5bGVJbmRleCxmYWxzZSk7cmVtb3ZlPWFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLHN0eWxlLHN0eWxlSW5kZXgsdHJ1ZSk7fWVsc2V7c3R5bGU9aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO3VwZGF0ZT1hcHBseVRvVGFnLmJpbmQobnVsbCxzdHlsZSxvcHRpb25zKTtyZW1vdmU9KCk9PntyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO307fXVwZGF0ZShvYmopO3JldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmope2lmKG5ld09iail7aWYobmV3T2JqLmNzcz09PW9iai5jc3MmJm5ld09iai5tZWRpYT09PW9iai5tZWRpYSYmbmV3T2JqLnNvdXJjZU1hcD09PW9iai5zb3VyY2VNYXApe3JldHVybjt9dXBkYXRlKG9iaj1uZXdPYmopO31lbHNle3JlbW92ZSgpO319O31tb2R1bGUuZXhwb3J0cz0obGlzdCxvcHRpb25zKT0+e29wdGlvbnM9b3B0aW9uc3x8e307Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5pZighb3B0aW9ucy5zaW5nbGV0b24mJnR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiE9PSdib29sZWFuJyl7b3B0aW9ucy5zaW5nbGV0b249aXNPbGRJRSgpO31saXN0PWxpc3R8fFtdO2xldCBsYXN0SWRlbnRpZmllcnM9bW9kdWxlc1RvRG9tKGxpc3Qsb3B0aW9ucyk7cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KXtuZXdMaXN0PW5ld0xpc3R8fFtdO2lmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSE9PSdbb2JqZWN0IEFycmF5XScpe3JldHVybjt9Zm9yKGxldCBpPTA7aTxsYXN0SWRlbnRpZmllcnMubGVuZ3RoO2krKyl7Y29uc3QgaWRlbnRpZmllcj1sYXN0SWRlbnRpZmllcnNbaV07Y29uc3QgaW5kZXg9Z2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7c3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTt9Y29uc3QgbmV3TGFzdElkZW50aWZpZXJzPW1vZHVsZXNUb0RvbShuZXdMaXN0LG9wdGlvbnMpO2ZvcihsZXQgaT0wO2k8bGFzdElkZW50aWZpZXJzLmxlbmd0aDtpKyspe2NvbnN0IGlkZW50aWZpZXI9bGFzdElkZW50aWZpZXJzW2ldO2NvbnN0IGluZGV4PWdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO2lmKHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzPT09MCl7c3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIoKTtzdHlsZXNJbkRvbS5zcGxpY2UoaW5kZXgsMSk7fX1sYXN0SWRlbnRpZmllcnM9bmV3TGFzdElkZW50aWZpZXJzO307fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5tYXAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgSGVhZCBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvaGVhZCdcbmltcG9ydCB7IHRvQmFzZTY0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3RvLWJhc2UtNjQnXG5pbXBvcnQge1xuICBJbWFnZUNvbmZpZyxcbiAgaW1hZ2VDb25maWdEZWZhdWx0LFxuICBMb2FkZXJWYWx1ZSxcbiAgVkFMSURfTE9BREVSUyxcbn0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvc2VydmVyL2ltYWdlLWNvbmZpZydcbmltcG9ydCB7IHVzZUludGVyc2VjdGlvbiB9IGZyb20gJy4vdXNlLWludGVyc2VjdGlvbidcblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIDsoZ2xvYmFsIGFzIGFueSkuX19ORVhUX0lNQUdFX0lNUE9SVEVEID0gdHJ1ZVxufVxuXG5jb25zdCBWQUxJRF9MT0FESU5HX1ZBTFVFUyA9IFsnbGF6eScsICdlYWdlcicsIHVuZGVmaW5lZF0gYXMgY29uc3RcbnR5cGUgTG9hZGluZ1ZhbHVlID0gdHlwZW9mIFZBTElEX0xPQURJTkdfVkFMVUVTW251bWJlcl1cblxuZXhwb3J0IHR5cGUgSW1hZ2VMb2FkZXIgPSAocmVzb2x2ZXJQcm9wczogSW1hZ2VMb2FkZXJQcm9wcykgPT4gc3RyaW5nXG5cbmV4cG9ydCB0eXBlIEltYWdlTG9hZGVyUHJvcHMgPSB7XG4gIHNyYzogc3RyaW5nXG4gIHdpZHRoOiBudW1iZXJcbiAgcXVhbGl0eT86IG51bWJlclxufVxuXG50eXBlIERlZmF1bHRJbWFnZUxvYWRlclByb3BzID0gSW1hZ2VMb2FkZXJQcm9wcyAmIHsgcm9vdDogc3RyaW5nIH1cblxuY29uc3QgbG9hZGVycyA9IG5ldyBNYXA8XG4gIExvYWRlclZhbHVlLFxuICAocHJvcHM6IERlZmF1bHRJbWFnZUxvYWRlclByb3BzKSA9PiBzdHJpbmdcbj4oW1xuICBbJ2ltZ2l4JywgaW1naXhMb2FkZXJdLFxuICBbJ2Nsb3VkaW5hcnknLCBjbG91ZGluYXJ5TG9hZGVyXSxcbiAgWydha2FtYWknLCBha2FtYWlMb2FkZXJdLFxuICBbJ2RlZmF1bHQnLCBkZWZhdWx0TG9hZGVyXSxcbl0pXG5cbmNvbnN0IFZBTElEX0xBWU9VVF9WQUxVRVMgPSBbXG4gICdmaWxsJyxcbiAgJ2ZpeGVkJyxcbiAgJ2ludHJpbnNpYycsXG4gICdyZXNwb25zaXZlJyxcbiAgdW5kZWZpbmVkLFxuXSBhcyBjb25zdFxudHlwZSBMYXlvdXRWYWx1ZSA9IHR5cGVvZiBWQUxJRF9MQVlPVVRfVkFMVUVTW251bWJlcl1cblxudHlwZSBJbWdFbGVtZW50U3R5bGUgPSBOb25OdWxsYWJsZTxKU1guSW50cmluc2ljRWxlbWVudHNbJ2ltZyddWydzdHlsZSddPlxuXG5leHBvcnQgdHlwZSBJbWFnZVByb3BzID0gT21pdDxcbiAgSlNYLkludHJpbnNpY0VsZW1lbnRzWydpbWcnXSxcbiAgJ3NyYycgfCAnc3JjU2V0JyB8ICdyZWYnIHwgJ3dpZHRoJyB8ICdoZWlnaHQnIHwgJ2xvYWRpbmcnIHwgJ3N0eWxlJ1xuPiAmIHtcbiAgc3JjOiBzdHJpbmdcbiAgbG9hZGVyPzogSW1hZ2VMb2FkZXJcbiAgcXVhbGl0eT86IG51bWJlciB8IHN0cmluZ1xuICBwcmlvcml0eT86IGJvb2xlYW5cbiAgbG9hZGluZz86IExvYWRpbmdWYWx1ZVxuICB1bm9wdGltaXplZD86IGJvb2xlYW5cbiAgb2JqZWN0Rml0PzogSW1nRWxlbWVudFN0eWxlWydvYmplY3RGaXQnXVxuICBvYmplY3RQb3NpdGlvbj86IEltZ0VsZW1lbnRTdHlsZVsnb2JqZWN0UG9zaXRpb24nXVxufSAmIChcbiAgICB8IHtcbiAgICAgICAgd2lkdGg/OiBuZXZlclxuICAgICAgICBoZWlnaHQ/OiBuZXZlclxuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIGBsYXlvdXQ9XCJmaWxsXCJgIGluc3RlYWQgKi9cbiAgICAgICAgdW5zaXplZDogdHJ1ZVxuICAgICAgfVxuICAgIHwgeyB3aWR0aD86IG5ldmVyOyBoZWlnaHQ/OiBuZXZlcjsgbGF5b3V0OiAnZmlsbCcgfVxuICAgIHwge1xuICAgICAgICB3aWR0aDogbnVtYmVyIHwgc3RyaW5nXG4gICAgICAgIGhlaWdodDogbnVtYmVyIHwgc3RyaW5nXG4gICAgICAgIGxheW91dD86IEV4Y2x1ZGU8TGF5b3V0VmFsdWUsICdmaWxsJz5cbiAgICAgIH1cbiAgKVxuXG5jb25zdCB7XG4gIGRldmljZVNpemVzOiBjb25maWdEZXZpY2VTaXplcyxcbiAgaW1hZ2VTaXplczogY29uZmlnSW1hZ2VTaXplcyxcbiAgbG9hZGVyOiBjb25maWdMb2FkZXIsXG4gIHBhdGg6IGNvbmZpZ1BhdGgsXG4gIGRvbWFpbnM6IGNvbmZpZ0RvbWFpbnMsXG59ID1cbiAgKChwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUyBhcyBhbnkpIGFzIEltYWdlQ29uZmlnKSB8fCBpbWFnZUNvbmZpZ0RlZmF1bHRcbi8vIHNvcnQgc21hbGxlc3QgdG8gbGFyZ2VzdFxuY29uc3QgYWxsU2l6ZXMgPSBbLi4uY29uZmlnRGV2aWNlU2l6ZXMsIC4uLmNvbmZpZ0ltYWdlU2l6ZXNdXG5jb25maWdEZXZpY2VTaXplcy5zb3J0KChhLCBiKSA9PiBhIC0gYilcbmFsbFNpemVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuXG5mdW5jdGlvbiBnZXRXaWR0aHMoXG4gIHdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gIGxheW91dDogTGF5b3V0VmFsdWUsXG4gIHNpemVzOiBzdHJpbmcgfCB1bmRlZmluZWRcbik6IHsgd2lkdGhzOiBudW1iZXJbXTsga2luZDogJ3cnIHwgJ3gnIH0ge1xuICBpZiAoc2l6ZXMgJiYgKGxheW91dCA9PT0gJ2ZpbGwnIHx8IGxheW91dCA9PT0gJ3Jlc3BvbnNpdmUnKSkge1xuICAgIC8vIEZpbmQgYWxsIHRoZSBcInZ3XCIgcGVyY2VudCBzaXplcyB1c2VkIGluIHRoZSBzaXplcyBwcm9wXG4gICAgY29uc3QgcGVyY2VudFNpemVzID0gWy4uLnNpemVzLm1hdGNoQWxsKC8oXnxcXHMpKDE/XFxkP1xcZCl2dy9nKV0ubWFwKChtKSA9PlxuICAgICAgcGFyc2VJbnQobVsyXSlcbiAgICApXG4gICAgaWYgKHBlcmNlbnRTaXplcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNtYWxsZXN0UmF0aW8gPSBNYXRoLm1pbiguLi5wZXJjZW50U2l6ZXMpICogMC4wMVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGhzOiBhbGxTaXplcy5maWx0ZXIoXG4gICAgICAgICAgKHMpID0+IHMgPj0gY29uZmlnRGV2aWNlU2l6ZXNbMF0gKiBzbWFsbGVzdFJhdGlvXG4gICAgICAgICksXG4gICAgICAgIGtpbmQ6ICd3JyxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgd2lkdGhzOiBhbGxTaXplcywga2luZDogJ3cnIH1cbiAgfVxuICBpZiAoXG4gICAgdHlwZW9mIHdpZHRoICE9PSAnbnVtYmVyJyB8fFxuICAgIGxheW91dCA9PT0gJ2ZpbGwnIHx8XG4gICAgbGF5b3V0ID09PSAncmVzcG9uc2l2ZSdcbiAgKSB7XG4gICAgcmV0dXJuIHsgd2lkdGhzOiBjb25maWdEZXZpY2VTaXplcywga2luZDogJ3cnIH1cbiAgfVxuXG4gIGNvbnN0IHdpZHRocyA9IFtcbiAgICAuLi5uZXcgU2V0KFxuICAgICAgLy8gPiBUaGlzIG1lYW5zIHRoYXQgbW9zdCBPTEVEIHNjcmVlbnMgdGhhdCBzYXkgdGhleSBhcmUgM3ggcmVzb2x1dGlvbixcbiAgICAgIC8vID4gYXJlIGFjdHVhbGx5IDN4IGluIHRoZSBncmVlbiBjb2xvciwgYnV0IG9ubHkgMS41eCBpbiB0aGUgcmVkIGFuZFxuICAgICAgLy8gPiBibHVlIGNvbG9ycy4gU2hvd2luZyBhIDN4IHJlc29sdXRpb24gaW1hZ2UgaW4gdGhlIGFwcCB2cyBhIDJ4XG4gICAgICAvLyA+IHJlc29sdXRpb24gaW1hZ2Ugd2lsbCBiZSB2aXN1YWxseSB0aGUgc2FtZSwgdGhvdWdoIHRoZSAzeCBpbWFnZVxuICAgICAgLy8gPiB0YWtlcyBzaWduaWZpY2FudGx5IG1vcmUgZGF0YS4gRXZlbiB0cnVlIDN4IHJlc29sdXRpb24gc2NyZWVucyBhcmVcbiAgICAgIC8vID4gd2FzdGVmdWwgYXMgdGhlIGh1bWFuIGV5ZSBjYW5ub3Qgc2VlIHRoYXQgbGV2ZWwgb2YgZGV0YWlsIHdpdGhvdXRcbiAgICAgIC8vID4gc29tZXRoaW5nIGxpa2UgYSBtYWduaWZ5aW5nIGdsYXNzLlxuICAgICAgLy8gaHR0cHM6Ly9ibG9nLnR3aXR0ZXIuY29tL2VuZ2luZWVyaW5nL2VuX3VzL3RvcGljcy9pbmZyYXN0cnVjdHVyZS8yMDE5L2NhcHBpbmctaW1hZ2UtZmlkZWxpdHktb24tdWx0cmEtaGlnaC1yZXNvbHV0aW9uLWRldmljZXMuaHRtbFxuICAgICAgW3dpZHRoLCB3aWR0aCAqIDIgLyosIHdpZHRoICogMyovXS5tYXAoXG4gICAgICAgICh3KSA9PiBhbGxTaXplcy5maW5kKChwKSA9PiBwID49IHcpIHx8IGFsbFNpemVzW2FsbFNpemVzLmxlbmd0aCAtIDFdXG4gICAgICApXG4gICAgKSxcbiAgXVxuICByZXR1cm4geyB3aWR0aHMsIGtpbmQ6ICd4JyB9XG59XG5cbnR5cGUgR2VuSW1nQXR0cnNEYXRhID0ge1xuICBzcmM6IHN0cmluZ1xuICB1bm9wdGltaXplZDogYm9vbGVhblxuICBsYXlvdXQ6IExheW91dFZhbHVlXG4gIGxvYWRlcjogSW1hZ2VMb2FkZXJcbiAgd2lkdGg/OiBudW1iZXJcbiAgcXVhbGl0eT86IG51bWJlclxuICBzaXplcz86IHN0cmluZ1xufVxuXG50eXBlIEdlbkltZ0F0dHJzUmVzdWx0ID0ge1xuICBzcmM6IHN0cmluZ1xuICBzcmNTZXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBzaXplczogc3RyaW5nIHwgdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlSW1nQXR0cnMoe1xuICBzcmMsXG4gIHVub3B0aW1pemVkLFxuICBsYXlvdXQsXG4gIHdpZHRoLFxuICBxdWFsaXR5LFxuICBzaXplcyxcbiAgbG9hZGVyLFxufTogR2VuSW1nQXR0cnNEYXRhKTogR2VuSW1nQXR0cnNSZXN1bHQge1xuICBpZiAodW5vcHRpbWl6ZWQpIHtcbiAgICByZXR1cm4geyBzcmMsIHNyY1NldDogdW5kZWZpbmVkLCBzaXplczogdW5kZWZpbmVkIH1cbiAgfVxuXG4gIGNvbnN0IHsgd2lkdGhzLCBraW5kIH0gPSBnZXRXaWR0aHMod2lkdGgsIGxheW91dCwgc2l6ZXMpXG4gIGNvbnN0IGxhc3QgPSB3aWR0aHMubGVuZ3RoIC0gMVxuXG4gIHJldHVybiB7XG4gICAgc2l6ZXM6ICFzaXplcyAmJiBraW5kID09PSAndycgPyAnMTAwdncnIDogc2l6ZXMsXG4gICAgc3JjU2V0OiB3aWR0aHNcbiAgICAgIC5tYXAoXG4gICAgICAgICh3LCBpKSA9PlxuICAgICAgICAgIGAke2xvYWRlcih7IHNyYywgcXVhbGl0eSwgd2lkdGg6IHcgfSl9ICR7XG4gICAgICAgICAgICBraW5kID09PSAndycgPyB3IDogaSArIDFcbiAgICAgICAgICB9JHtraW5kfWBcbiAgICAgIClcbiAgICAgIC5qb2luKCcsICcpLFxuXG4gICAgLy8gSXQncyBpbnRlbmRlZCB0byBrZWVwIGBzcmNgIHRoZSBsYXN0IGF0dHJpYnV0ZSBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAvLyBhdHRyaWJ1dGVzIGluIG9yZGVyLiBJZiB3ZSBrZWVwIGBzcmNgIHRoZSBmaXJzdCBvbmUsIFNhZmFyaSB3aWxsXG4gICAgLy8gaW1tZWRpYXRlbHkgc3RhcnQgdG8gZmV0Y2ggYHNyY2AsIGJlZm9yZSBgc2l6ZXNgIGFuZCBgc3JjU2V0YCBhcmUgZXZlblxuICAgIC8vIHVwZGF0ZWQgYnkgUmVhY3QuIFRoYXQgY2F1c2VzIG11bHRpcGxlIHVubmVjZXNzYXJ5IHJlcXVlc3RzIGlmIGBzcmNTZXRgXG4gICAgLy8gYW5kIGBzaXplc2AgYXJlIGRlZmluZWQuXG4gICAgLy8gVGhpcyBidWcgY2Fubm90IGJlIHJlcHJvZHVjZWQgaW4gQ2hyb21lIG9yIEZpcmVmb3guXG4gICAgc3JjOiBsb2FkZXIoeyBzcmMsIHF1YWxpdHksIHdpZHRoOiB3aWR0aHNbbGFzdF0gfSksXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SW50KHg6IHVua25vd24pOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHhcbiAgfVxuICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHgsIDEwKVxuICB9XG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEltYWdlTG9hZGVyKGxvYWRlclByb3BzOiBJbWFnZUxvYWRlclByb3BzKSB7XG4gIGNvbnN0IGxvYWQgPSBsb2FkZXJzLmdldChjb25maWdMb2FkZXIpXG4gIGlmIChsb2FkKSB7XG4gICAgcmV0dXJuIGxvYWQoeyByb290OiBjb25maWdQYXRoLCAuLi5sb2FkZXJQcm9wcyB9KVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgVW5rbm93biBcImxvYWRlclwiIGZvdW5kIGluIFwibmV4dC5jb25maWcuanNcIi4gRXhwZWN0ZWQ6ICR7VkFMSURfTE9BREVSUy5qb2luKFxuICAgICAgJywgJ1xuICAgICl9LiBSZWNlaXZlZDogJHtjb25maWdMb2FkZXJ9YFxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEltYWdlKHtcbiAgc3JjLFxuICBzaXplcyxcbiAgdW5vcHRpbWl6ZWQgPSBmYWxzZSxcbiAgcHJpb3JpdHkgPSBmYWxzZSxcbiAgbG9hZGluZyxcbiAgY2xhc3NOYW1lLFxuICBxdWFsaXR5LFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBvYmplY3RGaXQsXG4gIG9iamVjdFBvc2l0aW9uLFxuICBsb2FkZXIgPSBkZWZhdWx0SW1hZ2VMb2FkZXIsXG4gIC4uLmFsbFxufTogSW1hZ2VQcm9wcykge1xuICBsZXQgcmVzdDogUGFydGlhbDxJbWFnZVByb3BzPiA9IGFsbFxuICBsZXQgbGF5b3V0OiBOb25OdWxsYWJsZTxMYXlvdXRWYWx1ZT4gPSBzaXplcyA/ICdyZXNwb25zaXZlJyA6ICdpbnRyaW5zaWMnXG4gIGxldCB1bnNpemVkID0gZmFsc2VcbiAgaWYgKCd1bnNpemVkJyBpbiByZXN0KSB7XG4gICAgdW5zaXplZCA9IEJvb2xlYW4ocmVzdC51bnNpemVkKVxuICAgIC8vIFJlbW92ZSBwcm9wZXJ0eSBzbyBpdCdzIG5vdCBzcHJlYWQgaW50byBpbWFnZTpcbiAgICBkZWxldGUgcmVzdFsndW5zaXplZCddXG4gIH0gZWxzZSBpZiAoJ2xheW91dCcgaW4gcmVzdCkge1xuICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQgbGF5b3V0IGlmIHRoZSB1c2VyIHNwZWNpZmllZCBvbmU6XG4gICAgaWYgKHJlc3QubGF5b3V0KSBsYXlvdXQgPSByZXN0LmxheW91dFxuXG4gICAgLy8gUmVtb3ZlIHByb3BlcnR5IHNvIGl0J3Mgbm90IHNwcmVhZCBpbnRvIGltYWdlOlxuICAgIGRlbGV0ZSByZXN0WydsYXlvdXQnXVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoIXNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcInNyY1wiIHByb3BlcnR5LiBNYWtlIHN1cmUgeW91IHBhc3MgXCJzcmNcIiBpbiBwcm9wcyB0byB0aGUgXFxgbmV4dC9pbWFnZVxcYCBjb21wb25lbnQuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHsgd2lkdGgsIGhlaWdodCwgcXVhbGl0eSB9XG4gICAgICAgICl9YFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAoIVZBTElEX0xBWU9VVF9WQUxVRVMuaW5jbHVkZXMobGF5b3V0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcImxheW91dFwiIHByb3BlcnR5LiBQcm92aWRlZCBcIiR7bGF5b3V0fVwiIHNob3VsZCBiZSBvbmUgb2YgJHtWQUxJRF9MQVlPVVRfVkFMVUVTLm1hcChcbiAgICAgICAgICBTdHJpbmdcbiAgICAgICAgKS5qb2luKCcsJyl9LmBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKCFWQUxJRF9MT0FESU5HX1ZBTFVFUy5pbmNsdWRlcyhsb2FkaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCIke2xvYWRpbmd9XCIgc2hvdWxkIGJlIG9uZSBvZiAke1ZBTElEX0xPQURJTkdfVkFMVUVTLm1hcChcbiAgICAgICAgICBTdHJpbmdcbiAgICAgICAgKS5qb2luKCcsJyl9LmBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHByaW9yaXR5ICYmIGxvYWRpbmcgPT09ICdsYXp5Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcInByaW9yaXR5XCIgYW5kIFwibG9hZGluZz0nbGF6eSdcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC5gXG4gICAgICApXG4gICAgfVxuICAgIGlmICh1bnNpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBkZXByZWNhdGVkIFwidW5zaXplZFwiIHByb3BlcnR5LCB3aGljaCB3YXMgcmVtb3ZlZCBpbiBmYXZvciBvZiB0aGUgXCJsYXlvdXQ9J2ZpbGwnXCIgcHJvcGVydHlgXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgbGV0IGlzTGF6eSA9XG4gICAgIXByaW9yaXR5ICYmIChsb2FkaW5nID09PSAnbGF6eScgfHwgdHlwZW9mIGxvYWRpbmcgPT09ICd1bmRlZmluZWQnKVxuICBpZiAoc3JjICYmIHNyYy5zdGFydHNXaXRoKCdkYXRhOicpKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSSXNcbiAgICB1bm9wdGltaXplZCA9IHRydWVcbiAgICBpc0xhenkgPSBmYWxzZVxuICB9XG5cbiAgY29uc3QgW3NldFJlZiwgaXNJbnRlcnNlY3RlZF0gPSB1c2VJbnRlcnNlY3Rpb248SFRNTEltYWdlRWxlbWVudD4oe1xuICAgIHJvb3RNYXJnaW46ICcyMDBweCcsXG4gICAgZGlzYWJsZWQ6ICFpc0xhenksXG4gIH0pXG4gIGNvbnN0IGlzVmlzaWJsZSA9ICFpc0xhenkgfHwgaXNJbnRlcnNlY3RlZFxuXG4gIGNvbnN0IHdpZHRoSW50ID0gZ2V0SW50KHdpZHRoKVxuICBjb25zdCBoZWlnaHRJbnQgPSBnZXRJbnQoaGVpZ2h0KVxuICBjb25zdCBxdWFsaXR5SW50ID0gZ2V0SW50KHF1YWxpdHkpXG5cbiAgbGV0IHdyYXBwZXJTdHlsZTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXVsnc3R5bGUnXSB8IHVuZGVmaW5lZFxuICBsZXQgc2l6ZXJTdHlsZTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXVsnc3R5bGUnXSB8IHVuZGVmaW5lZFxuICBsZXQgc2l6ZXJTdmc6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBsZXQgaW1nU3R5bGU6IEltZ0VsZW1lbnRTdHlsZSB8IHVuZGVmaW5lZCA9IHtcbiAgICB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnaW5oZXJpdCcgOiAnaGlkZGVuJyxcblxuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICByaWdodDogMCxcblxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgYm9yZGVyOiAnbm9uZScsXG4gICAgbWFyZ2luOiAnYXV0bycsXG5cbiAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBtaW5XaWR0aDogJzEwMCUnLFxuICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgbWluSGVpZ2h0OiAnMTAwJScsXG4gICAgbWF4SGVpZ2h0OiAnMTAwJScsXG5cbiAgICBvYmplY3RGaXQsXG4gICAgb2JqZWN0UG9zaXRpb24sXG4gIH1cbiAgaWYgKFxuICAgIHR5cGVvZiB3aWR0aEludCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgaGVpZ2h0SW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIGxheW91dCAhPT0gJ2ZpbGwnXG4gICkge1xuICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgLz5cbiAgICBjb25zdCBxdW90aWVudCA9IGhlaWdodEludCAvIHdpZHRoSW50XG4gICAgY29uc3QgcGFkZGluZ1RvcCA9IGlzTmFOKHF1b3RpZW50KSA/ICcxMDAlJyA6IGAke3F1b3RpZW50ICogMTAwfSVgXG4gICAgaWYgKGxheW91dCA9PT0gJ3Jlc3BvbnNpdmUnKSB7XG4gICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIGxheW91dD1cInJlc3BvbnNpdmVcIiAvPlxuICAgICAgd3JhcHBlclN0eWxlID0ge1xuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuXG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICB9XG4gICAgICBzaXplclN0eWxlID0geyBkaXNwbGF5OiAnYmxvY2snLCBib3hTaXppbmc6ICdib3JkZXItYm94JywgcGFkZGluZ1RvcCB9XG4gICAgfSBlbHNlIGlmIChsYXlvdXQgPT09ICdpbnRyaW5zaWMnKSB7XG4gICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIGxheW91dD1cImludHJpbnNpY1wiIC8+XG4gICAgICB3cmFwcGVyU3R5bGUgPSB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgfVxuICAgICAgc2l6ZXJTdHlsZSA9IHtcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICB9XG4gICAgICBzaXplclN2ZyA9IGA8c3ZnIHdpZHRoPVwiJHt3aWR0aEludH1cIiBoZWlnaHQ9XCIke2hlaWdodEludH1cIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmVyc2lvbj1cIjEuMVwiLz5gXG4gICAgfSBlbHNlIGlmIChsYXlvdXQgPT09ICdmaXhlZCcpIHtcbiAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgbGF5b3V0PVwiZml4ZWRcIiAvPlxuICAgICAgd3JhcHBlclN0eWxlID0ge1xuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRJbnQsXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgIHR5cGVvZiB3aWR0aEludCA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgaGVpZ2h0SW50ID09PSAndW5kZWZpbmVkJyAmJlxuICAgIGxheW91dCA9PT0gJ2ZpbGwnXG4gICkge1xuICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIGxheW91dD1cImZpbGxcIiAvPlxuICAgIHdyYXBwZXJTdHlsZSA9IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG5cbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIHJpZ2h0OiAwLFxuXG4gICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgIG1hcmdpbjogMCxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgLz5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBtdXN0IHVzZSBcIndpZHRoXCIgYW5kIFwiaGVpZ2h0XCIgcHJvcGVydGllcyBvciBcImxheW91dD0nZmlsbCdcIiBwcm9wZXJ0eS5gXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgbGV0IGltZ0F0dHJpYnV0ZXM6IEdlbkltZ0F0dHJzUmVzdWx0ID0ge1xuICAgIHNyYzpcbiAgICAgICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3lINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQlJBQTcnLFxuICAgIHNyY1NldDogdW5kZWZpbmVkLFxuICAgIHNpemVzOiB1bmRlZmluZWQsXG4gIH1cblxuICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgaW1nQXR0cmlidXRlcyA9IGdlbmVyYXRlSW1nQXR0cnMoe1xuICAgICAgc3JjLFxuICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICBsYXlvdXQsXG4gICAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgICBxdWFsaXR5OiBxdWFsaXR5SW50LFxuICAgICAgc2l6ZXMsXG4gICAgICBsb2FkZXIsXG4gICAgfSlcbiAgfVxuXG4gIGlmICh1bnNpemVkKSB7XG4gICAgd3JhcHBlclN0eWxlID0gdW5kZWZpbmVkXG4gICAgc2l6ZXJTdHlsZSA9IHVuZGVmaW5lZFxuICAgIGltZ1N0eWxlID0gdW5kZWZpbmVkXG4gIH1cbiAgcmV0dXJuIChcbiAgICA8ZGl2IHN0eWxlPXt3cmFwcGVyU3R5bGV9PlxuICAgICAge3NpemVyU3R5bGUgPyAoXG4gICAgICAgIDxkaXYgc3R5bGU9e3NpemVyU3R5bGV9PlxuICAgICAgICAgIHtzaXplclN2ZyA/IChcbiAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIGFsdD1cIlwiXG4gICAgICAgICAgICAgIGFyaWEtaGlkZGVuPXt0cnVlfVxuICAgICAgICAgICAgICByb2xlPVwicHJlc2VudGF0aW9uXCJcbiAgICAgICAgICAgICAgc3JjPXtgZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwke3RvQmFzZTY0KHNpemVyU3ZnKX1gfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgPC9kaXY+XG4gICAgICApIDogbnVsbH1cbiAgICAgIDxpbWdcbiAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIHsuLi5pbWdBdHRyaWJ1dGVzfVxuICAgICAgICBkZWNvZGluZz1cImFzeW5jXCJcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgIHJlZj17c2V0UmVmfVxuICAgICAgICBzdHlsZT17aW1nU3R5bGV9XG4gICAgICAvPlxuICAgICAge3ByaW9yaXR5ID8gKFxuICAgICAgICAvLyBOb3RlIGhvdyB3ZSBvbWl0IHRoZSBgaHJlZmAgYXR0cmlidXRlLCBhcyBpdCB3b3VsZCBvbmx5IGJlIHJlbGV2YW50XG4gICAgICAgIC8vIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGBpbWFnZXNyY3NldGAsIGFuZCBpbiB0aG9zZSBjYXNlc1xuICAgICAgICAvLyBpdCB3b3VsZCBsaWtlbHkgY2F1c2UgdGhlIGluY29ycmVjdCBpbWFnZSB0byBiZSBwcmVsb2FkZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI2F0dHItbGluay1pbWFnZXNyY3NldFxuICAgICAgICA8SGVhZD5cbiAgICAgICAgICA8bGlua1xuICAgICAgICAgICAga2V5PXtcbiAgICAgICAgICAgICAgJ19fbmltZy0nICtcbiAgICAgICAgICAgICAgaW1nQXR0cmlidXRlcy5zcmMgK1xuICAgICAgICAgICAgICBpbWdBdHRyaWJ1dGVzLnNyY1NldCArXG4gICAgICAgICAgICAgIGltZ0F0dHJpYnV0ZXMuc2l6ZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbD1cInByZWxvYWRcIlxuICAgICAgICAgICAgYXM9XCJpbWFnZVwiXG4gICAgICAgICAgICBocmVmPXtpbWdBdHRyaWJ1dGVzLnNyY1NldCA/IHVuZGVmaW5lZCA6IGltZ0F0dHJpYnV0ZXMuc3JjfVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogaW1hZ2VzcmNzZXQgaXMgbm90IHlldCBpbiB0aGUgbGluayBlbGVtZW50IHR5cGVcbiAgICAgICAgICAgIGltYWdlc3Jjc2V0PXtpbWdBdHRyaWJ1dGVzLnNyY1NldH1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IGltYWdlc2l6ZXMgaXMgbm90IHlldCBpbiB0aGUgbGluayBlbGVtZW50IHR5cGVcbiAgICAgICAgICAgIGltYWdlc2l6ZXM9e2ltZ0F0dHJpYnV0ZXMuc2l6ZXN9XG4gICAgICAgICAgPjwvbGluaz5cbiAgICAgICAgPC9IZWFkPlxuICAgICAgKSA6IG51bGx9XG4gICAgPC9kaXY+XG4gIClcbn1cblxuLy9CVUlMVCBJTiBMT0FERVJTXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNyYyhzcmM6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzcmNbMF0gPT09ICcvJyA/IHNyYy5zbGljZSgxKSA6IHNyY1xufVxuXG5mdW5jdGlvbiBpbWdpeExvYWRlcih7XG4gIHJvb3QsXG4gIHNyYyxcbiAgd2lkdGgsXG4gIHF1YWxpdHksXG59OiBEZWZhdWx0SW1hZ2VMb2FkZXJQcm9wcyk6IHN0cmluZyB7XG4gIC8vIERlbW86IGh0dHBzOi8vc3RhdGljLmltZ2l4Lm5ldC9kYWlzeS5wbmc/Zm9ybWF0PWF1dG8mZml0PW1heCZ3PTMwMFxuICBjb25zdCBwYXJhbXMgPSBbJ2F1dG89Zm9ybWF0JywgJ2ZpdD1tYXgnLCAndz0nICsgd2lkdGhdXG4gIGxldCBwYXJhbXNTdHJpbmcgPSAnJ1xuICBpZiAocXVhbGl0eSkge1xuICAgIHBhcmFtcy5wdXNoKCdxPScgKyBxdWFsaXR5KVxuICB9XG5cbiAgaWYgKHBhcmFtcy5sZW5ndGgpIHtcbiAgICBwYXJhbXNTdHJpbmcgPSAnPycgKyBwYXJhbXMuam9pbignJicpXG4gIH1cbiAgcmV0dXJuIGAke3Jvb3R9JHtub3JtYWxpemVTcmMoc3JjKX0ke3BhcmFtc1N0cmluZ31gXG59XG5cbmZ1bmN0aW9uIGFrYW1haUxvYWRlcih7IHJvb3QsIHNyYywgd2lkdGggfTogRGVmYXVsdEltYWdlTG9hZGVyUHJvcHMpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7cm9vdH0ke25vcm1hbGl6ZVNyYyhzcmMpfT9pbXdpZHRoPSR7d2lkdGh9YFxufVxuXG5mdW5jdGlvbiBjbG91ZGluYXJ5TG9hZGVyKHtcbiAgcm9vdCxcbiAgc3JjLFxuICB3aWR0aCxcbiAgcXVhbGl0eSxcbn06IERlZmF1bHRJbWFnZUxvYWRlclByb3BzKTogc3RyaW5nIHtcbiAgLy8gRGVtbzogaHR0cHM6Ly9yZXMuY2xvdWRpbmFyeS5jb20vZGVtby9pbWFnZS91cGxvYWQvd18zMDAsY19saW1pdCxxX2F1dG8vdHVydGxlcy5qcGdcbiAgY29uc3QgcGFyYW1zID0gWydmX2F1dG8nLCAnY19saW1pdCcsICd3XycgKyB3aWR0aCwgJ3FfJyArIChxdWFsaXR5IHx8ICdhdXRvJyldXG4gIGxldCBwYXJhbXNTdHJpbmcgPSBwYXJhbXMuam9pbignLCcpICsgJy8nXG4gIHJldHVybiBgJHtyb290fSR7cGFyYW1zU3RyaW5nfSR7bm9ybWFsaXplU3JjKHNyYyl9YFxufVxuXG5mdW5jdGlvbiBkZWZhdWx0TG9hZGVyKHtcbiAgcm9vdCxcbiAgc3JjLFxuICB3aWR0aCxcbiAgcXVhbGl0eSxcbn06IERlZmF1bHRJbWFnZUxvYWRlclByb3BzKTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBtaXNzaW5nVmFsdWVzID0gW11cblxuICAgIC8vIHRoZXNlIHNob3VsZCBhbHdheXMgYmUgcHJvdmlkZWQgYnV0IG1ha2Ugc3VyZSB0aGV5IGFyZVxuICAgIGlmICghc3JjKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3NyYycpXG4gICAgaWYgKCF3aWR0aCkgbWlzc2luZ1ZhbHVlcy5wdXNoKCd3aWR0aCcpXG5cbiAgICBpZiAobWlzc2luZ1ZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBOZXh0IEltYWdlIE9wdGltaXphdGlvbiByZXF1aXJlcyAke21pc3NpbmdWYWx1ZXMuam9pbihcbiAgICAgICAgICAnLCAnXG4gICAgICAgICl9IHRvIGJlIHByb3ZpZGVkLiBNYWtlIHN1cmUgeW91IHBhc3MgdGhlbSBhcyBwcm9wcyB0byB0aGUgXFxgbmV4dC9pbWFnZVxcYCBjb21wb25lbnQuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHsgc3JjLCB3aWR0aCwgcXVhbGl0eSB9XG4gICAgICAgICl9YFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChzcmMuc3RhcnRzV2l0aCgnLy8nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHBhcnNlIHNyYyBcIiR7c3JjfVwiIG9uIFxcYG5leHQvaW1hZ2VcXGAsIHByb3RvY29sLXJlbGF0aXZlIFVSTCAoLy8pIG11c3QgYmUgY2hhbmdlZCB0byBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pYFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoJy8nKSAmJiBjb25maWdEb21haW5zKSB7XG4gICAgICBsZXQgcGFyc2VkU3JjOiBVUkxcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZFNyYyA9IG5ldyBVUkwoc3JjKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBwYXJzZSBzcmMgXCIke3NyY31cIiBvbiBcXGBuZXh0L2ltYWdlXFxgLCBpZiB1c2luZyByZWxhdGl2ZSBpbWFnZSBpdCBtdXN0IHN0YXJ0IHdpdGggYSBsZWFkaW5nIHNsYXNoIFwiL1wiIG9yIGJlIGFuIGFic29sdXRlIFVSTCAoaHR0cDovLyBvciBodHRwczovLylgXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb25maWdEb21haW5zLmluY2x1ZGVzKHBhcnNlZFNyYy5ob3N0bmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIHNyYyBwcm9wICgke3NyY30pIG9uIFxcYG5leHQvaW1hZ2VcXGAsIGhvc3RuYW1lIFwiJHtwYXJzZWRTcmMuaG9zdG5hbWV9XCIgaXMgbm90IGNvbmZpZ3VyZWQgdW5kZXIgaW1hZ2VzIGluIHlvdXIgXFxgbmV4dC5jb25maWcuanNcXGBcXG5gICtcbiAgICAgICAgICAgIGBTZWUgbW9yZSBpbmZvOiBodHRwczovL2Vyci5zaC9uZXh0LmpzL25leHQtaW1hZ2UtdW5jb25maWd1cmVkLWhvc3RgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYCR7cm9vdH0/dXJsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNyYyl9Jnc9JHt3aWR0aH0mcT0ke3F1YWxpdHkgfHwgNzV9YFxufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENoaWxkcmVuLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7XG4gIGFkZEJhc2VQYXRoLFxuICBhZGRMb2NhbGUsXG4gIGdldERvbWFpbkxvY2FsZSxcbiAgaXNMb2NhbFVSTCxcbiAgTmV4dFJvdXRlcixcbiAgUHJlZmV0Y2hPcHRpb25zLFxuICByZXNvbHZlSHJlZixcbn0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICcuL3JvdXRlcidcbmltcG9ydCB7IHVzZUludGVyc2VjdGlvbiB9IGZyb20gJy4vdXNlLWludGVyc2VjdGlvbidcblxudHlwZSBVcmwgPSBzdHJpbmcgfCBVcmxPYmplY3RcbnR5cGUgUmVxdWlyZWRLZXlzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiB7fSBleHRlbmRzIFBpY2s8VCwgSz4gPyBuZXZlciA6IEtcbn1ba2V5b2YgVF1cbnR5cGUgT3B0aW9uYWxLZXlzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiB7fSBleHRlbmRzIFBpY2s8VCwgSz4gPyBLIDogbmV2ZXJcbn1ba2V5b2YgVF1cblxuZXhwb3J0IHR5cGUgTGlua1Byb3BzID0ge1xuICBocmVmOiBVcmxcbiAgYXM/OiBVcmxcbiAgcmVwbGFjZT86IGJvb2xlYW5cbiAgc2Nyb2xsPzogYm9vbGVhblxuICBzaGFsbG93PzogYm9vbGVhblxuICBwYXNzSHJlZj86IGJvb2xlYW5cbiAgcHJlZmV0Y2g/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG59XG50eXBlIExpbmtQcm9wc1JlcXVpcmVkID0gUmVxdWlyZWRLZXlzPExpbmtQcm9wcz5cbnR5cGUgTGlua1Byb3BzT3B0aW9uYWwgPSBPcHRpb25hbEtleXM8TGlua1Byb3BzPlxuXG5jb25zdCBwcmVmZXRjaGVkOiB7IFtjYWNoZUtleTogc3RyaW5nXTogYm9vbGVhbiB9ID0ge31cblxuZnVuY3Rpb24gcHJlZmV0Y2goXG4gIHJvdXRlcjogTmV4dFJvdXRlcixcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICBvcHRpb25zPzogUHJlZmV0Y2hPcHRpb25zXG4pOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFyb3V0ZXIpIHJldHVyblxuICBpZiAoIWlzTG9jYWxVUkwoaHJlZikpIHJldHVyblxuICAvLyBQcmVmZXRjaCB0aGUgSlNPTiBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gIC8vIFdlIG5lZWQgdG8gaGFuZGxlIGEgcHJlZmV0Y2ggZXJyb3IgaGVyZSBzaW5jZSB3ZSBtYXkgYmVcbiAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG4gIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpLmNhdGNoKChlcnIpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9KVxuICBjb25zdCBjdXJMb2NhbGUgPVxuICAgIG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyBvcHRpb25zLmxvY2FsZVxuICAgICAgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZVxuXG4gIC8vIEpvaW4gb24gYW4gaW52YWxpZCBVUkkgY2hhcmFjdGVyXG4gIHByZWZldGNoZWRbaHJlZiArICclJyArIGFzICsgKGN1ckxvY2FsZSA/ICclJyArIGN1ckxvY2FsZSA6ICcnKV0gPSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudDogUmVhY3QuTW91c2VFdmVudCk6IGJvb2xlYW4ge1xuICBjb25zdCB7IHRhcmdldCB9ID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MQW5jaG9yRWxlbWVudFxuICByZXR1cm4gKFxuICAgICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSAnX3NlbGYnKSB8fFxuICAgIGV2ZW50Lm1ldGFLZXkgfHxcbiAgICBldmVudC5jdHJsS2V5IHx8XG4gICAgZXZlbnQuc2hpZnRLZXkgfHxcbiAgICBldmVudC5hbHRLZXkgfHwgLy8gdHJpZ2dlcnMgcmVzb3VyY2UgZG93bmxvYWRcbiAgICAoZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDIpXG4gIClcbn1cblxuZnVuY3Rpb24gbGlua0NsaWNrZWQoXG4gIGU6IFJlYWN0Lk1vdXNlRXZlbnQsXG4gIHJvdXRlcjogTmV4dFJvdXRlcixcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICByZXBsYWNlPzogYm9vbGVhbixcbiAgc2hhbGxvdz86IGJvb2xlYW4sXG4gIHNjcm9sbD86IGJvb2xlYW4sXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG4pOiB2b2lkIHtcbiAgY29uc3QgeyBub2RlTmFtZSB9ID0gZS5jdXJyZW50VGFyZ2V0XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQScgJiYgKGlzTW9kaWZpZWRFdmVudChlKSB8fCAhaXNMb2NhbFVSTChocmVmKSkpIHtcbiAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIGJyb3dzZXLigJlzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICByZXR1cm5cbiAgfVxuXG4gIGUucHJldmVudERlZmF1bHQoKVxuXG4gIC8vICBhdm9pZCBzY3JvbGwgZm9yIHVybHMgd2l0aCBhbmNob3IgcmVmc1xuICBpZiAoc2Nyb2xsID09IG51bGwpIHtcbiAgICBzY3JvbGwgPSBhcy5pbmRleE9mKCcjJykgPCAwXG4gIH1cblxuICAvLyByZXBsYWNlIHN0YXRlIGluc3RlYWQgb2YgcHVzaCBpZiBwcm9wIGlzIHByZXNlbnRcbiAgcm91dGVyW3JlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCddKGhyZWYsIGFzLCB7XG4gICAgc2hhbGxvdyxcbiAgICBsb2NhbGUsXG4gICAgc2Nyb2xsLFxuICB9KS50aGVuKChzdWNjZXNzOiBib29sZWFuKSA9PiB7XG4gICAgaWYgKCFzdWNjZXNzKSByZXR1cm5cbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAvLyBGSVhNRTogcHJvcGVyIHJvdXRlIGFubm91bmNpbmcgYXQgUm91dGVyIGxldmVsLCBub3QgTGluazpcbiAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gTGluayhwcm9wczogUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48TGlua1Byb3BzPikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BFcnJvcihhcmdzOiB7XG4gICAgICBrZXk6IHN0cmluZ1xuICAgICAgZXhwZWN0ZWQ6IHN0cmluZ1xuICAgICAgYWN0dWFsOiBzdHJpbmdcbiAgICB9KSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHByb3AgdHlwZTogVGhlIHByb3AgXFxgJHthcmdzLmtleX1cXGAgZXhwZWN0cyBhICR7YXJncy5leHBlY3RlZH0gaW4gXFxgPExpbms+XFxgLCBidXQgZ290IFxcYCR7YXJncy5hY3R1YWx9XFxgIGluc3RlYWQuYCArXG4gICAgICAgICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IFwiXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIlxuICAgICAgICAgICAgOiAnJylcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZDogUmVjb3JkPExpbmtQcm9wc1JlcXVpcmVkLCB0cnVlPiA9IHtcbiAgICAgIGhyZWY6IHRydWUsXG4gICAgfSBhcyBjb25zdFxuICAgIGNvbnN0IHJlcXVpcmVkUHJvcHM6IExpbmtQcm9wc1JlcXVpcmVkW10gPSBPYmplY3Qua2V5cyhcbiAgICAgIHJlcXVpcmVkUHJvcHNHdWFyZFxuICAgICkgYXMgTGlua1Byb3BzUmVxdWlyZWRbXVxuICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5OiBMaW5rUHJvcHNSZXF1aXJlZCkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wc1trZXldID09IG51bGwgfHxcbiAgICAgICAgICAodHlwZW9mIHByb3BzW2tleV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wc1trZXldICE9PSAnb2JqZWN0JylcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgYWN0dWFsOiBwcm9wc1trZXldID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHByb3BzW2tleV0sXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCBfOiBuZXZlciA9IGtleVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZDogUmVjb3JkPExpbmtQcm9wc09wdGlvbmFsLCB0cnVlPiA9IHtcbiAgICAgIGFzOiB0cnVlLFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgIHByZWZldGNoOiB0cnVlLFxuICAgICAgbG9jYWxlOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCBvcHRpb25hbFByb3BzOiBMaW5rUHJvcHNPcHRpb25hbFtdID0gT2JqZWN0LmtleXMoXG4gICAgICBvcHRpb25hbFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc09wdGlvbmFsW11cbiAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzT3B0aW9uYWwpID0+IHtcbiAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XVxuXG4gICAgICBpZiAoa2V5ID09PSAnYXMnKSB7XG4gICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdzdHJpbmcnICYmIHZhbFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnbG9jYWxlJykge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBrZXkgPT09ICdyZXBsYWNlJyB8fFxuICAgICAgICBrZXkgPT09ICdzY3JvbGwnIHx8XG4gICAgICAgIGtleSA9PT0gJ3NoYWxsb3cnIHx8XG4gICAgICAgIGtleSA9PT0gJ3Bhc3NIcmVmJyB8fFxuICAgICAgICBrZXkgPT09ICdwcmVmZXRjaCdcbiAgICAgICkge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAhPSBudWxsICYmIHZhbFR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2Bib29sZWFuYCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCBfOiBuZXZlciA9IGtleVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBUaGlzIGhvb2sgaXMgaW4gYSBjb25kaXRpb25hbCBidXQgdGhhdCBpcyBvayBiZWNhdXNlIGBwcm9jZXNzLmVudi5OT0RFX0VOVmAgbmV2ZXIgY2hhbmdlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIGNvbnN0IGhhc1dhcm5lZCA9IFJlYWN0LnVzZVJlZihmYWxzZSlcbiAgICBpZiAocHJvcHMucHJlZmV0Y2ggJiYgIWhhc1dhcm5lZC5jdXJyZW50KSB7XG4gICAgICBoYXNXYXJuZWQuY3VycmVudCA9IHRydWVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ05leHQuanMgYXV0by1wcmVmZXRjaGVzIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdmlld3BvcnQuIFRoZSBwcmVmZXRjaCBhdHRyaWJ1dGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gTW9yZTogaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvcHJlZmV0Y2gtdHJ1ZS1kZXByZWNhdGVkJ1xuICAgICAgKVxuICAgIH1cbiAgfVxuICBjb25zdCBwID0gcHJvcHMucHJlZmV0Y2ggIT09IGZhbHNlXG5cbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKClcbiAgY29uc3QgcGF0aG5hbWUgPSAocm91dGVyICYmIHJvdXRlci5wYXRobmFtZSkgfHwgJy8nXG5cbiAgY29uc3QgeyBocmVmLCBhcyB9ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSByZXNvbHZlSHJlZihwYXRobmFtZSwgcHJvcHMuaHJlZiwgdHJ1ZSlcbiAgICByZXR1cm4ge1xuICAgICAgaHJlZjogcmVzb2x2ZWRIcmVmLFxuICAgICAgYXM6IHByb3BzLmFzXG4gICAgICAgID8gcmVzb2x2ZUhyZWYocGF0aG5hbWUsIHByb3BzLmFzKVxuICAgICAgICA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmLFxuICAgIH1cbiAgfSwgW3BhdGhuYW1lLCBwcm9wcy5ocmVmLCBwcm9wcy5hc10pXG5cbiAgbGV0IHsgY2hpbGRyZW4sIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlIH0gPSBwcm9wc1xuXG4gIC8vIERlcHJlY2F0ZWQuIFdhcm5pbmcgc2hvd24gYnkgcHJvcFR5cGUgY2hlY2suIElmIHRoZSBjaGlsZHJlbiBwcm92aWRlZCBpcyBhIHN0cmluZyAoPExpbms+ZXhhbXBsZTwvTGluaz4pIHdlIHdyYXAgaXQgaW4gYW4gPGE+IHRhZ1xuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgIGNoaWxkcmVuID0gPGE+e2NoaWxkcmVufTwvYT5cbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNoaWxkLCBpZiBtdWx0aXBsZSBhcmUgcHJvdmlkZWQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICBjb25zdCBjaGlsZDogYW55ID0gQ2hpbGRyZW4ub25seShjaGlsZHJlbilcbiAgY29uc3QgY2hpbGRSZWY6IGFueSA9IGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcgJiYgY2hpbGQucmVmXG5cbiAgY29uc3QgW3NldEludGVyc2VjdGlvblJlZiwgaXNWaXNpYmxlXSA9IHVzZUludGVyc2VjdGlvbih7XG4gICAgcm9vdE1hcmdpbjogJzIwMHB4JyxcbiAgfSlcbiAgY29uc3Qgc2V0UmVmID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGVsOiBFbGVtZW50KSA9PiB7XG4gICAgICBzZXRJbnRlcnNlY3Rpb25SZWYoZWwpXG4gICAgICBpZiAoY2hpbGRSZWYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gJ2Z1bmN0aW9uJykgY2hpbGRSZWYoZWwpXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjaGlsZFJlZi5jdXJyZW50ID0gZWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW2NoaWxkUmVmLCBzZXRJbnRlcnNlY3Rpb25SZWZdXG4gIClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzaG91bGRQcmVmZXRjaCA9IGlzVmlzaWJsZSAmJiBwICYmIGlzTG9jYWxVUkwoaHJlZilcbiAgICBjb25zdCBjdXJMb2NhbGUgPVxuICAgICAgdHlwZW9mIGxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbGUgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZVxuICAgIGNvbnN0IGlzUHJlZmV0Y2hlZCA9XG4gICAgICBwcmVmZXRjaGVkW2hyZWYgKyAnJScgKyBhcyArIChjdXJMb2NhbGUgPyAnJScgKyBjdXJMb2NhbGUgOiAnJyldXG4gICAgaWYgKHNob3VsZFByZWZldGNoICYmICFpc1ByZWZldGNoZWQpIHtcbiAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgbG9jYWxlOiBjdXJMb2NhbGUsXG4gICAgICB9KVxuICAgIH1cbiAgfSwgW2FzLCBocmVmLCBpc1Zpc2libGUsIGxvY2FsZSwgcCwgcm91dGVyXSlcblxuICBjb25zdCBjaGlsZFByb3BzOiB7XG4gICAgb25Nb3VzZUVudGVyPzogUmVhY3QuTW91c2VFdmVudEhhbmRsZXJcbiAgICBvbkNsaWNrOiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlclxuICAgIGhyZWY/OiBzdHJpbmdcbiAgICByZWY/OiBhbnlcbiAgfSA9IHtcbiAgICByZWY6IHNldFJlZixcbiAgICBvbkNsaWNrOiAoZTogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNoaWxkLnByb3BzLm9uQ2xpY2soZSlcbiAgICAgIH1cbiAgICAgIGlmICghZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlKVxuICAgICAgfVxuICAgIH0sXG4gIH1cblxuICBjaGlsZFByb3BzLm9uTW91c2VFbnRlciA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgaWYgKCFpc0xvY2FsVVJMKGhyZWYpKSByZXR1cm5cbiAgICBpZiAoY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyKGUpXG4gICAgfVxuICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHsgcHJpb3JpdHk6IHRydWUgfSlcbiAgfVxuXG4gIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAvLyBkZWZpbmVkLCB3ZSBzcGVjaWZ5IHRoZSBjdXJyZW50ICdocmVmJywgc28gdGhhdCByZXBldGl0aW9uIGlzIG5vdCBuZWVkZWQgYnkgdGhlIHVzZXJcbiAgaWYgKHByb3BzLnBhc3NIcmVmIHx8IChjaGlsZC50eXBlID09PSAnYScgJiYgISgnaHJlZicgaW4gY2hpbGQucHJvcHMpKSkge1xuICAgIGNvbnN0IGN1ckxvY2FsZSA9XG4gICAgICB0eXBlb2YgbG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsZSA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlXG5cbiAgICAvLyB3ZSBvbmx5IHJlbmRlciBkb21haW4gbG9jYWxlcyBpZiB3ZSBhcmUgY3VycmVudGx5IG9uIGEgZG9tYWluIGxvY2FsZVxuICAgIC8vIHNvIHRoYXQgbG9jYWxlIGxpbmtzIGFyZSBzdGlsbCB2aXNpdGFibGUgaW4gZGV2ZWxvcG1lbnQvcHJldmlldyBlbnZzXG4gICAgY29uc3QgbG9jYWxlRG9tYWluID1cbiAgICAgIHJvdXRlciAmJlxuICAgICAgcm91dGVyLmlzTG9jYWxlRG9tYWluICYmXG4gICAgICBnZXREb21haW5Mb2NhbGUoXG4gICAgICAgIGFzLFxuICAgICAgICBjdXJMb2NhbGUsXG4gICAgICAgIHJvdXRlciAmJiByb3V0ZXIubG9jYWxlcyxcbiAgICAgICAgcm91dGVyICYmIHJvdXRlci5kb21haW5Mb2NhbGVzXG4gICAgICApXG5cbiAgICBjaGlsZFByb3BzLmhyZWYgPVxuICAgICAgbG9jYWxlRG9tYWluIHx8XG4gICAgICBhZGRCYXNlUGF0aChhZGRMb2NhbGUoYXMsIGN1ckxvY2FsZSwgcm91dGVyICYmIHJvdXRlci5kZWZhdWx0TG9jYWxlKSlcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpXG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmtcbiIsIi8qKlxuICogUmVtb3ZlcyB0aGUgdHJhaWxpbmcgc2xhc2ggb2YgYSBwYXRoIGlmIHRoZXJlIGlzIG9uZS4gUHJlc2VydmVzIHRoZSByb290IHBhdGggYC9gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGguZW5kc1dpdGgoJy8nKSAmJiBwYXRoICE9PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGhcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSB0cmFpbGluZyBzbGFzaCBvZiBhIHBhdGggYWNjb3JkaW5nIHRvIHRoZSBgdHJhaWxpbmdTbGFzaGAgb3B0aW9uXG4gKiBpbiBgbmV4dC5jb25maWcuanNgLlxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2ggPSBwcm9jZXNzLmVudi5fX05FWFRfVFJBSUxJTkdfU0xBU0hcbiAgPyAocGF0aDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAgIGlmICgvXFwuW14vXStcXC8/JC8udGVzdChwYXRoKSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aClcbiAgICAgIH0gZWxzZSBpZiAocGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgIHJldHVybiBwYXRoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aCArICcvJ1xuICAgICAgfVxuICAgIH1cbiAgOiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaFxuIiwidHlwZSBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlID0gYW55XG50eXBlIFJlcXVlc3RJZGxlQ2FsbGJhY2tPcHRpb25zID0ge1xuICB0aW1lb3V0OiBudW1iZXJcbn1cbnR5cGUgUmVxdWVzdElkbGVDYWxsYmFja0RlYWRsaW5lID0ge1xuICByZWFkb25seSBkaWRUaW1lb3V0OiBib29sZWFuXG4gIHRpbWVSZW1haW5pbmc6ICgpID0+IG51bWJlclxufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2s6IChcbiAgICAgIGNhbGxiYWNrOiAoZGVhZGxpbmU6IFJlcXVlc3RJZGxlQ2FsbGJhY2tEZWFkbGluZSkgPT4gdm9pZCxcbiAgICAgIG9wdHM/OiBSZXF1ZXN0SWRsZUNhbGxiYWNrT3B0aW9uc1xuICAgICkgPT4gUmVxdWVzdElkbGVDYWxsYmFja0hhbmRsZVxuICAgIGNhbmNlbElkbGVDYWxsYmFjazogKGlkOiBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlKSA9PiB2b2lkXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPVxuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYucmVxdWVzdElkbGVDYWxsYmFjaykgfHxcbiAgZnVuY3Rpb24gKFxuICAgIGNiOiAoZGVhZGxpbmU6IFJlcXVlc3RJZGxlQ2FsbGJhY2tEZWFkbGluZSkgPT4gdm9pZFxuICApOiBOb2RlSlMuVGltZW91dCB7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKHtcbiAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSlcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSwgMSlcbiAgfVxuXG5leHBvcnQgY29uc3QgY2FuY2VsSWRsZUNhbGxiYWNrID1cbiAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLmNhbmNlbElkbGVDYWxsYmFjaykgfHxcbiAgZnVuY3Rpb24gKGlkOiBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlKSB7XG4gICAgcmV0dXJuIGNsZWFyVGltZW91dChpZClcbiAgfVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQ2xpZW50QnVpbGRNYW5pZmVzdCB9IGZyb20gJy4uL2J1aWxkL3dlYnBhY2svcGx1Z2lucy9idWlsZC1tYW5pZmVzdC1wbHVnaW4nXG5pbXBvcnQgZ2V0QXNzZXRQYXRoRnJvbVJvdXRlIGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvZ2V0LWFzc2V0LXBhdGgtZnJvbS1yb3V0ZSdcbmltcG9ydCB7IHJlcXVlc3RJZGxlQ2FsbGJhY2sgfSBmcm9tICcuL3JlcXVlc3QtaWRsZS1jYWxsYmFjaydcblxuLy8gMy44cyB3YXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGl0J3Mgd2hhdCBodHRwczovL3dlYi5kZXYvaW50ZXJhY3RpdmVcbi8vIGNvbnNpZGVycyBhcyBcIkdvb2RcIiB0aW1lLXRvLWludGVyYWN0aXZlLiBXZSBtdXN0IGFzc3VtZSBzb21ldGhpbmcgd2VudFxuLy8gd3JvbmcgYmV5b25kIHRoaXMgcG9pbnQsIGFuZCB0aGVuIGZhbGwtYmFjayB0byBhIGZ1bGwgcGFnZSB0cmFuc2l0aW9uIHRvXG4vLyBzaG93IHRoZSB1c2VyIHNvbWV0aGluZyBvZiB2YWx1ZS5cbmNvbnN0IE1TX01BWF9JRExFX0RFTEFZID0gMzgwMFxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fQlVJTERfTUFOSUZFU1Q/OiBDbGllbnRCdWlsZE1hbmlmZXN0XG4gICAgX19CVUlMRF9NQU5JRkVTVF9DQj86IEZ1bmN0aW9uXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB7XG4gIGNvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICBleHBvcnRzOiBhbnlcbn1cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkRW50cnlwb2ludEZhaWx1cmUge1xuICBlcnJvcjogdW5rbm93blxufVxuZXhwb3J0IHR5cGUgUm91dGVFbnRyeXBvaW50ID0gTG9hZGVkRW50cnlwb2ludFN1Y2Nlc3MgfCBMb2FkZWRFbnRyeXBvaW50RmFpbHVyZVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlU3R5bGVTaGVldCB7XG4gIGhyZWY6IHN0cmluZ1xuICBjb250ZW50OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRSb3V0ZVN1Y2Nlc3MgZXh0ZW5kcyBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB7XG4gIHN0eWxlczogUm91dGVTdHlsZVNoZWV0W11cbn1cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkUm91dGVGYWlsdXJlIHtcbiAgZXJyb3I6IHVua25vd25cbn1cbmV4cG9ydCB0eXBlIFJvdXRlTG9hZGVyRW50cnkgPSBMb2FkZWRSb3V0ZVN1Y2Nlc3MgfCBMb2FkZWRSb3V0ZUZhaWx1cmVcblxuZXhwb3J0IHR5cGUgRnV0dXJlPFY+ID0ge1xuICByZXNvbHZlOiAoZW50cnlwb2ludDogVikgPT4gdm9pZFxuICBmdXR1cmU6IFByb21pc2U8Vj5cbn1cbmZ1bmN0aW9uIHdpdGhGdXR1cmU8VD4oXG4gIGtleTogc3RyaW5nLFxuICBtYXA6IE1hcDxzdHJpbmcsIEZ1dHVyZTxUPiB8IFQ+LFxuICBnZW5lcmF0b3I/OiAoKSA9PiBQcm9taXNlPFQ+XG4pOiBQcm9taXNlPFQ+IHtcbiAgbGV0IGVudHJ5OiBGdXR1cmU8VD4gfCBUIHwgdW5kZWZpbmVkID0gbWFwLmdldChrZXkpXG4gIGlmIChlbnRyeSkge1xuICAgIGlmICgnZnV0dXJlJyBpbiBlbnRyeSkge1xuICAgICAgcmV0dXJuIGVudHJ5LmZ1dHVyZVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVudHJ5KVxuICB9XG4gIGxldCByZXNvbHZlcjogKGVudHJ5cG9pbnQ6IFQpID0+IHZvaWRcbiAgY29uc3QgcHJvbTogUHJvbWlzZTxUPiA9IG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlKSA9PiB7XG4gICAgcmVzb2x2ZXIgPSByZXNvbHZlXG4gIH0pXG4gIG1hcC5zZXQoa2V5LCAoZW50cnkgPSB7IHJlc29sdmU6IHJlc29sdmVyISwgZnV0dXJlOiBwcm9tIH0pKVxuICByZXR1cm4gZ2VuZXJhdG9yXG4gICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICBnZW5lcmF0b3IoKS50aGVuKCh2YWx1ZSkgPT4gKHJlc29sdmVyKHZhbHVlKSwgdmFsdWUpKVxuICAgIDogcHJvbVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlTG9hZGVyIHtcbiAgd2hlbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8Um91dGVFbnRyeXBvaW50PlxuICBvbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZywgZXhlY3V0ZTogKCkgPT4gdW5rbm93bik6IHZvaWRcbiAgbG9hZFJvdXRlKHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPFJvdXRlTG9hZGVyRW50cnk+XG4gIHByZWZldGNoKHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+XG59XG5cbmZ1bmN0aW9uIGhhc1ByZWZldGNoKGxpbms/OiBIVE1MTGlua0VsZW1lbnQpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpXG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGRldGVjdCBJRTExIHNpbmNlIGl0IHN1cHBvcnRzIHByZWZldGNoIGJ1dCBpc24ndCBkZXRlY3RlZFxuICAgICAgLy8gd2l0aCByZWxMaXN0LnN1cHBvcnRcbiAgICAgICghIXdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiAhIShkb2N1bWVudCBhcyBhbnkpLmRvY3VtZW50TW9kZSkgfHxcbiAgICAgIGxpbmsucmVsTGlzdC5zdXBwb3J0cygncHJlZmV0Y2gnKVxuICAgIClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuY29uc3QgY2FuUHJlZmV0Y2g6IGJvb2xlYW4gPSBoYXNQcmVmZXRjaCgpXG5cbmZ1bmN0aW9uIHByZWZldGNoVmlhRG9tKFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIGxpbms/OiBIVE1MTGlua0VsZW1lbnRcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgbGlua1tyZWw9XCJwcmVmZXRjaFwiXVtocmVmXj1cIiR7aHJlZn1cIl1gKSkge1xuICAgICAgcmV0dXJuIHJlcygpXG4gICAgfVxuXG4gICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKVxuXG4gICAgLy8gVGhlIG9yZGVyIG9mIHByb3BlcnR5IGFzc2lnbm1lbnQgaGVyZSBpcyBpbnRlbnRpb25hbDpcbiAgICBpZiAoYXMpIGxpbmshLmFzID0gYXNcbiAgICBsaW5rIS5yZWwgPSBgcHJlZmV0Y2hgXG4gICAgbGluayEuY3Jvc3NPcmlnaW4gPSBwcm9jZXNzLmVudi5fX05FWFRfQ1JPU1NfT1JJR0lOIVxuICAgIGxpbmshLm9ubG9hZCA9IHJlc1xuICAgIGxpbmshLm9uZXJyb3IgPSByZWpcblxuICAgIC8vIGBocmVmYCBzaG91bGQgYWx3YXlzIGJlIGxhc3Q6XG4gICAgbGluayEuaHJlZiA9IGhyZWZcblxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluaylcbiAgfSlcbn1cblxuY29uc3QgQVNTRVRfTE9BRF9FUlJPUiA9IFN5bWJvbCgnQVNTRVRfTE9BRF9FUlJPUicpXG4vLyBUT0RPOiB1bmV4cG9ydFxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtBc3NldEVycm9yKGVycjogRXJyb3IpOiBFcnJvciB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCBBU1NFVF9MT0FEX0VSUk9SLCB7fSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXNzZXRFcnJvcihlcnI/OiBFcnJvcik6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICByZXR1cm4gZXJyICYmIEFTU0VUX0xPQURfRVJST1IgaW4gZXJyXG59XG5cbmZ1bmN0aW9uIGFwcGVuZFNjcmlwdChcbiAgc3JjOiBzdHJpbmcsXG4gIHNjcmlwdD86IEhUTUxTY3JpcHRFbGVtZW50XG4pOiBQcm9taXNlPHVua25vd24+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuXG4gICAgLy8gVGhlIG9yZGVyIG9mIHByb3BlcnR5IGFzc2lnbm1lbnQgaGVyZSBpcyBpbnRlbnRpb25hbC5cbiAgICAvLyAxLiBTZXR1cCBzdWNjZXNzL2ZhaWx1cmUgaG9va3MgaW4gY2FzZSB0aGUgYnJvd3NlciBzeW5jaHJvbm91c2x5XG4gICAgLy8gICAgZXhlY3V0ZXMgd2hlbiBgc3JjYCBpcyBzZXQuXG4gICAgc2NyaXB0Lm9ubG9hZCA9IHJlc29sdmVcbiAgICBzY3JpcHQub25lcnJvciA9ICgpID0+XG4gICAgICByZWplY3QobWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzY3JpcHQ6ICR7c3JjfWApKSlcblxuICAgIC8vIDIuIENvbmZpZ3VyZSB0aGUgY3Jvc3Mtb3JpZ2luIGF0dHJpYnV0ZSBiZWZvcmUgc2V0dGluZyBgc3JjYCBpbiBjYXNlIHRoZVxuICAgIC8vICAgIGJyb3dzZXIgYmVnaW5zIHRvIGZldGNoLlxuICAgIHNjcmlwdC5jcm9zc09yaWdpbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DUk9TU19PUklHSU4hXG5cbiAgICAvLyAzLiBGaW5hbGx5LCBzZXQgdGhlIHNvdXJjZSBhbmQgaW5qZWN0IGludG8gdGhlIERPTSBpbiBjYXNlIHRoZSBjaGlsZFxuICAgIC8vICAgIG11c3QgYmUgYXBwZW5kZWQgZm9yIGZldGNoaW5nIHRvIHN0YXJ0LlxuICAgIHNjcmlwdC5zcmMgPSBzcmNcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdClcbiAgfSlcbn1cblxuLy8gUmVzb2x2ZSBhIHByb21pc2UgdGhhdCB0aW1lcyBvdXQgYWZ0ZXIgZ2l2ZW4gYW1vdW50IG9mIG1pbGxpc2Vjb25kcy5cbmZ1bmN0aW9uIHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQ8VD4oXG4gIHA6IFByb21pc2U8VD4sXG4gIG1zOiBudW1iZXIsXG4gIGVycjogRXJyb3Jcbik6IFByb21pc2U8VD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZVxuXG4gICAgcC50aGVuKChyKSA9PiB7XG4gICAgICAvLyBSZXNvbHZlZCwgY2FuY2VsIHRoZSB0aW1lb3V0XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlXG4gICAgICByZXNvbHZlKHIpXG4gICAgfSkuY2F0Y2gocmVqZWN0KVxuXG4gICAgcmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PlxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgfVxuICAgICAgfSwgbXMpXG4gICAgKVxuICB9KVxufVxuXG4vLyBUT0RPOiBzdG9wIGV4cG9ydGluZyBvciBjYWNoZSB0aGUgZmFpbHVyZVxuLy8gSXQnZCBiZSBiZXN0IHRvIHN0b3AgZXhwb3J0aW5nIHRoaXMuIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLiBXZSdyZVxuLy8gb25seSBleHBvcnRpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsdHkgd2l0aCB0aGUgYHBhZ2UtbG9hZGVyYC5cbi8vIE9ubHkgY2FjaGUgdGhpcyByZXNwb25zZSBhcyBhIGxhc3QgcmVzb3J0IGlmIHdlIGNhbm5vdCBlbGltaW5hdGUgYWxsIG90aGVyXG4vLyBjb2RlIGJyYW5jaGVzIHRoYXQgdXNlIHRoZSBCdWlsZCBNYW5pZmVzdCBDYWxsYmFjayBhbmQgcHVzaCB0aGVtIHRocm91Z2hcbi8vIHRoZSBSb3V0ZSBMb2FkZXIgaW50ZXJmYWNlLlxuZXhwb3J0IGZ1bmN0aW9uIGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKTogUHJvbWlzZTxDbGllbnRCdWlsZE1hbmlmZXN0PiB7XG4gIGlmIChzZWxmLl9fQlVJTERfTUFOSUZFU1QpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNlbGYuX19CVUlMRF9NQU5JRkVTVClcbiAgfVxuXG4gIGNvbnN0IG9uQnVpbGRNYW5pZmVzdDogUHJvbWlzZTxDbGllbnRCdWlsZE1hbmlmZXN0PiA9IG5ldyBQcm9taXNlPFxuICAgIENsaWVudEJ1aWxkTWFuaWZlc3RcbiAgPigocmVzb2x2ZSkgPT4ge1xuICAgIC8vIE1hbmRhdG9yeSBiZWNhdXNlIHRoaXMgaXMgbm90IGNvbmN1cnJlbnQgc2FmZTpcbiAgICBjb25zdCBjYiA9IHNlbGYuX19CVUlMRF9NQU5JRkVTVF9DQlxuICAgIHNlbGYuX19CVUlMRF9NQU5JRkVTVF9DQiA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKVxuICAgICAgY2IgJiYgY2IoKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dDxDbGllbnRCdWlsZE1hbmlmZXN0PihcbiAgICBvbkJ1aWxkTWFuaWZlc3QsXG4gICAgTVNfTUFYX0lETEVfREVMQVksXG4gICAgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjbGllbnQgYnVpbGQgbWFuaWZlc3QnKSlcbiAgKVxufVxuXG5pbnRlcmZhY2UgUm91dGVGaWxlcyB7XG4gIHNjcmlwdHM6IHN0cmluZ1tdXG4gIGNzczogc3RyaW5nW11cbn1cbmZ1bmN0aW9uIGdldEZpbGVzRm9yUm91dGUoXG4gIGFzc2V0UHJlZml4OiBzdHJpbmcsXG4gIHJvdXRlOiBzdHJpbmdcbik6IFByb21pc2U8Um91dGVGaWxlcz4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHNjcmlwdHM6IFtcbiAgICAgICAgYXNzZXRQcmVmaXggK1xuICAgICAgICAgICcvX25leHQvc3RhdGljL2NodW5rcy9wYWdlcycgK1xuICAgICAgICAgIGVuY29kZVVSSShnZXRBc3NldFBhdGhGcm9tUm91dGUocm91dGUsICcuanMnKSksXG4gICAgICBdLFxuICAgICAgLy8gU3R5bGVzIGFyZSBoYW5kbGVkIGJ5IGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50OlxuICAgICAgY3NzOiBbXSxcbiAgICB9KVxuICB9XG4gIHJldHVybiBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkudGhlbigobWFuaWZlc3QpID0+IHtcbiAgICBpZiAoIShyb3V0ZSBpbiBtYW5pZmVzdCkpIHtcbiAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvb2t1cCByb3V0ZTogJHtyb3V0ZX1gKSlcbiAgICB9XG4gICAgY29uc3QgYWxsRmlsZXMgPSBtYW5pZmVzdFtyb3V0ZV0ubWFwKFxuICAgICAgKGVudHJ5KSA9PiBhc3NldFByZWZpeCArICcvX25leHQvJyArIGVuY29kZVVSSShlbnRyeSlcbiAgICApXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmlwdHM6IGFsbEZpbGVzLmZpbHRlcigodikgPT4gdi5lbmRzV2l0aCgnLmpzJykpLFxuICAgICAgY3NzOiBhbGxGaWxlcy5maWx0ZXIoKHYpID0+IHYuZW5kc1dpdGgoJy5jc3MnKSksXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZUxvYWRlcihhc3NldFByZWZpeDogc3RyaW5nKTogUm91dGVMb2FkZXIge1xuICBjb25zdCBlbnRyeXBvaW50czogTWFwPFxuICAgIHN0cmluZyxcbiAgICBGdXR1cmU8Um91dGVFbnRyeXBvaW50PiB8IFJvdXRlRW50cnlwb2ludFxuICA+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IGxvYWRlZFNjcmlwdHM6IE1hcDxzdHJpbmcsIFByb21pc2U8dW5rbm93bj4+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IHN0eWxlU2hlZXRzOiBNYXA8c3RyaW5nLCBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IHJvdXRlczogTWFwPFxuICAgIHN0cmluZyxcbiAgICBGdXR1cmU8Um91dGVMb2FkZXJFbnRyeT4gfCBSb3V0ZUxvYWRlckVudHJ5XG4gID4gPSBuZXcgTWFwKClcblxuICBmdW5jdGlvbiBtYXliZUV4ZWN1dGVTY3JpcHQoc3JjOiBzdHJpbmcpOiBQcm9taXNlPHVua25vd24+IHtcbiAgICBsZXQgcHJvbTogUHJvbWlzZTx1bmtub3duPiB8IHVuZGVmaW5lZCA9IGxvYWRlZFNjcmlwdHMuZ2V0KHNyYylcbiAgICBpZiAocHJvbSkge1xuICAgICAgcmV0dXJuIHByb21cbiAgICB9XG5cbiAgICAvLyBTa2lwIGV4ZWN1dGluZyBzY3JpcHQgaWYgaXQncyBhbHJlYWR5IGluIHRoZSBET006XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHNjcmlwdFtzcmNePVwiJHtzcmN9XCJdYCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIGxvYWRlZFNjcmlwdHMuc2V0KHNyYywgKHByb20gPSBhcHBlbmRTY3JpcHQoc3JjKSkpXG4gICAgcmV0dXJuIHByb21cbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoU3R5bGVTaGVldChocmVmOiBzdHJpbmcpOiBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4ge1xuICAgIGxldCBwcm9tOiBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4gfCB1bmRlZmluZWQgPSBzdHlsZVNoZWV0cy5nZXQoaHJlZilcbiAgICBpZiAocHJvbSkge1xuICAgICAgcmV0dXJuIHByb21cbiAgICB9XG5cbiAgICBzdHlsZVNoZWV0cy5zZXQoXG4gICAgICBocmVmLFxuICAgICAgKHByb20gPSBmZXRjaChocmVmKVxuICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3R5bGVzaGVldDogJHtocmVmfWApXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXMudGV4dCgpLnRoZW4oKHRleHQpID0+ICh7IGhyZWY6IGhyZWYsIGNvbnRlbnQ6IHRleHQgfSkpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IoZXJyKVxuICAgICAgICB9KSlcbiAgICApXG4gICAgcmV0dXJuIHByb21cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2hlbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZykge1xuICAgICAgcmV0dXJuIHdpdGhGdXR1cmUocm91dGUsIGVudHJ5cG9pbnRzKVxuICAgIH0sXG4gICAgb25FbnRyeXBvaW50KHJvdXRlOiBzdHJpbmcsIGV4ZWN1dGU6ICgpID0+IHVua25vd24pIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZShleGVjdXRlKVxuICAgICAgICAudGhlbigoZm4pID0+IGZuKCkpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgIChleHBvcnRzOiBhbnkpID0+ICh7XG4gICAgICAgICAgICBjb21wb25lbnQ6IChleHBvcnRzICYmIGV4cG9ydHMuZGVmYXVsdCkgfHwgZXhwb3J0cyxcbiAgICAgICAgICAgIGV4cG9ydHM6IGV4cG9ydHMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgKGVycikgPT4gKHsgZXJyb3I6IGVyciB9KVxuICAgICAgICApXG4gICAgICAgIC50aGVuKChpbnB1dDogUm91dGVFbnRyeXBvaW50KSA9PiB7XG4gICAgICAgICAgY29uc3Qgb2xkID0gZW50cnlwb2ludHMuZ2V0KHJvdXRlKVxuICAgICAgICAgIGVudHJ5cG9pbnRzLnNldChyb3V0ZSwgaW5wdXQpXG4gICAgICAgICAgaWYgKG9sZCAmJiAncmVzb2x2ZScgaW4gb2xkKSBvbGQucmVzb2x2ZShpbnB1dClcbiAgICAgICAgfSlcbiAgICB9LFxuICAgIGxvYWRSb3V0ZShyb3V0ZTogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gd2l0aEZ1dHVyZTxSb3V0ZUxvYWRlckVudHJ5Pihyb3V0ZSwgcm91dGVzLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBzY3JpcHRzLCBjc3MgfSA9IGF3YWl0IGdldEZpbGVzRm9yUm91dGUoYXNzZXRQcmVmaXgsIHJvdXRlKVxuICAgICAgICAgIGNvbnN0IFssIHN0eWxlc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBlbnRyeXBvaW50cy5oYXMocm91dGUpXG4gICAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgICAgOiBQcm9taXNlLmFsbChzY3JpcHRzLm1hcChtYXliZUV4ZWN1dGVTY3JpcHQpKSxcbiAgICAgICAgICAgIFByb21pc2UuYWxsKGNzcy5tYXAoZmV0Y2hTdHlsZVNoZWV0KSksXG4gICAgICAgICAgXSBhcyBjb25zdClcblxuICAgICAgICAgIGNvbnN0IGVudHJ5cG9pbnQ6IFJvdXRlRW50cnlwb2ludCA9IGF3YWl0IHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQoXG4gICAgICAgICAgICB0aGlzLndoZW5FbnRyeXBvaW50KHJvdXRlKSxcbiAgICAgICAgICAgIE1TX01BWF9JRExFX0RFTEFZLFxuICAgICAgICAgICAgbWFya0Fzc2V0RXJyb3IoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihgUm91dGUgZGlkIG5vdCBjb21wbGV0ZSBsb2FkaW5nOiAke3JvdXRlfWApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgY29uc3QgcmVzOiBSb3V0ZUxvYWRlckVudHJ5ID0gT2JqZWN0LmFzc2lnbjxcbiAgICAgICAgICAgIHsgc3R5bGVzOiBSb3V0ZVN0eWxlU2hlZXRbXSB9LFxuICAgICAgICAgICAgUm91dGVFbnRyeXBvaW50XG4gICAgICAgICAgPih7IHN0eWxlcyB9LCBlbnRyeXBvaW50KVxuICAgICAgICAgIHJldHVybiAnZXJyb3InIGluIGVudHJ5cG9pbnQgPyBlbnRyeXBvaW50IDogcmVzXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiB7IGVycm9yOiBlcnIgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG4gICAgcHJlZmV0Y2gocm91dGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvcXVpY2tsaW5rL2Jsb2IvNDUzYTY2MWZhMWZhOTQwZTJkMmUwNDQ0NTIzOThlMzhjNjdhOThmYi9zcmMvaW5kZXgubWpzI0wxMTUtTDExOFxuICAgICAgLy8gTGljZW5zZTogQXBhY2hlIDIuMFxuICAgICAgbGV0IGNuXG4gICAgICBpZiAoKGNuID0gKG5hdmlnYXRvciBhcyBhbnkpLmNvbm5lY3Rpb24pKSB7XG4gICAgICAgIC8vIERvbid0IHByZWZldGNoIGlmIHVzaW5nIDJHIG9yIGlmIFNhdmUtRGF0YSBpcyBlbmFibGVkLlxuICAgICAgICBpZiAoY24uc2F2ZURhdGEgfHwgLzJnLy50ZXN0KGNuLmVmZmVjdGl2ZVR5cGUpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRGaWxlc0ZvclJvdXRlKGFzc2V0UHJlZml4LCByb3V0ZSlcbiAgICAgICAgLnRoZW4oKG91dHB1dCkgPT5cbiAgICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIGNhblByZWZldGNoXG4gICAgICAgICAgICAgID8gb3V0cHV0LnNjcmlwdHMubWFwKChzY3JpcHQpID0+IHByZWZldGNoVmlhRG9tKHNjcmlwdCwgJ3NjcmlwdCcpKVxuICAgICAgICAgICAgICA6IFtdXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHRoaXMubG9hZFJvdXRlKHJvdXRlKSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKFxuICAgICAgICAgIC8vIHN3YWxsb3cgcHJlZmV0Y2ggZXJyb3JzXG4gICAgICAgICAgKCkgPT4ge31cbiAgICAgICAgKVxuICAgIH0sXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUm91dGVMb2FkZXJcbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBSb3V0ZXIsIHsgTmV4dFJvdXRlciB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgUm91dGVyQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dCdcblxudHlwZSBDbGFzc0FyZ3VtZW50czxUPiA9IFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGluZmVyIFUpID0+IGFueSA/IFUgOiBhbnlcblxudHlwZSBSb3V0ZXJBcmdzID0gQ2xhc3NBcmd1bWVudHM8dHlwZW9mIFJvdXRlcj5cblxudHlwZSBTaW5nbGV0b25Sb3V0ZXJCYXNlID0ge1xuICByb3V0ZXI6IFJvdXRlciB8IG51bGxcbiAgcmVhZHlDYWxsYmFja3M6IEFycmF5PCgpID0+IGFueT5cbiAgcmVhZHkoY2I6ICgpID0+IGFueSk6IHZvaWRcbn1cblxuZXhwb3J0IHsgUm91dGVyLCBOZXh0Um91dGVyIH1cblxuZXhwb3J0IHR5cGUgU2luZ2xldG9uUm91dGVyID0gU2luZ2xldG9uUm91dGVyQmFzZSAmIE5leHRSb3V0ZXJcblxuY29uc3Qgc2luZ2xldG9uUm91dGVyOiBTaW5nbGV0b25Sb3V0ZXJCYXNlID0ge1xuICByb3V0ZXI6IG51bGwsIC8vIGhvbGRzIHRoZSBhY3R1YWwgcm91dGVyIGluc3RhbmNlXG4gIHJlYWR5Q2FsbGJhY2tzOiBbXSxcbiAgcmVhZHkoY2I6ICgpID0+IHZvaWQpIHtcbiAgICBpZiAodGhpcy5yb3V0ZXIpIHJldHVybiBjYigpXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJlYWR5Q2FsbGJhY2tzLnB1c2goY2IpXG4gICAgfVxuICB9LFxufVxuXG4vLyBDcmVhdGUgcHVibGljIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgb2YgdGhlIHJvdXRlciBpbiB0aGUgc2luZ2xldG9uUm91dGVyXG5jb25zdCB1cmxQcm9wZXJ0eUZpZWxkcyA9IFtcbiAgJ3BhdGhuYW1lJyxcbiAgJ3JvdXRlJyxcbiAgJ3F1ZXJ5JyxcbiAgJ2FzUGF0aCcsXG4gICdjb21wb25lbnRzJyxcbiAgJ2lzRmFsbGJhY2snLFxuICAnYmFzZVBhdGgnLFxuICAnbG9jYWxlJyxcbiAgJ2xvY2FsZXMnLFxuICAnZGVmYXVsdExvY2FsZScsXG4gICdpc1JlYWR5JyxcbiAgJ2lzUHJldmlldycsXG4gICdpc0xvY2FsZURvbWFpbicsXG5dXG5jb25zdCByb3V0ZXJFdmVudHMgPSBbXG4gICdyb3V0ZUNoYW5nZVN0YXJ0JyxcbiAgJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLFxuICAncm91dGVDaGFuZ2VDb21wbGV0ZScsXG4gICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgJ2hhc2hDaGFuZ2VTdGFydCcsXG4gICdoYXNoQ2hhbmdlQ29tcGxldGUnLFxuXVxuY29uc3QgY29yZU1ldGhvZEZpZWxkcyA9IFtcbiAgJ3B1c2gnLFxuICAncmVwbGFjZScsXG4gICdyZWxvYWQnLFxuICAnYmFjaycsXG4gICdwcmVmZXRjaCcsXG4gICdiZWZvcmVQb3BTdGF0ZScsXG5dXG5cbi8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsICdldmVudHMnLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gUm91dGVyLmV2ZW50c1xuICB9LFxufSlcblxudXJsUHJvcGVydHlGaWVsZHMuZm9yRWFjaCgoZmllbGQ6IHN0cmluZykgPT4ge1xuICAvLyBIZXJlIHdlIG5lZWQgdG8gdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBiZWNhdXNlLCB3ZSBuZWVkIHRvIHJldHVyblxuICAvLyB0aGUgcHJvcGVydHkgYXNzaWduZWQgdG8gdGhlIGFjdHVhbCByb3V0ZXJcbiAgLy8gVGhlIHZhbHVlIG1pZ2h0IGdldCBjaGFuZ2VkIGFzIHdlIGNoYW5nZSByb3V0ZXMgYW5kIHRoaXMgaXMgdGhlXG4gIC8vIHByb3BlciB3YXkgdG8gYWNjZXNzIGl0XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsIGZpZWxkLCB7XG4gICAgZ2V0KCkge1xuICAgICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgICByZXR1cm4gcm91dGVyW2ZpZWxkXSBhcyBzdHJpbmdcbiAgICB9LFxuICB9KVxufSlcblxuY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZDogc3RyaW5nKSA9PiB7XG4gIC8vIFdlIGRvbid0IHJlYWxseSBrbm93IHRoZSB0eXBlcyBoZXJlLCBzbyB3ZSBhZGQgdGhlbSBsYXRlciBpbnN0ZWFkXG4gIDsoc2luZ2xldG9uUm91dGVyIGFzIGFueSlbZmllbGRdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgcmV0dXJuIHJvdXRlcltmaWVsZF0oLi4uYXJncylcbiAgfVxufSlcblxucm91dGVyRXZlbnRzLmZvckVhY2goKGV2ZW50OiBzdHJpbmcpID0+IHtcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5KCgpID0+IHtcbiAgICBSb3V0ZXIuZXZlbnRzLm9uKGV2ZW50LCAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgZXZlbnRGaWVsZCA9IGBvbiR7ZXZlbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHtldmVudC5zdWJzdHJpbmcoXG4gICAgICAgIDFcbiAgICAgICl9YFxuICAgICAgY29uc3QgX3NpbmdsZXRvblJvdXRlciA9IHNpbmdsZXRvblJvdXRlciBhcyBhbnlcbiAgICAgIGlmIChfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSguLi5hcmdzKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGVuIHJ1bm5pbmcgdGhlIFJvdXRlciBldmVudDogJHtldmVudEZpZWxkfWApXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIGdldFJvdXRlcigpOiBSb3V0ZXIge1xuICBpZiAoIXNpbmdsZXRvblJvdXRlci5yb3V0ZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICdObyByb3V0ZXIgaW5zdGFuY2UgZm91bmQuXFxuJyArXG4gICAgICAnWW91IHNob3VsZCBvbmx5IHVzZSBcIm5leHQvcm91dGVyXCIgaW5zaWRlIHRoZSBjbGllbnQgc2lkZSBvZiB5b3VyIGFwcC5cXG4nXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gRXhwb3J0IHRoZSBzaW5nbGV0b25Sb3V0ZXIgYW5kIHRoaXMgaXMgdGhlIHB1YmxpYyBBUEkuXG5leHBvcnQgZGVmYXVsdCBzaW5nbGV0b25Sb3V0ZXIgYXMgU2luZ2xldG9uUm91dGVyXG5cbi8vIFJlZXhwb3J0IHRoZSB3aXRoUm91dGUgSE9DXG5leHBvcnQgeyBkZWZhdWx0IGFzIHdpdGhSb3V0ZXIgfSBmcm9tICcuL3dpdGgtcm91dGVyJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVyKCk6IE5leHRSb3V0ZXIge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChSb3V0ZXJDb250ZXh0KVxufVxuXG4vLyBJTlRFUk5BTCBBUElTXG4vLyAtLS0tLS0tLS0tLS0tXG4vLyAoZG8gbm90IHVzZSBmb2xsb3dpbmcgZXhwb3J0cyBpbnNpZGUgdGhlIGFwcClcblxuLy8gQ3JlYXRlIGEgcm91dGVyIGFuZCBhc3NpZ24gaXQgYXMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZS5cbi8vIFRoaXMgaXMgdXNlZCBpbiBjbGllbnQgc2lkZSB3aGVuIHdlIGFyZSBpbml0aWxpemluZyB0aGUgYXBwLlxuLy8gVGhpcyBzaG91bGQgKipub3QqKiB1c2UgaW5zaWRlIHRoZSBzZXJ2ZXIuXG5leHBvcnQgY29uc3QgY3JlYXRlUm91dGVyID0gKC4uLmFyZ3M6IFJvdXRlckFyZ3MpOiBSb3V0ZXIgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucm91dGVyID0gbmV3IFJvdXRlciguLi5hcmdzKVxuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IGNiKCkpXG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcyA9IFtdXG5cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgYHdpdGhSb3V0ZXJgIHJvdXRlciBpbnN0YW5jZVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXI6IFJvdXRlcik6IE5leHRSb3V0ZXIge1xuICBjb25zdCBfcm91dGVyID0gcm91dGVyIGFzIGFueVxuICBjb25zdCBpbnN0YW5jZSA9IHt9IGFzIGFueVxuXG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdXJsUHJvcGVydHlGaWVsZHMpIHtcbiAgICBpZiAodHlwZW9mIF9yb3V0ZXJbcHJvcGVydHldID09PSAnb2JqZWN0Jykge1xuICAgICAgaW5zdGFuY2VbcHJvcGVydHldID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgQXJyYXkuaXNBcnJheShfcm91dGVyW3Byb3BlcnR5XSkgPyBbXSA6IHt9LFxuICAgICAgICBfcm91dGVyW3Byb3BlcnR5XVxuICAgICAgKSAvLyBtYWtlcyBzdXJlIHF1ZXJ5IGlzIG5vdCBzdGF0ZWZ1bFxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpbnN0YW5jZVtwcm9wZXJ0eV0gPSBfcm91dGVyW3Byb3BlcnR5XVxuICB9XG5cbiAgLy8gRXZlbnRzIGlzIGEgc3RhdGljIHByb3BlcnR5IG9uIHRoZSByb3V0ZXIsIHRoZSByb3V0ZXIgZG9lc24ndCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIHRvIHVzZSBpdFxuICBpbnN0YW5jZS5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgIGluc3RhbmNlW2ZpZWxkXSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgcmV0dXJuIF9yb3V0ZXJbZmllbGRdKC4uLmFyZ3MpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBpbnN0YW5jZVxufVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHtcbiAgcmVxdWVzdElkbGVDYWxsYmFjayxcbiAgY2FuY2VsSWRsZUNhbGxiYWNrLFxufSBmcm9tICcuL3JlcXVlc3QtaWRsZS1jYWxsYmFjaydcblxudHlwZSBVc2VJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQgPSBQaWNrPEludGVyc2VjdGlvbk9ic2VydmVySW5pdCwgJ3Jvb3RNYXJnaW4nPlxudHlwZSBVc2VJbnRlcnNlY3Rpb24gPSB7IGRpc2FibGVkPzogYm9vbGVhbiB9ICYgVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0XG50eXBlIE9ic2VydmVDYWxsYmFjayA9IChpc1Zpc2libGU6IGJvb2xlYW4pID0+IHZvaWRcbnR5cGUgT2JzZXJ2ZXIgPSB7XG4gIGlkOiBzdHJpbmdcbiAgb2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyXG4gIGVsZW1lbnRzOiBNYXA8RWxlbWVudCwgT2JzZXJ2ZUNhbGxiYWNrPlxufVxuXG5jb25zdCBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCdcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbjxUIGV4dGVuZHMgRWxlbWVudD4oe1xuICByb290TWFyZ2luLFxuICBkaXNhYmxlZCxcbn06IFVzZUludGVyc2VjdGlvbik6IFsoZWxlbWVudDogVCB8IG51bGwpID0+IHZvaWQsIGJvb2xlYW5dIHtcbiAgY29uc3QgaXNEaXNhYmxlZDogYm9vbGVhbiA9IGRpc2FibGVkIHx8ICFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlclxuXG4gIGNvbnN0IHVub2JzZXJ2ZSA9IHVzZVJlZjxGdW5jdGlvbj4oKVxuICBjb25zdCBbdmlzaWJsZSwgc2V0VmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSlcblxuICBjb25zdCBzZXRSZWYgPSB1c2VDYWxsYmFjayhcbiAgICAoZWw6IFQgfCBudWxsKSA9PiB7XG4gICAgICBpZiAodW5vYnNlcnZlLmN1cnJlbnQpIHtcbiAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQoKVxuICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBpZiAoaXNEaXNhYmxlZCB8fCB2aXNpYmxlKSByZXR1cm5cblxuICAgICAgaWYgKGVsICYmIGVsLnRhZ05hbWUpIHtcbiAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQgPSBvYnNlcnZlKFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIChpc1Zpc2libGUpID0+IGlzVmlzaWJsZSAmJiBzZXRWaXNpYmxlKGlzVmlzaWJsZSksXG4gICAgICAgICAgeyByb290TWFyZ2luIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0sXG4gICAgW2lzRGlzYWJsZWQsIHJvb3RNYXJnaW4sIHZpc2libGVdXG4gIClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICBjb25zdCBpZGxlQ2FsbGJhY2sgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHNldFZpc2libGUodHJ1ZSkpXG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxJZGxlQ2FsbGJhY2soaWRsZUNhbGxiYWNrKVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3Zpc2libGVdKVxuXG4gIHJldHVybiBbc2V0UmVmLCB2aXNpYmxlXVxufVxuXG5mdW5jdGlvbiBvYnNlcnZlKFxuICBlbGVtZW50OiBFbGVtZW50LFxuICBjYWxsYmFjazogT2JzZXJ2ZUNhbGxiYWNrLFxuICBvcHRpb25zOiBVc2VJbnRlcnNlY3Rpb25PYnNlcnZlckluaXRcbik6ICgpID0+IHZvaWQge1xuICBjb25zdCB7IGlkLCBvYnNlcnZlciwgZWxlbWVudHMgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpXG4gIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjaylcblxuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpXG4gIHJldHVybiBmdW5jdGlvbiB1bm9ic2VydmUoKTogdm9pZCB7XG4gICAgZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpXG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpXG5cbiAgICAvLyBEZXN0cm95IG9ic2VydmVyIHdoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gd2F0Y2g6XG4gICAgaWYgKGVsZW1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZClcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcDxzdHJpbmcsIE9ic2VydmVyPigpXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zOiBVc2VJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQpOiBPYnNlcnZlciB7XG4gIGNvbnN0IGlkID0gb3B0aW9ucy5yb290TWFyZ2luIHx8ICcnXG4gIGxldCBpbnN0YW5jZSA9IG9ic2VydmVycy5nZXQoaWQpXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZVxuICB9XG5cbiAgY29uc3QgZWxlbWVudHMgPSBuZXcgTWFwPEVsZW1lbnQsIE9ic2VydmVDYWxsYmFjaz4oKVxuICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gZWxlbWVudHMuZ2V0KGVudHJ5LnRhcmdldClcbiAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMFxuICAgICAgaWYgKGNhbGxiYWNrICYmIGlzVmlzaWJsZSkge1xuICAgICAgICBjYWxsYmFjayhpc1Zpc2libGUpXG4gICAgICB9XG4gICAgfSlcbiAgfSwgb3B0aW9ucylcblxuICBvYnNlcnZlcnMuc2V0KFxuICAgIGlkLFxuICAgIChpbnN0YW5jZSA9IHtcbiAgICAgIGlkLFxuICAgICAgb2JzZXJ2ZXIsXG4gICAgICBlbGVtZW50cyxcbiAgICB9KVxuICApXG4gIHJldHVybiBpbnN0YW5jZVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgTmV4dENvbXBvbmVudFR5cGUsIE5leHRQYWdlQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi91dGlscydcbmltcG9ydCB7IE5leHRSb3V0ZXIsIHVzZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJ1xuXG5leHBvcnQgdHlwZSBXaXRoUm91dGVyUHJvcHMgPSB7XG4gIHJvdXRlcjogTmV4dFJvdXRlclxufVxuXG5leHBvcnQgdHlwZSBFeGNsdWRlUm91dGVyUHJvcHM8UD4gPSBQaWNrPFxuICBQLFxuICBFeGNsdWRlPGtleW9mIFAsIGtleW9mIFdpdGhSb3V0ZXJQcm9wcz5cbj5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2l0aFJvdXRlcjxcbiAgUCBleHRlbmRzIFdpdGhSb3V0ZXJQcm9wcyxcbiAgQyA9IE5leHRQYWdlQ29udGV4dFxuPihcbiAgQ29tcG9zZWRDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPEMsIGFueSwgUD5cbik6IFJlYWN0LkNvbXBvbmVudFR5cGU8RXhjbHVkZVJvdXRlclByb3BzPFA+PiB7XG4gIGZ1bmN0aW9uIFdpdGhSb3V0ZXJXcmFwcGVyKHByb3BzOiBhbnkpOiBKU1guRWxlbWVudCB7XG4gICAgcmV0dXJuIDxDb21wb3NlZENvbXBvbmVudCByb3V0ZXI9e3VzZVJvdXRlcigpfSB7Li4ucHJvcHN9IC8+XG4gIH1cblxuICBXaXRoUm91dGVyV3JhcHBlci5nZXRJbml0aWFsUHJvcHMgPSBDb21wb3NlZENvbXBvbmVudC5nZXRJbml0aWFsUHJvcHNcbiAgLy8gVGhpcyBpcyBuZWVkZWQgdG8gYWxsb3cgY2hlY2tpbmcgZm9yIGN1c3RvbSBnZXRJbml0aWFsUHJvcHMgaW4gX2FwcFxuICA7KFdpdGhSb3V0ZXJXcmFwcGVyIGFzIGFueSkub3JpZ0dldEluaXRpYWxQcm9wcyA9IChDb21wb3NlZENvbXBvbmVudCBhcyBhbnkpLm9yaWdHZXRJbml0aWFsUHJvcHNcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBuYW1lID1cbiAgICAgIENvbXBvc2VkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvc2VkQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG4gICAgV2l0aFJvdXRlcldyYXBwZXIuZGlzcGxheU5hbWUgPSBgd2l0aFJvdXRlcigke25hbWV9KWBcbiAgfVxuXG4gIHJldHVybiBXaXRoUm91dGVyV3JhcHBlclxufVxuIiwibW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgbj17NzYyOmZ1bmN0aW9uKG4pe24uZXhwb3J0cz1mdW5jdGlvbihuKXt2YXIgdD1bXTt0LnRvU3RyaW5nPWZ1bmN0aW9uIHRvU3RyaW5nKCl7cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHQpe3ZhciByPWNzc1dpdGhNYXBwaW5nVG9TdHJpbmcodCxuKTtpZih0WzJdKXtyZXR1cm5cIkBtZWRpYSBcIi5jb25jYXQodFsyXSxcIiB7XCIpLmNvbmNhdChyLFwifVwiKX1yZXR1cm4gcn0pLmpvaW4oXCJcIil9O3QuaT1mdW5jdGlvbihuLHIsbyl7aWYodHlwZW9mIG49PT1cInN0cmluZ1wiKXtuPVtbbnVsbCxuLFwiXCJdXX12YXIgZT17fTtpZihvKXtmb3IodmFyIGE9MDthPHRoaXMubGVuZ3RoO2ErKyl7dmFyIGM9dGhpc1thXVswXTtpZihjIT1udWxsKXtlW2NdPXRydWV9fX1mb3IodmFyIGk9MDtpPG4ubGVuZ3RoO2krKyl7dmFyIHU9W10uY29uY2F0KG5baV0pO2lmKG8mJmVbdVswXV0pe2NvbnRpbnVlfWlmKHIpe2lmKCF1WzJdKXt1WzJdPXJ9ZWxzZXt1WzJdPVwiXCIuY29uY2F0KHIsXCIgYW5kIFwiKS5jb25jYXQodVsyXSl9fXQucHVzaCh1KX19O3JldHVybiB0fTtmdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKG4sdCl7dmFyIHI9blsxXXx8XCJcIjt2YXIgbz1uWzNdO2lmKCFvKXtyZXR1cm4gcn1pZih0JiZ0eXBlb2YgYnRvYT09PVwiZnVuY3Rpb25cIil7dmFyIGU9dG9Db21tZW50KG8pO3ZhciBhPW8uc291cmNlcy5tYXAoZnVuY3Rpb24obil7cmV0dXJuXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChvLnNvdXJjZVJvb3R8fFwiXCIpLmNvbmNhdChuLFwiICovXCIpfSk7cmV0dXJuW3JdLmNvbmNhdChhKS5jb25jYXQoW2VdKS5qb2luKFwiXFxuXCIpfXJldHVybltyXS5qb2luKFwiXFxuXCIpfWZ1bmN0aW9uIHRvQ29tbWVudChuKXt2YXIgdD1idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShuKSkpKTt2YXIgcj1cInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdCh0KTtyZXR1cm5cIi8qIyBcIi5jb25jYXQocixcIiAqL1wiKX19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe2lmKHRbcl0pe3JldHVybiB0W3JdLmV4cG9ydHN9dmFyIG89dFtyXT17ZXhwb3J0czp7fX07dmFyIGU9dHJ1ZTt0cnl7bltyXShvLG8uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtlPWZhbHNlfWZpbmFsbHl7aWYoZSlkZWxldGUgdFtyXX1yZXR1cm4gby5leHBvcnRzfV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3JldHVybiBfX25jY3dwY2tfcmVxdWlyZV9fKDc2Mil9KCk7IiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLmxheW91dF9jb250YWluZXJfXzJ0NHYyIHtcXHJcXG4gICAgbWF4LXdpZHRoOiAzNnJlbTtcXHJcXG4gICAgcGFkZGluZzogMCAxcmVtO1xcclxcbiAgICBtYXJnaW46IDNyZW0gYXV0byA2cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4ubGF5b3V0X2hlYWRlcl9fMnJoV3Ege1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4ubGF5b3V0X2JhY2tUb2hvbWVfXzEwb3lsIHtcXHJcXG4gICAgbWFyZ2luOiAzcmVtIDAgMDtcXHJcXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL2NvbXBvbmVudHMvbGF5b3V0Lm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxnQkFBZ0I7SUFDaEIsZUFBZTtJQUNmLHNCQUFzQjtBQUMxQjs7QUFFQTtJQUNJLGFBQWE7SUFDYixzQkFBc0I7SUFDdEIsbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksZ0JBQWdCO0FBQ3BCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5jb250YWluZXIge1xcclxcbiAgICBtYXgtd2lkdGg6IDM2cmVtO1xcclxcbiAgICBwYWRkaW5nOiAwIDFyZW07XFxyXFxuICAgIG1hcmdpbjogM3JlbSBhdXRvIDZyZW07XFxyXFxufVxcclxcblxcclxcbi5oZWFkZXIge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uYmFja1RvaG9tZSB7XFxyXFxuICAgIG1hcmdpbjogM3JlbSAwIDA7XFxyXFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcImNvbnRhaW5lclwiOiBcImxheW91dF9jb250YWluZXJfXzJ0NHYyXCIsXG5cdFwiaGVhZGVyXCI6IFwibGF5b3V0X2hlYWRlcl9fMnJoV3FcIixcblx0XCJiYWNrVG9ob21lXCI6IFwibGF5b3V0X2JhY2tUb2hvbWVfXzEwb3lsXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLnV0aWxzX2hlYWRpbmcyWGxfXzFJNjVtIHtcXHJcXG4gICAgZm9udC1zaXplOiAyLjVyZW07XFxyXFxuICAgIGxpbmUtaGVpZ2h0OiAxLjI7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiA4MDA7XFxyXFxuICAgIGxldHRlci1zcGFjaW5nOiAtMC4wNXJlbTtcXHJcXG4gICAgbWFyZ2luOiAxcmVtIDA7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC51dGlsc19oZWFkaW5nWGxfXzFYZWNOIHtcXHJcXG4gICAgZm9udC1zaXplOiAycmVtO1xcclxcbiAgICBsaW5lLWhlaWdodDogMS4zO1xcclxcbiAgICBmb250LXdlaWdodDogODAwO1xcclxcbiAgICBsZXR0ZXItc3BhY2luZzogLTAuMDVyZW07XFxyXFxuICAgIG1hcmdpbjogMXJlbSAwO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAudXRpbHNfaGVhZGluZ0xnX19kZTdwMCB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMS41cmVtO1xcclxcbiAgICBsaW5lLWhlaWdodDogMS40O1xcclxcbiAgICBtYXJnaW46IDFyZW0gMDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLnV0aWxzX2hlYWRpbmdNZF9fM2RlNkcge1xcclxcbiAgICBmb250LXNpemU6IDEuMnJlbTtcXHJcXG4gICAgbGluZS1oZWlnaHQ6IDEuNTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLnV0aWxzX2JvcmRlckNpcmNsZV9fMTNxZEoge1xcclxcbiAgICBib3JkZXItcmFkaXVzOiA5OTk5cHg7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC51dGlsc19jb2xvckluaGVyaXRfXzNHdWRmIHtcXHJcXG4gICAgY29sb3I6IGluaGVyaXQ7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC51dGlsc19wYWRkaW5nMXB4X19vQ255OCB7XFxyXFxuICAgIHBhZGRpbmctdG9wOiAxcHg7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC51dGlsc19saXN0X19TN19wZSB7XFxyXFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XFxyXFxuICAgIHBhZGRpbmc6IDA7XFxyXFxuICAgIG1hcmdpbjogMDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLnV0aWxzX2xpc3RJdGVtX18yZUpwSiB7XFxyXFxuICAgIG1hcmdpbjogMCAwIDEuMjVyZW07XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC51dGlsc19saWdodFRleHRfXzEyQ2ttIHtcXHJcXG4gICAgY29sb3I6ICM2NjY7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAudXRpbHNfY2FudmFzX18xU1dMaSB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgdG9wOiAxMDBweDtcXHJcXG4gICAgei1pbmRleDogMTA7XFxyXFxuICAgIG1hcmdpbjogM3JlbSBhdXRvIDZyZW07XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcclxcbiAgfVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zdHlsZXMvdXRpbHMubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLGlCQUFpQjtJQUNqQixnQkFBZ0I7SUFDaEIsZ0JBQWdCO0lBQ2hCLHdCQUF3QjtJQUN4QixjQUFjO0VBQ2hCOztFQUVBO0lBQ0UsZUFBZTtJQUNmLGdCQUFnQjtJQUNoQixnQkFBZ0I7SUFDaEIsd0JBQXdCO0lBQ3hCLGNBQWM7RUFDaEI7O0VBRUE7SUFDRSxpQkFBaUI7SUFDakIsZ0JBQWdCO0lBQ2hCLGNBQWM7RUFDaEI7O0VBRUE7SUFDRSxpQkFBaUI7SUFDakIsZ0JBQWdCO0VBQ2xCOztFQUVBO0lBQ0UscUJBQXFCO0VBQ3ZCOztFQUVBO0lBQ0UsY0FBYztFQUNoQjs7RUFFQTtJQUNFLGdCQUFnQjtFQUNsQjs7RUFFQTtJQUNFLGdCQUFnQjtJQUNoQixVQUFVO0lBQ1YsU0FBUztFQUNYOztFQUVBO0lBQ0UsbUJBQW1CO0VBQ3JCOztFQUVBO0lBQ0UsV0FBVztFQUNiOztFQUVBO0lBQ0Usa0JBQWtCO0lBQ2xCLFVBQVU7SUFDVixXQUFXO0lBQ1gsc0JBQXNCO0lBQ3RCLHVCQUF1QjtFQUN6QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuaGVhZGluZzJYbCB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMi41cmVtO1xcclxcbiAgICBsaW5lLWhlaWdodDogMS4yO1xcclxcbiAgICBmb250LXdlaWdodDogODAwO1xcclxcbiAgICBsZXR0ZXItc3BhY2luZzogLTAuMDVyZW07XFxyXFxuICAgIG1hcmdpbjogMXJlbSAwO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAuaGVhZGluZ1hsIHtcXHJcXG4gICAgZm9udC1zaXplOiAycmVtO1xcclxcbiAgICBsaW5lLWhlaWdodDogMS4zO1xcclxcbiAgICBmb250LXdlaWdodDogODAwO1xcclxcbiAgICBsZXR0ZXItc3BhY2luZzogLTAuMDVyZW07XFxyXFxuICAgIG1hcmdpbjogMXJlbSAwO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAuaGVhZGluZ0xnIHtcXHJcXG4gICAgZm9udC1zaXplOiAxLjVyZW07XFxyXFxuICAgIGxpbmUtaGVpZ2h0OiAxLjQ7XFxyXFxuICAgIG1hcmdpbjogMXJlbSAwO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAuaGVhZGluZ01kIHtcXHJcXG4gICAgZm9udC1zaXplOiAxLjJyZW07XFxyXFxuICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5ib3JkZXJDaXJjbGUge1xcclxcbiAgICBib3JkZXItcmFkaXVzOiA5OTk5cHg7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5jb2xvckluaGVyaXQge1xcclxcbiAgICBjb2xvcjogaW5oZXJpdDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLnBhZGRpbmcxcHgge1xcclxcbiAgICBwYWRkaW5nLXRvcDogMXB4O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAubGlzdCB7XFxyXFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XFxyXFxuICAgIHBhZGRpbmc6IDA7XFxyXFxuICAgIG1hcmdpbjogMDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmxpc3RJdGVtIHtcXHJcXG4gICAgbWFyZ2luOiAwIDAgMS4yNXJlbTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmxpZ2h0VGV4dCB7XFxyXFxuICAgIGNvbG9yOiAjNjY2O1xcclxcbiAgfVxcclxcblxcclxcbiAgLmNhbnZhcyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgdG9wOiAxMDBweDtcXHJcXG4gICAgei1pbmRleDogMTA7XFxyXFxuICAgIG1hcmdpbjogM3JlbSBhdXRvIDZyZW07XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcclxcbiAgfVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcImhlYWRpbmcyWGxcIjogXCJ1dGlsc19oZWFkaW5nMlhsX18xSTY1bVwiLFxuXHRcImhlYWRpbmdYbFwiOiBcInV0aWxzX2hlYWRpbmdYbF9fMVhlY05cIixcblx0XCJoZWFkaW5nTGdcIjogXCJ1dGlsc19oZWFkaW5nTGdfX2RlN3AwXCIsXG5cdFwiaGVhZGluZ01kXCI6IFwidXRpbHNfaGVhZGluZ01kX18zZGU2R1wiLFxuXHRcImJvcmRlckNpcmNsZVwiOiBcInV0aWxzX2JvcmRlckNpcmNsZV9fMTNxZEpcIixcblx0XCJjb2xvckluaGVyaXRcIjogXCJ1dGlsc19jb2xvckluaGVyaXRfXzNHdWRmXCIsXG5cdFwicGFkZGluZzFweFwiOiBcInV0aWxzX3BhZGRpbmcxcHhfX29Dbnk4XCIsXG5cdFwibGlzdFwiOiBcInV0aWxzX2xpc3RfX1M3X3BlXCIsXG5cdFwibGlzdEl0ZW1cIjogXCJ1dGlsc19saXN0SXRlbV9fMmVKcEpcIixcblx0XCJsaWdodFRleHRcIjogXCJ1dGlsc19saWdodFRleHRfXzEyQ2ttXCIsXG5cdFwiY2FudmFzXCI6IFwidXRpbHNfY2FudmFzX18xU1dMaVwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIm1vZHVsZS5leHBvcnRzID1cbi8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDE0OTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxudmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0dmFyIHRocmV3ID0gdHJ1ZTtcbi8qKioqKiovIFx0XHR0cnkge1xuLyoqKioqKi8gXHRcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX19uY2N3cGNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFx0XHR0aHJldyA9IGZhbHNlO1xuLyoqKioqKi8gXHRcdH0gZmluYWxseSB7XG4vKioqKioqLyBcdFx0XHRpZih0aHJldykgZGVsZXRlIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9jb21wYXQgKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdF9fbmNjd3Bja19yZXF1aXJlX18uYWIgPSBfX2Rpcm5hbWUgKyBcIi9cIjsvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBtb2R1bGUgZXhwb3J0cyBtdXN0IGJlIHJldHVybmVkIGZyb20gcnVudGltZSBzbyBlbnRyeSBpbmxpbmluZyBpcyBkaXNhYmxlZFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX19uY2N3cGNrX3JlcXVpcmVfXygxNDkpO1xuLyoqKioqKi8gfSkoKVxuOyIsIm1vZHVsZS5leHBvcnRzID1cbi8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDkzMTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbE1vZHVsZSkge1xuXHRpZiAoIW9yaWdpbmFsTW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdHZhciBtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsTW9kdWxlKTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJleHBvcnRzXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdHZhciB0aHJldyA9IHRydWU7XG4vKioqKioqLyBcdFx0dHJ5IHtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fbmNjd3Bja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcdFx0dGhyZXcgPSBmYWxzZTtcbi8qKioqKiovIFx0XHR9IGZpbmFsbHkge1xuLyoqKioqKi8gXHRcdFx0aWYodGhyZXcpIGRlbGV0ZSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0ICovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRfX25jY3dwY2tfcmVxdWlyZV9fLmFiID0gX19kaXJuYW1lICsgXCIvXCI7LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gbW9kdWxlIGV4cG9ydHMgbXVzdCBiZSByZXR1cm5lZCBmcm9tIHJ1bnRpbWUgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fbmNjd3Bja19yZXF1aXJlX18oOTMxKTtcbi8qKioqKiovIH0pKClcbjsiLCJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24oKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA4ODA6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdHZhciB0aHJldyA9IHRydWU7XG4vKioqKioqLyBcdFx0dHJ5IHtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fbmNjd3Bja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcdFx0dGhyZXcgPSBmYWxzZTtcbi8qKioqKiovIFx0XHR9IGZpbmFsbHkge1xuLyoqKioqKi8gXHRcdFx0aWYodGhyZXcpIGRlbGV0ZSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0ICovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRfX25jY3dwY2tfcmVxdWlyZV9fLmFiID0gX19kaXJuYW1lICsgXCIvXCI7LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gbW9kdWxlIGV4cG9ydHMgbXVzdCBiZSByZXR1cm5lZCBmcm9tIHJ1bnRpbWUgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fbmNjd3Bja19yZXF1aXJlX18oODgwKTtcbi8qKioqKiovIH0pKClcbjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBjb25zdCBBbXBTdGF0ZUNvbnRleHQ6IFJlYWN0LkNvbnRleHQ8YW55PiA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEFtcFN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdBbXBTdGF0ZUNvbnRleHQnXG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBBbXBTdGF0ZUNvbnRleHQgfSBmcm9tICcuL2FtcC1jb250ZXh0J1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJbkFtcE1vZGUoe1xuICBhbXBGaXJzdCA9IGZhbHNlLFxuICBoeWJyaWQgPSBmYWxzZSxcbiAgaGFzUXVlcnkgPSBmYWxzZSxcbn0gPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gYW1wRmlyc3QgfHwgKGh5YnJpZCAmJiBoYXNRdWVyeSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFtcCgpOiBib29sZWFuIHtcbiAgLy8gRG9uJ3QgYXNzaWduIHRoZSBjb250ZXh0IHZhbHVlIHRvIGEgdmFyaWFibGUgdG8gc2F2ZSBieXRlc1xuICByZXR1cm4gaXNJbkFtcE1vZGUoUmVhY3QudXNlQ29udGV4dChBbXBTdGF0ZUNvbnRleHQpKVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgSGVhZE1hbmFnZXJDb250ZXh0OiBSZWFjdC5Db250ZXh0PHtcbiAgdXBkYXRlSGVhZD86IChzdGF0ZTogYW55KSA9PiB2b2lkXG4gIG1vdW50ZWRJbnN0YW5jZXM/OiBhbnlcbiAgdXBkYXRlU2NyaXB0cz86IChzdGF0ZTogYW55KSA9PiB2b2lkXG4gIHNjcmlwdHM/OiBhbnlcbn0+ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgSGVhZE1hbmFnZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0hlYWRNYW5hZ2VyQ29udGV4dCdcbn1cbiIsImltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgRWZmZWN0IGZyb20gJy4vc2lkZS1lZmZlY3QnXG5pbXBvcnQgeyBBbXBTdGF0ZUNvbnRleHQgfSBmcm9tICcuL2FtcC1jb250ZXh0J1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi9oZWFkLW1hbmFnZXItY29udGV4dCdcbmltcG9ydCB7IGlzSW5BbXBNb2RlIH0gZnJvbSAnLi9hbXAnXG5cbnR5cGUgV2l0aEluQW1wTW9kZSA9IHtcbiAgaW5BbXBNb2RlPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEhlYWQoaW5BbXBNb2RlID0gZmFsc2UpOiBKU1guRWxlbWVudFtdIHtcbiAgY29uc3QgaGVhZCA9IFs8bWV0YSBjaGFyU2V0PVwidXRmLThcIiAvPl1cbiAgaWYgKCFpbkFtcE1vZGUpIHtcbiAgICBoZWFkLnB1c2goPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aFwiIC8+KVxuICB9XG4gIHJldHVybiBoZWFkXG59XG5cbmZ1bmN0aW9uIG9ubHlSZWFjdEVsZW1lbnQoXG4gIGxpc3Q6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgY2hpbGQ6IFJlYWN0LlJlYWN0Q2hpbGRcbik6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PiB7XG4gIC8vIFJlYWN0IGNoaWxkcmVuIGNhbiBiZSBcInN0cmluZ1wiIG9yIFwibnVtYmVyXCIgaW4gdGhpcyBjYXNlIHdlIGlnbm9yZSB0aGVtIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbGlzdFxuICB9XG4gIC8vIEFkZHMgc3VwcG9ydCBmb3IgUmVhY3QuRnJhZ21lbnRcbiAgaWYgKGNoaWxkLnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KFxuICAgICAgUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZC5wcm9wcy5jaGlsZHJlbikucmVkdWNlKFxuICAgICAgICAoXG4gICAgICAgICAgZnJhZ21lbnRMaXN0OiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gICAgICAgICAgZnJhZ21lbnRDaGlsZDogUmVhY3QuUmVhY3RDaGlsZFxuICAgICAgICApOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4gPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnbWVudENoaWxkID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdudW1iZXInXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3QuY29uY2F0KGZyYWdtZW50Q2hpbGQpXG4gICAgICAgIH0sXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgKVxuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChjaGlsZClcbn1cblxuY29uc3QgTUVUQVRZUEVTID0gWyduYW1lJywgJ2h0dHBFcXVpdicsICdjaGFyU2V0JywgJ2l0ZW1Qcm9wJ11cblxuLypcbiByZXR1cm5zIGEgZnVuY3Rpb24gZm9yIGZpbHRlcmluZyBoZWFkIGNoaWxkIGVsZW1lbnRzXG4gd2hpY2ggc2hvdWxkbid0IGJlIGR1cGxpY2F0ZWQsIGxpa2UgPHRpdGxlLz5cbiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgZGVkdXBsaWNhdGVkIGBrZXlgIHByb3BlcnRpZXNcbiovXG5mdW5jdGlvbiB1bmlxdWUoKSB7XG4gIGNvbnN0IGtleXMgPSBuZXcgU2V0KClcbiAgY29uc3QgdGFncyA9IG5ldyBTZXQoKVxuICBjb25zdCBtZXRhVHlwZXMgPSBuZXcgU2V0KClcbiAgY29uc3QgbWV0YUNhdGVnb3JpZXM6IHsgW21ldGF0eXBlOiBzdHJpbmddOiBTZXQ8c3RyaW5nPiB9ID0ge31cblxuICByZXR1cm4gKGg6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+KSA9PiB7XG4gICAgbGV0IGlzVW5pcXVlID0gdHJ1ZVxuICAgIGxldCBoYXNLZXkgPSBmYWxzZVxuXG4gICAgaWYgKGgua2V5ICYmIHR5cGVvZiBoLmtleSAhPT0gJ251bWJlcicgJiYgaC5rZXkuaW5kZXhPZignJCcpID4gMCkge1xuICAgICAgaGFzS2V5ID0gdHJ1ZVxuICAgICAgY29uc3Qga2V5ID0gaC5rZXkuc2xpY2UoaC5rZXkuaW5kZXhPZignJCcpICsgMSlcbiAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgc3dpdGNoIChoLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIGNhc2UgJ2Jhc2UnOlxuICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWdzLmFkZChoLnR5cGUpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gTUVUQVRZUEVTLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbWV0YXR5cGUgPSBNRVRBVFlQRVNbaV1cbiAgICAgICAgICBpZiAoIWgucHJvcHMuaGFzT3duUHJvcGVydHkobWV0YXR5cGUpKSBjb250aW51ZVxuXG4gICAgICAgICAgaWYgKG1ldGF0eXBlID09PSAnY2hhclNldCcpIHtcbiAgICAgICAgICAgIGlmIChtZXRhVHlwZXMuaGFzKG1ldGF0eXBlKSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtZXRhVHlwZXMuYWRkKG1ldGF0eXBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGgucHJvcHNbbWV0YXR5cGVdXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdIHx8IG5ldyBTZXQoKVxuICAgICAgICAgICAgaWYgKChtZXRhdHlwZSAhPT0gJ25hbWUnIHx8ICFoYXNLZXkpICYmIGNhdGVnb3JpZXMuaGFzKGNhdGVnb3J5KSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXRlZ29yaWVzLmFkZChjYXRlZ29yeSlcbiAgICAgICAgICAgICAgbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdID0gY2F0ZWdvcmllc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHJldHVybiBpc1VuaXF1ZVxuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBoZWFkRWxlbWVudHMgTGlzdCBvZiBtdWx0aXBsZSA8SGVhZD4gaW5zdGFuY2VzXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZUNvbXBvbmVudHMoXG4gIGhlYWRFbGVtZW50czogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBwcm9wczogV2l0aEluQW1wTW9kZVxuKSB7XG4gIHJldHVybiBoZWFkRWxlbWVudHNcbiAgICAucmVkdWNlKFxuICAgICAgKGxpc3Q6IFJlYWN0LlJlYWN0Q2hpbGRbXSwgaGVhZEVsZW1lbnQ6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+KSA9PiB7XG4gICAgICAgIGNvbnN0IGhlYWRFbGVtZW50Q2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KFxuICAgICAgICAgIGhlYWRFbGVtZW50LnByb3BzLmNoaWxkcmVuXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGxpc3QuY29uY2F0KGhlYWRFbGVtZW50Q2hpbGRyZW4pXG4gICAgICB9LFxuICAgICAgW11cbiAgICApXG4gICAgLnJlZHVjZShvbmx5UmVhY3RFbGVtZW50LCBbXSlcbiAgICAucmV2ZXJzZSgpXG4gICAgLmNvbmNhdChkZWZhdWx0SGVhZChwcm9wcy5pbkFtcE1vZGUpKVxuICAgIC5maWx0ZXIodW5pcXVlKCkpXG4gICAgLnJldmVyc2UoKVxuICAgIC5tYXAoKGM6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+LCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGMua2V5IHx8IGlcbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVpFX0ZPTlRTICYmXG4gICAgICAgICFwcm9wcy5pbkFtcE1vZGVcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYy50eXBlID09PSAnbGluaycgJiZcbiAgICAgICAgICBjLnByb3BzWydocmVmJ10gJiZcbiAgICAgICAgICAvLyBUT0RPKHByYXRlZWtiaEApOiBSZXBsYWNlIHRoaXMgd2l0aCBjb25zdCBmcm9tIGBjb25zdGFudHNgIHdoZW4gdGhlIHRyZWUgc2hha2luZyB3b3Jrcy5cbiAgICAgICAgICBbJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzJ10uc29tZSgodXJsKSA9PlxuICAgICAgICAgICAgYy5wcm9wc1snaHJlZiddLnN0YXJ0c1dpdGgodXJsKVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7IC4uLihjLnByb3BzIHx8IHt9KSB9XG4gICAgICAgICAgbmV3UHJvcHNbJ2RhdGEtaHJlZiddID0gbmV3UHJvcHNbJ2hyZWYnXVxuICAgICAgICAgIG5ld1Byb3BzWydocmVmJ10gPSB1bmRlZmluZWRcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIG5ld1Byb3BzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIHsga2V5IH0pXG4gICAgfSlcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBpbmplY3RzIGVsZW1lbnRzIHRvIGA8aGVhZD5gIG9mIHlvdXIgcGFnZS5cbiAqIFRvIGF2b2lkIGR1cGxpY2F0ZWQgYHRhZ3NgIGluIGA8aGVhZD5gIHlvdSBjYW4gdXNlIHRoZSBga2V5YCBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBtYWtlIHN1cmUgZXZlcnkgdGFnIGlzIG9ubHkgcmVuZGVyZWQgb25jZS5cbiAqL1xuZnVuY3Rpb24gSGVhZCh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IGFtcFN0YXRlID0gdXNlQ29udGV4dChBbXBTdGF0ZUNvbnRleHQpXG4gIGNvbnN0IGhlYWRNYW5hZ2VyID0gdXNlQ29udGV4dChIZWFkTWFuYWdlckNvbnRleHQpXG4gIHJldHVybiAoXG4gICAgPEVmZmVjdFxuICAgICAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU9e3JlZHVjZUNvbXBvbmVudHN9XG4gICAgICBoZWFkTWFuYWdlcj17aGVhZE1hbmFnZXJ9XG4gICAgICBpbkFtcE1vZGU9e2lzSW5BbXBNb2RlKGFtcFN0YXRlKX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9FZmZlY3Q+XG4gIClcbn1cblxuLy8gVE9ETzogUmVtb3ZlIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2VcbkhlYWQucmV3aW5kID0gKCkgPT4ge31cblxuZXhwb3J0IGRlZmF1bHQgSGVhZFxuIiwiZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gIHBhdGhuYW1lOiBzdHJpbmcsXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuKToge1xuICBkZXRlY3RlZExvY2FsZT86IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG59IHtcbiAgbGV0IGRldGVjdGVkTG9jYWxlOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgLy8gZmlyc3QgaXRlbSB3aWxsIGJlIGVtcHR5IHN0cmluZyBmcm9tIHNwbGl0dGluZyBhdCBmaXJzdCBjaGFyXG4gIGNvbnN0IHBhdGhuYW1lUGFydHMgPSBwYXRobmFtZS5zcGxpdCgnLycpXG5cbiAgOyhsb2NhbGVzIHx8IFtdKS5zb21lKChsb2NhbGUpID0+IHtcbiAgICBpZiAocGF0aG5hbWVQYXJ0c1sxXS50b0xvd2VyQ2FzZSgpID09PSBsb2NhbGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgZGV0ZWN0ZWRMb2NhbGUgPSBsb2NhbGVcbiAgICAgIHBhdGhuYW1lUGFydHMuc3BsaWNlKDEsIDEpXG4gICAgICBwYXRobmFtZSA9IHBhdGhuYW1lUGFydHMuam9pbignLycpIHx8ICcvJ1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBkZXRlY3RlZExvY2FsZSxcbiAgfVxufVxuIiwiLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgSmFzb24gTWlsbGVyIChodHRwczovL2phc29uZm9ybWF0LmNvbS8pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbi8vIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L21pdHQvYmxvYi92MS4xLjMvc3JjL2luZGV4LmpzXG4vLyBJdCdzIGJlZW4gZWRpdGVkIGZvciB0aGUgbmVlZHMgb2YgdGhpcyBzY3JpcHRcbi8vIFNlZSB0aGUgTElDRU5TRSBhdCB0aGUgdG9wIG9mIHRoZSBmaWxlXG5cbnR5cGUgSGFuZGxlciA9ICguLi5ldnRzOiBhbnlbXSkgPT4gdm9pZFxuXG5leHBvcnQgdHlwZSBNaXR0RW1pdHRlciA9IHtcbiAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBvZmYodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBlbWl0KHR5cGU6IHN0cmluZywgLi4uZXZ0czogYW55W10pOiB2b2lkXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pdHQoKTogTWl0dEVtaXR0ZXIge1xuICBjb25zdCBhbGw6IHsgW3M6IHN0cmluZ106IEhhbmRsZXJbXSB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIHJldHVybiB7XG4gICAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKSB7XG4gICAgICA7KGFsbFt0eXBlXSB8fCAoYWxsW3R5cGVdID0gW10pKS5wdXNoKGhhbmRsZXIpXG4gICAgfSxcblxuICAgIG9mZih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpIHtcbiAgICAgIGlmIChhbGxbdHlwZV0pIHtcbiAgICAgICAgYWxsW3R5cGVdLnNwbGljZShhbGxbdHlwZV0uaW5kZXhPZihoYW5kbGVyKSA+Pj4gMCwgMSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW1pdCh0eXBlOiBzdHJpbmcsIC4uLmV2dHM6IGFueVtdKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICA7KGFsbFt0eXBlXSB8fCBbXSkuc2xpY2UoKS5tYXAoKGhhbmRsZXI6IEhhbmRsZXIpID0+IHtcbiAgICAgICAgaGFuZGxlciguLi5ldnRzKVxuICAgICAgfSlcbiAgICB9LFxuICB9XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuXG5leHBvcnQgY29uc3QgUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TmV4dFJvdXRlcj4obnVsbCBhcyBhbnkpXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnUm91dGVyQ29udGV4dCdcbn1cbiIsIi8qIGdsb2JhbCBfX05FWFRfREFUQV9fICovXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHtcbiAgbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gsXG4gIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoLFxufSBmcm9tICcuLi8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoJ1xuaW1wb3J0IHsgR29vZFBhZ2VDYWNoZSwgU3R5bGVTaGVldFR1cGxlIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3BhZ2UtbG9hZGVyJ1xuaW1wb3J0IHtcbiAgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCxcbiAgaXNBc3NldEVycm9yLFxuICBtYXJrQXNzZXRFcnJvcixcbn0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlcidcbmltcG9ydCB7IERvbWFpbkxvY2FsZXMgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvY29uZmlnJ1xuaW1wb3J0IHsgZGVub3JtYWxpemVQYWdlUGF0aCB9IGZyb20gJy4uLy4uL3NlcnZlci9kZW5vcm1hbGl6ZS1wYWdlLXBhdGgnXG5pbXBvcnQgeyBub3JtYWxpemVMb2NhbGVQYXRoIH0gZnJvbSAnLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnXG5pbXBvcnQgbWl0dCwgeyBNaXR0RW1pdHRlciB9IGZyb20gJy4uL21pdHQnXG5pbXBvcnQge1xuICBBcHBDb250ZXh0VHlwZSxcbiAgZm9ybWF0V2l0aFZhbGlkYXRpb24sXG4gIGdldExvY2F0aW9uT3JpZ2luLFxuICBnZXRVUkwsXG4gIGxvYWRHZXRJbml0aWFsUHJvcHMsXG4gIE5leHRQYWdlQ29udGV4dCxcbiAgU1QsXG4gIE5FWFRfREFUQSxcbn0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQgeyBpc0R5bmFtaWNSb3V0ZSB9IGZyb20gJy4vdXRpbHMvaXMtZHluYW1pYydcbmltcG9ydCB7IHBhcnNlUmVsYXRpdmVVcmwgfSBmcm9tICcuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybCdcbmltcG9ydCB7IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgfSBmcm9tICcuL3V0aWxzL3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHJlc29sdmVSZXdyaXRlcyBmcm9tICcuL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXMnXG5pbXBvcnQgeyBnZXRSb3V0ZU1hdGNoZXIgfSBmcm9tICcuL3V0aWxzL3JvdXRlLW1hdGNoZXInXG5pbXBvcnQgeyBnZXRSb3V0ZVJlZ2V4IH0gZnJvbSAnLi91dGlscy9yb3V0ZS1yZWdleCdcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICAvKiBwcm9kICovXG4gICAgX19ORVhUX0RBVEFfXzogTkVYVF9EQVRBXG4gIH1cbn1cblxuaW50ZXJmYWNlIFJvdXRlUHJvcGVydGllcyB7XG4gIHNoYWxsb3c6IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIFRyYW5zaXRpb25PcHRpb25zIHtcbiAgc2hhbGxvdz86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2VcbiAgc2Nyb2xsPzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgTmV4dEhpc3RvcnlTdGF0ZSB7XG4gIHVybDogc3RyaW5nXG4gIGFzOiBzdHJpbmdcbiAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnNcbn1cblxudHlwZSBIaXN0b3J5U3RhdGUgPVxuICB8IG51bGxcbiAgfCB7IF9fTjogZmFsc2UgfVxuICB8ICh7IF9fTjogdHJ1ZTsgaWR4OiBudW1iZXIgfSAmIE5leHRIaXN0b3J5U3RhdGUpXG5cbmxldCBkZXRlY3REb21haW5Mb2NhbGU6IHR5cGVvZiBpbXBvcnQoJy4uL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKS5kZXRlY3REb21haW5Mb2NhbGVcblxuaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZSgnLi4vaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZScpXG4gICAgLmRldGVjdERvbWFpbkxvY2FsZVxufVxuXG5jb25zdCBiYXNlUGF0aCA9IChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIGFzIHN0cmluZykgfHwgJydcblxuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdSb3V0ZSBDYW5jZWxsZWQnKSwge1xuICAgIGNhbmNlbGxlZDogdHJ1ZSxcbiAgfSlcbn1cblxuZnVuY3Rpb24gYWRkUGF0aFByZWZpeChwYXRoOiBzdHJpbmcsIHByZWZpeD86IHN0cmluZykge1xuICByZXR1cm4gcHJlZml4ICYmIHBhdGguc3RhcnRzV2l0aCgnLycpXG4gICAgPyBwYXRoID09PSAnLydcbiAgICAgID8gbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gocHJlZml4KVxuICAgICAgOiBgJHtwcmVmaXh9JHtwYXRoTm9RdWVyeUhhc2gocGF0aCkgPT09ICcvJyA/IHBhdGguc3Vic3RyaW5nKDEpIDogcGF0aH1gXG4gICAgOiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREb21haW5Mb2NhbGUoXG4gIHBhdGg6IHN0cmluZyxcbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2UsXG4gIGxvY2FsZXM/OiBzdHJpbmdbXSxcbiAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbikge1xuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgIGxvY2FsZSA9IGxvY2FsZSB8fCBub3JtYWxpemVMb2NhbGVQYXRoKHBhdGgsIGxvY2FsZXMpLmRldGVjdGVkTG9jYWxlXG5cbiAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIGxvY2FsZSlcblxuICAgIGlmIChkZXRlY3RlZERvbWFpbikge1xuICAgICAgcmV0dXJuIGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtkZXRlY3RlZERvbWFpbi5kb21haW59JHtcbiAgICAgICAgYmFzZVBhdGggfHwgJydcbiAgICAgIH0ke2xvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZSA/ICcnIDogYC8ke2xvY2FsZX1gfSR7cGF0aH1gXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRMb2NhbGUoXG4gIHBhdGg6IHN0cmluZyxcbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2UsXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbikge1xuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgIHJldHVybiBsb2NhbGUgJiZcbiAgICAgIGxvY2FsZSAhPT0gZGVmYXVsdExvY2FsZSAmJlxuICAgICAgIXBhdGguc3RhcnRzV2l0aCgnLycgKyBsb2NhbGUgKyAnLycpICYmXG4gICAgICBwYXRoICE9PSAnLycgKyBsb2NhbGVcbiAgICAgID8gYWRkUGF0aFByZWZpeChwYXRoLCAnLycgKyBsb2NhbGUpXG4gICAgICA6IHBhdGhcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsTG9jYWxlKHBhdGg6IHN0cmluZywgbG9jYWxlPzogc3RyaW5nKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgcmV0dXJuIGxvY2FsZSAmJlxuICAgICAgKHBhdGguc3RhcnRzV2l0aCgnLycgKyBsb2NhbGUgKyAnLycpIHx8IHBhdGggPT09ICcvJyArIGxvY2FsZSlcbiAgICAgID8gcGF0aC5zdWJzdHIobG9jYWxlLmxlbmd0aCArIDEpIHx8ICcvJ1xuICAgICAgOiBwYXRoXG4gIH1cbiAgcmV0dXJuIHBhdGhcbn1cblxuZnVuY3Rpb24gcGF0aE5vUXVlcnlIYXNoKHBhdGg6IHN0cmluZykge1xuICBjb25zdCBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKCc/JylcbiAgY29uc3QgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJylcblxuICBpZiAocXVlcnlJbmRleCA+IC0xIHx8IGhhc2hJbmRleCA+IC0xKSB7XG4gICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHF1ZXJ5SW5kZXggPiAtMSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXgpXG4gIH1cbiAgcmV0dXJuIHBhdGhcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0Jhc2VQYXRoKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBwYXRoID0gcGF0aE5vUXVlcnlIYXNoKHBhdGgpXG4gIHJldHVybiBwYXRoID09PSBiYXNlUGF0aCB8fCBwYXRoLnN0YXJ0c1dpdGgoYmFzZVBhdGggKyAnLycpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRCYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyB3ZSBvbmx5IGFkZCB0aGUgYmFzZXBhdGggb24gcmVsYXRpdmUgdXJsc1xuICByZXR1cm4gYWRkUGF0aFByZWZpeChwYXRoLCBiYXNlUGF0aClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbEJhc2VQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHBhdGggPSBwYXRoLnNsaWNlKGJhc2VQYXRoLmxlbmd0aClcbiAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSkgcGF0aCA9IGAvJHtwYXRofWBcbiAgcmV0dXJuIHBhdGhcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHdoZXRoZXIgYSBnaXZlbiB1cmwgaXMgcm91dGFibGUgYnkgdGhlIE5leHQuanMgcm91dGVyIChicm93c2VyIG9ubHkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMb2NhbFVSTCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAvLyBwcmV2ZW50IGEgaHlkcmF0aW9uIG1pc21hdGNoIG9uIGhyZWYgZm9yIHVybCB3aXRoIGFuY2hvciByZWZzXG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnLycpIHx8IHVybC5zdGFydHNXaXRoKCcjJykpIHJldHVybiB0cnVlXG4gIHRyeSB7XG4gICAgLy8gYWJzb2x1dGUgdXJscyBjYW4gYmUgbG9jYWwgaWYgdGhleSBhcmUgb24gdGhlIHNhbWUgb3JpZ2luXG4gICAgY29uc3QgbG9jYXRpb25PcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gICAgY29uc3QgcmVzb2x2ZWQgPSBuZXcgVVJMKHVybCwgbG9jYXRpb25PcmlnaW4pXG4gICAgcmV0dXJuIHJlc29sdmVkLm9yaWdpbiA9PT0gbG9jYXRpb25PcmlnaW4gJiYgaGFzQmFzZVBhdGgocmVzb2x2ZWQucGF0aG5hbWUpXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG50eXBlIFVybCA9IFVybE9iamVjdCB8IHN0cmluZ1xuXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwb2xhdGVBcyhcbiAgcm91dGU6IHN0cmluZyxcbiAgYXNQYXRobmFtZTogc3RyaW5nLFxuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbikge1xuICBsZXQgaW50ZXJwb2xhdGVkUm91dGUgPSAnJ1xuXG4gIGNvbnN0IGR5bmFtaWNSZWdleCA9IGdldFJvdXRlUmVnZXgocm91dGUpXG4gIGNvbnN0IGR5bmFtaWNHcm91cHMgPSBkeW5hbWljUmVnZXguZ3JvdXBzXG4gIGNvbnN0IGR5bmFtaWNNYXRjaGVzID1cbiAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGR5bmFtaWMgcm91dGUgYWdhaW5zdCB0aGUgYXNQYXRoXG4gICAgKGFzUGF0aG5hbWUgIT09IHJvdXRlID8gZ2V0Um91dGVNYXRjaGVyKGR5bmFtaWNSZWdleCkoYXNQYXRobmFtZSkgOiAnJykgfHxcbiAgICAvLyBGYWxsIGJhY2sgdG8gcmVhZGluZyB0aGUgdmFsdWVzIGZyb20gdGhlIGhyZWZcbiAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyB0YWtlIHByaW9yaXR5OyBhbHNvIG5lZWQgdG8gY2hhbmdlIGluIHRoZSByb3V0ZXIuXG4gICAgcXVlcnlcblxuICBpbnRlcnBvbGF0ZWRSb3V0ZSA9IHJvdXRlXG4gIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5rZXlzKGR5bmFtaWNHcm91cHMpXG5cbiAgaWYgKFxuICAgICFwYXJhbXMuZXZlcnkoKHBhcmFtKSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBkeW5hbWljTWF0Y2hlc1twYXJhbV0gfHwgJydcbiAgICAgIGNvbnN0IHsgcmVwZWF0LCBvcHRpb25hbCB9ID0gZHluYW1pY0dyb3Vwc1twYXJhbV1cblxuICAgICAgLy8gc3VwcG9ydCBzaW5nbGUtbGV2ZWwgY2F0Y2gtYWxsXG4gICAgICAvLyBUT0RPOiBtb3JlIHJvYnVzdCBoYW5kbGluZyBmb3IgdXNlci1lcnJvciAocGFzc2luZyBgL2ApXG4gICAgICBsZXQgcmVwbGFjZWQgPSBgWyR7cmVwZWF0ID8gJy4uLicgOiAnJ30ke3BhcmFtfV1gXG4gICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgcmVwbGFjZWQgPSBgJHshdmFsdWUgPyAnLycgOiAnJ31bJHtyZXBsYWNlZH1dYFxuICAgICAgfVxuICAgICAgaWYgKHJlcGVhdCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHZhbHVlID0gW3ZhbHVlXVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAob3B0aW9uYWwgfHwgcGFyYW0gaW4gZHluYW1pY01hdGNoZXMpICYmXG4gICAgICAgIC8vIEludGVycG9sYXRlIGdyb3VwIGludG8gZGF0YSBVUkwgaWYgcHJlc2VudFxuICAgICAgICAoaW50ZXJwb2xhdGVkUm91dGUgPVxuICAgICAgICAgIGludGVycG9sYXRlZFJvdXRlIS5yZXBsYWNlKFxuICAgICAgICAgICAgcmVwbGFjZWQsXG4gICAgICAgICAgICByZXBlYXRcbiAgICAgICAgICAgICAgPyAodmFsdWUgYXMgc3RyaW5nW10pXG4gICAgICAgICAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVzZSB2YWx1ZXMgc2hvdWxkIGJlIGZ1bGx5IGVuY29kZWQgaW5zdGVhZCBvZiBqdXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhdGggZGVsaW1pdGVyIGVzY2FwZWQgc2luY2UgdGhleSBhcmUgYmVpbmcgaW5zZXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50byB0aGUgVVJMIGFuZCB3ZSBleHBlY3QgVVJMIGVuY29kZWQgc2VnbWVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBwYXJzaW5nIGR5bmFtaWMgcm91dGUgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgIChzZWdtZW50KSA9PiBlbmNvZGVVUklDb21wb25lbnQoc2VnbWVudClcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIC5qb2luKCcvJylcbiAgICAgICAgICAgICAgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUgYXMgc3RyaW5nKVxuICAgICAgICAgICkgfHwgJy8nKVxuICAgICAgKVxuICAgIH0pXG4gICkge1xuICAgIGludGVycG9sYXRlZFJvdXRlID0gJycgLy8gZGlkIG5vdCBzYXRpc2Z5IGFsbCByZXF1aXJlbWVudHNcblxuICAgIC8vIG4uYi4gV2UgaWdub3JlIHRoaXMgZXJyb3IgYmVjYXVzZSB3ZSBoYW5kbGUgd2FybmluZyBmb3IgdGhpcyBjYXNlIGluXG4gICAgLy8gZGV2ZWxvcG1lbnQgaW4gdGhlIGA8TGluaz5gIGNvbXBvbmVudCBkaXJlY3RseS5cbiAgfVxuICByZXR1cm4ge1xuICAgIHBhcmFtcyxcbiAgICByZXN1bHQ6IGludGVycG9sYXRlZFJvdXRlLFxuICB9XG59XG5cbmZ1bmN0aW9uIG9taXRQYXJtc0Zyb21RdWVyeShxdWVyeTogUGFyc2VkVXJsUXVlcnksIHBhcmFtczogc3RyaW5nW10pIHtcbiAgY29uc3QgZmlsdGVyZWRRdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuXG4gIE9iamVjdC5rZXlzKHF1ZXJ5KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoIXBhcmFtcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBmaWx0ZXJlZFF1ZXJ5W2tleV0gPSBxdWVyeVtrZXldXG4gICAgfVxuICB9KVxuICByZXR1cm4gZmlsdGVyZWRRdWVyeVxufVxuXG4vKipcbiAqIFJlc29sdmVzIGEgZ2l2ZW4gaHlwZXJsaW5rIHdpdGggYSBjZXJ0YWluIHJvdXRlciBzdGF0ZSAoYmFzZVBhdGggbm90IGluY2x1ZGVkKS5cbiAqIFByZXNlcnZlcyBhYnNvbHV0ZSB1cmxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUhyZWYoXG4gIGN1cnJlbnRQYXRoOiBzdHJpbmcsXG4gIGhyZWY6IFVybCxcbiAgcmVzb2x2ZUFzPzogYm9vbGVhblxuKTogc3RyaW5nIHtcbiAgLy8gd2UgdXNlIGEgZHVtbXkgYmFzZSB1cmwgZm9yIHJlbGF0aXZlIHVybHNcbiAgY29uc3QgYmFzZSA9IG5ldyBVUkwoY3VycmVudFBhdGgsICdodHRwOi8vbicpXG4gIGNvbnN0IHVybEFzU3RyaW5nID1cbiAgICB0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycgPyBocmVmIDogZm9ybWF0V2l0aFZhbGlkYXRpb24oaHJlZilcbiAgLy8gUmV0dXJuIGJlY2F1c2UgaXQgY2Fubm90IGJlIHJvdXRlZCBieSB0aGUgTmV4dC5qcyByb3V0ZXJcbiAgaWYgKCFpc0xvY2FsVVJMKHVybEFzU3RyaW5nKSkge1xuICAgIHJldHVybiAocmVzb2x2ZUFzID8gW3VybEFzU3RyaW5nXSA6IHVybEFzU3RyaW5nKSBhcyBzdHJpbmdcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTCh1cmxBc1N0cmluZywgYmFzZSlcbiAgICBmaW5hbFVybC5wYXRobmFtZSA9IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGZpbmFsVXJsLnBhdGhuYW1lKVxuICAgIGxldCBpbnRlcnBvbGF0ZWRBcyA9ICcnXG5cbiAgICBpZiAoXG4gICAgICBpc0R5bmFtaWNSb3V0ZShmaW5hbFVybC5wYXRobmFtZSkgJiZcbiAgICAgIGZpbmFsVXJsLnNlYXJjaFBhcmFtcyAmJlxuICAgICAgcmVzb2x2ZUFzXG4gICAgKSB7XG4gICAgICBjb25zdCBxdWVyeSA9IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoZmluYWxVcmwuc2VhcmNoUGFyYW1zKVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCwgcGFyYW1zIH0gPSBpbnRlcnBvbGF0ZUFzKFxuICAgICAgICBmaW5hbFVybC5wYXRobmFtZSxcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5XG4gICAgICApXG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkQXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgcGF0aG5hbWU6IHJlc3VsdCxcbiAgICAgICAgICBoYXNoOiBmaW5hbFVybC5oYXNoLFxuICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIHBhcmFtcyksXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIG9yaWdpbiBkaWRuJ3QgY2hhbmdlLCBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHJlbGF0aXZlIGhyZWZcbiAgICBjb25zdCByZXNvbHZlZEhyZWYgPVxuICAgICAgZmluYWxVcmwub3JpZ2luID09PSBiYXNlLm9yaWdpblxuICAgICAgICA/IGZpbmFsVXJsLmhyZWYuc2xpY2UoZmluYWxVcmwub3JpZ2luLmxlbmd0aClcbiAgICAgICAgOiBmaW5hbFVybC5ocmVmXG5cbiAgICByZXR1cm4gKHJlc29sdmVBc1xuICAgICAgPyBbcmVzb2x2ZWRIcmVmLCBpbnRlcnBvbGF0ZWRBcyB8fCByZXNvbHZlZEhyZWZdXG4gICAgICA6IHJlc29sdmVkSHJlZikgYXMgc3RyaW5nXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gKHJlc29sdmVBcyA/IFt1cmxBc1N0cmluZ10gOiB1cmxBc1N0cmluZykgYXMgc3RyaW5nXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaXBPcmlnaW4odXJsOiBzdHJpbmcpIHtcbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuXG4gIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybFxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyOiBOZXh0Um91dGVyLCB1cmw6IFVybCwgYXM/OiBVcmwpIHtcbiAgLy8gSWYgdXJsIGFuZCBhcyBwcm92aWRlZCBhcyBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24sXG4gIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9IHJlc29sdmVIcmVmKHJvdXRlci5wYXRobmFtZSwgdXJsLCB0cnVlKVxuICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIGNvbnN0IGhyZWZIYWRPcmlnaW4gPSByZXNvbHZlZEhyZWYuc3RhcnRzV2l0aChvcmlnaW4pXG4gIGNvbnN0IGFzSGFkT3JpZ2luID0gcmVzb2x2ZWRBcyAmJiByZXNvbHZlZEFzLnN0YXJ0c1dpdGgob3JpZ2luKVxuXG4gIHJlc29sdmVkSHJlZiA9IHN0cmlwT3JpZ2luKHJlc29sdmVkSHJlZilcbiAgcmVzb2x2ZWRBcyA9IHJlc29sdmVkQXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlZEFzKSA6IHJlc29sdmVkQXNcblxuICBjb25zdCBwcmVwYXJlZFVybCA9IGhyZWZIYWRPcmlnaW4gPyByZXNvbHZlZEhyZWYgOiBhZGRCYXNlUGF0aChyZXNvbHZlZEhyZWYpXG4gIGNvbnN0IHByZXBhcmVkQXMgPSBhc1xuICAgID8gc3RyaXBPcmlnaW4ocmVzb2x2ZUhyZWYocm91dGVyLnBhdGhuYW1lLCBhcykpXG4gICAgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZlxuXG4gIHJldHVybiB7XG4gICAgdXJsOiBwcmVwYXJlZFVybCxcbiAgICBhczogYXNIYWRPcmlnaW4gPyBwcmVwYXJlZEFzIDogYWRkQmFzZVBhdGgocHJlcGFyZWRBcyksXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNSb3V0ZShcbiAgcGFyc2VkSHJlZjogVXJsT2JqZWN0LFxuICBwYWdlczogc3RyaW5nW10sXG4gIGFwcGx5QmFzZVBhdGggPSB0cnVlXG4pIHtcbiAgY29uc3QgeyBwYXRobmFtZSB9ID0gcGFyc2VkSHJlZlxuICBjb25zdCBjbGVhblBhdGhuYW1lID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goXG4gICAgZGVub3JtYWxpemVQYWdlUGF0aChhcHBseUJhc2VQYXRoID8gZGVsQmFzZVBhdGgocGF0aG5hbWUhKSA6IHBhdGhuYW1lISlcbiAgKVxuXG4gIGlmIChjbGVhblBhdGhuYW1lID09PSAnLzQwNCcgfHwgY2xlYW5QYXRobmFtZSA9PT0gJy9fZXJyb3InKSB7XG4gICAgcmV0dXJuIHBhcnNlZEhyZWZcbiAgfVxuXG4gIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgaWYgKCFwYWdlcy5pbmNsdWRlcyhjbGVhblBhdGhuYW1lISkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgcGFnZXMuc29tZSgocGFnZSkgPT4ge1xuICAgICAgaWYgKGlzRHluYW1pY1JvdXRlKHBhZ2UpICYmIGdldFJvdXRlUmVnZXgocGFnZSkucmUudGVzdChjbGVhblBhdGhuYW1lISkpIHtcbiAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IGFwcGx5QmFzZVBhdGggPyBhZGRCYXNlUGF0aChwYWdlKSA6IHBhZ2VcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIHBhcnNlZEhyZWYucGF0aG5hbWUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXJzZWRIcmVmLnBhdGhuYW1lISlcbiAgcmV0dXJuIHBhcnNlZEhyZWZcbn1cblxuZXhwb3J0IHR5cGUgQmFzZVJvdXRlciA9IHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG4gIGxvY2FsZT86IHN0cmluZ1xuICBsb2NhbGVzPzogc3RyaW5nW11cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICBkb21haW5Mb2NhbGVzPzogRG9tYWluTG9jYWxlc1xuICBpc0xvY2FsZURvbWFpbjogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBOZXh0Um91dGVyID0gQmFzZVJvdXRlciAmXG4gIFBpY2s8XG4gICAgUm91dGVyLFxuICAgIHwgJ3B1c2gnXG4gICAgfCAncmVwbGFjZSdcbiAgICB8ICdyZWxvYWQnXG4gICAgfCAnYmFjaydcbiAgICB8ICdwcmVmZXRjaCdcbiAgICB8ICdiZWZvcmVQb3BTdGF0ZSdcbiAgICB8ICdldmVudHMnXG4gICAgfCAnaXNGYWxsYmFjaydcbiAgICB8ICdpc1JlYWR5J1xuICAgIHwgJ2lzUHJldmlldydcbiAgPlxuXG5leHBvcnQgdHlwZSBQcmVmZXRjaE9wdGlvbnMgPSB7XG4gIHByaW9yaXR5PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxufVxuXG5leHBvcnQgdHlwZSBQcml2YXRlUm91dGVJbmZvID1cbiAgfCAoT21pdDxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8sICdzdHlsZVNoZWV0cyc+ICYgeyBpbml0aWFsOiB0cnVlIH0pXG4gIHwgQ29tcGxldGVQcml2YXRlUm91dGVJbmZvXG5cbmV4cG9ydCB0eXBlIENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyA9IHtcbiAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gIHN0eWxlU2hlZXRzOiBTdHlsZVNoZWV0VHVwbGVbXVxuICBfX05fU1NHPzogYm9vbGVhblxuICBfX05fU1NQPzogYm9vbGVhblxuICBwcm9wcz86IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgZXJyPzogRXJyb3JcbiAgZXJyb3I/OiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHMgPSBQaWNrPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbywgJ0NvbXBvbmVudCcgfCAnZXJyJz4gJiB7XG4gIHJvdXRlcjogUm91dGVyXG59ICYgUmVjb3JkPHN0cmluZywgYW55PlxuZXhwb3J0IHR5cGUgQXBwQ29tcG9uZW50ID0gQ29tcG9uZW50VHlwZTxBcHBQcm9wcz5cblxudHlwZSBTdWJzY3JpcHRpb24gPSAoXG4gIGRhdGE6IFByaXZhdGVSb3V0ZUluZm8sXG4gIEFwcDogQXBwQ29tcG9uZW50LFxuICByZXNldFNjcm9sbDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbFxuKSA9PiBQcm9taXNlPHZvaWQ+XG5cbnR5cGUgQmVmb3JlUG9wU3RhdGVDYWxsYmFjayA9IChzdGF0ZTogTmV4dEhpc3RvcnlTdGF0ZSkgPT4gYm9vbGVhblxuXG50eXBlIENvbXBvbmVudExvYWRDYW5jZWwgPSAoKCkgPT4gdm9pZCkgfCBudWxsXG5cbnR5cGUgSGlzdG9yeU1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnIHwgJ3B1c2hTdGF0ZSdcblxuY29uc3QgbWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gPVxuICBwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OICYmXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICdzY3JvbGxSZXN0b3JhdGlvbicgaW4gd2luZG93Lmhpc3RvcnkgJiZcbiAgISEoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgdiA9ICdfX25leHQnXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh2LCB2KSwgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh2KSwgdHJ1ZVxuICAgIH0gY2F0Y2ggKG4pIHt9XG4gIH0pKClcblxuY29uc3QgU1NHX0RBVEFfTk9UX0ZPVU5EID0gU3ltYm9sKCdTU0dfREFUQV9OT1RfRk9VTkQnKVxuXG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybDogc3RyaW5nLCBhdHRlbXB0czogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgIC8vXG4gICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgIC8vID4gb3B0aW9uLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAvL1xuICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGlmIChhdHRlbXB0cyA+IDEgJiYgcmVzLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgcmV0dXJuIGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEpXG4gICAgICB9XG4gICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiByZXMuanNvbigpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoZGF0YS5ub3RGb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORCB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYClcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5qc29uKClcbiAgfSlcbn1cblxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZjogc3RyaW5nLCBpc1NlcnZlclJlbmRlcjogYm9vbGVhbikge1xuICByZXR1cm4gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSkuY2F0Y2goKGVycjogRXJyb3IpID0+IHtcbiAgICAvLyBXZSBzaG91bGQgb25seSB0cmlnZ2VyIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbiBpZiB0aGlzIHdhcyBjYXVzZWRcbiAgICAvLyBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50byBhbiBpbmZpbml0ZVxuICAgIC8vIGxvb3AuXG5cbiAgICBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICBtYXJrQXNzZXRFcnJvcihlcnIpXG4gICAgfVxuICAgIHRocm93IGVyclxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXIgaW1wbGVtZW50cyBCYXNlUm91dGVyIHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIE1hcCBvZiBhbGwgY29tcG9uZW50cyBsb2FkZWQgaW4gYFJvdXRlcmBcbiAgICovXG4gIGNvbXBvbmVudHM6IHsgW3BhdGhuYW1lOiBzdHJpbmddOiBQcml2YXRlUm91dGVJbmZvIH1cbiAgLy8gU3RhdGljIERhdGEgQ2FjaGVcbiAgc2RjOiB7IFthc1BhdGg6IHN0cmluZ106IG9iamVjdCB9ID0ge31cbiAgLy8gSW4tZmxpZ2h0IFNlcnZlciBEYXRhIFJlcXVlc3RzLCBmb3IgZGVkdXBpbmdcbiAgc2RyOiB7IFthc1BhdGg6IHN0cmluZ106IFByb21pc2U8b2JqZWN0PiB9ID0ge31cblxuICBzdWI6IFN1YnNjcmlwdGlvblxuICBjbGM6IENvbXBvbmVudExvYWRDYW5jZWxcbiAgcGFnZUxvYWRlcjogYW55XG4gIF9icHM6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgfCB1bmRlZmluZWRcbiAgZXZlbnRzOiBNaXR0RW1pdHRlclxuICBfd3JhcEFwcDogKEFwcDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgaXNTc3I6IGJvb2xlYW5cbiAgaXNGYWxsYmFjazogYm9vbGVhblxuICBfaW5GbGlnaHRSb3V0ZT86IHN0cmluZ1xuICBfc2hhbGxvdz86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gIGRvbWFpbkxvY2FsZXM/OiBEb21haW5Mb2NhbGVzXG4gIGlzUmVhZHk6IGJvb2xlYW5cbiAgaXNQcmV2aWV3OiBib29sZWFuXG4gIGlzTG9jYWxlRG9tYWluOiBib29sZWFuXG5cbiAgcHJpdmF0ZSBfaWR4OiBudW1iZXIgPSAwXG5cbiAgc3RhdGljIGV2ZW50czogTWl0dEVtaXR0ZXIgPSBtaXR0KClcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIHtcbiAgICAgIGluaXRpYWxQcm9wcyxcbiAgICAgIHBhZ2VMb2FkZXIsXG4gICAgICBBcHAsXG4gICAgICB3cmFwQXBwLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgZXJyLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgaXNGYWxsYmFjayxcbiAgICAgIGxvY2FsZSxcbiAgICAgIGxvY2FsZXMsXG4gICAgICBkZWZhdWx0TG9jYWxlLFxuICAgICAgZG9tYWluTG9jYWxlcyxcbiAgICAgIGlzUHJldmlldyxcbiAgICB9OiB7XG4gICAgICBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvblxuICAgICAgaW5pdGlhbFByb3BzOiBhbnlcbiAgICAgIHBhZ2VMb2FkZXI6IGFueVxuICAgICAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gICAgICBBcHA6IEFwcENvbXBvbmVudFxuICAgICAgd3JhcEFwcDogKEFwcDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgICAgIGVycj86IEVycm9yXG4gICAgICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gICAgICBsb2NhbGU/OiBzdHJpbmdcbiAgICAgIGxvY2FsZXM/OiBzdHJpbmdbXVxuICAgICAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICAgICAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbiAgICAgIGlzUHJldmlldz86IGJvb2xlYW5cbiAgICB9XG4gICkge1xuICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgIHRoaXMucm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcblxuICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgIHRoaXMuY29tcG9uZW50cyA9IHt9XG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgIGlmIChwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0gPSB7XG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgZXJyLFxuICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7XG4gICAgICBDb21wb25lbnQ6IEFwcCBhcyBDb21wb25lbnRUeXBlLFxuICAgICAgc3R5bGVTaGVldHM6IFtcbiAgICAgICAgLyogL19hcHAgZG9lcyBub3QgbmVlZCBpdHMgc3R5bGVzaGVldHMgbWFuYWdlZCAqL1xuICAgICAgXSxcbiAgICB9XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgIGNvbnN0IGF1dG9FeHBvcnREeW5hbWljID1cbiAgICAgIGlzRHluYW1pY1JvdXRlKHBhdGhuYW1lKSAmJiBzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydFxuXG4gICAgdGhpcy5hc1BhdGggPSBhdXRvRXhwb3J0RHluYW1pYyA/IHBhdGhuYW1lIDogYXNcbiAgICB0aGlzLmJhc2VQYXRoID0gYmFzZVBhdGhcbiAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvblxuICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwXG4gICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgdGhpcy5pc1NzciA9IHRydWVcblxuICAgIHRoaXMuaXNGYWxsYmFjayA9IGlzRmFsbGJhY2tcblxuICAgIHRoaXMuaXNSZWFkeSA9ICEhKFxuICAgICAgc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHxcbiAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5naXAgfHxcbiAgICAgICghYXV0b0V4cG9ydER5bmFtaWMgJiYgIXNlbGYubG9jYXRpb24uc2VhcmNoKVxuICAgIClcbiAgICB0aGlzLmlzUHJldmlldyA9ICEhaXNQcmV2aWV3XG4gICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9IGZhbHNlXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGVcbiAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXNcbiAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGVcbiAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXNcbiAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSAhIWRldGVjdERvbWFpbkxvY2FsZShcbiAgICAgICAgZG9tYWluTG9jYWxlcyxcbiAgICAgICAgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZVxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICBpZiAoYXMuc3Vic3RyKDAsIDIpICE9PSAnLy8nKSB7XG4gICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSwgcXVlcnkgfSksXG4gICAgICAgICAgZ2V0VVJMKCksXG4gICAgICAgICAgeyBsb2NhbGUgfVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSlcblxuICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Qb3BTdGF0ZSA9IChlOiBQb3BTdGF0ZUV2ZW50KTogdm9pZCA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlIGFzIEhpc3RvcnlTdGF0ZVxuXG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLCBxdWVyeSB9KSxcbiAgICAgICAgZ2V0VVJMKClcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgZm9yY2VkU2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCB1bmRlZmluZWRcbiAgICBjb25zdCB7IHVybCwgYXMsIG9wdGlvbnMsIGlkeCB9ID0gc3RhdGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZHggIT09IGlkeCkge1xuICAgICAgICAgIC8vIFNuYXBzaG90IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgICAnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5faWR4LFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IHg6IHNlbGYucGFnZVhPZmZzZXQsIHk6IHNlbGYucGFnZVlPZmZzZXQgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGNhdGNoIHt9XG5cbiAgICAgICAgICAvLyBSZXN0b3JlIG9sZCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyBpZHgpXG4gICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYhKVxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0geyB4OiAwLCB5OiAwIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faWR4ID0gaWR4XG5cbiAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgIGlmICh0aGlzLmlzU3NyICYmIGFzID09PSB0aGlzLmFzUGF0aCAmJiBwYXRobmFtZSA9PT0gdGhpcy5wYXRobmFtZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGRvd25zdHJlYW0gYXBwbGljYXRpb24gcmV0dXJucyBmYWxzeSwgcmV0dXJuLlxuICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jaGFuZ2UoXG4gICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgIHVybCxcbiAgICAgIGFzLFxuICAgICAgT2JqZWN0LmFzc2lnbjx7fSwgVHJhbnNpdGlvbk9wdGlvbnMsIFRyYW5zaXRpb25PcHRpb25zPih7fSwgb3B0aW9ucywge1xuICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgbG9jYWxlOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGUsXG4gICAgICB9KSxcbiAgICAgIGZvcmNlZFNjcm9sbFxuICAgIClcbiAgfVxuXG4gIHJlbG9hZCgpOiB2b2lkIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICovXG4gIGJhY2soKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuYmFjaygpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBgcHVzaFN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovXG4gIHB1c2godXJsOiBVcmwsIGFzPzogVXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICAnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5faWR4LFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyB4OiBzZWxmLnBhZ2VYT2Zmc2V0LCB5OiBzZWxmLnBhZ2VZT2Zmc2V0IH0pXG4gICAgICAgICAgKVxuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfVxuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICByZXBsYWNlKHVybDogVXJsLCBhcz86IFVybCwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjaGFuZ2UoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMsXG4gICAgZm9yY2VkU2Nyb2xsPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9XG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghaXNMb2NhbFVSTCh1cmwpKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybFxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XG4gICAgLy8gbWFya2luZyB0aGUgcm91dGVyIHJlYWR5IHVudGlsIGFmdGVyIHRoZSBxdWVyeSBpcyB1cGRhdGVkXG4gICAgaWYgKChvcHRpb25zIGFzIGFueSkuX2gpIHtcbiAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIHNjcm9sbCByZXNldCBiZWhhdmlvciB1bmxlc3MgZXhwbGljaXRseSBzcGVjaWZpZWQgdG8gYmVcbiAgICAvLyBgZmFsc2VgISBUaGlzIG1ha2VzIHRoZSBiZWhhdmlvciBiZXR3ZWVuIHVzaW5nIGBSb3V0ZXIjcHVzaGAgYW5kIGFcbiAgICAvLyBgPExpbmsgLz5gIGNvbnNpc3RlbnQuXG4gICAgb3B0aW9ucy5zY3JvbGwgPSAhIShvcHRpb25zLnNjcm9sbCA/PyB0cnVlKVxuXG4gICAgbGV0IGxvY2FsZUNoYW5nZSA9IG9wdGlvbnMubG9jYWxlICE9PSB0aGlzLmxvY2FsZVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIHRoaXMubG9jYWxlID1cbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlXG4gICAgICAgICAgPyB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICA6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMubG9jYWxlXG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnMubG9jYWxlID0gdGhpcy5sb2NhbGVcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzKVxuICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lLFxuICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgIClcblxuICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGFyc2VkQXMucGF0aG5hbWUpXG4gICAgICAgIGFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpXG4gICAgICAgIHVybCA9IGFkZEJhc2VQYXRoKFxuICAgICAgICAgIG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgICAgICBoYXNCYXNlUGF0aCh1cmwpID8gZGVsQmFzZVBhdGgodXJsKSA6IHVybCxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgICAgICkucGF0aG5hbWVcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgbGV0IGRpZE5hdmlnYXRlID0gZmFsc2VcblxuICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIC8vIGlmIHRoZSBsb2NhbGUgaXNuJ3QgY29uZmlndXJlZCBoYXJkIG5hdmlnYXRlIHRvIHNob3cgNDA0IHBhZ2VcbiAgICAgICAgaWYgKCF0aGlzLmxvY2FsZXM/LmluY2x1ZGVzKHRoaXMubG9jYWxlISkpIHtcbiAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGFkZExvY2FsZShwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGUpXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcylcbiAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoXG4gICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB0aGlzLmxvY2FsZVxuICAgICAgKVxuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgLy8gY29ycmVjdCBkb21haW5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFkaWROYXZpZ2F0ZSAmJlxuICAgICAgICAgIGRldGVjdGVkRG9tYWluICYmXG4gICAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiAmJlxuICAgICAgICAgIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgIT09IGRldGVjdGVkRG9tYWluLmRvbWFpblxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBhc05vQmFzZVBhdGggPSBkZWxCYXNlUGF0aChhcylcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtcbiAgICAgICAgICAgIGRldGVjdGVkRG9tYWluLmRvbWFpblxuICAgICAgICAgIH0ke2FkZEJhc2VQYXRoKFxuICAgICAgICAgICAgYCR7XG4gICAgICAgICAgICAgIHRoaXMubG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlXG4gICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgIDogYC8ke3RoaXMubG9jYWxlfWBcbiAgICAgICAgICAgIH0ke2FzTm9CYXNlUGF0aCA9PT0gJy8nID8gJycgOiBhc05vQmFzZVBhdGh9YCB8fCAnLydcbiAgICAgICAgICApfWBcbiAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRpZE5hdmlnYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIShvcHRpb25zIGFzIGFueSkuX2gpIHtcbiAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZVxuICAgIH1cbiAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgaWYgKFNUKSB7XG4gICAgICBwZXJmb3JtYW5jZS5tYXJrKCdyb3V0ZUNoYW5nZScpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaGFsbG93ID0gZmFsc2UgfSA9IG9wdGlvbnNcbiAgICBjb25zdCByb3V0ZVByb3BzID0geyBzaGFsbG93IH1cblxuICAgIGlmICh0aGlzLl9pbkZsaWdodFJvdXRlKSB7XG4gICAgICB0aGlzLmFib3J0Q29tcG9uZW50TG9hZCh0aGlzLl9pbkZsaWdodFJvdXRlLCByb3V0ZVByb3BzKVxuICAgIH1cblxuICAgIGFzID0gYWRkQmFzZVBhdGgoXG4gICAgICBhZGRMb2NhbGUoXG4gICAgICAgIGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzLFxuICAgICAgICBvcHRpb25zLmxvY2FsZSxcbiAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICApXG4gICAgKVxuICAgIGNvbnN0IGNsZWFuZWRBcyA9IGRlbExvY2FsZShcbiAgICAgIGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzLFxuICAgICAgdGhpcy5sb2NhbGVcbiAgICApXG4gICAgdGhpcy5faW5GbGlnaHRSb3V0ZSA9IGFzXG5cbiAgICAvLyBJZiB0aGUgdXJsIGNoYW5nZSBpcyBvbmx5IHJlbGF0ZWQgdG8gYSBoYXNoIGNoYW5nZVxuICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cblxuICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcbiAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgaWYgKCEob3B0aW9ucyBhcyBhbnkpLl9oICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykpIHtcbiAgICAgIHRoaXMuYXNQYXRoID0gY2xlYW5lZEFzXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKVxuICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0aGUgcmVzb2x2ZWQgaHJlZiB3aGVuIG9ubHkgYSBoYXNoIGNoYW5nZT9cbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKVxuICAgICAgdGhpcy5zY3JvbGxUb0hhc2goY2xlYW5lZEFzKVxuICAgICAgdGhpcy5ub3RpZnkodGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdLCBudWxsKVxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgbGV0IHBhcnNlZCA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuICAgIGxldCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gcGFyc2VkXG5cbiAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgLy8gZ2V0IHRoZWlyIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYWxsb3cgZW5zdXJpbmcgdGhleSBjYW4gYmUgcGFyc2VkIHByb3Blcmx5XG4gICAgLy8gd2hlbiByZXdyaXR0ZW4gdG9cbiAgICBsZXQgcGFnZXM6IGFueSwgcmV3cml0ZXM6IGFueVxuICAgIHRyeSB7XG4gICAgICBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpXG4gICAgICA7KHsgX19yZXdyaXRlczogcmV3cml0ZXMgfSA9IGF3YWl0IGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIElmIHdlIGZhaWwgdG8gcmVzb2x2ZSB0aGUgcGFnZSBsaXN0IG9yIGNsaWVudC1idWlsZCBtYW5pZmVzdCwgd2UgbXVzdFxuICAgICAgLy8gZG8gYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uOlxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcGFyc2VkID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWQsIHBhZ2VzKSBhcyB0eXBlb2YgcGFyc2VkXG5cbiAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcbiAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICB9XG5cbiAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXG4gICAgLy8gcG9pbnQgYnkgZWl0aGVyIG5leHQvbGluayBvciByb3V0ZXIucHVzaC9yZXBsYWNlIHNvIHN0cmlwIHRoZVxuICAgIC8vIGJhc2VQYXRoIGZyb20gdGhlIHBhdGhuYW1lIHRvIG1hdGNoIHRoZSBwYWdlcyBkaXIgMS10by0xXG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgPyByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChkZWxCYXNlUGF0aChwYXRobmFtZSkpXG4gICAgICA6IHBhdGhuYW1lXG5cbiAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJ1xuICAgIH1cblxuICAgIGxldCByb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuXG4gICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAvLyBwYWdlcyB0byBhbGxvdyBidWlsZGluZyB0aGUgZGF0YSBVUkwgY29ycmVjdGx5XG4gICAgbGV0IHJlc29sdmVkQXMgPSBhc1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXMuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9IHJlc29sdmVSZXdyaXRlcyhcbiAgICAgICAgYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGRlbEJhc2VQYXRoKGFzKSwgdGhpcy5sb2NhbGUpKSxcbiAgICAgICAgcGFnZXMsXG4gICAgICAgIHJld3JpdGVzLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgKHA6IHN0cmluZykgPT4gcmVzb2x2ZUR5bmFtaWNSb3V0ZSh7IHBhdGhuYW1lOiBwIH0sIHBhZ2VzKS5wYXRobmFtZSEsXG4gICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgKVxuICAgICAgcmVzb2x2ZWRBcyA9IHJld3JpdGVzUmVzdWx0LmFzUGF0aFxuXG4gICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgcm91dGUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWZcbiAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWZcbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNMb2NhbFVSTChhcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBocmVmOiBcIiR7dXJsfVwiIGFuZCBhczogXCIke2FzfVwiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhc2AgK1xuICAgICAgICAgICAgYFxcblNlZSBtb3JlIGluZm86IGh0dHBzOi8vZXJyLnNoL25leHQuanMvaW52YWxpZC1yZWxhdGl2ZS11cmwtZXh0ZXJuYWwtYXNgXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmVzb2x2ZWRBcyA9IGRlbExvY2FsZShkZWxCYXNlUGF0aChyZXNvbHZlZEFzKSwgdGhpcy5sb2NhbGUpXG5cbiAgICBpZiAoaXNEeW5hbWljUm91dGUocm91dGUpKSB7XG4gICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwocmVzb2x2ZWRBcylcbiAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZVxuXG4gICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoYXNQYXRobmFtZSlcbiAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWVcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZEFzID0gc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgPyBpbnRlcnBvbGF0ZUFzKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSlcbiAgICAgICAgOiAoe30gYXMgeyByZXN1bHQ6IHVuZGVmaW5lZDsgcGFyYW1zOiB1bmRlZmluZWQgfSlcblxuICAgICAgaWYgKCFyb3V0ZU1hdGNoIHx8IChzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSkge1xuICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcihcbiAgICAgICAgICAocGFyYW0pID0+ICFxdWVyeVtwYXJhbV1cbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgICAgPyBgSW50ZXJwb2xhdGluZyBocmVmYFxuICAgICAgICAgICAgICAgICAgOiBgTWlzbWF0Y2hpbmcgXFxgYXNcXGAgYW5kIFxcYGhyZWZcXGBgXG4gICAgICAgICAgICAgIH0gZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgYCArXG4gICAgICAgICAgICAgICAgYHRoZSBwYXJhbXM6ICR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICl9IGluIHRoZSBcXGBocmVmXFxgJ3MgXFxgcXVlcnlcXGBgXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgKHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgID8gYFRoZSBwcm92aWRlZCBcXGBocmVmXFxgICgke3VybH0pIHZhbHVlIGlzIG1pc3NpbmcgcXVlcnkgdmFsdWVzICgke21pc3NpbmdQYXJhbXMuam9pbihcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgXG4gICAgICAgICAgICAgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgK1xuICAgICAgICAgICAgICBgUmVhZCBtb3JlOiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy8ke1xuICAgICAgICAgICAgICAgIHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgICA/ICdocmVmLWludGVycG9sYXRpb24tZmFpbGVkJ1xuICAgICAgICAgICAgICAgICAgOiAnaW5jb21wYXRpYmxlLWhyZWYtYXMnXG4gICAgICAgICAgICAgIH1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgIGFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24oXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMhKSxcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKVxuICAgICAgfVxuICAgIH1cblxuICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgYXMsXG4gICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgIHJvdXRlUHJvcHNcbiAgICAgIClcbiAgICAgIGxldCB7IGVycm9yLCBwcm9wcywgX19OX1NTRywgX19OX1NTUCB9ID0gcm91dGVJbmZvXG5cbiAgICAgIC8vIGhhbmRsZSByZWRpcmVjdCBvbiBjbGllbnQtdHJhbnNpdGlvblxuICAgICAgaWYgKChfX05fU1NHIHx8IF9fTl9TU1ApICYmIHByb3BzKSB7XG4gICAgICAgIGlmICgocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMgJiYgKHByb3BzIGFzIGFueSkucGFnZVByb3BzLl9fTl9SRURJUkVDVCkge1xuICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gKHByb3BzIGFzIGFueSkucGFnZVByb3BzLl9fTl9SRURJUkVDVFxuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgZGVzdGluYXRpb24gaXMgaW50ZXJuYWwgKHJlc29sdmVzIHRvIGEgcGFnZSkgYW5kIGF0dGVtcHRcbiAgICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gcGFyc2VSZWxhdGl2ZVVybChkZXN0aW5hdGlvbilcbiAgICAgICAgICAgIHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkSHJlZiwgcGFnZXMsIGZhbHNlKVxuXG4gICAgICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMocGFyc2VkSHJlZi5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCwgYXM6IG5ld0FzIH0gPSBwcmVwYXJlVXJsQXMoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvblxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkZXN0aW5hdGlvblxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNQcmV2aWV3ID0gISFwcm9wcy5fX05fUFJFVklFV1xuXG4gICAgICAgIC8vIGhhbmRsZSBTU0cgZGF0YSA0MDRcbiAgICAgICAgaWYgKHByb3BzLm5vdEZvdW5kID09PSBTU0dfREFUQV9OT1RfRk9VTkQpIHtcbiAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy80MDQnKVxuICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvNDA0J1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnL19lcnJvcidcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICB7IHNoYWxsb3c6IGZhbHNlIH1cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdiZWZvcmVIaXN0b3J5Q2hhbmdlJywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucylcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgYXBwQ29tcDogYW55ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudFxuICAgICAgICA7KHdpbmRvdyBhcyBhbnkpLm5leHQuaXNQcmVyZW5kZXJlZCA9XG4gICAgICAgICAgYXBwQ29tcC5nZXRJbml0aWFsUHJvcHMgPT09IGFwcENvbXAub3JpZ0dldEluaXRpYWxQcm9wcyAmJlxuICAgICAgICAgICEocm91dGVJbmZvLkNvbXBvbmVudCBhcyBhbnkpLmdldEluaXRpYWxQcm9wc1xuICAgICAgfVxuXG4gICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXG4gICAgICBjb25zdCBpc1ZhbGlkU2hhbGxvd1JvdXRlID0gb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMucm91dGUgPT09IHJvdXRlXG5cbiAgICAgIGlmIChcbiAgICAgICAgKG9wdGlvbnMgYXMgYW55KS5faCAmJlxuICAgICAgICBwYXRobmFtZSA9PT0gJy9fZXJyb3InICYmXG4gICAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcz8ucGFnZVByb3BzPy5zdGF0dXNDb2RlID09PSA1MDAgJiZcbiAgICAgICAgcHJvcHM/LnBhZ2VQcm9wc1xuICAgICAgKSB7XG4gICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgIHByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMuc2V0KFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgcGF0aG5hbWUhLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgY2xlYW5lZEFzLFxuICAgICAgICByb3V0ZUluZm8sXG4gICAgICAgIGZvcmNlZFNjcm9sbCB8fFxuICAgICAgICAgIChpc1ZhbGlkU2hhbGxvd1JvdXRlIHx8ICFvcHRpb25zLnNjcm9sbCA/IG51bGwgOiB7IHg6IDAsIHk6IDAgfSlcbiAgICAgICkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgaWYgKGUuY2FuY2VsbGVkKSBlcnJvciA9IGVycm9yIHx8IGVcbiAgICAgICAgZWxzZSB0aHJvdyBlXG4gICAgICB9KVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcylcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSB0aGlzLmxvY2FsZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcylcblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgY2hhbmdlU3RhdGUoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fVxuICApOiB2b2lkIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZS5gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS4ke21ldGhvZH0gaXMgbm90IGF2YWlsYWJsZWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtZXRob2QgIT09ICdwdXNoU3RhdGUnIHx8IGdldFVSTCgpICE9PSBhcykge1xuICAgICAgdGhpcy5fc2hhbGxvdyA9IG9wdGlvbnMuc2hhbGxvd1xuICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXShcbiAgICAgICAge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBhcyxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIF9fTjogdHJ1ZSxcbiAgICAgICAgICBpZHg6IHRoaXMuX2lkeCA9IG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgPyB0aGlzLl9pZHggOiB0aGlzLl9pZHggKyAxLFxuICAgICAgICB9IGFzIEhpc3RvcnlTdGF0ZSxcbiAgICAgICAgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICcnLFxuICAgICAgICBhc1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgIGVycjogRXJyb3IgJiB7IGNvZGU6IGFueTsgY2FuY2VsbGVkOiBib29sZWFuIH0sXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICByb3V0ZVByb3BzOiBSb3V0ZVByb3BlcnRpZXMsXG4gICAgbG9hZEVycm9yRmFpbD86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8+IHtcbiAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIGlmIChpc0Fzc2V0RXJyb3IoZXJyKSB8fCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnIsIGFzLCByb3V0ZVByb3BzKVxuXG4gICAgICAvLyBJZiB3ZSBjYW4ndCBsb2FkIHRoZSBwYWdlIGl0IGNvdWxkIGJlIG9uZSBvZiBmb2xsb3dpbmcgcmVhc29uc1xuICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgLy8gIDMuIEludGVybmFsIGVycm9yIHdoaWxlIGxvYWRpbmcgdGhlIHBhZ2VcblxuICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzXG5cbiAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxuICAgICAgLy8gU28gbGV0J3MgdGhyb3cgYSBjYW5jZWxsYXRpb24gZXJyb3Igc3RvcCB0aGUgcm91dGluZyBsb2dpYy5cbiAgICAgIHRocm93IGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBsZXQgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gICAgICBsZXQgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdXG4gICAgICBsZXQgcHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWRcblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgQ29tcG9uZW50ISA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgdHlwZW9mIHN0eWxlU2hlZXRzISA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICkge1xuICAgICAgICA7KHsgcGFnZTogQ29tcG9uZW50LCBzdHlsZVNoZWV0cyB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcbiAgICAgICAgICAnL19lcnJvcidcbiAgICAgICAgKSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm91dGVJbmZvOiBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gPSB7XG4gICAgICAgIHByb3BzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICBlcnIsXG4gICAgICAgIGVycm9yOiBlcnIsXG4gICAgICB9XG5cbiAgICAgIGlmICghcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIH0gYXMgYW55KVxuICAgICAgICB9IGNhdGNoIChnaXBFcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBlcnJvciBwYWdlIGBnZXRJbml0aWFsUHJvcHNgOiAnLCBnaXBFcnIpXG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzID0ge31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcm91dGVJbmZvXG4gICAgfSBjYXRjaCAocm91dGVJbmZvRXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcihcbiAgICAgICAgcm91dGVJbmZvRXJyLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFzLFxuICAgICAgICByb3V0ZVByb3BzLFxuICAgICAgICB0cnVlXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0Um91dGVJbmZvKFxuICAgIHJvdXRlOiBzdHJpbmcsXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogYW55LFxuICAgIGFzOiBzdHJpbmcsXG4gICAgcmVzb2x2ZWRBczogc3RyaW5nLFxuICAgIHJvdXRlUHJvcHM6IFJvdXRlUHJvcGVydGllc1xuICApOiBQcm9taXNlPFByaXZhdGVSb3V0ZUluZm8+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXhpc3RpbmdSb3V0ZUluZm86IFByaXZhdGVSb3V0ZUluZm8gfCB1bmRlZmluZWQgPSB0aGlzLmNvbXBvbmVudHNbXG4gICAgICAgIHJvdXRlXG4gICAgICBdXG4gICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWNoZWRSb3V0ZUluZm86IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyB8IHVuZGVmaW5lZCA9XG4gICAgICAgIGV4aXN0aW5nUm91dGVJbmZvICYmICdpbml0aWFsJyBpbiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgOiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgY29uc3Qgcm91dGVJbmZvOiBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm9cbiAgICAgICAgPyBjYWNoZWRSb3V0ZUluZm9cbiAgICAgICAgOiBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KHJvdXRlKS50aGVuKChyZXMpID0+ICh7XG4gICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgIF9fTl9TU1A6IHJlcy5tb2QuX19OX1NTUCxcbiAgICAgICAgICB9KSlcblxuICAgICAgY29uc3QgeyBDb21wb25lbnQsIF9fTl9TU0csIF9fTl9TU1AgfSA9IHJvdXRlSW5mb1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKVxuICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhdGhuYW1lfVwiYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YUhyZWY6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgICBpZiAoX19OX1NTRyB8fCBfX05fU1NQKSB7XG4gICAgICAgIGRhdGFIcmVmID0gdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWUsIHF1ZXJ5IH0pLFxuICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgX19OX1NTRyxcbiAgICAgICAgICB0aGlzLmxvY2FsZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BzID0gYXdhaXQgdGhpcy5fZ2V0RGF0YTxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8+KCgpID0+XG4gICAgICAgIF9fTl9TU0dcbiAgICAgICAgICA/IHRoaXMuX2dldFN0YXRpY0RhdGEoZGF0YUhyZWYhKVxuICAgICAgICAgIDogX19OX1NTUFxuICAgICAgICAgID8gdGhpcy5fZ2V0U2VydmVyRGF0YShkYXRhSHJlZiEpXG4gICAgICAgICAgOiB0aGlzLmdldEluaXRpYWxQcm9wcyhcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgfSBhcyBhbnlcbiAgICAgICAgICAgIClcbiAgICAgIClcblxuICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHNcbiAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm9cbiAgICAgIHJldHVybiByb3V0ZUluZm9cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKGVyciwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcylcbiAgICB9XG4gIH1cblxuICBzZXQoXG4gICAgcm91dGU6IHN0cmluZyxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIGRhdGE6IFByaXZhdGVSb3V0ZUluZm8sXG4gICAgcmVzZXRTY3JvbGw6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IG51bGxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5pc0ZhbGxiYWNrID0gZmFsc2VcblxuICAgIHRoaXMucm91dGUgPSByb3V0ZVxuICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgIHRoaXMucXVlcnkgPSBxdWVyeVxuICAgIHRoaXMuYXNQYXRoID0gYXNcbiAgICByZXR1cm4gdGhpcy5ub3RpZnkoZGF0YSwgcmVzZXRTY3JvbGwpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovXG4gIGJlZm9yZVBvcFN0YXRlKGNiOiBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYnBzID0gY2JcbiAgfVxuXG4gIG9ubHlBSGFzaENoYW5nZShhczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycpXG4gICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdCgnIycpXG5cbiAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXJscyBhcmUgY2hhbmdlLCB0aGVyZSdzIG1vcmUgdGhhbiBhIGhhc2ggY2hhbmdlXG4gICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgYm90aCB0aGUgZW50ZXIgYW5kXG4gICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgIHJldHVybiBvbGRIYXNoICE9PSBuZXdIYXNoXG4gIH1cblxuICBzY3JvbGxUb0hhc2goYXM6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IFssIGhhc2hdID0gYXMuc3BsaXQoJyMnKVxuICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZSBvciBgI3RvcGBcbiAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICBpZiAoaGFzaCA9PT0gJycgfHwgaGFzaCA9PT0gJ3RvcCcpIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICBjb25zdCBpZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaClcbiAgICBpZiAoaWRFbCkge1xuICAgICAgaWRFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgY29uc3QgbmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoaGFzaClbMF1cbiAgICBpZiAobmFtZUVsKSB7XG4gICAgICBuYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgIH1cbiAgfVxuXG4gIHVybElzTmV3KGFzUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGhcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovXG4gIGFzeW5jIHByZWZldGNoKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzUGF0aDogc3RyaW5nID0gdXJsLFxuICAgIG9wdGlvbnM6IFByZWZldGNoT3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBwYXJzZWQgPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIGxldCB7IHBhdGhuYW1lIH0gPSBwYXJzZWRcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICBpZiAob3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHBhdGhuYW1lID0gbm9ybWFsaXplTG9jYWxlUGF0aCEocGF0aG5hbWUsIHRoaXMubG9jYWxlcykucGF0aG5hbWVcbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuXG4gICAgICAgIGxldCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKVxuICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aCEoXG4gICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUsXG4gICAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICAgIClcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lXG4gICAgICAgIG9wdGlvbnMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgYXNQYXRoID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKVxuXG4gICAgcGFyc2VkID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWQsIHBhZ2VzLCBmYWxzZSkgYXMgdHlwZW9mIHBhcnNlZFxuXG4gICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lXG4gICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgfVxuICAgIGxldCByb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuICAgIGxldCByZXNvbHZlZEFzID0gYXNQYXRoXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhc1BhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICBsZXQgcmV3cml0ZXM6IGFueVtdXG4gICAgICA7KHsgX19yZXdyaXRlczogcmV3cml0ZXMgfSA9IGF3YWl0IGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSlcblxuICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSByZXNvbHZlUmV3cml0ZXMoXG4gICAgICAgIGFkZEJhc2VQYXRoKGFkZExvY2FsZShkZWxCYXNlUGF0aChhc1BhdGgpLCB0aGlzLmxvY2FsZSkpLFxuICAgICAgICBwYWdlcyxcbiAgICAgICAgcmV3cml0ZXMsXG4gICAgICAgIHBhcnNlZC5xdWVyeSxcbiAgICAgICAgKHA6IHN0cmluZykgPT4gcmVzb2x2ZUR5bmFtaWNSb3V0ZSh7IHBhdGhuYW1lOiBwIH0sIHBhZ2VzKS5wYXRobmFtZSEsXG4gICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgKVxuXG4gICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgcm91dGUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWZcbiAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWZcbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgICByZXNvbHZlZEFzID0gcmV3cml0ZXNSZXN1bHQuYXNQYXRoXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHVybCkudGhlbigoaXNTc2c6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgcmV0dXJuIGlzU3NnXG4gICAgICAgICAgPyB0aGlzLl9nZXRTdGF0aWNEYXRhKFxuICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICA/IG9wdGlvbnMubG9jYWxlXG4gICAgICAgICAgICAgICAgICA6IHRoaXMubG9jYWxlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGZhbHNlXG4gICAgICB9KSxcbiAgICAgIHRoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gJ2xvYWRQYWdlJyA6ICdwcmVmZXRjaCddKHJvdXRlKSxcbiAgICBdKVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8R29vZFBhZ2VDYWNoZT4ge1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNhbmNlbCA9ICh0aGlzLmNsYyA9ICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICB9KVxuXG4gICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKVxuXG4gICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcihcbiAgICAgICAgYEFib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJHtyb3V0ZX1cImBcbiAgICAgIClcbiAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnRSZXN1bHRcbiAgfVxuXG4gIF9nZXREYXRhPFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH1cbiAgICB0aGlzLmNsYyA9IGNhbmNlbFxuICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgIGNvbnN0IGVycjogYW55ID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJylcbiAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRTdGF0aWNEYXRhKGRhdGFIcmVmOiBzdHJpbmcpOiBQcm9taXNlPG9iamVjdD4ge1xuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICF0aGlzLmlzUHJldmlldyAmJlxuICAgICAgdGhpcy5zZGNbY2FjaGVLZXldXG4gICAgKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2RjW2NhY2hlS2V5XSlcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIHRoaXMuaXNTc3IpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIHRoaXMuc2RjW2NhY2hlS2V5XSA9IGRhdGFcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRTZXJ2ZXJEYXRhKGRhdGFIcmVmOiBzdHJpbmcpOiBQcm9taXNlPG9iamVjdD4ge1xuICAgIGNvbnN0IHsgaHJlZjogcmVzb3VyY2VLZXkgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgIGlmICh0aGlzLnNkcltyZXNvdXJjZUtleV0pIHtcbiAgICAgIHJldHVybiB0aGlzLnNkcltyZXNvdXJjZUtleV1cbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLnNkcltyZXNvdXJjZUtleV0gPSBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCB0aGlzLmlzU3NyKVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2RyW3Jlc291cmNlS2V5XVxuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNkcltyZXNvdXJjZUtleV1cbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9KSlcbiAgfVxuXG4gIGdldEluaXRpYWxQcm9wcyhcbiAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGUsXG4gICAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB7IENvbXBvbmVudDogQXBwIH0gPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ11cbiAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHAgYXMgQXBwQ29tcG9uZW50KVxuICAgIGN0eC5BcHBUcmVlID0gQXBwVHJlZVxuICAgIHJldHVybiBsb2FkR2V0SW5pdGlhbFByb3BzPEFwcENvbnRleHRUeXBlPFJvdXRlcj4+KEFwcCwge1xuICAgICAgQXBwVHJlZSxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgIGN0eCxcbiAgICB9KVxuICB9XG5cbiAgYWJvcnRDb21wb25lbnRMb2FkKGFzOiBzdHJpbmcsIHJvdXRlUHJvcHM6IFJvdXRlUHJvcGVydGllcyk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNsYykge1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFxuICAgICAgICAncm91dGVDaGFuZ2VFcnJvcicsXG4gICAgICAgIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSxcbiAgICAgICAgYXMsXG4gICAgICAgIHJvdXRlUHJvcHNcbiAgICAgIClcbiAgICAgIHRoaXMuY2xjKClcbiAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIG5vdGlmeShcbiAgICBkYXRhOiBQcml2YXRlUm91dGVJbmZvLFxuICAgIHJlc2V0U2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnN1YihcbiAgICAgIGRhdGEsXG4gICAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50IGFzIEFwcENvbXBvbmVudCxcbiAgICAgIHJlc2V0U2Nyb2xsXG4gICAgKVxuICB9XG59XG4iLCIvLyBGb3JtYXQgZnVuY3Rpb24gbW9kaWZpZWQgZnJvbSBub2RlanNcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0ICogYXMgcXVlcnlzdHJpbmcgZnJvbSAnLi9xdWVyeXN0cmluZydcblxuY29uc3Qgc2xhc2hlZFByb3RvY29scyA9IC9odHRwcz98ZnRwfGdvcGhlcnxmaWxlL1xuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VXJsKHVybE9iajogVXJsT2JqZWN0KSB7XG4gIGxldCB7IGF1dGgsIGhvc3RuYW1lIH0gPSB1cmxPYmpcbiAgbGV0IHByb3RvY29sID0gdXJsT2JqLnByb3RvY29sIHx8ICcnXG4gIGxldCBwYXRobmFtZSA9IHVybE9iai5wYXRobmFtZSB8fCAnJ1xuICBsZXQgaGFzaCA9IHVybE9iai5oYXNoIHx8ICcnXG4gIGxldCBxdWVyeSA9IHVybE9iai5xdWVyeSB8fCAnJ1xuICBsZXQgaG9zdDogc3RyaW5nIHwgZmFsc2UgPSBmYWxzZVxuXG4gIGF1dGggPSBhdXRoID8gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpLnJlcGxhY2UoLyUzQS9pLCAnOicpICsgJ0AnIDogJydcblxuICBpZiAodXJsT2JqLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHVybE9iai5ob3N0XG4gIH0gZWxzZSBpZiAoaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh+aG9zdG5hbWUuaW5kZXhPZignOicpID8gYFske2hvc3RuYW1lfV1gIDogaG9zdG5hbWUpXG4gICAgaWYgKHVybE9iai5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHVybE9iai5wb3J0XG4gICAgfVxuICB9XG5cbiAgaWYgKHF1ZXJ5ICYmIHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICBxdWVyeSA9IFN0cmluZyhxdWVyeXN0cmluZy51cmxRdWVyeVRvU2VhcmNoUGFyYW1zKHF1ZXJ5IGFzIFBhcnNlZFVybFF1ZXJ5KSlcbiAgfVxuXG4gIGxldCBzZWFyY2ggPSB1cmxPYmouc2VhcmNoIHx8IChxdWVyeSAmJiBgPyR7cXVlcnl9YCkgfHwgJydcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOidcblxuICBpZiAoXG4gICAgdXJsT2JqLnNsYXNoZXMgfHxcbiAgICAoKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xzLnRlc3QocHJvdG9jb2wpKSAmJiBob3N0ICE9PSBmYWxzZSlcbiAgKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJylcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWVbMF0gIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZVxuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnXG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoWzBdICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoWzBdICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaFxuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBlbmNvZGVVUklDb21wb25lbnQpXG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpXG5cbiAgcmV0dXJuIGAke3Byb3RvY29sfSR7aG9zdH0ke3BhdGhuYW1lfSR7c2VhcmNofSR7aGFzaH1gXG59XG4iLCIvLyBUcmFuc2xhdGVzIGEgbG9naWNhbCByb3V0ZSBpbnRvIGl0cyBwYWdlcyBhc3NldCBwYXRoIChyZWxhdGl2ZSBmcm9tIGEgY29tbW9uIHByZWZpeClcbi8vIFwiYXNzZXQgcGF0aFwiIGJlaW5nIGl0cyBqYXZhc2NyaXB0IGZpbGUsIGRhdGEgZmlsZSwgcHJlcmVuZGVyZWQgaHRtbCwuLi5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFzc2V0UGF0aEZyb21Sb3V0ZShcbiAgcm91dGU6IHN0cmluZyxcbiAgZXh0OiBzdHJpbmcgPSAnJ1xuKTogc3RyaW5nIHtcbiAgY29uc3QgcGF0aCA9XG4gICAgcm91dGUgPT09ICcvJ1xuICAgICAgPyAnL2luZGV4J1xuICAgICAgOiAvXlxcL2luZGV4KFxcL3wkKS8udGVzdChyb3V0ZSlcbiAgICAgID8gYC9pbmRleCR7cm91dGV9YFxuICAgICAgOiBgJHtyb3V0ZX1gXG4gIHJldHVybiBwYXRoICsgZXh0XG59XG4iLCIvLyBJZGVudGlmeSAvW3BhcmFtXS8gaW4gcm91dGUgc3RyaW5nXG5jb25zdCBURVNUX1JPVVRFID0gL1xcL1xcW1teL10rP1xcXSg/PVxcL3wkKS9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRHluYW1pY1JvdXRlKHJvdXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIFRFU1RfUk9VVEUudGVzdChyb3V0ZSlcbn1cbiIsImltcG9ydCB7IGdldExvY2F0aW9uT3JpZ2luIH0gZnJvbSAnLi4vLi4vdXRpbHMnXG5pbXBvcnQgeyBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IH0gZnJvbSAnLi9xdWVyeXN0cmluZydcblxuLyoqXG4gKiBQYXJzZXMgcGF0aC1yZWxhdGl2ZSB1cmxzIChlLmcuIGAvaGVsbG8vd29ybGQ/Zm9vPWJhcmApLiBJZiB1cmwgaXNuJ3QgcGF0aC1yZWxhdGl2ZVxuICogKGUuZy4gYC4vaGVsbG9gKSB0aGVuIGF0IGxlYXN0IGJhc2UgbXVzdCBiZS5cbiAqIEFic29sdXRlIHVybHMgYXJlIHJlamVjdGVkIHdpdGggb25lIGV4Y2VwdGlvbiwgaW4gdGhlIGJyb3dzZXIsIGFic29sdXRlIHVybHMgdGhhdCBhcmUgb25cbiAqIHRoZSBjdXJyZW50IG9yaWdpbiB3aWxsIGJlIHBhcnNlZCBhcyByZWxhdGl2ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZWxhdGl2ZVVybCh1cmw6IHN0cmluZywgYmFzZT86IHN0cmluZykge1xuICBjb25zdCBnbG9iYWxCYXNlID0gbmV3IFVSTChcbiAgICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdodHRwOi8vbicgOiBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIClcbiAgY29uc3QgcmVzb2x2ZWRCYXNlID0gYmFzZSA/IG5ldyBVUkwoYmFzZSwgZ2xvYmFsQmFzZSkgOiBnbG9iYWxCYXNlXG4gIGNvbnN0IHsgcGF0aG5hbWUsIHNlYXJjaFBhcmFtcywgc2VhcmNoLCBoYXNoLCBocmVmLCBvcmlnaW4gfSA9IG5ldyBVUkwoXG4gICAgdXJsLFxuICAgIHJlc29sdmVkQmFzZVxuICApXG4gIGlmIChvcmlnaW4gIT09IGdsb2JhbEJhc2Uub3JpZ2luKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhcmlhbnQ6IGludmFsaWQgcmVsYXRpdmUgVVJMLCByb3V0ZXIgcmVjZWl2ZWQgJHt1cmx9YClcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lLFxuICAgIHF1ZXJ5OiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KHNlYXJjaFBhcmFtcyksXG4gICAgc2VhcmNoLFxuICAgIGhhc2gsXG4gICAgaHJlZjogaHJlZi5zbGljZShnbG9iYWxCYXNlLm9yaWdpbi5sZW5ndGgpLFxuICB9XG59XG4iLCJpbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShcbiAgc2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXNcbik6IFBhcnNlZFVybFF1ZXJ5IHtcbiAgY29uc3QgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5ID0ge31cbiAgc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAodHlwZW9mIHF1ZXJ5W2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBxdWVyeVtrZXldID0gdmFsdWVcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlba2V5XSkpIHtcbiAgICAgIDsocXVlcnlba2V5XSBhcyBzdHJpbmdbXSkucHVzaCh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnlba2V5XSA9IFtxdWVyeVtrZXldIGFzIHN0cmluZywgdmFsdWVdXG4gICAgfVxuICB9KVxuICByZXR1cm4gcXVlcnlcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5VXJsUXVlcnlQYXJhbShwYXJhbTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycgfHxcbiAgICAodHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyAmJiAhaXNOYU4ocGFyYW0pKSB8fFxuICAgIHR5cGVvZiBwYXJhbSA9PT0gJ2Jvb2xlYW4nXG4gICkge1xuICAgIHJldHVybiBTdHJpbmcocGFyYW0pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMoXG4gIHVybFF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gIE9iamVjdC5lbnRyaWVzKHVybFF1ZXJ5KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pID0+IHJlc3VsdC5hcHBlbmQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKGl0ZW0pKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnNldChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0odmFsdWUpKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKFxuICB0YXJnZXQ6IFVSTFNlYXJjaFBhcmFtcyxcbiAgLi4uc2VhcmNoUGFyYW1zTGlzdDogVVJMU2VhcmNoUGFyYW1zW11cbik6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIHNlYXJjaFBhcmFtc0xpc3QuZm9yRWFjaCgoc2VhcmNoUGFyYW1zKSA9PiB7XG4gICAgQXJyYXkuZnJvbShzZWFyY2hQYXJhbXMua2V5cygpKS5mb3JFYWNoKChrZXkpID0+IHRhcmdldC5kZWxldGUoa2V5KSlcbiAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGFyZ2V0LmFwcGVuZChrZXksIHZhbHVlKSlcbiAgfSlcbiAgcmV0dXJuIHRhcmdldFxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVzb2x2ZVJld3JpdGVzKCkge31cbiIsImltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3JvdXRlLXJlZ2V4J1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXg6IFJldHVyblR5cGU8dHlwZW9mIGdldFJvdXRlUmVnZXg+KSB7XG4gIGNvbnN0IHsgcmUsIGdyb3VwcyB9ID0gcm91dGVSZWdleFxuICByZXR1cm4gKHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgY29uc3Qgcm91dGVNYXRjaCA9IHJlLmV4ZWMocGF0aG5hbWUhKVxuICAgIGlmICghcm91dGVNYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgZGVjb2RlID0gKHBhcmFtOiBzdHJpbmcpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pXG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIGNvbnN0IGVycjogRXJyb3IgJiB7IGNvZGU/OiBzdHJpbmcgfSA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnZmFpbGVkIHRvIGRlY29kZSBwYXJhbSdcbiAgICAgICAgKVxuICAgICAgICBlcnIuY29kZSA9ICdERUNPREVfRkFJTEVEJ1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFyYW1zOiB7IFtwYXJhbU5hbWU6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdIH0gPSB7fVxuXG4gICAgT2JqZWN0LmtleXMoZ3JvdXBzKS5mb3JFYWNoKChzbHVnTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXVxuICAgICAgY29uc3QgbSA9IHJvdXRlTWF0Y2hbZy5wb3NdXG4gICAgICBpZiAobSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtc1tzbHVnTmFtZV0gPSB+bS5pbmRleE9mKCcvJylcbiAgICAgICAgICA/IG0uc3BsaXQoJy8nKS5tYXAoKGVudHJ5KSA9PiBkZWNvZGUoZW50cnkpKVxuICAgICAgICAgIDogZy5yZXBlYXRcbiAgICAgICAgICA/IFtkZWNvZGUobSldXG4gICAgICAgICAgOiBkZWNvZGUobSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBwYXJhbXNcbiAgfVxufVxuIiwiZXhwb3J0IGludGVyZmFjZSBHcm91cCB7XG4gIHBvczogbnVtYmVyXG4gIHJlcGVhdDogYm9vbGVhblxuICBvcHRpb25hbDogYm9vbGVhblxufVxuXG4vLyB0aGlzIGlzbid0IGltcG9ydGluZyB0aGUgZXNjYXBlLXN0cmluZy1yZWdleCBtb2R1bGVcbi8vIHRvIHJlZHVjZSBieXRlc1xuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dL2csICdcXFxcJCYnKVxufVxuXG5mdW5jdGlvbiBwYXJzZVBhcmFtZXRlcihwYXJhbTogc3RyaW5nKSB7XG4gIGNvbnN0IG9wdGlvbmFsID0gcGFyYW0uc3RhcnRzV2l0aCgnWycpICYmIHBhcmFtLmVuZHNXaXRoKCddJylcbiAgaWYgKG9wdGlvbmFsKSB7XG4gICAgcGFyYW0gPSBwYXJhbS5zbGljZSgxLCAtMSlcbiAgfVxuICBjb25zdCByZXBlYXQgPSBwYXJhbS5zdGFydHNXaXRoKCcuLi4nKVxuICBpZiAocmVwZWF0KSB7XG4gICAgcGFyYW0gPSBwYXJhbS5zbGljZSgzKVxuICB9XG4gIHJldHVybiB7IGtleTogcGFyYW0sIHJlcGVhdCwgb3B0aW9uYWwgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91dGVSZWdleChcbiAgbm9ybWFsaXplZFJvdXRlOiBzdHJpbmdcbik6IHtcbiAgcmU6IFJlZ0V4cFxuICBuYW1lZFJlZ2V4Pzogc3RyaW5nXG4gIHJvdXRlS2V5cz86IHsgW25hbWVkOiBzdHJpbmddOiBzdHJpbmcgfVxuICBncm91cHM6IHsgW2dyb3VwTmFtZTogc3RyaW5nXTogR3JvdXAgfVxufSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gKG5vcm1hbGl6ZWRSb3V0ZS5yZXBsYWNlKC9cXC8kLywgJycpIHx8ICcvJylcbiAgICAuc2xpY2UoMSlcbiAgICAuc3BsaXQoJy8nKVxuXG4gIGNvbnN0IGdyb3VwczogeyBbZ3JvdXBOYW1lOiBzdHJpbmddOiBHcm91cCB9ID0ge31cbiAgbGV0IGdyb3VwSW5kZXggPSAxXG4gIGNvbnN0IHBhcmFtZXRlcml6ZWRSb3V0ZSA9IHNlZ21lbnRzXG4gICAgLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aCgnWycpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICBjb25zdCB7IGtleSwgb3B0aW9uYWwsIHJlcGVhdCB9ID0gcGFyc2VQYXJhbWV0ZXIoc2VnbWVudC5zbGljZSgxLCAtMSkpXG4gICAgICAgIGdyb3Vwc1trZXldID0geyBwb3M6IGdyb3VwSW5kZXgrKywgcmVwZWF0LCBvcHRpb25hbCB9XG4gICAgICAgIHJldHVybiByZXBlYXQgPyAob3B0aW9uYWwgPyAnKD86LyguKz8pKT8nIDogJy8oLis/KScpIDogJy8oW14vXSs/KSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgLyR7ZXNjYXBlUmVnZXgoc2VnbWVudCl9YFxuICAgICAgfVxuICAgIH0pXG4gICAgLmpvaW4oJycpXG5cbiAgLy8gZGVhZCBjb2RlIGVsaW1pbmF0ZSBmb3IgYnJvd3NlciBzaW5jZSBpdCdzIG9ubHkgbmVlZGVkXG4gIC8vIHdoaWxlIGdlbmVyYXRpbmcgcm91dGVzLW1hbmlmZXN0XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIGxldCByb3V0ZUtleUNoYXJDb2RlID0gOTdcbiAgICBsZXQgcm91dGVLZXlDaGFyTGVuZ3RoID0gMVxuXG4gICAgLy8gYnVpbGRzIGEgbWluaW1hbCByb3V0ZUtleSB1c2luZyBvbmx5IGEteiBhbmQgbWluaW1hbCBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICAgIGNvbnN0IGdldFNhZmVSb3V0ZUtleSA9ICgpID0+IHtcbiAgICAgIGxldCByb3V0ZUtleSA9ICcnXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVLZXlDaGFyTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm91dGVLZXkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyb3V0ZUtleUNoYXJDb2RlKVxuICAgICAgICByb3V0ZUtleUNoYXJDb2RlKytcblxuICAgICAgICBpZiAocm91dGVLZXlDaGFyQ29kZSA+IDEyMikge1xuICAgICAgICAgIHJvdXRlS2V5Q2hhckxlbmd0aCsrXG4gICAgICAgICAgcm91dGVLZXlDaGFyQ29kZSA9IDk3XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb3V0ZUtleVxuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlS2V5czogeyBbbmFtZWQ6IHN0cmluZ106IHN0cmluZyB9ID0ge31cblxuICAgIGxldCBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSA9IHNlZ21lbnRzXG4gICAgICAubWFwKChzZWdtZW50KSA9PiB7XG4gICAgICAgIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICBjb25zdCB7IGtleSwgb3B0aW9uYWwsIHJlcGVhdCB9ID0gcGFyc2VQYXJhbWV0ZXIoc2VnbWVudC5zbGljZSgxLCAtMSkpXG4gICAgICAgICAgLy8gcmVwbGFjZSBhbnkgbm9uLXdvcmQgY2hhcmFjdGVycyBzaW5jZSB0aGV5IGNhbiBicmVha1xuICAgICAgICAgIC8vIHRoZSBuYW1lZCByZWdleFxuICAgICAgICAgIGxldCBjbGVhbmVkS2V5ID0ga2V5LnJlcGxhY2UoL1xcVy9nLCAnJylcbiAgICAgICAgICBsZXQgaW52YWxpZEtleSA9IGZhbHNlXG5cbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGUga2V5IGlzIHN0aWxsIGludmFsaWQgYW5kIGZhbGxiYWNrIHRvIHVzaW5nIGEga25vd25cbiAgICAgICAgICAvLyBzYWZlIGtleVxuICAgICAgICAgIGlmIChjbGVhbmVkS2V5Lmxlbmd0aCA9PT0gMCB8fCBjbGVhbmVkS2V5Lmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgICBpbnZhbGlkS2V5ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlSW50KGNsZWFuZWRLZXkuc3Vic3RyKDAsIDEpKSkpIHtcbiAgICAgICAgICAgIGludmFsaWRLZXkgPSB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGludmFsaWRLZXkpIHtcbiAgICAgICAgICAgIGNsZWFuZWRLZXkgPSBnZXRTYWZlUm91dGVLZXkoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdXRlS2V5c1tjbGVhbmVkS2V5XSA9IGtleVxuICAgICAgICAgIHJldHVybiByZXBlYXRcbiAgICAgICAgICAgID8gb3B0aW9uYWxcbiAgICAgICAgICAgICAgPyBgKD86Lyg/PCR7Y2xlYW5lZEtleX0+Lis/KSk/YFxuICAgICAgICAgICAgICA6IGAvKD88JHtjbGVhbmVkS2V5fT4uKz8pYFxuICAgICAgICAgICAgOiBgLyg/PCR7Y2xlYW5lZEtleX0+W14vXSs/KWBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYC8ke2VzY2FwZVJlZ2V4KHNlZ21lbnQpfWBcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlOiBuZXcgUmVnRXhwKGBeJHtwYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGApLFxuICAgICAgZ3JvdXBzLFxuICAgICAgcm91dGVLZXlzLFxuICAgICAgbmFtZWRSZWdleDogYF4ke25hbWVkUGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgLFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmU6IG5ldyBSZWdFeHAoYF4ke3BhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCksXG4gICAgZ3JvdXBzLFxuICB9XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5cbmNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcblxudHlwZSBTdGF0ZSA9IEpTWC5FbGVtZW50W10gfCB1bmRlZmluZWRcblxudHlwZSBTaWRlRWZmZWN0UHJvcHMgPSB7XG4gIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlOiA8VD4oXG4gICAgY29tcG9uZW50czogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICAgIHByb3BzOiBUXG4gICkgPT4gU3RhdGVcbiAgaGFuZGxlU3RhdGVDaGFuZ2U/OiAoc3RhdGU6IFN0YXRlKSA9PiB2b2lkXG4gIGhlYWRNYW5hZ2VyOiBhbnlcbiAgaW5BbXBNb2RlPzogYm9vbGVhblxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIENvbXBvbmVudDxTaWRlRWZmZWN0UHJvcHM+IHtcbiAgcHJpdmF0ZSBfaGFzSGVhZE1hbmFnZXI6IGJvb2xlYW5cblxuICBlbWl0Q2hhbmdlID0gKCk6IHZvaWQgPT4ge1xuICAgIGlmICh0aGlzLl9oYXNIZWFkTWFuYWdlcikge1xuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci51cGRhdGVIZWFkKFxuICAgICAgICB0aGlzLnByb3BzLnJlZHVjZUNvbXBvbmVudHNUb1N0YXRlKFxuICAgICAgICAgIFsuLi50aGlzLnByb3BzLmhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXNdLFxuICAgICAgICAgIHRoaXMucHJvcHNcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBhbnkpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLl9oYXNIZWFkTWFuYWdlciA9XG4gICAgICB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyICYmIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlc1xuXG4gICAgaWYgKGlzU2VydmVyICYmIHRoaXMuX2hhc0hlYWRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMuYWRkKHRoaXMpXG4gICAgICB0aGlzLmVtaXRDaGFuZ2UoKVxuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodGhpcy5faGFzSGVhZE1hbmFnZXIpIHtcbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcy5hZGQodGhpcylcbiAgICB9XG4gICAgdGhpcy5lbWl0Q2hhbmdlKClcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy5lbWl0Q2hhbmdlKClcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5faGFzSGVhZE1hbmFnZXIpIHtcbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcy5kZWxldGUodGhpcylcbiAgICB9XG4gICAgdGhpcy5lbWl0Q2hhbmdlKClcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG4iLCIvKipcbiAqIElzb21vcnBoaWMgYmFzZTY0IHRoYXQgd29ya3Mgb24gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Jhc2U2NChzdHI6IHN0cmluZykge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyKS50b1N0cmluZygnYmFzZTY0JylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gd2luZG93LmJ0b2Eoc3RyKVxuICB9XG59XG4iLCJpbXBvcnQgeyBJbmNvbWluZ01lc3NhZ2UsIFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnaHR0cCdcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgeyBmb3JtYXRVcmwgfSBmcm9tICcuL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJ1xuaW1wb3J0IHsgTWFuaWZlc3RJdGVtIH0gZnJvbSAnLi4vc2VydmVyL2xvYWQtY29tcG9uZW50cydcbmltcG9ydCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgeyBFbnYgfSBmcm9tICdAbmV4dC9lbnYnXG5pbXBvcnQgeyBCdWlsZE1hbmlmZXN0IH0gZnJvbSAnLi4vc2VydmVyL2dldC1wYWdlLWZpbGVzJ1xuaW1wb3J0IHsgRG9tYWluTG9jYWxlcyB9IGZyb20gJy4uL3NlcnZlci9jb25maWcnXG5cbi8qKlxuICogVHlwZXMgdXNlZCBieSBib3RoIG5leHQgYW5kIG5leHQtc2VydmVyXG4gKi9cblxuZXhwb3J0IHR5cGUgTmV4dENvbXBvbmVudFR5cGU8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCA9IE5leHRQYWdlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+ID0gQ29tcG9uZW50VHlwZTxQPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGluaXRpYWwgcGFnZSBsb2FkIGRhdGEgcG9wdWxhdGlvbi4gRGF0YSByZXR1cm5lZCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgIGlzIHNlcmlhbGl6ZWQgd2hlbiBzZXJ2ZXIgcmVuZGVyZWQuXG4gICAqIE1ha2Ugc3VyZSB0byByZXR1cm4gcGxhaW4gYE9iamVjdGAgd2l0aG91dCB1c2luZyBgRGF0ZWAsIGBNYXBgLCBgU2V0YC5cbiAgICogQHBhcmFtIGN0eCBDb250ZXh0IG9mIGBwYWdlYFxuICAgKi9cbiAgZ2V0SW5pdGlhbFByb3BzPyhjb250ZXh0OiBDKTogSVAgfCBQcm9taXNlPElQPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudEluaXRpYWxQcm9wcyxcbiAgRG9jdW1lbnRQcm9wc1xuPiAmIHtcbiAgcmVuZGVyRG9jdW1lbnQoXG4gICAgRG9jdW1lbnQ6IERvY3VtZW50VHlwZSxcbiAgICBwcm9wczogRG9jdW1lbnRQcm9wc1xuICApOiBSZWFjdC5SZWFjdEVsZW1lbnRcbn1cblxuZXhwb3J0IHR5cGUgQXBwVHlwZSA9IE5leHRDb21wb25lbnRUeXBlPFxuICBBcHBDb250ZXh0VHlwZSxcbiAgQXBwSW5pdGlhbFByb3BzLFxuICBBcHBQcm9wc1R5cGVcbj5cblxuZXhwb3J0IHR5cGUgQXBwVHJlZVR5cGUgPSBDb21wb25lbnRUeXBlPFxuICBBcHBJbml0aWFsUHJvcHMgJiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfVxuPlxuXG4vKipcbiAqIFdlYiB2aXRhbHMgcHJvdmlkZWQgdG8gX2FwcC5yZXBvcnRXZWJWaXRhbHMgYnkgQ29yZSBXZWIgVml0YWxzIHBsdWdpbiBkZXZlbG9wZWQgYnkgR29vZ2xlIENocm9tZSB0ZWFtLlxuICogaHR0cHM6Ly9uZXh0anMub3JnL2Jsb2cvbmV4dC05LTQjaW50ZWdyYXRlZC13ZWItdml0YWxzLXJlcG9ydGluZ1xuICovXG5leHBvcnQgdHlwZSBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICBpZDogc3RyaW5nXG4gIGxhYmVsOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4gIHZhbHVlOiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgRW5oYW5jZXI8Qz4gPSAoQ29tcG9uZW50OiBDKSA9PiBDXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHNFbmhhbmNlciA9XG4gIHwge1xuICAgICAgZW5oYW5jZUFwcD86IEVuaGFuY2VyPEFwcFR5cGU+XG4gICAgICBlbmhhbmNlQ29tcG9uZW50PzogRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG4gICAgfVxuICB8IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlUmVzdWx0ID0ge1xuICBodG1sOiBzdHJpbmdcbiAgaGVhZD86IEFycmF5PEpTWC5FbGVtZW50IHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZSA9IChcbiAgb3B0aW9ucz86IENvbXBvbmVudHNFbmhhbmNlclxuKSA9PiBSZW5kZXJQYWdlUmVzdWx0IHwgUHJvbWlzZTxSZW5kZXJQYWdlUmVzdWx0PlxuXG5leHBvcnQgdHlwZSBCYXNlQ29udGV4dCA9IHtcbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgW2s6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgdHlwZSBORVhUX0RBVEEgPSB7XG4gIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIHBhZ2U6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYnVpbGRJZDogc3RyaW5nXG4gIGFzc2V0UHJlZml4Pzogc3RyaW5nXG4gIHJ1bnRpbWVDb25maWc/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIG5leHRFeHBvcnQ/OiBib29sZWFuXG4gIGF1dG9FeHBvcnQ/OiBib29sZWFuXG4gIGlzRmFsbGJhY2s/OiBib29sZWFuXG4gIGR5bmFtaWNJZHM/OiBzdHJpbmdbXVxuICBlcnI/OiBFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9XG4gIGdzcD86IGJvb2xlYW5cbiAgZ3NzcD86IGJvb2xlYW5cbiAgY3VzdG9tU2VydmVyPzogYm9vbGVhblxuICBnaXA/OiBib29sZWFuXG4gIGFwcEdpcD86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gIGRvbWFpbkxvY2FsZXM/OiBEb21haW5Mb2NhbGVzXG4gIHNjcmlwdExvYWRlcj86IGFueVtdXG4gIGlzUHJldmlldz86IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBgTmV4dGAgY29udGV4dFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5leHRQYWdlQ29udGV4dCB7XG4gIC8qKlxuICAgKiBFcnJvciBvYmplY3QgaWYgZW5jb3VudGVyZWQgZHVyaW5nIHJlbmRlcmluZ1xuICAgKi9cbiAgZXJyPzogKEVycm9yICYgeyBzdGF0dXNDb2RlPzogbnVtYmVyIH0pIHwgbnVsbFxuICAvKipcbiAgICogYEhUVFBgIHJlcXVlc3Qgb2JqZWN0LlxuICAgKi9cbiAgcmVxPzogSW5jb21pbmdNZXNzYWdlXG4gIC8qKlxuICAgKiBgSFRUUGAgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgLyoqXG4gICAqIFBhdGggc2VjdGlvbiBvZiBgVVJMYC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgLyoqXG4gICAqIFF1ZXJ5IHN0cmluZyBzZWN0aW9uIG9mIGBVUkxgIHBhcnNlZCBhcyBhbiBvYmplY3QuXG4gICAqL1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgLyoqXG4gICAqIGBTdHJpbmdgIG9mIHRoZSBhY3R1YWwgcGF0aCBpbmNsdWRpbmcgcXVlcnkuXG4gICAqL1xuICBhc1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIGBDb21wb25lbnRgIHRoZSB0cmVlIG9mIHRoZSBBcHAgdG8gdXNlIGlmIG5lZWRpbmcgdG8gcmVuZGVyIHNlcGFyYXRlbHlcbiAgICovXG4gIEFwcFRyZWU6IEFwcFRyZWVUeXBlXG59XG5cbmV4cG9ydCB0eXBlIEFwcENvbnRleHRUeXBlPFIgZXh0ZW5kcyBOZXh0Um91dGVyID0gTmV4dFJvdXRlcj4gPSB7XG4gIENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8TmV4dFBhZ2VDb250ZXh0PlxuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxuICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICByb3V0ZXI6IFJcbn1cblxuZXhwb3J0IHR5cGUgQXBwSW5pdGlhbFByb3BzID0ge1xuICBwYWdlUHJvcHM6IGFueVxufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wc1R5cGU8XG4gIFIgZXh0ZW5kcyBOZXh0Um91dGVyID0gTmV4dFJvdXRlcixcbiAgUCA9IHt9XG4+ID0gQXBwSW5pdGlhbFByb3BzICYge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dCwgYW55LCBQPlxuICByb3V0ZXI6IFJcbiAgX19OX1NTRz86IGJvb2xlYW5cbiAgX19OX1NTUD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0ICYge1xuICByZW5kZXJQYWdlOiBSZW5kZXJQYWdlXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50SW5pdGlhbFByb3BzID0gUmVuZGVyUGFnZVJlc3VsdCAmIHtcbiAgc3R5bGVzPzogUmVhY3QuUmVhY3RFbGVtZW50W10gfCBSZWFjdC5SZWFjdEZyYWdtZW50XG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50UHJvcHMgPSBEb2N1bWVudEluaXRpYWxQcm9wcyAmIHtcbiAgX19ORVhUX0RBVEFfXzogTkVYVF9EQVRBXG4gIGRhbmdlcm91c0FzUGF0aDogc3RyaW5nXG4gIGRvY0NvbXBvbmVudHNSZW5kZXJlZDoge1xuICAgIEh0bWw/OiBib29sZWFuXG4gICAgTWFpbj86IGJvb2xlYW5cbiAgICBIZWFkPzogYm9vbGVhblxuICAgIE5leHRTY3JpcHQ/OiBib29sZWFuXG4gIH1cbiAgYnVpbGRNYW5pZmVzdDogQnVpbGRNYW5pZmVzdFxuICBhbXBQYXRoOiBzdHJpbmdcbiAgaW5BbXBNb2RlOiBib29sZWFuXG4gIGh5YnJpZEFtcDogYm9vbGVhblxuICBpc0RldmVsb3BtZW50OiBib29sZWFuXG4gIGR5bmFtaWNJbXBvcnRzOiBNYW5pZmVzdEl0ZW1bXVxuICBhc3NldFByZWZpeD86IHN0cmluZ1xuICBjYW5vbmljYWxCYXNlOiBzdHJpbmdcbiAgaGVhZFRhZ3M6IGFueVtdXG4gIHVuc3RhYmxlX3J1bnRpbWVKUz86IGZhbHNlXG4gIHVuc3RhYmxlX0pzUHJlbG9hZD86IGZhbHNlXG4gIGRldk9ubHlDYWNoZUJ1c3RlclF1ZXJ5U3RyaW5nOiBzdHJpbmdcbiAgc2NyaXB0TG9hZGVyOiB7IGRlZmVyPzogc3RyaW5nW107IGVhZ2VyPzogYW55W10gfVxuICBsb2NhbGU/OiBzdHJpbmdcbn1cblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0QXBpUmVxdWVzdCBleHRlbmRzIEluY29taW5nTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYHF1ZXJ5YCB2YWx1ZXMgZnJvbSB1cmxcbiAgICovXG4gIHF1ZXJ5OiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW11cbiAgfVxuICAvKipcbiAgICogT2JqZWN0IG9mIGBjb29raWVzYCBmcm9tIGhlYWRlclxuICAgKi9cbiAgY29va2llczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG5cbiAgYm9keTogYW55XG5cbiAgZW52OiBFbnZcblxuICBwcmV2aWV3PzogYm9vbGVhblxuICAvKipcbiAgICogUHJldmlldyBkYXRhIHNldCBvbiB0aGUgcmVxdWVzdCwgaWYgYW55XG4gICAqICovXG4gIHByZXZpZXdEYXRhPzogYW55XG59XG5cbi8qKlxuICogU2VuZCBib2R5IG9mIHJlc3BvbnNlXG4gKi9cbnR5cGUgU2VuZDxUPiA9IChib2R5OiBUKSA9PiB2b2lkXG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXNwb25zZVxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpUmVzcG9uc2U8VCA9IGFueT4gPSBTZXJ2ZXJSZXNwb25zZSAmIHtcbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBgYW55YCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBzZW5kOiBTZW5kPFQ+XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGpzb25gIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIGpzb246IFNlbmQ8VD5cbiAgc3RhdHVzOiAoc3RhdHVzQ29kZTogbnVtYmVyKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgcmVkaXJlY3QodXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgcmVkaXJlY3Qoc3RhdHVzOiBudW1iZXIsIHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPFQ+XG5cbiAgLyoqXG4gICAqIFNldCBwcmV2aWV3IGRhdGEgZm9yIE5leHQuanMnIHByZXJlbmRlciBtb2RlXG4gICAqL1xuICBzZXRQcmV2aWV3RGF0YTogKFxuICAgIGRhdGE6IG9iamVjdCB8IHN0cmluZyxcbiAgICBvcHRpb25zPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWZpZXMgdGhlIG51bWJlciAoaW4gc2Vjb25kcykgZm9yIHRoZSBwcmV2aWV3IHNlc3Npb24gdG8gbGFzdCBmb3IuXG4gICAgICAgKiBUaGUgZ2l2ZW4gbnVtYmVyIHdpbGwgYmUgY29udmVydGVkIHRvIGFuIGludGVnZXIgYnkgcm91bmRpbmcgZG93bi5cbiAgICAgICAqIEJ5IGRlZmF1bHQsIG5vIG1heGltdW0gYWdlIGlzIHNldCBhbmQgdGhlIHByZXZpZXcgc2Vzc2lvbiBmaW5pc2hlc1xuICAgICAgICogd2hlbiB0aGUgY2xpZW50IHNodXRzIGRvd24gKGJyb3dzZXIgaXMgY2xvc2VkKS5cbiAgICAgICAqL1xuICAgICAgbWF4QWdlPzogbnVtYmVyXG4gICAgfVxuICApID0+IE5leHRBcGlSZXNwb25zZTxUPlxuICBjbGVhclByZXZpZXdEYXRhOiAoKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbn1cblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIGhhbmRsZXJcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaUhhbmRsZXI8VCA9IGFueT4gPSAoXG4gIHJlcTogTmV4dEFwaVJlcXVlc3QsXG4gIHJlczogTmV4dEFwaVJlc3BvbnNlPFQ+XG4pID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+XG5cbi8qKlxuICogVXRpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNPbmNlPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IFJldHVyblR5cGU8VD4+KFxuICBmbjogVFxuKTogVCB7XG4gIGxldCB1c2VkID0gZmFsc2VcbiAgbGV0IHJlc3VsdDogUmV0dXJuVHlwZTxUPlxuXG4gIHJldHVybiAoKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgaWYgKCF1c2VkKSB7XG4gICAgICB1c2VkID0gdHJ1ZVxuICAgICAgcmVzdWx0ID0gZm4oLi4uYXJncylcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KSBhcyBUXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQgfSA9IHdpbmRvdy5sb2NhdGlvblxuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3RuYW1lfSR7cG9ydCA/ICc6JyArIHBvcnQgOiAnJ31gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkwoKSB7XG4gIGNvbnN0IHsgaHJlZiB9ID0gd2luZG93LmxvY2F0aW9uXG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZTxQPihDb21wb25lbnQ6IENvbXBvbmVudFR5cGU8UD4pIHtcbiAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnXG4gICAgPyBDb21wb25lbnRcbiAgICA6IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzU2VudChyZXM6IFNlcnZlclJlc3BvbnNlKSB7XG4gIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzPFxuICBDIGV4dGVuZHMgQmFzZUNvbnRleHQsXG4gIElQID0ge30sXG4gIFAgPSB7fVxuPihBcHA6IE5leHRDb21wb25lbnRUeXBlPEMsIElQLCBQPiwgY3R4OiBDKTogUHJvbWlzZTxJUD4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChBcHAucHJvdG90eXBlPy5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgICBBcHBcbiAgICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgfVxuICB9XG4gIC8vIHdoZW4gY2FsbGVkIGZyb20gX2FwcCBgY3R4YCBpcyBuZXN0ZWQgaW4gYGN0eGBcbiAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCAoY3R4LmN0eCAmJiBjdHguY3R4LnJlcylcblxuICBpZiAoIUFwcC5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlUHJvcHM6IGF3YWl0IGxvYWRHZXRJbml0aWFsUHJvcHMoY3R4LkNvbXBvbmVudCwgY3R4LmN0eCksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fSBhcyBJUFxuICB9XG5cbiAgY29uc3QgcHJvcHMgPSBhd2FpdCBBcHAuZ2V0SW5pdGlhbFByb3BzKGN0eClcblxuICBpZiAocmVzICYmIGlzUmVzU2VudChyZXMpKSB7XG4gICAgcmV0dXJuIHByb3BzXG4gIH1cblxuICBpZiAoIXByb3BzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICBBcHBcbiAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIHNob3VsZCByZXNvbHZlIHRvIGFuIG9iamVjdC4gQnV0IGZvdW5kIFwiJHtwcm9wc31cIiBpbnN0ZWFkLmBcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDAgJiYgIWN0eC5jdHgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYCR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgICAgQXBwXG4gICAgICAgICl9IHJldHVybmVkIGFuIGVtcHR5IG9iamVjdCBmcm9tIFxcYGdldEluaXRpYWxQcm9wc1xcYC4gVGhpcyBkZS1vcHRpbWl6ZXMgYW5kIHByZXZlbnRzIGF1dG9tYXRpYyBzdGF0aWMgb3B0aW1pemF0aW9uLiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9lbXB0eS1vYmplY3QtZ2V0SW5pdGlhbFByb3BzYFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wc1xufVxuXG5leHBvcnQgY29uc3QgdXJsT2JqZWN0S2V5cyA9IFtcbiAgJ2F1dGgnLFxuICAnaGFzaCcsXG4gICdob3N0JyxcbiAgJ2hvc3RuYW1lJyxcbiAgJ2hyZWYnLFxuICAncGF0aCcsXG4gICdwYXRobmFtZScsXG4gICdwb3J0JyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3F1ZXJ5JyxcbiAgJ3NlYXJjaCcsXG4gICdzbGFzaGVzJyxcbl1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHVybDogVXJsT2JqZWN0KTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKHVybE9iamVjdEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBVbmtub3duIGtleSBwYXNzZWQgdmlhIHVybE9iamVjdCBpbnRvIHVybC5mb3JtYXQ6ICR7a2V5fWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcm1hdFVybCh1cmwpXG59XG5cbmV4cG9ydCBjb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCdcbmV4cG9ydCBjb25zdCBTVCA9XG4gIFNQICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nXG4iLCJcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLm5vcm1hbGl6ZVBhdGhTZXA9bm9ybWFsaXplUGF0aFNlcDtleHBvcnRzLmRlbm9ybWFsaXplUGFnZVBhdGg9ZGVub3JtYWxpemVQYWdlUGF0aDtmdW5jdGlvbiBub3JtYWxpemVQYXRoU2VwKHBhdGgpe3JldHVybiBwYXRoLnJlcGxhY2UoL1xcXFwvZywnLycpO31mdW5jdGlvbiBkZW5vcm1hbGl6ZVBhZ2VQYXRoKHBhZ2Upe3BhZ2U9bm9ybWFsaXplUGF0aFNlcChwYWdlKTtpZihwYWdlLnN0YXJ0c1dpdGgoJy9pbmRleC8nKSl7cGFnZT1wYWdlLnNsaWNlKDYpO31lbHNlIGlmKHBhZ2U9PT0nL2luZGV4Jyl7cGFnZT0nLyc7fXJldHVybiBwYWdlO31cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbm9ybWFsaXplLXBhZ2UtcGF0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLmltYWdlQ29uZmlnRGVmYXVsdD1leHBvcnRzLlZBTElEX0xPQURFUlM9dm9pZCAwO2NvbnN0IFZBTElEX0xPQURFUlM9WydkZWZhdWx0JywnaW1naXgnLCdjbG91ZGluYXJ5JywnYWthbWFpJ107ZXhwb3J0cy5WQUxJRF9MT0FERVJTPVZBTElEX0xPQURFUlM7Y29uc3QgaW1hZ2VDb25maWdEZWZhdWx0PXtkZXZpY2VTaXplczpbNjQwLDc1MCw4MjgsMTA4MCwxMjAwLDE5MjAsMjA0OCwzODQwXSxpbWFnZVNpemVzOlsxNiwzMiw0OCw2NCw5NiwxMjgsMjU2LDM4NF0scGF0aDonL19uZXh0L2ltYWdlJyxsb2FkZXI6J2RlZmF1bHQnLGRvbWFpbnM6W119O2V4cG9ydHMuaW1hZ2VDb25maWdEZWZhdWx0PWltYWdlQ29uZmlnRGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWNvbmZpZy5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9uZXh0LXNlcnZlci9saWIvaGVhZCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvaW1hZ2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjFcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWJDEgPSAganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLmpzeERFViA9IGpzeERFViQxO1xuICB9KSgpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjFcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNy4wLjEnO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IDB4ZWFjYztcbmV4cG9ydHMuUHJvZmlsZXIgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbmV4cG9ydHMuU3VzcGVuc2UgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBleHBvcnRzLlN0cmljdE1vZGUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIGV4cG9ydHMuUHJvZmlsZXIgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBleHBvcnRzLlN1c3BlbnNlID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlci5cbiAqL1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBiYXRjaCdzIGNvbmZpZ3VyYXRpb24gc3VjaCBhcyBob3cgbG9uZyBhbiB1cGRhdGVcbiAqIHNob3VsZCBzdXNwZW5kIGZvciBpZiBpdCBuZWVkcyB0by5cbiAqL1xudmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnID0ge1xuICB0cmFuc2l0aW9uOiAwXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG52YXIgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IG51bGw7XG5mdW5jdGlvbiBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spIHtcbiAge1xuICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgfVxufVxuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAge1xuICAgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICAgIH1cbiAgfTsgLy8gU3RhY2sgaW1wbGVtZW50YXRpb24gaW5qZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcmVuZGVyZXIuXG5cblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnOyAvLyBBZGQgYW4gZXh0cmEgdG9wIGZyYW1lIHdoaWxlIGFuIGVsZW1lbnQgaXMgYmVpbmcgdmFsaWRhdGVkXG5cbiAgICBpZiAoY3VycmVudEV4dHJhU3RhY2tGcmFtZSkge1xuICAgICAgc3RhY2sgKz0gY3VycmVudEV4dHJhU3RhY2tGcmFtZTtcbiAgICB9IC8vIERlbGVnYXRlIHRvIHRoZSBpbmplY3RlZCByZW5kZXJlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuXG5cbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuXG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHN0YWNrICs9IGltcGwoKSB8fCAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbi8qKlxuICogVXNlZCBieSBhY3QoKSB0byB0cmFjayB3aGV0aGVyIHlvdSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGUuXG4gKi9cbnZhciBJc1NvbWVSZW5kZXJlckFjdGluZyA9IHtcbiAgY3VycmVudDogZmFsc2Vcbn07XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLFxuICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gIElzU29tZVJlbmRlcmVyQWN0aW5nOiBJc1NvbWVSZW5kZXJlckFjdGluZyxcbiAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgYXNzaWduOiBfYXNzaWduXG59O1xuXG57XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lO1xufVxuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyBcIi5cIiArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBcIiArICdUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiAnICsgJ0luc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCAnICsgJ2NsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cblxuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7IC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gIGlmICghKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCIgKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuXG5cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuXG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuXG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50OyAvLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cblxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcblxucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbi8vIGFuIGltbXV0YWJsZSBvYmplY3Qgd2l0aCBhIHNpbmdsZSBtdXRhYmxlIHZhbHVlXG5mdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG4gIHZhciByZWZPYmplY3QgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICB9XG5cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgZXhwb3J0cy5Qcm9maWxlcjpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBleHBvcnRzLlN0cmljdE1vZGU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgY29uZmlnLl9fc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gY29uZmlnLl9fc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuXG4gICAgICB7XG4gICAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTsgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIGlmICghIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm9wTmFtZTsgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cblxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjsgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cblxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7IC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7IC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuXG5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuXG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0ga2V5LnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcblxuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgZWxlbWVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBlbGVtZW50IEEgZWxlbWVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiBlbGVtZW50ICE9PSBudWxsICYmIGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKCcnICsgZWxlbWVudC5rZXkpO1xuICB9IC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG5cblxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIHZhciBfY2hpbGQgPSBjaGlsZHJlbjtcbiAgICB2YXIgbWFwcGVkQ2hpbGQgPSBjYWxsYmFjayhfY2hpbGQpOyAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3M6XG5cbiAgICB2YXIgY2hpbGRLZXkgPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0RWxlbWVudEtleShfY2hpbGQsIDApIDogbmFtZVNvRmFyO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgICB2YXIgZXNjYXBlZENoaWxkS2V5ID0gJyc7XG5cbiAgICAgIGlmIChjaGlsZEtleSAhPSBudWxsKSB7XG4gICAgICAgIGVzY2FwZWRDaGlsZEtleSA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShjaGlsZEtleSkgKyAnLyc7XG4gICAgICB9XG5cbiAgICAgIG1hcEludG9BcnJheShtYXBwZWRDaGlsZCwgYXJyYXksIGVzY2FwZWRDaGlsZEtleSwgJycsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLCAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgICAgZXNjYXBlZFByZWZpeCArICggLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgIG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBleGlzdGluZyBlbGVtZW50J3Mga2V5IGNhbiBiZSBhIG51bWJlclxuICAgICAgICBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoJycgKyBtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgICAgfVxuXG4gICAgICBhcnJheS5wdXNoKG1hcHBlZENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cblxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGl0ZXJhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGl0ZXJhYmxlQ2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlQ2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuXG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBjb3VudCA9IDA7XG4gIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCAnJywgJycsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGNvdW50KyspO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBuID0gMDtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBuKys7IC8vIERvbid0IHJldHVybiBhbnl0aGluZ1xuICB9KTtcbiAgcmV0dXJuIG47XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBmb3JFYWNoRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmcuXG4gIH0sIGZvckVhY2hDb250ZXh0KTtcbn1cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVudG9hcnJheVxuICovXG5cblxuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICByZXR1cm4gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSkgfHwgW107XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykge1xuICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09IG51bGwgJiYgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdjcmVhdGVDb250ZXh0OiBFeHBlY3RlZCB0aGUgb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxjdWxhdGVDaGFuZ2VkQml0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBVc2VkIHRvIHRyYWNrIGhvdyBtYW55IGNvbmN1cnJlbnQgcmVuZGVyZXJzIHRoaXMgY29udGV4dCBjdXJyZW50bHlcbiAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgLy8gVGhlc2UgYXJlIGNpcmN1bGFyXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGxcbiAgfTtcbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IGZhbHNlO1xuXG4gIHtcbiAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgdmFyIENvbnN1bWVyID0ge1xuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0c1xuICAgIH07IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICBQcm92aWRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb25zdW1lcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuQ29uc3VtZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyKSB7XG4gICAgICAgICAgICB3YXJuKCdTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiAnICsgXCJZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBkaXNwbGF5TmFtZSk7XG5cbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG5cbiAgICBjb250ZXh0LkNvbnN1bWVyID0gQ29uc3VtZXI7XG4gIH1cblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG52YXIgVW5pbml0aWFsaXplZCA9IC0xO1xudmFyIFBlbmRpbmcgPSAwO1xudmFyIFJlc29sdmVkID0gMTtcbnZhciBSZWplY3RlZCA9IDI7XG5cbmZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICB2YXIgdGhlbmFibGUgPSBjdG9yKCk7IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cbiAgICB2YXIgcGVuZGluZyA9IHBheWxvYWQ7XG4gICAgcGVuZGluZy5fc3RhdHVzID0gUGVuZGluZztcbiAgICBwZW5kaW5nLl9yZXN1bHQgPSB0aGVuYWJsZTtcbiAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRFeHBvcnQgPSBtb2R1bGVPYmplY3QuZGVmYXVsdDtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRFeHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcG9ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXCIsIG1vZHVsZU9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cblxuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZXNvbHZlZC5fc3RhdHVzID0gUmVzb2x2ZWQ7XG4gICAgICAgIHJlc29sdmVkLl9yZXN1bHQgPSBkZWZhdWx0RXhwb3J0O1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZWplY3RlZC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgIHJlamVjdGVkLl9yZXN1bHQgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFJlc29sdmVkKSB7XG4gICAgcmV0dXJuIHBheWxvYWQuX3Jlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBwYXlsb2FkID0ge1xuICAgIC8vIFdlIHVzZSB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfc3RhdHVzOiAtMSxcbiAgICBfcmVzdWx0OiBjdG9yXG4gIH07XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgfTtcblxuICB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBqdXN0IHNldCBpdCBvbiB0aGUgb2JqZWN0LlxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgdmFyIHByb3BUeXBlczsgLy8gJEZsb3dGaXhNZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgIGRlZmF1bHRQcm9wczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBwcm9wVHlwZXNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ3Byb3BUeXBlcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICBpZiAocmVuZGVyLmRlZmF1bHRQcm9wcyAhPSBudWxsIHx8IHJlbmRlci5wcm9wVHlwZXMgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmIChyZW5kZXIuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJlbmRlci5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gZXhwb3J0cy5Qcm9maWxlciB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBleHBvcnRzLlN0cmljdE1vZGUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdXNwZW5zZSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWVtbyh0eXBlLCBjb21wYXJlKSB7XG4gIHtcbiAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgZXJyb3IoJ21lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkICcgKyAncmVjZWl2ZWQ6ICVzJywgdHlwZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB0eXBlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbXBhcmU6IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb21wYXJlXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIGlmICghKGRpc3BhdGNoZXIgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXG4gIHtcbiAgICBpZiAodW5zdGFibGVfb2JzZXJ2ZWRCaXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yKCd1c2VDb250ZXh0KCkgc2Vjb25kIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgJyArICd1c2UgaW4gUmVhY3QuIFBhc3NpbmcgaXQgaXMgbm90IHN1cHBvcnRlZC4gJyArICdZb3UgcGFzc2VkOiAlcy4lcycsIHVuc3RhYmxlX29ic2VydmVkQml0cywgdHlwZW9mIHVuc3RhYmxlX29ic2VydmVkQml0cyA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMl0pID8gJ1xcblxcbkRpZCB5b3UgY2FsbCBhcnJheS5tYXAodXNlQ29udGV4dCk/ICcgKyAnQ2FsbGluZyBIb29rcyBpbnNpZGUgYSBsb29wIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnIDogJycpO1xuICAgIH0gLy8gVE9ETzogYWRkIGEgbW9yZSBnZW5lcmljIHdhcm5pbmcgZm9yIGludmFsaWQgdmFsdWVzLlxuXG5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKTtcbn1cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xufVxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZihpbml0aWFsVmFsdWUpO1xufVxuZnVuY3Rpb24gdXNlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VNZW1vKGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZU1lbW8oY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICB9XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcy5fX3NvdXJjZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICB9XG5cbiAge1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG52YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkpIHtcbiAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gdHJ1ZTtcblxuICAgICAgd2FybignUmVhY3QuY3JlYXRlRmFjdG9yeSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIENvbnNpZGVyIHVzaW5nIEpTWCAnICsgJ29yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC4nKTtcbiAgICB9IC8vIExlZ2FjeSBob29rOiByZW1vdmUgaXRcblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG5cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG57XG5cbiAgdHJ5IHtcbiAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5cbiAgICBuZXcgTWFwKFtbZnJvemVuT2JqZWN0LCBudWxsXV0pO1xuICAgIG5ldyBTZXQoW2Zyb3plbk9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuXG52YXIgY3JlYXRlRWxlbWVudCQxID0gIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY2xvbmVFbGVtZW50JDEgPSAgY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNyZWF0ZUZhY3RvcnkgPSAgY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uIDtcbnZhciBDaGlsZHJlbiA9IHtcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheSxcbiAgb25seTogb25seUNoaWxkXG59O1xuXG5leHBvcnRzLkNoaWxkcmVuID0gQ2hpbGRyZW47XG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGNsb25lRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlRmFjdG9yeSA9IGNyZWF0ZUZhY3Rvcnk7XG5leHBvcnRzLmNyZWF0ZVJlZiA9IGNyZWF0ZVJlZjtcbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG5leHBvcnRzLmxhenkgPSBsYXp5O1xuZXhwb3J0cy5tZW1vID0gbWVtbztcbmV4cG9ydHMudXNlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaztcbmV4cG9ydHMudXNlQ29udGV4dCA9IHVzZUNvbnRleHQ7XG5leHBvcnRzLnVzZURlYnVnVmFsdWUgPSB1c2VEZWJ1Z1ZhbHVlO1xuZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG5leHBvcnRzLnVzZUltcGVyYXRpdmVIYW5kbGUgPSB1c2VJbXBlcmF0aXZlSGFuZGxlO1xuZXhwb3J0cy51c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZU1lbW8gPSB1c2VNZW1vO1xuZXhwb3J0cy51c2VSZWR1Y2VyID0gdXNlUmVkdWNlcjtcbmV4cG9ydHMudXNlUmVmID0gdXNlUmVmO1xuZXhwb3J0cy51c2VTdGF0ZSA9IHVzZVN0YXRlO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jcmVhdGVCaW5kaW5nKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4iLCJpbXBvcnQgSGVhZCBmcm9tICduZXh0L2hlYWQnXG5pbXBvcnQgTGF5b3V0LCB7IHNpdGVUaXRsZSB9IGZyb20gJy4uL2NvbXBvbmVudHMvbGF5b3V0J1xuaW1wb3J0IHV0aWxTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3V0aWxzLm1vZHVsZS5jc3MnXG5pbXBvcnQgKiBhcyBmYWNlYXBpIGZyb20gJ2ZhY2UtYXBpLmpzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZSgpIHtcbiAgY29uc3QgTU9ERUxfVVJMID0gJy9tb2RlbHMnXG4gIFByb21pc2UuYWxsKFxuICAgIFtcbiAgICAgIGZhY2VhcGkubG9hZFRpbnlGYWNlRGV0ZWN0b3JNb2RlbChNT0RFTF9VUkwpLFxuICAgICAgZmFjZWFwaS5sb2FkRmFjZUxhbmRtYXJrTW9kZWwoTU9ERUxfVVJMKSxcbiAgICAgIGZhY2VhcGkubG9hZEZhY2VFeHByZXNzaW9uTW9kZWwoTU9ERUxfVVJMKSxcbiAgICAgIGZhY2VhcGkubG9hZEZhY2VSZWNvZ25pdGlvbk1vZGVsKE1PREVMX1VSTCksXG4gICAgICBmYWNlYXBpLmxvYWRTc2RNb2JpbGVuZXR2MU1vZGVsKE1PREVMX1VSTClcbiAgICBdXG4gIClcbiAgICAudGhlbihzdGFydCgpKVxuICAgIC5jYXRjaCgoZSkgPT4gY29uc29sZS5lcnJvcihlKSk7XG5cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgdXNlRWZmZWN0KGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lucHV0VmlkZW8nKVxuICAgICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYShcbiAgICAgICAgeyB2aWRlbzoge30gfSxcbiAgICAgICAgc3RyZWFtID0+IHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbSxcbiAgICAgICAgZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgKVxuICAgICAgXG4gICAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKCdwbGF5JywgKCkgPT4ge1xuICAgICAgICBvblBsYXkoKVxuICAgICAgfSlcblxuICAgIH0pXG5cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIG9uUGxheSgpIHtcbiAgICBjb25zdCB2aWRlbzEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5wdXRWaWRlbycpXG4gICAgY29uc3Qgb3ZlcmxheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvdmVybGF5JylcbiAgICBvdmVybGF5LndpZHRoID0gdmlkZW8xLm9mZnNldFdpZHRoO1xuICAgIG92ZXJsYXkuaGVpZ2h0ID0gdmlkZW8xLm9mZnNldEhlaWdodDtcbiAgICBjb25zdCB0aW55T3B0aW9ucyA9IG5ldyBmYWNlYXBpLlRpbnlGYWNlRGV0ZWN0b3JPcHRpb25zKCk7XG4gICAgbGV0IGxhc3RTZXRJbnRlcnZhbDtcbiAgICBvdmVybGF5LnN0eWxlLmJvcmRlclN0eWxlID0gXCJkb3R0ZWRcIjtcbiAgICBmdW5jdGlvbiBvbkludGVydmFsKCkge1xuICAgICAgbGFzdFNldEludGVydmFsID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQgZnVsbEZhY2VEZXNjcmlwdGlvbnMgPSBhd2FpdCBmYWNlYXBpLmRldGVjdEFsbEZhY2VzKHZpZGVvMSwgdGlueU9wdGlvbnMpLndpdGhGYWNlRXhwcmVzc2lvbnMoKVxuICAgICAgICBmdWxsRmFjZURlc2NyaXB0aW9ucy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50LmV4cHJlc3Npb25zLmhhcHB5ID4gMC45MCAmJiBlbGVtZW50LmV4cHJlc3Npb25zLmhhcHB5IDw9IDEpIHtcbiAgICAgICAgICAgIG92ZXJsYXkuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG92ZXJsYXkuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwobGFzdFNldEludGVydmFsKTtcbiAgICAgICAgb25JbnRlcnZhbCgpO1xuICAgICAgfSwgMjAwKTtcbiAgICB9XG4gICAgb25JbnRlcnZhbCgpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8TGF5b3V0PlxuICAgICAgPEhlYWQ+XG4gICAgICAgIDx0aXRsZT57c2l0ZVRpdGxlfTwvdGl0bGU+XG4gICAgICA8L0hlYWQ+XG4gICAgICA8c2VjdGlvbiBjbGFzc05hbWU9e3V0aWxTdHlsZXMuaGVhZGluZ01kfT5cbiAgICAgICAgPGgxPlNtaWxlPC9oMT5cbiAgICAgICAgPHZpZGVvIGlkPVwiaW5wdXRWaWRlb1wiIGF1dG9QbGF5IG11dGVkPiA8L3ZpZGVvPlxuICAgICAgICA8Y2FudmFzIGNsYXNzTmFtZT17dXRpbFN0eWxlcy5jYW52YXN9IGlkPVwib3ZlcmxheVwiIC8+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgPC9MYXlvdXQ+XG4gIClcbn0iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL3V0aWxzLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KXsvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbi8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbnZhciBhbmNob3JFbGVtZW50PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTt2YXIgcGFyZW50Tm9kZT1hbmNob3JFbGVtZW50LnBhcmVudE5vZGU7Ly8gTm9ybWFsbHkgPGhlYWQ+XG4vLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbi8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3Rcbi8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsYW5jaG9yRWxlbWVudCk7fTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSxiLGlzTmFtZWRFeHBvcnQpe2lmKCFhJiZifHxhJiYhYil7cmV0dXJuIGZhbHNlO31sZXQgcDtmb3IocCBpbiBhKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZihhW3BdIT09YltwXSl7cmV0dXJuIGZhbHNlO319Zm9yKHAgaW4gYil7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoIWFbcF0pe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO307XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL3V0aWxzLm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi91dGlscy5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyJdLCJzb3VyY2VSb290IjoiIn0=